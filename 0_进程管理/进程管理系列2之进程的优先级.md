# 目录





# linux进程优先级---cpu

## 0层(linux进程管理)

![image-20231106002601167](进程管理系列2之进程的优先级.assets/image-20231106002601167.png)

《linux进程管理.emmx》

## cpu调度----调度策略SCHED_FIFO

概念:

> cpu调度---------即 线程调度

参考：

> https://www.jianshu.com/p/1d2f6a5bbe76   Android 进程管理篇（五）-调度策略与优先级
>
> https://blog.csdn.net/aqrsxiao/article/details/84070223         linux进程调度策略

linux调度策略（部分依赖于优先级），即：

> <---------   SCHED_FIFO、SCHED_RR、SCHED_NOMAL（SCHED_OTHER）
>
> 详细：
>
> **实时调度：**针对0-99的RT(实时)进程
>
> > SCHED FIFO:    1、高优先级的终止低优先级的cpu（自然）    2、相同优先级， <font color='red'>先到先服务</font>（Fisrt in First Out，自然）  3、相同优先级下，一旦占据CPU就要到跑完为止（自然，不是轮转）
> >
> > SCHED RR:   1、高优先级的会终止低优先级的cpu（**自然**）     2、  相同优先级，<font color='red'>时间片轮询</font>（）
>
> ​      --------------> 总之，FIFO和RR 根据相同优先级下，起的名字
>
> **分时调度:** 针对100-139的普通进程，他们按nice值 -20 - 19来算优先级，越nice优先级越低
>
> > SCHED_NOMAL(SCHED OTHER) : 时间片轮询，优先级越高抢占能力越强，越容易获得更多时间片   ----> 感觉更合理，所以NOMAL
> >
> > ```java
> > SCHED BATCH 批处理进程，唤醒不频繁的使用SCHED BATCH，频繁的适合
> > ```

实时与分时的区别：

> 分时：雨露均沾。任意进程都有机会获得cpu？

优先级：承载的量：TODO: 优先级号？？？？？还是nice值？？？？？？

TODO:   具体实现 或者 实现原理

**设置链路**：

> **调度策略设置,  链路:** int sched_setscheduler(pid_t pid, int policy,conststruct sched_param *param);
>
> ​                                   ------------>
>
> **优先级设置，链路**：
>
> ​                             int setpriority(int which, int who, int prio); -------> nice值的设置
>
> 参考：https://www.kancloud.cn/alex_wsc/android-deep2/413496



应用例子：TODO：https://blog.csdn.net/aqrsxiao/article/details/84070223    

## cgroup限制 cpu 内存 I/O（目标cpuset）

主要参考： https://blog.csdn.net/shift_wwx/article/details/131854291    Android 中 cgroup抽象层详解

cgroups (全称：***control groups***)

位置：

> Linux 内核

作用：

> 限制单个进程或者多个进程所使用资源（CPU、memory）的机制。





### Q & A：既然有了调度策略+ 优先级，为什么还要有cgroup？

https://www.codenong.com/cs106895580/   为什么要有cgroup

-<font color='red'>防止 “聚沙成塔”：</font>

```java
只有nice值实际上并不能满足所有场景，比如某个应用有一个前台的UI线程，同时它还有10个后台线程，虽然后台线程的优先级比较低，但是数量较多，合起来这些后台线程对CPU的消耗也会影响到前台线程的性能。
```

----------->  所以对于Android来说又引入了另外一套机制来处理这种特殊的情况——cgroup



**背后的背后：与内存限制一个思路，即：**

> <font color='red'>单个限制 + 总的限制</font>





## 维测-----调度策略(目标nice值 )

--**<font color='red'>nice值的本质</font>：** 

> 硬件角度：即  nice值 代表的是 cpu 时间片的比例





方法一：

```cpp
 ps -p < PID > -o nice
```

方法二：top命令

> priority + nice：
>
> ![image-20231106005435133](进程管理系列2之进程的优先级.assets/image-20231106005435133.png)

方法三：chrt 方式

SurfaceFlinge线程---> FIFO, 优先级1

> ![image-20231107000339211](进程管理系列2之进程的优先级.assets/image-20231107000339211.png)





https://blog.csdn.net/renjianhhong/article/details/129196400    Linux优先级、调度策略（查看与设置大全）

https://www.cnblogs.com/Chary/p/16394567.html    [Top命令详解](https://www.cnblogs.com/Chary/p/16394567.html)





## TODO 合并：

cpu调度---------即 线程调度：

> 因为：任一时刻，只有一个线程占用CPU，处于运行状态

多线程并发：

> 轮流获取CPU使用权

线程调度模型：

> 1、分时调度模型：轮流获取、均分CPU时间
>
> 2、抢占式调度模型：优先级好的获取，JVM采用这种方式。 **nice值、cgroup**
>
> --------->TODO: 谁管理的？最终生效在哪里？
>
> ```
> nice值：
> 1）Process中定义
> 2）值越小，优先级越高
> 3）默认是THREAD_PRIORITY_DEFAULT,0
> 
> cgroup：
> 1) 更严格的群组调度策略。
> 2) 保证前台线程可以获取到更多的CPU
> 注意点：
> 线程过多会导致CPU频繁切换，降低线程运行效率
> 正确认识任务重要性决定哪种优先级。 （工作量越大优先级越低）
> 优先级具有继承性
> ```
>
> 参考： https://blog.51cto.com/u_16213654/7243574
>
> -------->TODO: 线程池





# Android 进程优先级----cpu

## 0层--(Android 进程管理)

![image-20231106002626131](进程管理系列2之进程的优先级.assets/image-20231106002626131.png)

《Android进程管理 .emmx》



AMS： 负责Android四大组建的启动和管理，进程的创建和调度。

(任意一个系统) 进程管理,  角度:

> 调度策略、优先级以及 可调度CPU范围

进程管理：

> 1、CPU调度： cpu调度策略-----------进程调度优先级nice值（linux量）：决定CPU资源调度的优先级
>
> 2、内存管理： 进程存活策略---------- 杀死应用，即**内存**释放优先级ADJ（安卓量）：系统根据一定策略先杀优先级最低的进程
>
> 当内存小于X时，结束“oom_adj”大于Y的进程  -----> 如何确定X与Y？ 如何确定oom_adj值？



## cpu调度----策略+优先级

linux侧： 见上

安卓侧调用栈：（基于linux）     

> ​                AMS + PMS ----->  Process  ---- >
>
> ![image-20231031010931513](进程管理系列2之进程的优先级.assets/image-20231031010931513.png)
>
> ~~来源： https://blog.51cto.com/u_12218/7412595~~





## 补充：安卓Process.setThreadPriority(int tid, int priority)详解

使用点：

> 在AMS进程中使用，设置APP某些线程的优先级

调用：

> Process.setThreadPriority(int tid, int priority)
>
> ------->  androidSetThreadPriority(pid_t tid, int pri)        Threads.cpp
>
> setpriority(PRIO_PROCESS, tid, pri)           # include <sys/resource.h>        实现setpriority.c
>
> syscall(SYS_setpriority, which, who, prio)
>
> SYSCALL_DEFINE2(setpriority, int, which, int, who)        /kernel/sys.c
>
> set_one_prio(p, niceval, error);

https://zhuanlan.zhihu.com/p/491874949?utm_id=0       如何正确的理解和获取Linux中进程/线程的PID/TID

https://blog.csdn.net/zhwenx3/article/details/86662733    Linux环境下进程pid、线程tid和线程pid

> pthread_self  与 getpid

TODO:

> .h的理解：协议。。。。使用者和定义者之间的协议（自然，使用者和定义者都要 # include <sys/resource.h> ）





## 进程移除：

### 疑问：

参考： https://juejin.cn/post/7220775341605568570#heading-16     AMS的内存管理ADJ算法（Android12）

疑问：

> adj值 与 进程优先级SYSTEM_ADJ之间是什么关系？
>
> adj值 与 进程组  之间是什么关系？

**Android 中，对一个进程   是否会被杀   有三个定义：**

> 进程优先级（越小越重要，越大越容易被杀）CPU调度组  SCHED_GROUP_BACKGROUND （越大越重要，adj 算法只会杀 SCHED_GROUP_BACKGROUND 进程组的进程）进程状态（表示当前进程的运行状态）

答：

1、进程优先级---------adj值  即 优先级的承载

adj值的更新时机：四大组件状态改变时，updateOomAdjLocked。比如：TODO:

2、进程状态 ---------- BACKUP_APP_ADJ  = 300 是 adj值 的一个大致的取值。待细化，比如 adj值 = 301    -------> 理解有问题

3、**CPU调度组**   ------- SCHED_GROUP_BACKGROUND   、 SCHED_GROUP_RESTRICTED、

​           ---------------> 这个影响进程 影响进程的CPU资源调度?????

疑问：   具体如何融合这三个？

![adj_summary](进程管理系列2之进程的优先级.assets/adj-summary.jpg)

来源：https://gityuan.com/2018/05/19/android-process-adj/

LMK侧：

（1） LMK侧拿到AMS给的  一堆adj值的集合

-<font color='red'>进程移除的阈值</font>：~~根据ADJ--剩余Memory（内存阈值）表，如果此时系统内存（比如147MB）小于 221MB，则 900~906 范围都是可杀的  --------> 自然先从adj最大的进程开始，看杀了是否够~~

![lmk_adj](进程管理系列2之进程的优先级.assets/lmk_adj.jpg)

> 自然，剩余内存非常非常小的时候，才杀ADJ = 0
>
> 来源：https://gityuan.com/2018/05/19/android-process-adj/

其中，进程移除的阈值表

> dumpsys activity o
>
> ![image-20231031011435975](进程管理系列2之进程的优先级.assets/image-20231031011435975.png)
>
> 



### 0层

![img](进程管理系列2之进程的优先级.assets/2018082913472653ad001b-4850-41f6-9a7b-bc00a8a37e72.png)

https://sq.sf.163.com/blog/article/193132570932527104

疑问：

> 更新优先级，到底指的更新的是啥？

### 关注ADJ<0的进程

- NATIVE_ADJ(-1000)：是由init进程fork出来的Native进程，并不受system管控； --------> 牛

- SYSTEM_ADJ(-900)：是指system_server进程；

  

### LRU列表

LRU列表结构：



### updateLruProcessLocked

​         ------------> 作用是啥

### adj

### 展开updateOomAdjLocked

### 杀应用

### 维测-----进程ADJ值查看

查看一个进程的adj 值：

> cat proc/[pid]/oom_score_adj -------> TODO: 为啥会写进文件里？不应该是实时的嘛？这里是整数，比如-900
>
> 例1：surfaceFlinger进程（ ps -ef | grep  surface）
>
> ![image-20231031215121578](进程管理系列2之进程的优先级.assets/image-20231031215121578.png)
>
> 例2：抖音分别在前台和后台时ADJ值(变动值):
>
> > 前台：0
> >
> > 后台：700
> >
> > ![image-20231031222218746](进程管理系列2之进程的优先级.assets/image-20231031222218746.png)
>
> 

查看阈值：

> dumpsys activity o：要杀的进程级别 <-------- 剩余的内存
>
> ```java
> OOM levels:
> -900: SYSTEM_ADJ (   73,728K)
> -800: PERSISTENT_PROC_ADJ (   73,728K)
> -700: PERSISTENT_SERVICE_ADJ (   73,728K)
>  0: FOREGROUND_APP_ADJ (   73,728K)
> 100: VISIBLE_APP_ADJ (   92,160K)
> 200: PERCEPTIBLE_APP_ADJ (  110,592K)
> 250: PERCEPTIBLE_LOW_APP_ADJ (  129,024K)
> 300: BACKUP_APP_ADJ (  221,184K)
> 400: HEAVY_WEIGHT_APP_ADJ (  221,184K)
> 500: SERVICE_ADJ (  221,184K)
> 600: HOME_APP_ADJ (  221,184K)
> 700: PREVIOUS_APP_ADJ (  221,184K)
> 800: SERVICE_B_ADJ (  221,184K)
> 900: CACHED_APP_MIN_ADJ (  221,184K)
> 999: CACHED_APP_MAX_ADJ (  322,560K)
> ```
>
> 

其他维测：

> dumpsys meminfo
>
> dumpsys activity p



## cpu调度----可调度范围cpuset

### 背景：

完全参考：

> https://www.jianshu.com/p/0532e4239703      cpuset负载均衡在AMS中是如何应用的

背景：

> TODO:这里因此逻辑不懂？

### cpuset设置

cpuset设置-------AMS阶段：

> 计算curSchedGroup ：
>
> 设置curSchedGroup ：

cpuset设置-------最终生效：

> 根据不同的cgroup写cpuset对应节点：
>
> 最终生效节点：
>
> 比如：MTK6875，总共7个核心:
>
> > top app 满核随便跑
> >
> > background只能跑在小核上

**总之：**

> （1）AMS计算cgroup
>
> （2）根据不同的cgroup写cpuset对应节点：

其他：

> cpuset开关

TODO：

> 举例子，其如何应用，以及 实际解决的问题

### 维测

top-app组 ： 限定哪些核心使用：

```
 adb shell cat /dev/CPUset/top-app/CPUs
 0-7
 -------> 0-7都可以被top-app使用
```

top-app组  ：有哪些进程和线程是跑在这个组里面：

```
 adb shell cat /dev/CPUset/top-app/tasks
```

cpu:  cat  /proc/cpuinfo     CPU的架构、cpu的名称、核心数

其他方式，限定任务跑在哪个核心上：参考：https://www.cnblogs.com/mikaelzero/p/16916730.html

> taskset -pc 3  pid    表示将进程pid绑定到第3个核上

## 参考：

https://juejin.cn/post/7174713775944138809    AMS是如何动态管理进程的？

https://www.cnblogs.com/andy-songwei/p/9845771.html   [【朝花夕拾】Android性能篇之（六）Android进程管理机制](https://www.cnblogs.com/andy-songwei/p/9845771.html)   ----> 优秀文章

https://gityuan.com/2018/05/19/android-process-adj/      解读Android进程优先级ADJ算法

https://blog.51cto.com/u_16213654/7243574   android cpu调度策略 修改 安卓cpu调度模式

https://blog.51cto.com/u_12218/7412595    android 调试看实时cpu android cpu调度

> https://sq.sf.163.com/blog/article/187631163406041088   利用cgroup来限制进程的资源使用量
>
> 防止出现资源泄漏影响其他应用

https://xiaozhuanlan.com/topic/4135276908

https://sq.sf.163.com/blog/article/193127728117825536   Android后台杀死系列之一：FragmentActivity及PhoneWindow后台杀死处理机制（上篇）

https://sq.sf.163.com/blog/article/193127674185461760   Android后台杀死系列之一：FragmentActivity及PhoneWindow后台杀死处理机制（下篇）

https://sq.sf.163.com/blog/article/193130044973854720   Android后台杀死系列之二：ActivityManagerService与App现场恢复机制（上篇）

https://sq.sf.163.com/blog/article/193129960244719616   Android后台杀死系列之二：ActivityManagerService与App现场恢复机制（下篇）

https://sq.sf.163.com/blog/article/193132570932527104   Android后台杀死系列之三：LowMemoryKiller原理（4.3-6.0）上篇

-------->  注意图

https://sq.sf.163.com/blog/article/193132514978508800   Android后台杀死系列之三：LowMemoryKiller原理（4.3-6.0）下篇

https://www.jianshu.com/p/221f4a246b45?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation   Android进程系列第六篇---LowmemoryKiller机制分析(上)





## TODO:

向linux侧oom_adj的设置（类似API）：(**注意：oom_adj是安卓魔改的linux才有**)

> 向   /proc/进程id/oom_adj文件中写入对应的oom_adj值
>
> **本质： 进程id ------oom_adj 的映射**



# AMS杀进程场景

## 后台cpu/电量使用checkExcessivePowerUsageLocked

### 规则：

完全参考： https://www.jianshu.com/p/ee027ed53724

AMS 每 5分钟 检查一下异常耗电情况：

![image-20231103003931320](进程管理系列2之进程的优先级.assets/image-20231103003931320.png)

简言之：

> 1、随着时间延长，后台应用，占用CPU必须越来越少(30min之后，占用不能超2%)
>
> 2、检测频率：5min
>
> ---------------> <font color='red'>在曲线以上，会触发杀进程</font>

计算方式：

```
 rate = cputimeUsed*100/uptimeSince 一个检查周期内CPU的使用时长 / 检查周期时长
```

### 具体细节&证明：

检测频率：5min，~~即checkExcessivePowerUsageLocked调用频率：~~   TODO:

### 一些结论：

checkExcessivePowerUsageLocked ----> 与 mLruProcesses 关系不大

## adb shell am force-stop



# 目标---nice值设置

## java代码setThreadPriority----setThreadScheduler

参数：

```java
Process.setThreadPriority(int tid, int priority)
 
   -------->  tid  线程id
 
              priority： -20 ~ 19
```

-<font color='red'>setThreadPriority调用点：</font>

> **AMS.setRenderThread** ----------> 自然(要提高render线程的优先级)     **时机：**HardwareRenderer初始化时   详解：见下
>
> ​                                setThreadPriority(proc.getRenderThreadTid(), THREAD_PRIORITY_TOP_APP_BOOST);
>
> 
>
> **AMS侧OomAdjuster.**applyOomAdjLSP    ----------->  **<font color='red'>主要调用点</font>** ： 各种情况调用
>
> ​                            //  ~~setThreadPriority(app.getPid(), THREAD_PRIORITY_TOP_APP_BOOST);~~    **提高UI线程优先级**
>
> ​                           //  ~~setThreadPriority(renderThreadTid, THREAD_PRIORITY_TOP_APP_BOOST);~~   提高**renderThread**优先级
>
> 

-<font color='red'>setThreadScheduler调用点：</font>

​        **AMS侧OomAdjuster.**applyOomAdjLSP  ------>   scheduleAsFifoPriority(renderThreadTid, true)    ------->  FIFO级别





调用流程：

```cpp
Process.setThreadPriority(int tid, int priority)
    android_os_Process_setThreadPriority   -----------jni--------------
        Threads::androidSetThreadPriority(pid, pri)
             SetTaskProfiles(tid, {"SCHED_SP_SYSTEM"}, true)  //processgroup.cpp TODO:  设置了profiles
                  TaskProfiles::SetTaskProfiles(int tid, const std::vector<std::string>& profiles, bool use_fd_cache)
             setpriority(PRIO_PROCESS, tid, pri)     // 即设置nice值
```



问题：

> 既然是设置给线程的，那么不同进程之间怎么调度？
>
> 调度是以线程，还是按照进程维度去分配资源的？



## 经典调用路径-------前后台切换

前台myappliaction  退到 后台 （自然，launcher进入前台）

###  **<font color='red'>目标：</font>myappliaction 线程优先级降低、launcher的提高**

时机： TODO：

> 
>
> ```java
> applyOomAdjLocked:1817, OomAdjuster (com.android.server.am)
> updateOomAdjLocked:447, OomAdjuster (com.android.server.am)
> updateOomAdjLocked:16947, ActivityManagerService (com.android.server.am)
> updateProcessInfo:1304, ProcessRecord (com.android.server.am)
> accept:-1, -$$Lambda$BEx3OWenCvYAaV5h_J2ZkZXhEcY (com.android.server.wm)
> doInvoke:300, PooledLambdaImpl (com.android.internal.util.function.pooled)
> invoke:195, PooledLambdaImpl (com.android.internal.util.function.pooled)
> run:86, OmniFunction (com.android.internal.util.function.pooled)
> handleCallback:883, Handler (android.os)
> dispatchMessage:100, Handler (android.os)
> loop:214, Looper (android.os)
> run:67, HandlerThread (android.os)
> run:44, ServiceThread (com.android.server)
> ```



```java
//OomAdjuster
applyOomAdjLocked 方法：

//1、提高launcher的
// Boost priority for top app UI and render threads
setThreadPriority(app.pid, TOP_APP_PRIORITY_BOOST);
setThreadPriority(app.renderThreadTid,  TOP_APP_PRIORITY_BOOST);
    
//2、降低myappliaction 的
setThreadPriority(app.pid, 0);
setThreadPriority(app.renderThreadTid, 0);
```

------------> TODO: 

> 了解app.renderThreadTid != 0 系统侧如何判断 APP有没有render线程的！！！！！！







## ~~del:inux 接口  setpriority~~

```cpp
#include <sys/time.h>
#include <sys/resource.h>

int setpriority(int which, id_t who, int value);

```

## ~~del:命令设置nice值~~

```java
nice -n <nice_value> <command>
```

TODO： 实战验证

## nice值维测

见linux章节



## 例子---安卓修改nice值的线程：

### RenderThread线程

详解setRenderThread ：

> -1、<font color='red'>默认情况下</font>
>
> > 每个进程的绘画线程RenderThread的调度策略是SCHED_OTHER, 并且优先级为-10.
>
> 2、mUseFifoUiScheduling = true下: （即设置系统属性sys.use_fifo_ui为1（TODO: 手机和车机，暂时没看到这样做））
>
> > 每个进程的绘画线程RenderThread的调度策略变更为SCHED_FIFO,并且实时优先级为1.(其实，只是在硬件加速时，会设置setRenderThread 。但是默认硬件加速)
>
> --------------> 无论哪种，RenderThread都提高了优先级

https://blog.csdn.net/hdxx2022/article/details/127630906    关于Android进程调度浅谈 (Android系统在以下几个地方设置了SCHED_FIFO调度策略)

setThreadScheduler  ------>  调度策略 + 优先级

### 应用主线程

TODO: 哪里设置的？

### SurfaceFlinger线程

SurfaceFlinger设置为FIFO

> ![image-20231107000339211](进程管理系列2之进程的优先级.assets/image-20231107000339211-1700055904962.png)

linux +<font color='red'> KDE桌面环境</font>：

> kwin_x11   ------->  是KDE的图形合成器
>
> renderThread  ------->  KDE  也有



# 一些结论：

## Linux上，各线程nice值大多一样

linux ：

> 应用火狐浏览器：
>
> ```
> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
> [m17632 chen  20   0 2550392 176168 100700 S  6.7  2.9 633:26.35 Xorg
> [m17633 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-0
> [m17634 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-1
> [m17635 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-2
> [m17636 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-3
> [m17637 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-4
> [m17638 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-5
> [m17639 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-6
> [m17640 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-7
> [m17641 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-8
> [m17642 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-9
> [m17643 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-10
> [m17644 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-11
> [m17645 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-12
> [m17646 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 llvmpipe-13
> [m17647 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17648 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.01 Xorg
> [m17649 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17650 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17651 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17652 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17653 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17654 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17655 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17656 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17657 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17658 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17659 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17660 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:00.00 Xorg
> [m17663 chen  20   0 2550392 176168 100700 S  0.0  2.9   0:17.93 InputThread
> ```

linux ：整个系统：

> ![image-20231107001904401](进程管理系列2之进程的优先级.assets/image-20231107001904401.png)

安卓：应用进程com.huawei.notepad

> render线程和主线程，比较优先级高
>
> ![image-20231107002417154](进程管理系列2之进程的优先级.assets/image-20231107002417154.png)

安卓整个系统：

> ![image-20231107002231954](进程管理系列2之进程的优先级.assets/image-20231107002231954.png)
>
> 

**初步结论：**

> 安卓上：com.huawei.notepad应用的各个线程的**nice值不一样**
>
> ​                比如 RenderThread---------->  **设置点：**AMS.setRenderThread，
>
> Linux上，各线程明显一样



# Linux   cgroup 实操

目的：隔离资源（CPU、Mem）--------> 从而优化性能



在 Linux 中，使用 `cgroup v2` 可以限制或绑定进程到特定的 CPU 核（即 CPU 亲和性）。通过 `cgroup v2` 的 `cpuset` 控制组，能够将某个或多个进程限制在指定的 CPU 核上执行。

### 使用 `cgroup v2` 绑定进程到特定 CPU 核的方法

#### 1. 确保 `cgroup v2` 已经挂载

首先，检查是否已经挂载了 `cgroup v2`。

```
bash


Copy code
mount | grep cgroup2
```

如果没有看到类似 `/sys/fs/cgroup` 的挂载信息，则需要挂载 `cgroup v2`：

```
bash


Copy code
sudo mount -t cgroup2 none /sys/fs/cgroup
```

#### 2. 创建并配置 `cpuset` 控制组

在 `cgroup v2` 中，`cpuset` 用于控制进程可以使用的 CPU 和内存节点。首先，创建一个 `cgroup` 目录来限制进程的 CPU 使用。

```
bashCopy codecd /sys/fs/cgroup
mkdir cpuset_group
```

#### 3. 配置 `cpuset.cpus` 和 `cpuset.mems`

-   **`cpuset.cpus`**：指定进程可以使用的 CPU 核。
-   **`cpuset.mems`**：指定进程可以使用的内存节点（通常只需要设为 `0`，表示使用默认的内存节点）。

例如，将进程绑定到 CPU 0 和 CPU 1：

```
bashCopy codeecho 0-1 > cpuset_group/cpuset.cpus
echo 0 > cpuset_group/cpuset.mems
```

#### 4. 启动或将进程加入到 `cgroup`

你可以通过以下方式，将特定的进程放入这个控制组：

-   **启动一个新的进程**： 使用 `echo $$` 或 `pgrep` 获取进程的 PID，然后将 PID 添加到 `cgroup.procs` 文件。

    ```
    bash
    
    
    Copy code
    echo <PID> > cpuset_group/cgroup.procs
    ```

-   **将现有进程加入到 `cgroup`**： 假设你想让 PID 为 `1234` 的进程绑定到特定 CPU 核：

    ```
    bash
    
    
    Copy code
    echo 1234 > cpuset_group/cgroup.procs
    ```

现在，进程 `1234` 将只能在 CPU 0 和 CPU 1 上运行。

#### 5. 验证进程是否绑定到指定的 CPU 核

你可以通过以下方式检查进程的 CPU 亲和性：

```
bash


Copy code
taskset -cp <PID>
```

这将显示进程的 CPU 绑定情况，应该只显示你在 `cpuset.cpus` 中指定的 CPU 核。

### 示例

假设你想绑定进程 `4567` 到 CPU 2 和 CPU 3，执行步骤如下：

1.  创建 `cpuset` 控制组：

    ```
    bashCopy codecd /sys/fs/cgroup
    mkdir cpuset_test
    ```

2.  配置 `cpuset`：

    ```
    bashCopy codeecho 2-3 > cpuset_test/cpuset.cpus
    echo 0 > cpuset_test/cpuset.mems
    ```

3.  将进程 `4567` 添加到 `cgroup` 中：

    ```
    bash
    
    
    Copy code
    echo 4567 > cpuset_test/cgroup.procs
    ```

4.  验证绑定情况：

    ```
    bash
    
    
    Copy code
    taskset -cp 4567
    ```

这个命令将显示进程 `4567` 只在 CPU 2 和 CPU 3 上运行。

### 总结

通过 `cgroup v2` 的 `cpuset`，你可以方便地将进程绑定到特定的 CPU 核上，从而控制进程的 CPU 使用。这样的方法非常适用于性能优化、隔离系统资源以及确保多核系统上进程的执行效率。





4o



##### You said:

上述方式，可以将某个核被 特定进程独占吗



###### ChatGPT said:

ChatGPT

是的，通过 `cgroup v2` 的 `cpuset` 控制组，可以将某个或某些 CPU 核分配给特定的进程，并且确保其他进程无法使用这些 CPU 核，从而实现 CPU 核的**独占**。

为了实现某个 CPU 核被特定进程独占，通常需要以下两个步骤：

1.  **将指定的 CPU 核分配给目标进程的 `cgroup`**，即将该进程绑到特定的 CPU 核上。
2.  **确保其他进程不能使用这些 CPU 核**，即将其他进程的 CPU 使用限制在剩余的 CPU 核上。

### 实现 CPU 核独占的步骤

#### 1. 确保 `cgroup v2` 已挂载

与之前相同，首先确保 `cgroup v2` 已挂载。

```
bash


Copy code
mount | grep cgroup2
```

如果没有看到类似 `/sys/fs/cgroup` 的挂载信息，则挂载 `cgroup v2`：

```
bash


Copy code
sudo mount -t cgroup2 none /sys/fs/cgroup
```

#### 2. 创建两个 `cgroup` 控制组

创建两个 `cgroup` 控制组，一个用于将特定进程绑到目标 CPU 核，另一个用于将所有其他进程限制在剩余的 CPU 核上。

```
bashCopy codecd /sys/fs/cgroup
mkdir exclusive_group    # 用于绑定独占的进程
mkdir other_group        # 用于限制其他进程
```

#### 3. 配置 `cpuset.cpus` 和 `cpuset.mems`

-   **`exclusive_group`**：将要独占的进程绑定到特定的 CPU 核上，比如 `CPU 2`。
-   **`other_group`**：将所有其他进程限制在其他 CPU 核上（例如 `CPU 0` 和 `CPU 1`）。

```
bashCopy code# 独占 CPU 2 的进程
echo 2 > exclusive_group/cpuset.cpus
echo 0 > exclusive_group/cpuset.mems

# 限制其他进程只能使用 CPU 0 和 CPU 1
echo 0-1 > other_group/cpuset.cpus
echo 0 > other_group/cpuset.mems
```

#### 4. 将特定进程加入 `exclusive_group`

假设你希望进程 `1234` 独占 `CPU 2`，可以通过以下命令将该进程添加到 `exclusive_group` 中：

```
bash


Copy code
echo 1234 > exclusive_group/cgroup.procs
```

#### 5. 将其他进程加入 `other_group`

对于其他进程，可以将它们限制在 `other_group`，这样它们就只能使用 `CPU 0` 和 `CPU 1`。你可以通过如下命令，将其他系统进程加入这个 `cgroup`：

```
bash


Copy code
echo <PID> > other_group/cgroup.procs
```

也可以通过脚本自动将所有当前运行的进程限制在 `other_group` 中：

```
bashCopy codefor pid in $(pgrep -v -P 1); do
    echo $pid > other_group/cgroup.procs
done
```

这个脚本会将所有非根进程加入到 `other_group`，并让它们只使用 `CPU 0` 和 `CPU 1`。

#### 6. 验证 CPU 独占情况

你可以通过以下命令验证特定进程是否只运行在指定的 CPU 核上：

```
bash


Copy code
taskset -cp <PID>
```

该命令应显示进程 `1234` 只绑定在 `CPU 2` 上。

### 总结

通过 `cgroup v2` 的 `cpuset` 控制组，可以将某个 CPU 核独占分配给特定进程，并将其他进程限制在剩余的 CPU 核上，实现特定进程对 CPU 核的独占。





4o

##### You said:

我不喜欢手动添加，可以结合systemd，在系统启动的时候，启动weston进程后，weston进程自动独占cpu2嘛



###### ChatGPT said:

ChatGPT

Memory updated

是的，你可以通过 `systemd` 配置来实现自动在系统启动时，将 `Weston` 进程绑定到特定的 CPU（如 `CPU 2`），并确保它独占该 CPU。下面是实现这一目的的步骤。

### 1. 创建 `systemd` 服务文件

首先，创建或编辑一个 `systemd` 服务文件，使其启动 `Weston` 并将其绑定到 `CPU 2`。

假设你希望创建一个自定义的 `Weston` 启动服务文件，比如 `/etc/systemd/system/weston-cpuset.service`，内容如下：

```
iniCopy code[Unit]
Description=Start Weston and bind to CPU 2
After=network.target

[Service]
Type=simple
ExecStartPre=/usr/bin/cgroup2-cpuset-setup.sh
ExecStart=/usr/bin/weston
CPUAffinity=2

[Install]
WantedBy=multi-user.target
```

-   `ExecStartPre`：用于执行一个预启动脚本，在启动 `Weston` 之前设置 CPU 亲和性。
-   `ExecStart`：启动 `Weston` 的命令。
-   `CPUAffinity=2`：`systemd` 原生支持通过 `CPUAffinity` 参数绑定进程到指定的 CPU（这里是 `CPU 2`）。

### 2. 编写预启动脚本

在 `ExecStartPre` 中提到的脚本 `/usr/bin/cgroup2-cpuset-setup.sh` 是为了确保 `cgroup v2` 的 CPU 亲和性设置能够自动化，下面是脚本的内容：

```
bashCopy code#!/bin/bash

# 创建 cpuset 控制组目录
CGROUP_PATH="/sys/fs/cgroup/cpuset_weston"
if [ ! -d "$CGROUP_PATH" ]; then
    mkdir "$CGROUP_PATH"
fi

# 将 Weston 进程绑定到 CPU 2，并设置内存节点
echo 2 > "$CGROUP_PATH/cpuset.cpus"
echo 0 > "$CGROUP_PATH/cpuset.mems"

# 启动后将所有其他进程限制在 CPU 0 和 CPU 1
CGROUP_OTHER="/sys/fs/cgroup/cpuset_others"
if [ ! -d "$CGROUP_OTHER" ]; then
    mkdir "$CGROUP_OTHER"
fi
echo 0-1 > "$CGROUP_OTHER/cpuset.cpus"
echo 0 > "$CGROUP_OTHER/cpuset.mems"
```

确保该脚本具有执行权限：

```
bash


Copy code
sudo chmod +x /usr/bin/cgroup2-cpuset-setup.sh
```

### 3. 启用和启动服务

保存并退出后，使用以下命令重新加载 `systemd` 并启用该服务：

```
bashCopy codesudo systemctl daemon-reload
sudo systemctl enable weston-cpuset.service
sudo systemctl start weston-cpuset.service
```

### 4. 验证 Weston 是否独占 CPU 2

启动后，可以使用以下命令验证 `Weston` 是否被绑定到 `CPU 2`：

```
bash


Copy code
ps -eo pid,cmd,psr | grep weston
```

`psr` 列应显示 `Weston` 进程运行在 `CPU 2` 上。

### 总结

通过结合 `systemd` 和 `cgroup v2`，你可以在系统启动时自动将 `Weston` 进程绑定到指定的 CPU（如 `CPU 2`），并通过 `systemd` 的 `CPUAffinity` 选项确保进程的独占性。这种方法自动化了进程的 CPU 亲和性设置，避免了手动操作。





## 既然通过 CPUAffinity 参数绑定进程到指定的 CPU，为啥还需要cgroup呢



###### ChatGPT said:

ChatGPT

你的疑问很有道理！`CPUAffinity` 和 `cgroup` 的确都能实现进程的 CPU 亲和性控制，但它们的用途和功能范围稍有不同。根据你的目标（让 `Weston` 独占 `CPU 2`），我们可以选择使用 `CPUAffinity` 参数，而无需额外使用 `cgroup` 来绑定 CPU，因为 `CPUAffinity` 已经能够很好地完成这个任务。

### 区别与简化解释

-   **`CPUAffinity`**：这是 `systemd` 提供的一个选项，能够简单快捷地将服务绑定到指定的 CPU 核。例如，在服务文件中设置 `CPUAffinity=2`，就可以让 `Weston` 进程只在 `CPU 2` 上运行，而不会运行在其他 CPU 核上。这种方式适用于较为简单的场景，主要是绑定进程到指定 CPU。
-   **`cgroup` 的作用**：`cgroup v2` 提供了更精细的资源控制，比如 CPU 使用权、内存限制等。通过 `cgroup`，你不仅可以限制进程使用的 CPU 核，还可以实现更多复杂的资源管理，比如控制一组进程的总 CPU 使用、内存和 I/O 限制等。在你希望更灵活地管理一组进程，或需要实现多种资源控制时，`cgroup` 更有用。

### 在你的场景中

如果你只想让 `Weston` 独占 `CPU 2`，完全可以只使用 `systemd` 提供的 `CPUAffinity` 参数，这样配置更简单，且无需引入 `cgroup`。

### 使用 `systemd` 和 `CPUAffinity` 实现 Weston 独占 CPU 2

你可以简化之前的流程，直接使用 `systemd` 的 `CPUAffinity` 参数。

1.  **创建或修改 `systemd` 服务文件**：

```java
sudo nano /etc/systemd/system/weston-cpuset.service
```

内容如下：

```java
iniCopy code[Unit]
Description=Start Weston and bind to CPU 2
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/weston
CPUAffinity=2

[Install]
WantedBy=multi-user.target
```

1.  **启用并启动服务**：

```
bashCopy codesudo systemctl daemon-reload
sudo systemctl enable weston-cpuset.service
sudo systemctl start weston-cpuset.service
```

### 3. **验证效果**：

你可以使用以下命令查看 `Weston` 是否运行在 `CPU 2`：

```java
ps -eo pid,cmd,psr | grep weston
```

如果 `psr` 列中显示 `2`，说明 `Weston` 已成功绑定到 `CPU 2`。

### 总结

在你的场景中，通过 `systemd` 的 `CPUAffinity` 参数已经可以非常简洁地实现进程绑定到特定的 CPU 核上，不需要使用 `cgroup`。





# TODO： 整理

 进程管理系列3进程的优先级: https://paul.pub/android-process-priority/