# 目录

# 安卓自由窗口 

参考：

https://blog.csdn.net/sunmmer123/article/details/118211623?spm=1001.2014.3001.5501

https://huaweicloud.csdn.net/64e5c3da6ffa5020257601d1.html            **android framework实战开发之WINDOWING_MODE_FREEFORM自由窗口相关**

**前提**：自由窗口**模式打开**：（默认关闭）

```java
adb shell settings put global enable_freeform_support 1
adb shell settings put global force_resizable_activities 1
```

**以自由窗口模式启动Activity:**

**以自由窗口模式启动系统所有应用**

https://www.toscl.com/android_freeform/#小窗的边界









参考：

https://www.toscl.com/android_freeform/#小窗的启动方式

https://zhuanlan.zhihu.com/p/645953575#:~:text=哥的视频，-,及视频配套资料,-。      android framework实战开发之WINDOWING_MODE_FREEFORM自由窗口相关

https://blog.csdn.net/kavin_ma/article/details/79000549     Android Freeform模式  -------> 好文，其中的图

## 0层功能

**freedom窗口是一组功能的集合：**

>   1、永远置顶
>
>   2、可放缩
>
>   3、可移动
>
>   4、装饰（阴影、圆角）
>
>   5、启动动画---------> 是否是系统动画？与freedom无关？
>
>   图：
>
>   https://zhuanlan.zhihu.com/p/645953575#:~:text=哥的视频，-,及视频配套资料,-。

标志：

```
 /** Can be freely resized within its parent container. */ /** 可以在其父容器中自由调整大小。 */
 WINDOWING_MODE_FREEFORM = 5;
```

为什么起名freedom？ -------> 可自由移动 & 自由缩放

## UI结构

疑问：TODO:

>   装饰区域  最终的承载是一个window，还是surfaceview？？？？？
>
>   以及如何插入的

进程结构：

>   systemui进程里

从功能角度拆解：

>   系统侧生命周期的承载:  CaptionWindowDecorViewModel
>
>   （同时创建WindowDecoration）
>
>   Decoration区域的UI & UI操作 承载:  WindowDecoration

WindowDecoration

>   1、UI图：TODO
>
>   ```
>    <com.android.internal.widget.DecorCaptionView xmlns:android="<http://schemas.android.com/apk/res/android>"
>             ..................
>     <LinearLayout
>             .................... >
>         <Button
>                 android:id="@+id/maximize_window"
>                    。。。。。。。。。。。。。。
>         <Button
>                 android:id="@+id/close_window"
>                    ...................." />
>     </LinearLayout>
>    </com.android.internal.widget.DecorCaptionView>
>   ```
>
>   2、给    四个button + 根布局DecorCaptionView    设置监听器
>
>   ```java
>    caption.setOnTouchListener(mOnCaptionTouchListener); //  DecorCaptionView设置touch监听
>    
>    close.setOnClickListener(mOnCaptionButtonClickListener); // 四个button设置click监听
>    back.setOnClickListener(mOnCaptionButtonClickListener);
>    minimize.setOnClickListener(mOnCaptionButtonClickListener);
>    maximize.setOnClickListener(mOnCaptionButtonClickListener);
>   ```

## 图形承载---跨进程显示：

TODO: 图形结构为什么是这样设计的？？？？目的在于？？？

```java
 //WindowDecoration.java
 
 // DecorationContainerSurface
 if (mDecorationContainerSurface == null) {
     final SurfaceControl.Builder builder = mSurfaceControlBuilderSupplier.get();
     mDecorationContainerSurface = builder
             .setName("Decor container of Task=" + mTaskInfo.taskId)
             .setContainerLayer()
             .setParent(mTaskSurface) // 【】 绑定 DecorationContainerSurface 与 mTaskSurface     TODO: mTaskSurface这个是什么surface？
             .build();
 
 
 // CaptionContainerSurface, CaptionWindowManager
 if (mCaptionContainerSurface == null) {
     final SurfaceControl.Builder builder = mSurfaceControlBuilderSupplier.get();//【】创建mCaptionContainerSurface
     mCaptionContainerSurface = builder
             .setName("Caption container of Task=" + mTaskInfo.taskId)
             .setContainerLayer()
             .setParent(mDecorationContainerSurface) // 【】至此，三个surface都绑定到一起了
             .build();
 }
 
 
 if (mViewHost == null) {
     mViewHost = mSurfaceControlViewHostFactory.create(mDecorWindowContext, mDisplay,
             mCaptionWindowManager); //mCaptionWindowManager 关联 mCaptionContainerSurface
     if (params.mApplyStartTransactionOnDraw) {
         mViewHost.getRootSurfaceControl().applyTransactionOnDraw(startT);
     }
     mViewHost.setView(outResult.mRootView, lp); //
```

SurfaceControlViewHost  <----------  跨进程UI渲染的工具类

手段： 将本地的`View hierarchy`和远端的`SurfaceView`绑定起来，实现跨进程渲染

绘制/渲染（host承载）   -------->  显示（远端client承载）

>   图：
>
>   https://blog.csdn.net/april_12345/article/details/133749602#:~:text=是显示进程-,的一个view。,-具体实现
>
>   SurfacePackage的序列化：
>
>   ```java
>    // SurfacePackage
>    public void writeToParcel(@NonNull Parcel out, int flags) {
>     mSurfaceControl.writeToParcel(out, flags); // 【】  传递给远端的是surface，不是view！
>     out.writeStrongBinder(mAccessibilityEmbeddedConnection.asBinder());
>     out.writeStrongBinder(mInputToken);
>     out.writeStrongBinder(mRemoteInterface.asBinder());  // 【】 远端用来控制 viewHost的接口，ISurfaceControlViewHost
>    }
>   ```

-----------------> 简言之，远端插入surface

关于跨进程传递surface的本质：

>   猜测，应该是同mem buffer的传递 -------------------fd传递，共享内存
>
>   所以，不太会有损耗

host端层级：

```java
 - SurfaceControlViewHost： mSurfaceControl （contrainer layer)
         -  WindowlessWindowManager.State.mSurfaceControl (buffer laye)
```

TODO:  -------->   画图

client端层级：

```
 // SurfaceView hierarchy：
      - ViewRootImpl surface // 【】应用绘制的那块surface（去除status bar宽度）
           - bounds layer (crops all child surfaces to parent surface insets)
               - SurfaceView surface (drawn relative to ViewRootImpl surface)
 
                    - SurfaceControlViewHost.SurfacePackage surface   // 【】 插入进来的
 
               - Background color layer (drawn behind all SurfaceView surfaces)
 

 原文链接：<https://blog.csdn.net/april_12345/article/details/133749602>
```

TODO:  -------->   画图

维测：

surfaceFlinger角度：

```
 Display 4630946523002478721 (active) HWC layers:
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  Layer name
            Z |  Window Type |  Comp Type |  Transform |   Disp Frame (LTRB) |          Source Crop (LTRB) |     Frame Rate (Explicit) (Seamlessness) [Focused]
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  Wallpaper BBQ wrapper#68
   rel      0 |            0 |     DEVICE |          0 |    0    0 1080 2340 |   21.0   47.0  451.0  977.0 |                                              [ ]
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  com.android.launcher3/com.android.launcher3.uioverrides.QuickstepLauncher#662
   rel      0 |            1 |     DEVICE |          0 |    0    0 1080 2340 |    0.0    0.0 1080.0 2340.0 |                                              [ ]
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  com.android.dialer/com.android.dialer.main.impl.MainActivity#663
   rel      0 |            1 |     DEVICE |          0 |   50  186  655 1356 |    0.0    0.0  605.0 1170.0 |                                              [*]
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  Caption of Task=37#670
   rel      0 |            0 |     DEVICE |          0 |   50  186  655  302 |    0.0    0.0  605.0  116.0 |                                              [ ]
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------  //【】  ----------->  能够看到Caption的surface（dialer应用对应的）
  StatusBar#81
   rel      0 |         2000 |     DEVICE |          0 |    0    0 1080  136 |    0.0    0.0 1080.0  136.0 |                                              [ ]
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  NavigationBar0#77
   rel      0 |         2019 |     DEVICE |          0 |    0 2208 1080 2340 |    0.0    0.0 1080.0  132.0 |                                              [ ]
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ScreenDecorOverlay#64
   rel      0 |         2024 |     DEVICE |          0 |    0    0 1080  216 |    0.0    0.0 1080.0  216.0 |                                              [ ]
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ScreenDecorOverlayBottom#69
   rel      0 |         2024 |     DEVICE |          0 |    0 2103 1080 2340 |    0.0    0.0 1080.0  237.0 |                                              [ ]
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
```

-   -------------------> 结论：

>   1、Task=37是dialer应用所在Task  --------->  可见，surfaceFlinger在底层把  Caption的surface  插入到Task=37里了
>
>   2、层级是 670，比dialer应用高
>
>   <-----------  自然结论：因为task是跳跳跳。这个surface 生命周期同 底下window

window角度：

>   看不到caption：
>
>   ```java
>    //  dumpSys window
>    
>    Window #7 Window{6d69d9c u0 com.android.dialer/com.android.dialer.main.impl.MainActivity}:
>     mDisplayId=0 //【】 rootTaskId=37 mSession=Session{b51bfd6 7784:u0a10070} mClient=android.os.BinderProxy@f8e090f
>     mOwnerUid=10070 showForAllUsers=false package=com.android.dialer appop=NONE
>     mAttrs={(0,0)(fillxfill) sim={state=always_hidden adjust=nothing forwardNavigation} ty=BASE_APPLICATION wanim=0x10302fe
>       fl=LAYOUT_IN_SCREEN LAYOUT_INSET_DECOR SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS
>       pfl=NO_MOVE_ANIMATION FORCE_DRAW_STATUS_BAR_BACKGROUND USE_BLAST FIT_INSETS_CONTROLLED
>       vsysui=LIGHT_NAVIGATION_BAR
>       apr=LIGHT_NAVIGATION_BARS
>       bhv=DEFAULT
>       fitSides=}
>   ```

host 与  client联系：

>   final SurfaceControlViewHost host = new SurfaceControlViewHost(this, getDisplay(),          hostInputToken); host.setView(suggestionRoot, lp); aidlClass.aidlFunction(host.getSurfacePackage());  //通过aidl接口将SurfacePackage交给显示进程即client端。
>
>   ```java
>    SurfaceHolder.Callback.surfaceCreated() {
>      从远程host中获取SurfaceControlViewHost.SurfacePackage。 可以显示进程调用aidl接口从绘制进程获取，或绘制进程调用aidl传入到显示进程。
>      SurfaceView.setChildSurfacePackage(SurfacePackage);
>    }
>   ```

为什么要这样做？

>   setParent会绑定两个surface的 transition？？？

WindowDecoration 初始化时机：

>   %accordion%  Transitions.onTransitionReady  %accordion%
>
>   ```java
>    WindowDecoration.WindowDecoration(Context, DisplayController, ShellTaskOrganizer, RunningTaskInfo, SurfaceControl)  (com.android.wm.shell.windowdecor)
>     DesktopModeWindowDecoration.DesktopModeWindowDecoration(Context, DisplayController, ShellTaskOrganizer, RunningTaskInfo, SurfaceControl, Handler, Choreographer, ...)  (com.android.wm.shell.windowdecor)
>         create(Context, DisplayController, ShellTaskOrganizer, RunningTaskInfo, SurfaceControl, Handler, Choreographer, ...) in Factory in DesktopModeWindowDecoration  (com.android.wm.shell.windowdecor)
>             DesktopModeWindowDecorViewModel.createWindowDecoration(RunningTaskInfo, SurfaceControl, Transaction, Transaction)  (com.android.wm.shell.windowdecor)
>                 DesktopModeWindowDecorViewModel.onTaskChanging(RunningTaskInfo, SurfaceControl, Transaction, Transaction)  (com.android.wm.shell.windowdecor)  // 【】 public
>                     FreeformTaskTransitionObserver.onToFrontTransitionReady(Change, Transaction, Transaction)  (com.android.wm.shell.freeform)
>                         FreeformTaskTransitionObserver.onTransitionReady(IBinder, TransitionInfo, Transaction, Transaction)  (com.android.wm.shell.freeform)   // 【】 public
>                             Transitions.dispatchReady(ActiveTransition)  (com.android.wm.shell.transition)
>                                 Transitions.onTransitionReady(IBinder, TransitionInfo, Transaction, Transaction) // 【】 public
>    
>    
>    
>   ```
>
>   %/accordion%

TODO:

>   forceDisableBLAST

TODO:

>   事件是怎么过来的？
>
>   上下window如何同步的？
>
>   为啥上面不用window？不用的原因是什么？
>
>   为啥要这样设计？传给cliet显示的作用是啥？好处是啥？

remote-surface  demo：

>   https://github.com/Felix-Dai/remote-surface

参考：

>   https://blog.csdn.net/april_12345/article/details/133749602      Android SurfaceControlViewHost介绍及使用
>
>   https://www.jianshu.com/p/0f45fdb36631         使用SurfaceControlViewHost 实现跨进程UI渲染
>
>   https://commonsware.com/blog/2020/03/27/peek-surfacecontrolviewhost-android-r.html    牛人文章

## UI的事件

事件是直接基于surface分发的?     还是 先分发到 client再传给host  ？

## 功能代码入口

入口：应用（系统应用多任务、三方应用侧边栏）

>   多任务界面（属于launcher3界面）启动：
>
>   >   多任务里面，点击应用图标，选择小窗模式（安卓原生）： ------->  必然： 需求决定：触发点 & 确定点是 launcher3
>   >
>   >   ```java
>   >    // ActivityTaskSupervisor.java   // TODO: 为啥log显示 system_server调用的这个接口？
>   >    startActivityFromRecents() {
>   >    
>   >    }
>   >   ```
>
>   侧边栏：
>
>   >   三方应用启动，比如侧边栏（华为手机），通知栏等待
>   >
>   >   %accordion%  代码  %accordion%
>   >
>   >   ```java
>   >    // TODO: 侧边栏进程是？类？  TODO: 从0层来看，在此之前，要由pms判断，是否支持
>   >    public void startFreeFormActivity(View view) {
>   >     ...................
>   >     options.setLaunchWindowingMode(WINDOWING_MODE_FREEFORM); // 【】 自然，以FREEFORM startActivity
>   >     startActivity(intent, options.toBundle());
>   >    }
>   >   ```
>   >
>   >   %/accordion%

-   ------------------> **总结：**

>   1、都是应用启动   2、都是应用指定了浮窗模式

妥协-----------**白名单：**

**白名单位置：**应用侧配置，系统侧Pms去解析

>   1、支持小窗的应用 ---------->  应用需要设置 android:resizeableActivity="true"
>
>   系统侧判断：AndroidManifest.xml ---> PackageParser.ActivityInfo`的`privateFlags
>
>   PMS解析：
>
>   ```
>   
>   ```
>
>   TODO: 从应用角度，需要做哪些事情呢？？？仅仅适配小窗的尺寸？
>
>   android:resizeableActivity="true"  含义又是啥
>
>   2、不支持的应用：
>
>   >   系统侧如何处理的？似乎没有强制resize

## 功能之 可放缩

国内厂商--------------只有一种长宽比（假的缩放）：

>   ------------->  目的在于：避免适配无数种宽高比
>
>   >   resize 过程  通过矩阵变化中的缩放  ------->  事件、显示的映射？？？？surface大小变了没？

安卓原生------------任意宽高比（真实的resize）

疑问：（1）**应用如何保证可以无限resize？**

（2）

触发：

```java
onDragPositioningEnd:89, FluidResizeTaskPositioner // 【2】 识别是resize后，交给 FluidResizeTaskPositioner 处理 
handleMotionEvent:144, 
DragResizeInputListener$TaskResizeInputEventReceiver 
onMotionEvent:109, DragDetector  // 【1】 DragDetector 识别是否是resize！！！！
onInputEvent:14, 
DragResizeInputListener$TaskResizeInputEventReceiver
dispatchInputEvent:267,
InputEventReceiver  
nativePollOnce:-1, 
MessageQueue  
next:335, 
MessageQueue loopOnce:162, 
Looper loop:294, 
Looper run:67, HandlerThread //【】 TODO:  最开始谁触发的？ 事件机制是怎么样的？
```

参考：

>   https://zhuanlan.zhihu.com/p/645953575#:~:text=插入图片描述-,自由窗口模式的拖拽变大,-frameworks/base

## 功能之 可移动

结论：由 CaptionView 承载

```java
 frameworks/base/core/java/com/android/internal/widget/DecorCaptionView.java
 
 @Override
     public boolean onTouch(View v, MotionEvent e) {
             ............
             case MotionEvent.ACTION_MOVE:
 
             //这里app进程发起startMovingTask调用
                     startMovingTask(e.getRawX(), e.getRawY());  // 【】 安卓的task对应kwin的Tile
                 break;
    }
 
 
    public final boolean startMovingTask(float startX, float startY) {
         ............
         try {
              //【】 这里最后通过Session进行跨进程调用到systemserver
             return mAttachInfo.mSession.startMovingTask(mAttachInfo.mWindow, startX, startY);
         } catch (RemoteException e) {
             ............
         }
         ............
     }
```

TODO:   移动的同步：

>   底层窗口是如何同步移动的？

参考：

>   https://blog.csdn.net/learnframework/article/details/131130412?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-131130412-blog-135064522.235^v43^pc_blog_bottom_relevance_base7&spm=1001.2101.3001.4242.1&utm_relevant_index=3#:~:text=96-,自由窗口模式的移动,-自由窗口的

## 栈维护

效果：

>   安卓原生:  可以多个自由窗口同时显示（类似于windows和linux）
>
>   华为：始终保持一个

## 功能之 装饰UI

### 阴影

## 补充操作入口

```
 adb shell settings put global enable_freeform_support 1
 adb shell settings put global force_resizable_activities 1
```





# 窗口的阴影和圆角

见《SF特效》


