# 进程与子进程

参考： [C++ 多进程，父进程监控子进程 - 代码先锋网 (codeleading.com)](https://codeleading.com/article/60953963187/)          https://codeleading.com/article/60953963187/

```java
 #include <unistd.h>
 #include <sys/types.h>
 #include <stdlib.h>
 #include <signal.h>
 #include <stdio.h>
 #include<sys/wait.h>
 

 //子进程个数
 #define SUB_PRO_COUNT 10

 //处理子进程的退出信号
 void sub_quit_signal_handle(int sig);

 //父进程的事件循环
 void ParentCycle();

 //子进程的事件循环
 void ChildCycle();

 int main(void)
 {
     pid_t  pid;
     int i;

     //创建SUB_PRO_COUNT个子进程
     for(i=0; i<SUB_PRO_COUNT; i++)
     {
         pid = fork();
         printf("cg, this process id: %d, i: %d, fork, pid: %d\\n", getpid(), i, pid);
         if( 0 == pid || -1 == pid )
             break;
     }

     //创建子进程失败
     if( -1 == pid )
     {
         printf("No. %d: fork error\\n", i);
     }
     //子进程的事件循环
     else if( 0 == pid )
     {
         printf("cg, this process id: %d, ChildCycle, pid: %d\\n", getpid(), pid);
         ChildCycle();
     }
     //父进程的事件循环
     else
     {
         printf("cg, this process id: %d, ParentCycle, pid: %d\\n", getpid(), pid);
         ParentCycle();
     }

     return 0;
 }

 void sub_quit_signal_handle(int sig)
 {
     printf("sub_quit_signal_handle, this process: %d\\n", getpid());
     int status;
     //获取退出的那个子进程的状态
     int quit_pid = wait(&status);
     printf("sub process %d quit, exit status %d\\n", quit_pid, status);

     //新创建一个子进程
     //pid_t pid = fork();
     //if( 0 == pid )
       //   ChildCycle();
 }

 void ParentCycle()
 {
     printf("Parent process1 %d\\n", getpid());
     signal(SIGCHLD, sub_quit_signal_handle);    // todo:
     printf("Parent process2 %d\\n", getpid());
     while(1){
         printf("Parent process3 %d\\n", getpid());
         pause();
     };
 }

 void ChildCycle()
 {
     printf("create sub process id: %d, parent id: %d\\n", getpid(), getppid());
     while(1){
         pause();
     };
 }
 
```

-----------------> 一行关键代码：

```java
 signal(SIGCHLD, sub_quit_signal_handle);  // 父进程，收到child的信号  ------>【1】  为啥这行不会阻塞？
```

~~次要：调用处理，获取具体信息~~

```java
 //获取退出的那个子进程的状态
 int quit_pid = wait(&status);
 printf("sub process %d quit, exit status %d\\n", quit_pid, status);
```

TODO: 【1】为什么没有阻塞？后面SIGCHLD却可以唤醒 主进程！！！！！

[【信号】SIGCHLD信号-CSDN博客](https://blog.csdn.net/isunbin/article/details/84032708?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-84032708-blog-127649401.235^v38^pc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-84032708-blog-127649401.235^v38^pc_relevant_sort_base1&utm_relevant_index=2)            https://blog.csdn.net/isunbin/article/details/84032708?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-84032708-blog-127649401.235^v38^pc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-84032708-blog-127649401.235^v38^pc_relevant_sort_base1&utm_relevant_index=2



结论：

> 父进程可以感知到子进程的死亡



# 进程组

## linux进程组

参考： https://blog.csdn.net/jinking01/article/details/126925313?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-126925313-blog-128064414.235^v38^pc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-126925313-blog-128064414.235^v38^pc_relevant_sort_base1&utm_relevant_index=2   Linux基础概念--进程、子进程、进程组和会话

概念：

**站在进程角度 ：**

> 进程号pid,
>
> 父进程号 ppid,
>
> 进程组号pgid

参考：

### 编程角度：

> 参考： https://blog.csdn.net/chen_y09/article/details/130869886   Linux C 查询当前进程号、父进程号、进程组号_c语言获取当前进程号-CSDN博客
>
> ```
>   #include<stdio.h>
>   #include<sys/types.h>
>   #include<unistd.h>
>  
>   int main(int argc,char *argv[])
>   {
>       pid_t pid,ppid,pgid;
>  
>       pid = getpid();
>       printf("pid = %d\\\\n",pid);
>  
>       ppid = getppid();
>       printf("father pid = %d\\\\n",ppid);
>  
>       pgid = getpgid(pid);
>       printf("group pid = %d\\\\n",pgid);
>       return 0;
>   }
> ```

## 进程组视角：SCHED_GROUP/ProcessGroup/SchedPolicy组/cpuset

Activity调度组：  ~~------->  安卓组件的概念（因为安卓是组件，必须有）、AMS层的东西~~

```
   SCHED_GROUP_BACKGROUND = 0  // 后台进程组
   SCHED_GROUP_RESTRICTED = 1  // 限制
   SCHED_GROUP_DEFAULT = 2   // 默认进程组
   SCHED_GROUP_TOP_APP = 3   // top进程组
   SCHED_GROUP_TOP_APP_BOUND = 4
```

thread group：     --------->  进程组，linux范畴（必须对接）、linux层的东西

```
   THREAD_GROUP_DEFAULT = -1
   THREAD_GROUP_BG_NONINTERACTIVE = 0
   THREAD_GROUP_FOREGROUND = 1
   THREAD_GROUP_SYSTEM = 2
   THREAD_GROUP_AUDIO_APP = 3
   THREAD_GROUP_AUDIO_SYS = 4
   THREAD_GROUP_TOP_APP = 5
   THREAD_GROUP_RT_APP = 6
   THREAD_GROUP_RESTRICTED = 7
```

**大致映射关系：**

| Activity调度组（安卓AMS）SCHED_GROUP                       | 进程组 THREAD_GROUP（安卓模仿linux创造的） | SchedPolicy （linux） SP_ |
| ---------------------------------------------------------- | ------------------------------------------ | ------------------------- |
| SCHED_GROUP_DEFAULT(2)                                     | THREAD_GROUP_DEFAULT(-1)                   | SP_DEFAULTSP_DEFAULT = -1 |
| SCHED_GROUP_BACKGROUND(0)                                  | THREAD_GROUP_BG_NONINTERACTIVE(0)          | SP_BACKGROUND = 0         |
|                                                            |                                            | SP_FOREGROUND = 1         |
|                                                            |                                            |                           |
| SCHED_GROUP_TOP_APP（3）    SCHED_GROUP_TOP_APP_BOUND（4） | THREAD_GROUP_TOP_APP(5)同上                | SP_   .............  = 3  |
| SCHED_GROUP_RESTRICTED(1)                                  | THREAD_GROUP_RESTRICTED(7)                 | SP_   .............  = 7  |

**目标：**Activity调度组SCHED_GROUP ---->  进程组THREAD_GROUP -----> SchedPolicy （linux） SP_

------------------> **结论：**

~~1、右边两个是完全一致的关系：~~

```java
/* Keep in sync with THREAD_GROUP_* in frameworks/base/core/java/android/os/Process.java */  
typedef enum {    
    SP_DEFAULT = -1,    
    SP_BACKGROUND = 0,    
    SP_FOREGROUND = 1,    
    SP_SYSTEM = 2,  // can't be used with set_sched_policy()    
    SP_AUDIO_APP = 3,    
    SP_AUDIO_SYS = 4,   
    SP_TOP_APP = 5,    
    SP_RT_APP = 6,    
    SP_RESTRICTED = 7,    
    SP_CNT,    
    SP_MAX = SP_CNT - 1,    
    SP_SYSTEM_DEFAULT = SP_FOREGROUND,  
} SchedPolicy;
```

------------------> 其实没明白：

TODO:  从设计角度：  设置进程组setProcessGroup的作用是啥？  不是有了setThreadPriority设置优先级嘛？  ------> TODO: 类似于用户组？





设置 Activity调度组SCHED_GROU流程：

```java
// OomAdjuster.applyOomAdjLocked流程中： 目标：Activity调度组SCHED_GROUP ---->  进程组THREAD_GROUP ---》 SchedPolicy （linux） SP_    
   设置 Activity调度组SCHED_GROUP：     
        Process.setProcessGroup 透传        
              android_os_Process_setProcessGroup 具体做的事情：           
                      SchedPolicy sp = (SchedPolicy) grp; // 调度组，转化成调度策略                 
                      set_cpuset_policy(t_pid, sp); ----> SetTaskProfiles("CPUSET_SP_BACKGROUND")  // 目标：设置cpuset（Cgroup范畴）  ------》 TODO: 具体做了啥？【1】          
                      set_sched_policy(t_pid, sp)  ---> SetTaskProfiles("SCHED_SP_BACKGROUND")   //------> TODO: 具体做了啥？     
                          
sprintf(proc_path, "/proc/%d/task", pid); ------->  // 创建目录:  /proc/5770/task/14372
```

【1】写cpuset对应的**task节点配置**，添加对应的pid:

> ```java
> //  task下pid ------> 运行时决定 sailfish:/dev/cpuset/top-app # cat tasks | grep 5770  -----> [//com.example.myapplication在前台](http://com.example.xn--myapplication-1l3vp4qw0o) 5770 sailfish:/dev/cpuset/top-app # cat tasks | grep 5770  -----> [//com.example.myapplication在后台](http://com.example.xn--myapplication-ne8v3my32b)  //top-app组使用的 cpuset 的核心 --------> TODO: 按道理，是初始化时决定的 sailfish:/dev/cpuset/top-app # cat cpus 0-3
> ```
>
> 参考： https://www.jianshu.com/p/0532e4239703   Android 进程管理篇（四）-cpu限制

**总之：**

> (1) 进入组：SCHED_GROUP调度组 ----> 进程组  -----> cpuset 节点（基于cgroup），加入task
>
> (2) 限制组里的成员：~~而 cpuset 节点本身就有对组的限制-------cpuset/top-app/cpus~~

注释：

> Profiles 配置文件

### ~~del:临时扩展：set_cpuset_policy(int tid, SchedPolicy policy)~~

```
 int set_cpuset_policy(int tid, SchedPolicy policy) {
     if (tid == 0) {
         tid = GetThreadId();
     }
     policy = _policy(policy);
 
     switch (policy) {
         case SP_BACKGROUND:
             return SetTaskProfiles(tid, {"CPUSET_SP_BACKGROUND", "BlkIOBackground"}, true) ? 0 : -1;
         case SP_FOREGROUND:
         case SP_AUDIO_APP:
         case SP_AUDIO_SYS:
             return SetTaskProfiles(tid, {"CPUSET_SP_FOREGROUND"}, true) ? 0 : -1;
         case SP_TOP_APP:
             return SetTaskProfiles(tid, {"CPUSET_SP_TOP_APP"}, true) ? 0 : -1;
         case SP_SYSTEM:
             return SetTaskProfiles(tid, {"CPUSET_SP_SYSTEM"}, true) ? 0 : -1;
         case SP_RESTRICTED:
             return SetTaskProfiles(tid, {"CPUSET_SP_RESTRICTED"}, true) ? 0 : -1;
         default:
             break;
     }
 
     return 0;
 }
```

---------> /dev/cpuset/backgroud/各种后台应用的pid

```
 sailfish:/dev/cpuset/background # ls -la   //cpuset 含义？
 drwxr-xr-x  2 system system 0 1971-05-11 00:47 .
 dr-xr-xr-x 11 system system 0 1971-05-11 00:47 ..
 -rw-r--r--  1 root   root   0 2023-10-16 04:12 cgroup.clone_children
 -rw-r--r--  1 root   root   0 2023-10-16 04:12 cgroup.procs
 -rw-r--r--  1 root   root   0 2023-10-16 04:12 cpu_exclusive
 -rw-r--r--  1 root   root   0 2023-10-11 17:19 cpus    // 【1】主要作用：限制background可以使用的核心，比如0
 -r--r--r--  1 root   root   0 2023-10-16 04:12 effective_cpus
 -r--r--r--  1 root   root   0 2023-10-16 04:12 effective_mems
 -rw-r--r--  1 root   root   0 2023-10-16 04:12 mem_exclusive
 -rw-r--r--  1 root   root   0 2023-10-16 04:12 mem_hardwall
 -rw-r--r--  1 root   root   0 2023-10-16 04:12 memory_migrate
 -r--r--r--  1 root   root   0 2023-10-16 04:12 memory_pressure
 -rw-r--r--  1 root   root   0 2023-10-16 04:12 memory_spread_page
 -rw-r--r--  1 root   root   0 2023-10-16 04:12 memory_spread_slab
 -rw-r--r--  1 root   root   0 1971-05-11 00:47 mems
 -rw-r--r--  1 root   root   0 2023-10-16 04:12 notify_on_release
 -rw-r--r--  1 root   root   0 2023-10-16 04:12 sched_load_balance
 -rw-r--r--  1 root   root   0 2023-10-16 04:12 sched_relax_domain_level
 -rw-rw-r--  1 system system 0 1971-05-11 00:47 tasks   // 记录属于background的各种pid，比如：12186，5770，14345
```

注： 【1】cpuset是linux原本就有的机制，~~但是目录不一样：~~

```
 cpuset -------- 根据前后台状态，把后台应用进程限制在特定的cpu核上
                echo "0-3,6" > /sys/fs/cgroup/cpuset/mygroup/cpuset.cpus   核心0-3 和 6
```

### ~~del:临时扩展：set_sched_policy(int tid, SchedPolicy policy)~~

完全参考：https://www.jianshu.com/p/06aab76bb7da   没懂

TODO: 图  调用，最终生效，作用

set_sched_policy  -------->  设置cpu/schedtune两个子系统，子系统节点和SchedPolicy类型对应如下：

最终生效：

> https://www.jianshu.com/p/06aab76bb7da
>
> （1）cpuctl：   -----> 似乎啥也没做
>
> ```java
>  /dev/cpuctl/tasks   // TODO: 一堆pid。作用是啥？            SP_FOREGROUND SP_AUDIO_APP SP_AUDIO_SYS
>  /dev/cpuctl/bg_non_interactive/tasks                 //    SP_BACKGROUND
> ```
>
> （2）stune：**调频**
>
> ```java
>  /dev/stune/top-app/tasks                               SP_TOP_APP
>                    /schedtune.boost ---->  10  【2_1】
>  
>  /dev/stune/foreground/tasks                            SP_FOREGROUND SP_AUDIO_APP SP_AUDIO_SYS
>  /dev/stune/background/tasks                            SP_BACKGROUND
> ```
>
> 参考： [Android/Linux EAS优化-schedtune-CSDN博客](https://blog.csdn.net/liaochaoyun/article/details/122377605)   ~~https://blog.csdn.net/liaochaoyun/article/details/122377605~~

补充： 【2_1】 schedtune.boost的值在 **init.rc** 中设置的：  参考： https://blog.csdn.net/liaochaoyun/article/details/122377605

```java
 //  / init.rc
 
 # set default schedTune value for foreground/top-app (only affects EAS)
 write /dev/stune/foreground/schedtune.prefer_idle 1
 write /dev/stune/top-app/schedtune.boost 10
 write /dev/stune/top-app/schedtune.prefer_idle 1
 write /dev/stune/rt/schedtune.boost 30
 write /dev/stune/rt/schedtune.prefer_idle 1
```

## process视角：/proc/5770/task/ 记录一个process(linux & android)

**现状：**  /proc/5770/task/目录      ------>  **是linux的机制**

-----> **安卓所做：** 给进程设定特定的进程组

以com.example.myapplication为例，pid：5770;  renderTread  Tid: 14372

文件目录结构：

```java
 sailfish:/proc/5770 # ls -la
 dr-xr-xr-x   2 u0_a103 u0_a103 0 2023-11-20 14:35 attr
 -r--------   1 u0_a103 u0_a103 0 2023-11-20 14:35 auxv
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 cgroup // 【1】
 --w-------   1 u0_a103 u0_a103 0 2023-11-20 14:35 clear_refs
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:14 cmdline // 即：com.example.myapplication
 -rw-r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:14 comm
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 concurrent_active_time //
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 concurrent_policy_time
 -rw-r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 coredump_filter
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 cpuset
 lrwxrwxrwx   1 u0_a103 u0_a103 0 2023-11-20 14:35 cwd -> /
 -r--------   1 u0_a103 u0_a103 0 2023-11-20 14:35 environ
 lrwxrwxrwx   1 u0_a103 u0_a103 0 2023-11-20 14:35 exe -> /system/bin/app_process64
 dr-x------   2 u0_a103 u0_a103 0 2023-11-20 14:14 fd
 dr-x------   2 u0_a103 u0_a103 0 2023-11-20 14:35 fdinfo
 -r--------   1 u0_a103 u0_a103 0 2023-11-20 14:35 io
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 limits
 -rw-r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 loginuid
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 maps
 -rw-------   1 u0_a103 u0_a103 0 2023-11-20 14:35 mem
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 mountinfo
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 mounts
 -r--------   1 u0_a103 u0_a103 0 2023-11-20 14:35 mountstats
 dr-xr-xr-x  10 u0_a103 u0_a103 0 2023-11-20 14:35 net
 dr-x--x--x   2 u0_a103 u0_a103 0 2023-11-20 14:35 ns
 -r--------   1 u0_a103 u0_a103 0 2023-11-20 14:35 oom_adj
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 oom_score
 -r--------   1 u0_a103 u0_a103 0 2023-11-20 14:14 oom_score_adj
 -r--------   1 u0_a103 u0_a103 0 2023-11-20 14:35 pagemap
 -r--------   1 u0_a103 u0_a103 0 2023-11-20 14:35 personality
 lrwxrwxrwx   1 u0_a103 u0_a103 0 2023-11-20 14:35 root -> /
 -rw-r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 sched
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 schedstat
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 sessionid
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 smaps
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:20 smaps_rollup
 -r--------   1 u0_a103 u0_a103 0 2023-11-20 14:35 stack
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:14 stat
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:20 statm
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:14 status
 -r--------   1 u0_a103 u0_a103 0 2023-11-20 14:35 syscall
 dr-xr-xr-x  19 u0_a103 u0_a103 0 2023-11-20 14:14 task
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 time_in_state
 -r--r--r--   1 u0_a103 u0_a103 0 2023-11-20 14:35 wchan
```

// 【1】cgroup（ linux & android）：

```java
 sailfish:/proc/5770 # cat cgroup
 4:schedtune:/background    ------>  //调频限制组
 3:cpuset:/background       ------> //cpu核set限制，限制组background
 2:cpuacct:/uid_10103/pid_5770
 1:cpu:/
```

## ~~del：临时补充： **cgroups机制中的cpu/cpuset/schedtune子系**~~

cgroups机制：

cpuset

cpuctl

schedtune   CPU调频





# 一些结论：

1、Android系统认为**“重要”的进程**主要有三类：

1. 系统进程
2. 前台与用户交互的进程
3. 前台进程所使用到的进程

完全参考：  https://blog.csdn.net/weixin_47465999/article/details/132043377

2、**AMS层面的  进程优先级** 有三个方面：

```java
 app.curAdj = app.modifyRawOomAdj(adj);
 app.curSchedGroup = schedGroup;
 app.curProcState = procState;
 app.foregroundActivities = foregroundActivities;
 
 <---------  计算过程确定（updateOomAdjLocked、updateOomAdjLocked）
 原文链接：<https://blog.csdn.net/weixin_47465999/article/details/132043377>
```

三方面的 **生效点**：

```java
 ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj); 将计算出来的adj值写入到procfs中，即：/proc/[pid]/oom_score_adj 这个文件中。
 Process.setProcessGroup(app.pid, processGroup); 用来设置进程的调度组（【1】调度组processGroup是机器init时创建的）
 app.thread.setProcessState(app.repProcState); 这个方法会最终调用到 VMRuntime.getRuntime().updateProcessState();将进程的状态设置到虚拟机中。
 
 
 原文链接：<https://blog.csdn.net/weixin_47465999/article/details/132043377>
```

linux处的**生效点**：

## TODO:【1】init时创建调度组processGroup

原文链接：https://www.jianshu.com/p/ee2f2344658f

```java
   // init.rc 有关 foreground 和 background的设置
     mkdir /dev/cpuset/foreground
     write /dev/cpuset/foreground/cpus 0
     write /dev/cpuset/foreground/mems 0
     mkdir /dev/cpuset/foreground/boost
     write /dev/cpuset/foreground/boost/cpus 0
     write /dev/cpuset/foreground/boost/mems 0
     mkdir /dev/cpuset/background
     write /dev/cpuset/background/cpus 0
     write /dev/cpuset/background/mems 0
 
     # system-background is for system tasks that should only run on
     # little cores, not on bigs
     # to be used only by init, so don't change system-bg permissions
     mkdir /dev/cpuset/system-background
     write /dev/cpuset/system-background/cpus 0
     write /dev/cpuset/system-background/mems 0
 
     # change permissions for all cpusets we'll touch at runtime
     chown system system /dev/cpuset
     chown system system /dev/cpuset/foreground
     chown system system /dev/cpuset/foreground/boost
     chown system system /dev/cpuset/background
     chown system system /dev/cpuset/tasks
     chown system system /dev/cpuset/foreground/tasks
     chown system system /dev/cpuset/foreground/boost/tasks
     chown system system /dev/cpuset/background/tasks
     chmod 0664 /dev/cpuset/foreground/tasks
     chmod 0664 /dev/cpuset/foreground/boost/tasks
     chmod 0664 /dev/cpuset/background/tasks
     chmod 0664 /dev/cpuset/tasks
```



## 疑问： setThreadPriority 与 setProcessGroup的关系？

必然要求： 调度组，不涉及nice的设置

## linux本身提供的机制：

例如：

- 通过fork来创建进行
- 通过**信号量**来管理进程
- 通过**proc文件系统**来查询和调整进程状态 等