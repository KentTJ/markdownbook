{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. Your Book Title Your Book Title 1. Your Book Title 0_图形系统 0_Graphic系统总论 1_Render系统 Opengl 2_窗口系统 0_窗口系统总论 次要 Virtual Display 自由窗口 Surface Control Virtual Display Wms Animination 窗口管理之weston 窗口管理器WMS 3_Display系统 Display系统 DRM sf特效 合成之surfaceFlinger 合成之weston 其他 QT 多屏显示分析 0_输入系统 Input 全局手势 0_进程管理 0 AMS App保活的方式 后台杀进程 杀进程原理 进程与子进程 进程管理系列0_总论 进程管理系列1之进程的创建 进程管理系列2之进程的优先级 进程管理系列3之内存回收 Andriod 关键流程 Init System Start APP 其他核心服务 1 Input Method Multi Client Ime 无障碍_ 0 Andriod System log框架 Permissions 模型 Coding 0 Computor Base Design Pattern How To Read Code How Writecode Linux linux文件系统 Operate System Refactor 用户_用户组 解耦 0 IPC Andriod IPC IPC前提_序列化 Socket 线程间通信 0_性能 Profiler Systrace 内存 性能_ 1_稳定性 ANR Watch Dog Andriod Car Car Service Android Tool Hierarchy View App APK 64 Bit 32 Bit APP开发 Launcher 3 System UI 小程序 Coding Language C Cpp Java java反射 JNI Js Python R Features 其他特性 多用户 Other OS Open Harmony Other OS Wayland Kwin 多线程 多线程的模型 线程池与binder线程池 文件系统结构 虚拟化 Naturalaw Reading And Thinking Book 2 Check List console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/":{"url":"0_图形系统/","title":"0_图形系统","keywords":"","body":"1. Your Book Title Your Book Title 1. Your Book Title 0_图形系统 0_Graphic系统总论 1_Render系统 Effect Opengl 2_窗口系统 次要 Virtual Display 自由窗口 0_窗口系统总论 Surface Control Virtual Display Wms Animination 窗口管理器WMS 3_Display系统 Display系统 合成器surfaceFlinger 其他 Android 多屏显示分析 QT Weston 0_输入系统 Input 全局手势 0_进程管理 0 AMS App保活的方式 后台杀进程 杀进程原理 进程与子进程 进程管理系列0_总论 进程管理系列1之进程的创建 进程管理系列2之进程的优先级 进程管理系列3之内存回收 Andriod 关键流程 Init System Start APP 其他核心服务 1 Input Method Multi Client Ime 无障碍_ 0 Andriod System log框架 Permissions 模型 Coding 0 Computor Base Design Pattern How To Read Code How Writecode Linux linux文件系统 Operate System Refactor 用户_用户组 解耦 0 IPC Andriod IPC IPC前提_序列化 Socket 线程间通信 0_性能 Profiler Systrace 内存 性能_ 1_稳定性 ANR Watch Dog Andriod Car Car Service Android Tool Hierarchy View App APK 64 Bit 32 Bit APP开发 Launcher 3 System UI 小程序 Coding Language C Cpp Java java反射 JNI Js Python R Features 其他特性 多用户 Kde Kwin Other OS Open Harmony Other OS Tool Aosp Building AS Building Chroot Clion Command Debug Skills Docker Gdb Git Phone Command Search Software Pc Settings Source Insight Tmux Linux 编译 多线程 多线程的模型 线程池与binder线程池 文件系统结构 虚拟化 Communication English Investment Naturalaw Reading And Thinking 修 Scriptures 金刚经 Check List console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/0_Graphic系统总论/0_Graphic系统总论.html":{"url":"0_图形系统/0_Graphic系统总论/0_Graphic系统总论.html","title":"0_Graphic系统总论","keywords":"","body":"1. 目录2. 图形3. 系统（脱离安卓来看）3.1. 图形系统0层3.2. 图形系统1层3.2.1. 渲染系统3.2.2. Window系统（图形视角）3.2.3. 显示系统3.3. 基于1层------窗口系统：4. 显示驱动模型DRM架构介绍（一）5. 好的图形文章6. ===安卓源码分析=====7. View/ViewGroup7.1. 功能点0层7.2. UI刷新 -invalidate7.2.1. 流程图：7.2.2. 调用栈角度：7.2.3. 关于首帧7.3. 性能方面的优化：7.4. 面试题：7.4.1. 多次invalidate 会刷新几次？7.4.2. Activity, Window,View三者的联系和区别?7.4.3. 关于首帧问题7.4.4. 我们调用invalidate()之后会马上进行屏幕刷新吗?7.4.5. 我们说丢帧是因为主线程做了耗时操作,为什么主线程做了耗时操作就会引起丢帧?7.4.6. 都有消息屏障，为什么还会掉帧呢？8. Grapics8.1. 0层框架-----系统数据流向：8.2. 硬件框架8.3. 0层框架8.4. 0层纵向8.5. 1层框架8.6. 三缓冲+vsync：从显示屏显示讲起，为什么要这么设计8.6.1. 背景：8.6.2. 问题1：帧缓冲区同时读写，会造成画面的撕裂8.6.3. 基于双缓冲机制，问题2：8.6.4. 基于双缓冲机制+Vsync机制，问题3：8.7. SurfaceFlinger 图形合成者8.7.1. 功能（what）8.8. 解决屏幕撕裂、卡顿、掉帧问题8.9. 关于掉帧的实操8.10. 申请surface的流程(APP向surfaceFlinger)8.10.1. Q&A：8.11. 关于draw：8.12. 面试问题：8.13. Grapics-----Flutter8.13.1. Flutter渲染pipeline8.13.2. Flutter数据模型---四棵树0层8.14. 几个概念：8.14.1. 渲染------硬件加速（GPU） 与 软件加速(CPU)8.14.2. 合成-------硬件合成(HWC) 与 软件合成8.15. 参考文章：9. view-Graphic 纵向0层10. SurfaceFlinger11. 显示问题收集：11.1. 拖动的残影： 图形 系统（脱离安卓来看） 图形系统0层 图形系统1层 渲染系统 Window系统（图形视角） 显示系统 基于1层------窗口系统： 显示驱动模型DRM架构介绍（一） 好的图形文章 ===安卓源码分析===== View/ViewGroup 功能点0层 UI刷新 -invalidate 流程图： 调用栈角度： 关于首帧 首次 View 的绘制流程是在什么时候触发的?----> 即首帧的触发 onResume函数中度量的高有效? 性能方面的优化： 面试题： 多次invalidate 会刷新几次？ Activity, Window,View三者的联系和区别? 关于首帧问题 我们调用invalidate()之后会马上进行屏幕刷新吗? 我们说丢帧是因为主线程做了耗时操作,为什么主线程做了耗时操作就会引起丢帧? 都有消息屏障，为什么还会掉帧呢？ Grapics 0层框架-----系统数据流向： 硬件框架 0层框架 0层纵向 1层框架 三缓冲+vsync：从显示屏显示讲起，为什么要这么设计 背景： 问题1：帧缓冲区同时读写，会造成画面的撕裂 基于双缓冲机制，问题2： 基于双缓冲机制+Vsync机制，问题3： Q&A环节： 补充： 三缓冲，可以关闭 SurfaceFlinger 图形合成者 功能（what） 解决屏幕撕裂、卡顿、掉帧问题 关于掉帧的实操 申请surface的流程(APP向surfaceFlinger) Q&A： 关于draw： 面试问题： Grapics-----Flutter Flutter渲染pipeline Flutter数据模型---四棵树0层 layout过程： 几个概念： 渲染------硬件加速（GPU） 与 软件加速(CPU) 面试题：既然硬件加速很好，为啥还要有软件加速？ 合成-------硬件合成(HWC) 与 软件合成 参考文章： view-Graphic 纵向0层 SurfaceFlinger 显示问题收集： 拖动的残影： 1. 目录 2. 图形 3. 系统（脱离安卓来看） 3.1. 图形系统0层 图片来源： [深入理解Android图形系统](https://mp.weixin.qq.com/s/LVVR1IGrn_PopGUkefjKvA ), [Linux阅码场](javascript:void(0);) 对于任何图形系统（抛开安卓不谈），为什么需要这些？ 不得不： GUI需要： 1、Render系统： ​ 作用： view界面数据 到Buffer上（实际上是绘制控件）： 即 执行GUI的绘图指令集 ​ 位置：Render线程 2、window系统 ： （1）窗口的管理器 ，对于安卓，位于WMS 中 ​ （2）窗口的合成器 ----> 注：对于安卓是surfaceFlinger 3、DisPlay系统： ​ 作用：把Buffer的位图显示出来 ​ 位置：内核驱动 总之： 图形系统 = window系统 + Render系统 + DisPlay系统 3.2. 图形系统1层 render系统: 1、是以 lib（.so）形式存在 2、运行时：在App GUI进程里 3.2.1. 渲染系统 目标： view数据转buffer数据 基于目标，渲染引擎有哪些？ 2D引擎 Skia，3D引擎 OpenGL ES，RenderScript，OpenCV和Vulkan 3.2.2. Window系统（图形视角） 目标： 区别各个窗口之间 协调各窗口之间的关系 3.2.3. 显示系统 目标： 将buffer数据，最终到显示屏上 3.3. 基于1层------窗口系统： HWC： 每一层对应一个驱动 /dev/fbx # ls -la /dev/graphics . .. fb0 fb1 fb2 APP操作某层，直接写对应的FrameBuffer 硬件直接自动合成他们 Display control：是个什么？？？TODO Exynos 4412 SCP_Users Manual_Ver.0.10.00_Preliminary0.pdf 4. 显示驱动模型DRM架构介绍（一） https://www.eet-china.com/mp/a178945.html Linux阅码场 5. 好的图形文章 https://mp.weixin.qq.com/s?__biz=MzUyMjI5OTU1Ng==&mid=2247484433&idx=1&sn=57e262d2c555e579943e2d4504de2b2c&chksm=f9ccb5dacebb3cccc91fb3c0a785bc0b71ce8a16754de1745005e10a95e34bd1ad6d3e280d63&scene=178&cur_album_id=3231071844901011460#rd 系列文章 图形基础系列 Android Graphics 显示系统 - 开篇 Android Graphics 显示系统 - 基本组件（一） Android Graphics 显示系统 - 基本组件（二） Android Graphics 显示系统 - 基本组件（三） Android Graphics 显示系统 - Surface绘图示例（四） Android Graphics 显示系统 - Surface绘图示例（五） Android Graphics 显示系统 - 建立SurfaceFlinger通信的流程（六） Android Graphics 显示系统 - SurfaceFlinger的启动与初始化（七） Android Graphics 显示系统 - SurfaceFlinger MessageQueue机制（八） Android Graphics 显示系统 - 创建Surface流程（九） Android Graphics 显示系统 - 初识BufferQueue（十） Android Graphics 显示系统 - ANativeWindow/Surface/SurfaceControl（十一） Android Graphics 显示系统 - BufferQueue的工作流程（十二） Android Graphics 显示系统 - BufferQueue的工作流程（十三） Android Graphics 显示系统 - BufferQueue的工作流程（十四） Android Graphics 显示系统 - BufferQueue的工作流程（十五） Android Graphics 显示系统 - Surface补充知识（十六） Android Graphics 显示系统 - SurfaceView与BufferQueue关系（十七） Android Graphics 显示系统 - Gralloc架构及GraphicBuffer创建/传递/释放（十八） Android Graphics 显示系统 - 简述Allocator/Mapper服务的获取流程（十九） Android Graphics 显示系统 - GraphicBuffer同步机制-Fence（二十） Android Graphics 显示系统 - SurfaceFlinger的GPU合成（廿一） Android Graphics 显示系统 - 导出图层数据(dump graphic raw data)（廿二） Android Graphics 显示系统 - 基础知识之 BitTube（廿三） Android Graphics 显示系统 - SurfaceFlinger之VSync-1（廿四） Android Graphics 显示系统 - SurfaceFlinger之VSync-2（廿五） Android Graphics 显示系统 - SurfaceFlinger之VSync-3（廿六） Android Graphics 显示系统 - HWC HAL的初始化（廿七） Android Graphics 显示系统 - 聊聊屏幕刷新机制（廿八） Android Graphics 显示系统 - HWC 探秘 - 1（廿九） Android Graphics 显示系统 - HWC 探秘 - 2（三十） Android Graphics 显示系统 - HWC 探秘 - 3（三一） 原文链接：https://blog.csdn.net/u010542873/article/details/136080207 https://blog.csdn.net/jxt1234and2010/category_2826805.html Android图形显示 系列文章 https://www.51cto.com/article/717713.html 深入理解Android图形系统 ----------> 图很好 总的结论：图形系统 与 输入系统，一上一下 TODO: opengl 与 skia之间到底什么关系？？？？？？？为什么3D要使用它？功能是啥 https://blog.csdn.net/tianzhaoai/article/details/128943124?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-128943124-blog-136080207.235^v43^pc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-128943124-blog-136080207.235^v43^pc_blog_bottom_relevance_base7&utm_relevant_index=10#:~:text=整体分为 App 进程和系统进程两个部分 -----------------> 化简图 6. ===安卓源码分析===== 7. View/ViewGroup view （G:\\working_pan\\doc_my\\Draw\\view_viewGroup.eddx） 其中，Graphic与Input是核心 , 与用户交互的两个功能点：看和触摸 7.1. 功能点0层 见li 11 7.2. UI刷新 -invalidate 7.2.1. 流程图： 关键函数：vsync信号 1、必然有请求： invalidate -----> scheduleTraversal： 请求vsync、设置同步屏障。 2、必然有执行: perform................ 绘制、 取消同步屏障？ 新增枝叶： 1、为了给 vsync信号 带来的 vsync msg 让道， 请求vsnc的同时（自然），插入同步屏障： --------》见handler 同步屏障 必然： 1、所有 控件的 invalidate操作，最终都 转接到 ViewRootImpl的invalidate (设计模式上，单一职责) 7.2.2. 调用栈角度： 1、请求： 2、vsync信号来后，执行： 等到VSYNC到来后， 会移除同步栅栏 ----- 》 TODO: 具体哪里？ todo：很奇怪，这里为啥涉及到两次 消息？ 7.2.3. 关于首帧 首次 View 的绘制流程是在什么时候触发的?----> 即首帧的触发 Activity Resume时-> WindowManagerImpl.addView -> WindowManagerGlobal.addView-> ViewRootimpl.setView -> ViewRootimpl.requestLayout ->ViewRootImpl.scheduleTraversals onResume函数中度量的高有效? Activity第一次调用onResume的时候是无效的 Activity第二次之后调用onResume是有效 因为首次request vysn是在addwindow过程中（viewrootimpl的setview） 下一帧，才真正绘制（包括测量、layout、draw） 7.3. 性能方面的优化： 房间中椅子坏了，不会换整个房子 局部刷新：dirty脏区 7.4. 面试题： 7.4.1. 多次invalidate 会刷新几次？ 代码上： 有标致 设计上：是不得不的。 因为vsync信号，从上到下隔离 1.onResume函数中度量的高有效? 2.Activity, Window,View三者的联系和区别? 3. 首次 View 的绘制流程是在什么时候触发的? 4.我们调用invalidate()之后会马上进行屏幕刷新吗? 5.我们说丢帧是因为主线程做了耗时操作,为什么主线程做了耗时操作就会引起丢帧? 问题1和问题3和问题4，是一个东西 因为首次request vysn是在addwindow过程中（viewrootimpl的setview） 下一帧，才真正绘制（包括测量、layout、draw） 7.4.2. Activity, Window,View三者的联系和区别? 7.4.3. 关于首帧问题 见《关于首帧》 7.4.4. 我们调用invalidate()之后会马上进行屏幕刷新吗? 7.4.5. 我们说丢帧是因为主线程做了耗时操作,为什么主线程做了耗时操作就会引起丢帧? 7.4.6. 都有消息屏障，为什么还会掉帧呢？ 因为消息屏障之前的消息（具体指哪些？），还会执行的 主线程加的消息屏障 8. Grapics 8.1. 0层框架-----系统数据流向： 参考: https://blog.csdn.net/qq_45254908/article/details/125449470 0层框架中的角色： 1、image stream produceers 图像流生产者（见图） ， 即生成BufferData的： OpenGL ES、NDK(即Skia)、Canvas 2D 、 mediaserver等。 例： draw方法把 绘制指令 通过canvas传递给framework层的RenderThread线程，在buffer上绘制 两种生产方式： （1） NDK（Skia），OpenGL ES是通过自身的绘制能力生产的图像数据 （2） MediaPlayer和Camera Preview是通过直接读取图像源来生成图像数据 2、 image stream consumers 图像流消费者，消费 BufferData的： SurfaceFlinger： 消耗当前可见的Surface（对应的buffer数据）+ 不同buffer数据 合成到屏幕 （自然，是根据图中 WMS 提供的window信息） OpenGL ES 应用也可以消费：例如相机应用会消耗相机预览图像流 ------> TODO: 证明 并没有经过 SurfaceFlinger 显示子系统的硬件抽象实现，在HAL中： 负责协助消费者把图形数据展示到设备屏幕。 图形内存分配器 (Gralloc) ： 分配图像生产方请求的内存 缓冲区 Buffer Queue： TODO: 这个到底是啥？ 下面图到底是个啥？ 可以大概看到BufferQueue的工作过程： TODO BufferQueue 类是 Android 中所有图形处理操作的核心。它的作用很简单：将生成图形数据缓冲区的一方（生产方）连接到接受数据以进行显示或进一步处理的一方（消耗方）。 即：Android中的图像生产者OpenGL，Skia，Vulkan将绘制的数据存放在图像缓冲区中，Android中的图像消费SurfaceFlinger从图像缓冲区将数据取出，进行加工及合成 https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/#/BufferQueue-%E9%83%A8%E5%88%86 注意： 1、 一个可见APP对应一个BufferQueue（有backBuffer和frontBuffer） 2、frontButter是要 经过 SurfaceFlinger合成 TODO: 证明 8.2. 硬件框架 出自：《1-111显示系统框架_framebuffer原理及改进.wmv》 TODO: DisplayControl的作用：把FrameBuffer数据搬到LCD上 ----------> TODO: 待验证 操纵LCD去读取FrameBuffer？ 显示驱动？到底指的是哪块功能？ 只有一个FB的问题：FrameBuffer（FB）被应用写，同时被DisplayControl读取： 屏幕大小 内存的关系： 屏幕上一个像素16位 ，即 2字节 ----> 内存Buffer： 800*600* 2字节 8.3. 0层框架 1、贯穿0层框架的主线buffer： buffer的获取，填充完的buffer流转过程 2、基于0层框架，自然： （1）数量关系： 1个 window ： 1个surface：一个bufferQueue（三个buffer）：一个bufferQueueLayer 注意：给到surface的 是一个buffer 即surface是对buffer的封装 ，一个surface内部具有多个buffer TODO: 上述的buffer与frameBuffer什么关系？frameBuffer应该是一个屏幕大小 frameBuffer有几个？ 三缓冲，处于0层框架什么位置？ BufferQueue中: SurfaceFling 消费 FrontBuffer，GPU 使用一个 BackBuffer，CPU使用一个 BackBuffer -----> TODO: GPU在软件上是怎么调用的？CPU 怎么调用的？ 硬件图： 出自： https://androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer/#/Android-%E7%89%88%E6%9C%AC-lt-Android-P TODO: 0层架构图 与 硬件图中 CPU和GPU 什么关系？ 如何整合到一起表达？？？？？？？？？？】 8.4. 0层纵向 自然： 1、Render线程--> SurfaceFlinge进程： 跨了进程 所以，不得不：BufferQueue中的 backBuffer 通过Binder的形式提供给了APP的Render线程 （TODO，核心:Binder 如何流转给APP的？！！！！） 2、App 是生产者，负责填充显示缓冲区（Buffer）；SurfaceFlinger 是消费者，将各个进程的显示缓冲区做合成操作。 3、触发点：vsync信号过来，view.onDraw 8.5. 1层框架 来自： https://www.jianshu.com/p/37370c1d17fc 8.6. 三缓冲+vsync：从显示屏显示讲起，为什么要这么设计 8.6.1. 背景： 屏幕刷新率（即屏幕读取速率）： 1、固定是16.67ms （永恒不变的） 2、其 物理本质就是 逐行扫描 的时间：显示器并不是一次性将显存里的数据显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点（硬件 晶体管），不过这一过程快到人眼无法察觉到变化。 沿着帧缓冲区 逐行扫描： 注意，这里的内存实际上是显存（GPU的） vsync信号 ： 1、硬件天然存在的（在硬件侧可能不叫vsync），与是否发给软件无关。注意区别 vsync信号 与vsync机制 2、标致着屏幕开始扫描 系统帧速率FPS（即CPU+GPU 合成数据速率）： 代表了系统在一秒内合成的帧数, 该值的大小由系统算法和硬件决定 (没有vsync时，其实不是固定的) 两者的关系造成的问题（没有vsync和双缓冲机制的话），胖子吃面包模型： ①屏幕刷新速率比系统帧速率快 胖子吃的很快，面包不够 ------> 「造成一帧显示多次,也就是卡顿。」 ②系统帧速率比屏幕刷新率快 胖子吃的慢，面包很多就吃了一半 ------> 「造成屏幕上显示多帧,也就是屏幕撕裂。」 ③系统帧速率 快很多 胖子很多面包没吃就跳过了 ------> 跳帧 ------------------》 一句话总结vsync： 卡顿、撕裂、跳帧 就是Vsync设计的初衷 为啥绘制阶段，也用到了GPU? Todo 8.6.2. 问题1：帧缓冲区同时读写，会造成画面的撕裂 问题1：并发问题（存在临界资源 竞争问题） 解决问题1，不得不： 双缓冲机制： fontBuffer、backBuffer -------》 并发，性能高：可以一个写一个读，之后，两个交换指针 加锁： 太耗费性能，而且 不能同时 读和 写 ----》 不是并发 引入双缓冲机制： 双缓冲的位置（线程）： fontBuffer、backBuffer 在bufferQueue里面嘛？ 与 屏幕进行交互的，我理解只有一个buffer(所有APP的) 所以，上面图有没有问题？？？？？？？？？？？？？？是不是少了合成这一步？？？ 基于双缓冲区，不得不的结论，铁律： 即使没有vsync机制，交换指针的时机，就是 vsync时机（因为这个时候，前刚被用完，后填充完）：这个因为此时刚好扫描完，硬件决定的 （注：1、图中vsync只是固有的硬件信号，还没有vsync机制 ​ 2、图中蓝、绿都是指backBuffer，时间先后 ​ 3、后的1 在下个扫描时，交换给了Display ​ 4、这里Display即屏幕，即屏幕刷新速率 ， 自然 ​ 5、图中GPU+CPU 即 系统帧速率 ​ 6、注意：图中的 0和1理解为 内容数据 ，而不是内存，下同 内存是框起来的部分，两个 ​ 7、不得不，CPU+GPU准备好数据为一帧数据，显示display 必然在下一帧显示 这个数据） 8.6.3. 基于双缓冲机制，问题2： 存在的问题2： 卡顿：因为vsync机制，CPU+GPU 绘制数据不是vsync触发，而是APP自己触发的，很可能backBuffer没准备好（即上面 屏幕刷新率快 问题） -----> 导致，Display用的上一帧数据, 屏幕平白无故地多显示了一次第1帧。 TODO: 这不是丢帧呀？？？？ https://blog.csdn.net/qq_45254908/article/details/125449470 假设图中是双缓冲的（1234明显不是） 解决问题2的方法，引入vsync机制： 把硬件信号，给到软件，触发 软件绘制backBuffer(即CPU+GPU 填充backBuffer) -----》 结果：自然，如果性能ok，后必然在 16.67ms内准备ok。不存在问题 一些不得不： 1、vsync信号是CPU执行的起点，即view.draw ---------> 软件设计保证的 2、vsync信号 是 指针交换时刻 ---------> 硬件决定的，此时刚好 扫描完，必须交换 8.6.4. 基于双缓冲机制+Vsync机制，问题3： 双缓冲机制+Vsync机制 其实已经非常好了，解决大部分情况。 问题3： 双缓冲机制+Vsync机制 好的前提是 ，CPU + GPU 在16ms内完成了工作 极端情况下，CPU + GPU 没能及时完成工作，导致下一帧显示数据没准备好： 解决办法，让CPU多多跑起来（三缓冲）： 红框处 GPU 占据着 BackBuffer，CPU没有填充的内存，所以单独给其一个BackBuffer -----》 注意：三缓冲本质： 让CPU多多跑起来，所以只是一个优化，不是一个大的机制变动 最左边，三块内存; A B C是 内容 Q&A环节： 1、三缓冲 + Vsync机制： CPU开始用 新的C内存，生成C数据（注意：C数据两帧之后才显示），那么 ​ 补充： 三缓冲，可以关闭 所以，不是必须的 https://blog.csdn.net/wjky2014/article/details/117962861 8.7. SurfaceFlinger 图形合成者 8.7.1. 功能（what） 从进程角度：SF是整个Android系统渲染的核心进程 -----> TODO: 什么是渲染？渲染到底做了啥？I 从功能角度：将所有Surface到Framebuffer -----> todo： Surface的buffer与 Framebuffer 数据转换上什么关系？ 个数上是什么比例？ 从信息流角度：信息的传递： 1、以Surface为图元数据 2、SurfaceFlinger： 所有 图层(Surface数据 )合成。 3、最终交给CPU和GPU 绘制-----> 绘制是什么概念？跟view的draw是什么区别？ 绘制的结果又是啥？ 设计模式：生产者-消费者 Queue：BufferQueue 这里表达不清 TODO: surface对应buffer去画，跨进程到 surfaceflinger？ 图元数据到底是进程级别？还是 surface？ 区别很大 surface属于应用进程，那么在 surfaceflinger端是什么数据结构？ 硬件合成与软件合成，理解TODO： 软件合成：软件将多个surface合成一个屏幕图像，给到屏幕 硬件合成： 实操： adb shell dump System surfaceFlinger 8.8. 解决屏幕撕裂、卡顿、掉帧问题 三缓冲机制 + vsync 8.9. 关于掉帧的实操 8.10. 申请surface的流程(APP向surfaceFlinger) 目的： 解决在哪里绘制问题？ 图出自：Android画面显示流程分析(4) 主要：WMS去申请的 触发时机： viewRootImpl.performTraversals时 ----> relayoutWindow TODO 三个进程，APP，system_server, surfaceflinger 8.10.1. Q&A： Q：为什么要经过wms? APP直接 向 surfaceflinger 申请呢？ --------->A： 不行，wms要管理surface TODO: 具体如何管理的？ Q: app侧的java surface就是一个空壳子 ​ WMS surfaceControl 是surface的包装类，无法直接控制surface 8.11. 关于draw： 主线程与render线程之间数据同步：绘图指令集 （主产生，render利用canvas去 执行 指令集，结果：buffer上） 见 《0层纵向》 TODO: 卡顿、掉帧 -----》 这些概念对应的 物理解释！！！ 8.12. 面试问题： 问题 丢帧(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 答：延迟显示，因为缓存交换的时机只能等下一个VSync了。 布局层级较多/主线程耗时 是如何造成 丢帧的呢？ 答：布局层级较多/主线程耗时 会影响CPU/GPU的执行时间，大于16.6ms时只能等下一个VSync了。 16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure/layout/draw ？ 答：屏幕的固定刷新频率是60Hz，即16.6ms。不是每16.6ms都走一次 measure/layout/draw，而是有绘制任务才会走，并且绘制时间间隔是取决于布局复杂度及主线程耗时。 measure/layout/draw 走完，界面就立刻刷新了吗? 答：不是。measure/layout/draw 走完后 会在VSync到来时进行缓存交换和刷新。 如果界面没动静止了，还会刷新吗？ 答：屏幕会固定每16.6ms刷新，但CPU/GPU没有绘制任务时就不走绘制流程。 VSYNC具体指啥？在屏幕刷新中如何工作的？ 答：当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时会发出一个vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。并且Android4.1后 CPU/GPU的绘制是在VSYNC到来时开始。 屏幕刷新使用 双缓存、三缓存，这又是啥意思呢？ 答：双缓存是Back buffer、Frame buffer，用于解决画面撕裂。三缓存增加一个Back buffer，用于减少Jank。 ———————————————— 版权声明：本文为CSDN博主「贺兰猪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/u013773608/article/details/125142405 什么是surfaceView'？TODO 8.13. Grapics-----Flutter 8.13.1. Flutter渲染pipeline Flutter的渲染管道分为以下七个步骤： 用户输入（User Input）： 响应用户通过鼠标、键盘、触摸屏等设备产生的手势行为。 动画（Animation）： 基于定时器（Timer）更新当前帧的数据。 构建（Build）： 三棵树的创建，更新和销毁阶段，StatelessWidget和State的build方法将在改阶段执行。 布局（Layout）： Render Tree将在该阶段完成各个节点的大小和位置计算。 绘制（Paint）： Render Tree遍历每个节点，生成Layer Tree、RenderObject的paint方法在该阶段执行，生成一系列绘制指令。 合成（Composition）： 处理Layer Tree，生成一个Scene对象，作为栅格化的输入。-----> TODO: 这个地方与英文图有差异, 一个是 栅格化（Rasterize）：将绘制指令处理成可供GPU上屏的原始数据（合成的视图数据其实还是一份矢量描述数据，光栅化帮助把这份数据真正地生成一个一个的像素填充数据，即 矢量描述---> 像素填充） 8.13.2. Flutter数据模型---四棵树0层 https://docs.flutter.dev/resources/architectural-overview TODO: 1、flutter一个widgets会对应非常多的element嘛？（Y是这样）上图没有体现出来 2、flutter的layerTree到底是啥？ layout过程： 布局约束 https://www.cnblogs.com/qianxiaox/p/14120511.html 盒子协议： 8.14. 几个概念： Paint画笔：颜色、画笔宽度、 canvas: 画家画圆、画三角形 bitmap: 位图－－> 存储像素的，初始的时候，是空的 surface (有多于一个的缓冲区（通常是两个）来做双缓冲渲染）：屏幕缓存/墙(比bitMap大很多）一》真正的画布 --------------------> 上述几个概念是类。存在于Skia 图像渲染库中 SurfaceFlinger: 按照它们的Z轴顺序将各个surface渲染出来 view: 是—个舞台，让其他演员演绎的舞台 https://www.cnblogs.com/CreateLight/archive/2012/07/04/2575401.html 好的比喻： surface ------------ 画布 多个App ----------- 多个画家 同时画 framebuffer（屏幕级、功能：承载合成的结果）： 挂墙展示 合成（安卓的sf承载、weston的compositor承载） -------- 即 把各个画布（画）挂 墙上 参考： 补充： canvas虽然英文名是画布，但是功能是画家 各图形库的比较： 承载的能力 skia（安卓使用） opengl ES（安卓、linux） QT QPainter 画家/作画工具集（画东西、执行画笔的） canvas（或java的Canvas） QPainter 画笔（颜色、画笔宽度） Paint 画布(窗口的绘制承载) surface（c++） （持有两个mem的buffer） surface（c++） （持有两个mem的buffer） TODO：似乎被QPainter封装了 画布2 应用侧创建的bitmap（自定义缓冲区） FrameBuffer(屏幕级别)墙 FrameBuffer FrameBuffer FrameBuffer 能力承载 主要软件绘制 也可以配置硬件加速opengl 硬件 软件绘制 补充： 如果画到画布2上，需要复制到画布1上？(不是直接给到surfaceFlinger？) 见： https://blog.51cto.com/u_16099189/9844011#:~:text=也可以先绘制在任何一块缓存上，然后将这块缓存中的内容复制到屏幕缓存中 注意： 内存缓冲区 与 framebuffer的区别 补充buffer： https://www.jianshu.com/p/dd2837c43a7b#:~:text=多个surface最终经过SurfaceFlinger进入到硬件 skia 与 opengl： skia主要软件绘制（例外: 也可以配置硬件加速opengl） opengl 主要硬件GPU绘制 opengl是利用着色器shader（frag）去让GPU绘制的，单sf 应该不会这样使用opengl吧，那么如何使用的呢？？？？？？？ 8.14.1. 渲染------硬件加速（GPU） 与 软件加速(CPU) 详细参考：Android GPU硬件加速渲染流程（上） TODO： 好文 1、本身没有软件加速这一概念。 2、硬件加速是基于软件加速做的优化（区分点）：Buffer数据谁来绘制 ​ 代码中的分歧点： //ViewRootImpl.java performTraversals relayoutWindow performMeasure performLayout performDraw ----> draw //draw流程 注意：这里是NativeWindow, 当年Z 也是。 但没见Z有软件绘制 其中，软件绘制流程： 面试题：既然硬件加速很好，为啥还要有软件加速？ 深度好文：理解Android硬件加速原理 Android GPU硬件加速渲染流程（上） 8.14.2. 合成-------硬件合成(HWC) 与 软件合成 8.15. 参考文章： Android Systrace 基础知识 - Triple Buffer 解读 -----> 好文 https://blog.csdn.net/qq_45254908/article/details/125449470 Systrace 之 三级缓存 Triple Buffer Android画面显示流程分析(1)~(5) Android Graphic UI with GPU Hardware Acceleration 深度好文：理解Android硬件加速原理 Android 图形系统（Graphics） Android 14 HWUI 源码研究 View Canvas RenderThread ViewRootImpl skia -----------> 好文 9. view-Graphic 纵向0层 即一帧的整体流程： 纵轴为时间 图来源 为什么选取一帧呢？ 一帧即是 for循环中一个 TODO: 上图是一个好的纵向0层图，借鉴其画法： 1、纵轴是时间、横轴为 空间（进程、线程、类） -------> 跟时序图很像 2、只列 最核心函数/功能 + 没有调用栈 -------> 跟时序图差异 证据+细节： 10. SurfaceFlinger 11. 显示问题收集： 11.1. 拖动的残影： 控件残影 -------> 窗口内级别： 窗口buffer部分刷新-------------------> 必然是窗口的mask区域、dirty区域问题。。。。。 窗口残影 --------> FrameBuffer级别问题： FrameBuffer部分刷新 ---------> 为啥FrameBuffer部分刷新？前面流程是合成，必然是合成时，对buffer部分合成 ​ -------------------> 即过滤了背景buffer ​ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/1_Render系统/":{"url":"0_图形系统/1_Render系统/","title":"1_Render系统","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/1_Render系统/opengl.html":{"url":"0_图形系统/1_Render系统/opengl.html","title":"Opengl","keywords":"","body":"1. 目录2. 环境搭建2.1. 运行opengl的环境2.2. 实时预览shader(GLSL)的环境2.3. 机器环境确认3. 基本概念3.1. OpenGL ES 与 OpenGL 关系3.2. 图形渲染管线（Graphics Pipeline）4. 一些接口/效果4.1. window4.2. Triangle4.3. 安卓openGLE接口5. 着色器shader5.1. 输入5.2. 输出：5.3. 片元着色器 输入输出图：5.4. 补充 纹理5.4.1. cpp侧 构造纹理5.4.2. glsl侧 接收纹理5.4.3. 混合色 TODO：6. Opengl6.1. OpenGL课程6.2. 时间上变化6.3. 空间上变化6.4. 纹理6.5. 加载png 或 jpg图片6.6. 已有图片的截取-----纹理坐标6.7. 已有图片过小，不足以覆盖模型6.8. 纹理过滤------没懂6.9. 错误信息的获取6.10. printf' in GLSL6.11. EGL操作6.11.1. 清除GPU缓冲区buffer -------glClear & glClearColor6.11.2. eglMakeCurrent6.11.3. 顶点的属性值（位置、颜色、纹理坐标）传递 给 顶点shader：6.11.4. eglSwapBuffers6.11.5. 优化之限制局部区域的操作 glScissors6.11.6. glPixelStorei TODO6.11.7. 捞取实时图片：glReadpixels 从缓冲区里6.11.8. glDrawArrays(GL_TRIANGLE_FAN, 0, 3);6.12. 内建变量6.12.1. gl_FragCoord6.13. glsl内建函数 --------字典6.13.1. 插值函数 mix6.13.2. 台阶函数step(a, x)6.13.3. 距离函数distance6.13.4. clamp6.13.5. abs6.13.6. 台阶step6.13.7. smoothstep6.13.8. smoothstep 和自定义的 linearstep6.14. 补充： Texture ------> 另一个翻译更贴切：贴图6.15. 混合 & 透明6.16. shader 变量类型6.17. 抗锯齿6.17.1. 锯齿产生的根源6.17.2. 如何抗锯齿6.17.3. 其他6.18. OpenGL坐标系统6.18.1. 画布坐标系（站在画布上看）6.18.2. 窗口坐标系（站在屏幕，看画布）6.18.3. void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);6.19. OpenGL裁剪6.20. 技巧：7. 安卓GLSurfaceView源码分析7.1. 抛开安卓，使用 EGL 绘图的基本步骤：7.1.1. 补充：TODO, 如果有纹理的话:7.2. 0层流程框架7.3. 0层7.4. eglMakeCurrent 绑定、创造环境（为后续gl操作）7.5. 与Skia渲染比较7.6. 双缓冲机制7.7. 其他demo7.8. 疑问：7.9. TODO:7.10. 参考7.11. 背后的设计8. OpenGL状态机的理解9. shader编程实战9.1. 本质理解9.2. 在线网站 （教程 & 运行）9.3. 距离函数9.4. 基本素材---距离函数(圆、矩形、三角形........)9.4.1. 2d距离函数9.4.2. 自然，推论:2d圆角(矩形、三角形.............)9.4.3. 自然，推论：环----同心圆、同心圆角矩形9.4.4. 3d距离函数9.4.5. 自然：推论：9.5. 酷炫的shader9.6. shade调试技巧10. OpenGL调试10.1. glgetError 封装函数，每次执行gl操作，执行一行10.2. 捞取实时图片：glReadpixels 从缓冲区里-------大招10.3. TODO 其他回捞函数10.4. 向后输出-----颜色输出：10.5. 像素级操作：TODO10.6. 思想：11. 网站12. TODO：13. 书籍14. opengl 与skia的联系与区别（个人理解）15. Mesa(OpenGL的最优实现)15.1. 与weston12的匹配关系：15.2. 编译15.3. 参考 目录 环境搭建 运行opengl的环境 实时预览shader(GLSL)的环境 机器环境确认 基本概念 OpenGL ES 与 OpenGL 关系 图形渲染管线（Graphics Pipeline） 一些接口/效果 window Triangle 安卓openGLE接口 着色器shader 输入 输出： 片元着色器 输入输出图： 补充 纹理 cpp侧 构造纹理 glsl侧 接收纹理 混合色 TODO： Opengl OpenGL课程 时间上变化 空间上变化 纹理 加载png 或 jpg图片 已有图片的截取-----纹理坐标 已有图片过小，不足以覆盖模型 纹理过滤------没懂 错误信息的获取 printf' in GLSL EGL操作 清除GPU缓冲区buffer -------glClear & glClearColor 功能之 按照区域clear： eglMakeCurrent 顶点的属性值（位置、颜色、纹理坐标）传递 给 顶点shader： eglSwapBuffers 优化之限制局部区域的操作 glScissors glPixelStorei TODO 捞取实时图片：glReadpixels 从缓冲区里 glDrawArrays(GL_TRIANGLE_FAN, 0, 3); 内建变量 gl_FragCoord glsl内建函数 --------字典 插值函数 mix 台阶函数step(a, x) 距离函数distance clamp abs 台阶step smoothstep smoothstep 和自定义的 linearstep 补充： Texture ------> 另一个翻译更贴切：贴图 混合 & 透明 shader 变量类型 抗锯齿 锯齿产生的根源 如何抗锯齿 其他 OpenGL坐标系统 画布坐标系（站在画布上看） 窗口坐标系（站在屏幕，看画布） void glViewport(GLint x, GLint y, GLsizei width, GLsizei height); OpenGL裁剪 技巧： 安卓GLSurfaceView源码分析 抛开安卓，使用 EGL 绘图的基本步骤： 补充：TODO, 如果有纹理的话: 0层流程框架 0层 eglMakeCurrent 绑定、创造环境（为后续gl操作） 与Skia渲染比较 双缓冲机制 其他demo 疑问： TODO: 参考 背后的设计 OpenGL状态机的理解 shader编程实战 本质理解 在线网站 （教程 & 运行） 距离函数 基本素材---距离函数(圆、矩形、三角形........) 2d距离函数 自然，推论:2d圆角(矩形、三角形.............) 自然，推论：环----同心圆、同心圆角矩形 3d距离函数 自然：推论： 酷炫的shader shade调试技巧 OpenGL调试 glgetError 封装函数，每次执行gl操作，执行一行 捞取实时图片：glReadpixels 从缓冲区里-------大招 TODO 其他回捞函数 向后输出-----颜色输出： 像素级操作：TODO 思想： 网站 TODO： 书籍 opengl 与skia的联系与区别（个人理解） Mesa(OpenGL的最优实现) 与weston12的匹配关系： 编译 参考 1. 目录 2. 环境搭建 2.1. 运行opengl的环境 clion： 【OpenGL】Clion配置 -------->没试过 VsCode： VsCode下配置OpenGL开发环境 AS： 直接使用AS，调用NDK接口 2.2. 实时预览shader(GLSL)的环境 vscode安装插件： GLSL：用来编译 glsl-canvas：用来显示 // test.frag precision mediump float; void main() { vec3 color = vec3(1,0,0); gl_FragColor = vec4(color, 1); } ------------> 运行： ctrl + shift + P ，搜索 show glslcanvas 参考 2.3. 机器环境确认 EGL有1.0、1.1、1.2、1.3、1.4这几个版本，Android中使用的是1.4，EGL提供了查询版本的API，以下为Android中例子： 具体见 3. 基本概念 3.1. OpenGL ES 与 OpenGL 关系 子集关系： OpenGL ES 是 OpenGL 的子集（删除了一些低效能的操作方式） 3.2. 图形渲染管线（Graphics Pipeline） 一个输送管道: 图形数据 到 屏幕过程 作用： 1、平面化：将3D坐标 ------> 2D坐标 2、光栅化：2D坐标 ------> 像素(实际的有颜色的) 注意：坐标是精准表达 渲染管线流程： 图片来源 数据流： （1）建模型（比如兔子）： 顶点数据 + 面数据 三角形面数据（面1基于点：点1 点3 点5） （2）序列化为数组[] int = {1,5，........} 必然有：(3) 序列化的东西跨越到GPU （4）存到GPU的VBO（一块buffer）上 unsigned int VBO; glGenBuffers(1, &VBO); （5）VBO中的数据，反序列化为结构数据，VAO： 顶点数据 + 面数据 -----------------> 即兔子模型 （6）VAO中，顶点数据 -------------> 灌入，即vertext 4. 一些接口/效果 4.1. window 创建window（对于安卓，不需要） 参考 4.2. Triangle 4.3. 安卓openGLE接口 湖广午王OpenGLES系列 一篇搞懂OpenGL中的着色器和如何使用 5. 着色器shader 5.1. 输入 图来源 输入来源： 1、GPU可以从voa中挖数据（比如 从顶点数据中直接接收输入） layout (location = 0) -------> 0顶点的位置 layout (location = 0) in vec3 aPos; ----> 赋值给aPos 2、从CPU获取（比如时间），uniform 通道： （1） uniform 全局唯一 （2） 是更新一个uniform之前你必须先使用程序（调用glUseProgram)： glUseProgram(shaderProgram); 3、前面的shader的输出，可以作为后面shader的输入。比如： 5.2. 输出： 片段着色器，必然有一个vec4颜色输出变量，作为最终颜色（RGBA） 推论：自然，这个颜色赋值，很可能计算于顶点着色器，最后传给片段着色器 一篇搞懂OpenGL中的着色器和如何使用 ---------> 图来源： OpenGL ES 3. 着色器 shader的编译和使用 5.3. 片元着色器 输入输出图： 图来源 输入: 片元坐标texCoord、纹理数据iChannel0 输出：gl_FragColor 5.4. 补充 纹理 5.4.1. cpp侧 构造纹理 加载纹理： // 使用 stb_image.h int width, height, nrChannels; unsigned char *data = stbi_load(\"container.jpg\", &width, &height, &nrChannels, 0); 创建纹理： unsigned int texture; glGenTextures(1, &texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); --------------> 当前绑定的纹理对象texture就会被附加上纹理图像data 应用纹理： 新增纹理坐标------即截取： float vertices[] = { // ---- 位置 ---- ---- 颜色 ---- - 纹理坐标 - 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, // 右上 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // 左下 -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f // 左上 }; 告诉OpenGL新的顶点格式（顶点属性）： glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); glEnableVertexAttribArray(2); 5.4.2. glsl侧 接收纹理 顶点着色器新增： #version 330 .................... layout (location = 2) in vec2 aTexCoord; out vec2 TexCoord; void main() { .................... TexCoord = aTexCoord; } 把TexCoord输入给片段着色器： #version 330 core ............ ................ in vec2 TexCoord; uniform sampler2D ourTexture; // 【】cpp侧赋值 采样器 void main() { FragColor = texture(ourTexture, TexCoord); 采样器 纹理坐标 } 【】cpp侧赋值 采样器ourTexture：-----> TODO glBindTexture(GL_TEXTURE_2D, texture); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); TODO： 为什么sampler2D变量是个uniform，我们却不用glUniform给它赋值 5.4.3. 混合色 TODO： 纹理颜色*顶点颜色 6. Opengl 6.1. OpenGL课程 第9章 https://youtu.be/DVvDd_acJoQ?list=PL0luF_aDUOooIB56NOFVTS4ahMzBHS_6z&t=1158 图没看得懂 补充：uniform 换图：https://youtu.be/AxrrrI6hzKw?list=PL0luF_aDUOooIB56NOFVTS4ahMzBHS_6z&t=27 6.2. 时间上变化 见 HOM cpp内： int vertexColorLocation = glGetUniformLocation(g_programObject, \"ourColor\"); // 获取 glsl内 \"ourColor\"字段位置 glUseProgram(g_programObject); glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); // cpp侧设置值 andriod_cpp_openGL-Demo/app/src/main/cpp/RendererJNI.cpp at master · KentTJ/andriod_cpp_openGL-Demo (github.com) 6.3. 空间上变化 空间上，色彩默认是插值的（光栅化阶段）： 顶点颜色值不一样：渐变色插值 顶点颜色值一样：也是插值，插值结果都是一样颜色 -------------------> TODO: 从这个角度来： 两个 glsl文件，只是提供了 顶点的location + 顶点的color？？？？？？？？？？？？？？？？并没有提供中间点？？？ vs.glsl： #version 300 es layout(location = 0) in vec3 position; // 挖值 layout(location = 1) in vec3 acolor; // 挖值 out vec3 vertexcolor; void main() { gl_Position = vec4(position.x, position.y, position.z, 1.0); vertexcolor = acolor; } fs.glsl： #version 300 es precision mediump float; // add by kent in vec3 vertexcolor; out vec4 fragColor; void main() { // fragColor = vec4(1.0, 0.0, 0.0, 1.0); // add by kent fragColor = vec4(vertexcolor.x, vertexcolor.y, vertexcolor.z, 1.0); } RendererJNI.cpp： JNIEXPORT void JNICALL Java_opengl_panjq_com_opengl_1demo_RendererJNI_glesRender (JNIEnv *pEnv, jobject obj){ // GLfloat vVertices[] = { 0.0f, 0.5f, 0.0f, // -0.5f, -0.5f, 0.0f, // 0.5f, -0.5f, 0.0f // }; // cg modify GLfloat vVertices[] = { // 位置 // 颜色 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // 左下 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // 顶部 }; // Set the viewport glViewport ( 0, 0, g_width, g_height ); // Clear the color buffer glClear ( GL_COLOR_BUFFER_BIT ); // Use the program object glUseProgram ( g_programObject ); // -------------------modify by kent------------------------------ // Load the vertex data ------> to glsl // location data------define location index = 0 glVertexAttribPointer ( 0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), vVertices); // ---------> para解释： index 是定义出来的协议，glsl中会用 // size 是location数据的数据大小 // type ............. // stride 步长：下一个location的跨度：6*float数据大小 // pointer 偏移量：颜色属性是有偏移量的 6*float数据大小 glEnableVertexAttribArray ( 0 ); // color data------define index = 1 float* pVertices = &vVertices[0]; // 获取数组的起始地址 pVertices += 3; // 移动到第四个元素的位置 glVertexAttribPointer ( 1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), pVertices ); glEnableVertexAttribArray ( 1 ); / -------------------modify by kent------------------------------ glDrawArrays ( GL_TRIANGLES, 0, 3 ); } 效果： 6.4. 纹理 6.5. 加载png 或 jpg图片 目标： ----------> 一堆像素 --------> 一堆RGB，比如（0,122，144） int width, height, nrChannels; unsigned char *data = stbi_load(\"container.jpg\", &width, &height, &nrChannels, 0); 验证： //打印前50个pixel for (size_t i = 0; i RGB: 三个Channel alpha：第四通道 Texture ------> 另一个翻译更贴切：贴图 把一个已有的图，贴到模型上 6.6. 已有图片的截取-----纹理坐标 以左下角为（0,0） 采样，即截取出三角形贴图： ----------> 用纹理坐标截取 float texCoords[] = { 0.0f, 0.0f, // 左下角 1.0f, 0.0f, // 右下角 0.5f, 1.0f // 上中 }; -----------> 这里本质上截取了三个点，内部插值 6.7. 已有图片过小，不足以覆盖模型 GL_REPEAT 重复贴图 GL_CLAMP_TO_EDGE 超出部分，拉伸 GL_CLAMP_TO_BORDER 超出的坐标为用户指定的边缘颜色。 6.8. 纹理过滤------没懂 https://youtu.be/mZM15IKuNWY?list=PL0luF_aDUOooIB56NOFVTS4ahMzBHS_6z&t=1341 6.9. 错误信息的获取 参考：官方代码： COMPILE错误 与 LINK 错误 // utility function for checking shader compilation/linking errors. // ------------------------------------------------------------------------ void checkCompileErrors(unsigned int shader, std::string type) { int success; char infoLog[1024]; if (type != \"PROGRAM\") { glGetShaderiv(shader, GL_COMPILE_STATUS, &success); if (!success) { glGetShaderInfoLog(shader, 1024, NULL, infoLog); std::cout 6.10. printf' in GLSL https://stackoverflow.com/questions/3420558/printf-in-glsl 调试输出， OpenGL4.3版本 官网--- 调试输出 6.11. EGL操作 6.11.1. 清除GPU缓冲区buffer -------glClear & glClearColor 功能之 按照区域clear： // add by kent glScissor(0, 0, 800, 400); // 限制的区域 glEnable(GL_SCISSOR_TEST); // add by kent glClearColor(0.0, 0.0, 0.0, 0.0); glClear(GL_COLOR_BUFFER_BIT); // add by kent glDisable(GL_SCISSOR_TEST); // 解除限制 // add by kent glScissor(800, 200, 800, 400); glEnable(GL_SCISSOR_TEST); // add by kent glClearColor(0.0, 0.0, 0.0, 0.0); glClear(GL_COLOR_BUFFER_BIT); // add by kent glDisable(GL_SCISSOR_TEST); 效果： 6.11.2. eglMakeCurrent OpenGL ES EGL eglMakeCurrent-CSDN博客 ------------------> 非常详细，系列文章 与线程绑定 TODO: 多个EGLContext 具体例子，见 《eglMakeCurrent 绑定、创造环境（为后续gl操作）》 6.11.3. 顶点的属性值（位置、颜色、纹理坐标）传递 给 顶点shader： EGL内指定: // position: 顶点位置 指定了index = 0一组数据 glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof *v, &v[0]); // 在这里给定顶点数据！！！ // texcoord: 纹理坐标 glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof *v, &v[2]); 与shader的对应： EGL内再次指定 : index = 0 与 shader里 \"position\"绑定 glBindAttribLocation(shader->program, 0, \"position\"); glBindAttribLocation(shader->program, 1, \"texcoord\"); 或者 // 在shader内绑定 location = 0 与 position layout(location = 0) in vec3 position; // 挖值 layout(location = 1) in vec3 acolor; // 挖值 参考：opengl学习glBindAttribLocation-CSDN博客 6.11.4. eglSwapBuffers eglSwapBuffers详解-CSDN博客 6.11.5. 优化之限制局部区域的操作 glScissors glScissors是OpenGL中的一个函数，用于定义一个矩形区域，只有在该区域内的像素才会被绘制。 参考 glScissors ------限制局部，操作比如： 限制gldraw 限制 glClear 局部clear： // add by kent glScissor(0, 0, 800, 400); // 限制的区域 glEnable(GL_SCISSOR_TEST); // add by kent glClearColor(0.0, 0.0, 0.0, 0.0); glClear(GL_COLOR_BUFFER_BIT); // add by kent glDisable(GL_SCISSOR_TEST); // 解除限制 6.11.6. glPixelStorei TODO https://blog.csdn.net/weixin_38432324/article/details/135251289 6.11.7. 捞取实时图片：glReadpixels 从缓冲区里 6.11.8. glDrawArrays(GL_TRIANGLE_FAN, 0, 3); https://blog.csdn.net/code09/article/details/41377847 绘制三角形序列的三种方式 ：GL_TRIANGLES、GL_TRIANGLE_STRIP和GL_TRIANGLE_FAN 6.12. 内建变量 大全 ： GLSL内置变量和内置函数 内建函数集合 内建函数的图像解释 6.12.1. gl_FragCoord 参考：shader着色器变量gl_FragCoord 的含义 openGL默认以左下为原点! 原点并非(0, 0)而是(0.5, 0.5) !!! ----> 则： 若viewport范围 为(0, 0, 2560, 1440)时， x, y 的取值范围就为(0.5, 0.5, 2559.5, 1439.5)； 6.13. glsl内建函数 --------字典 大全 ： GLSL内置变量和内置函数 6.13.1. 插值函数 mix genType mix (genType x, genType y, float a) ----------> 返回线性混合的x和y，如：x⋅(1−a)+y⋅a。 6.13.2. 台阶函数step(a, x) 0到1的台阶（如果 x 图： 6.13.3. 距离函数distance 判断两个vec的距离 distance(color1.rgb, color2.rgb) 6.13.4. clamp genType clamp (genType x, genType minVal, genType maxVal) genType clamp (genType x, float minVal, float maxVal) clamp翻译为夹具，clamp实际上是获得三个参数中大小处在中间的那个值 6.13.5. abs 比如： vec2 abs(vec2 x)，即向量 向 第一象限 图来源-,vec4 abs(vec4 x),-sign) 6.13.6. 台阶step y = step(0.5, x) 6.13.7. smoothstep y = smoothstep(0.0,1.0,x); 作用：将step的突变，优化成渐变 -------> 用于抗锯齿 6.13.8. smoothstep 和自定义的 linearstep 参数意义相同，完全可以等价替换 6.14. 补充： Texture ------> 另一个翻译更贴切：贴图 纹理即贴图！！！！！！！！！！ 6.15. 混合 & 透明 混合 - LearnOpenGL CN (learnopengl-cn.github.io) 第十课：透明 (opengl-tutorial.org) 6.16. shader 变量类型 参考：着色器详解 1、uniform （自然，全局统一）： 数据流： cpp（CPU） shader 使用参考 2、attribute变量 3、varying ： 数据流： vertex shader fragment shader 4、in/out 6.17. 抗锯齿 6.17.1. 锯齿产生的根源 TODO: 根源： 连续 ------> 离散造成的 (即： 光栅器将顶点数据转化为片段) 注意：不是屏幕分辨率造成的，分辨率造成的锯齿很小！！！ 6.17.2. 如何抗锯齿 参考： Shadertoy 的坐标转换 - 知乎 (zhihu.com) A Simple Circle (shadertoy.com) 抗锯齿实现 抗锯齿 抗锯齿的思想： 1、在边缘预留一段缓冲区间 2、在区间内渐变（颜色、透明度） 根据渐变策略的不同： 1、多重采样(MSAA)：一个像素，多点采样，求平均？ 缓冲区间内多重采样，计算缓冲区内颜色值 图： 具体代码： glfwWindowHint2 glEnable(GL_MULTISAMPLE); 2、............ 3、自定义抗锯齿算法：smoothstep、自制smoothstep函数、自制linearstep函数 有锯齿的圆------if else形式： // 【】 if else 等价于 数学中的step函数 void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x); float r = 0.5; float len = length(uv) - r; // length(uv)是距离原点的距离 // r是圆半径 if (len 有锯齿的圆------step形式： -参考：Unity Shader：优化GPU代码--用step()代替if else等条件语句 没有锯齿的圆： // 抗锯齿：mix + linearstep float linearstep(float edge0, float edge1, float x) { // 极小缓冲区, 宽度 edge1 - edge0 ------> 经验值！！！ float t = (x - edge0)/(edge1 - edge0); // 中心（edge1 + edge0）/2 ------> 由边界决定！！！！！ return clamp(t, 0.0, 1.0); // 输出 --> 换算到[0, 1]之间一个值 } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x); float r = 0.5; float len = length(uv) - r; float Edgewidth = 0.002; float linear = linearstep(r - Edgewidth, r + Edgewidth, len); // 获取线性系数 fragColor = mix(vec4(1.0, 0.0, 0.0, 1.0),vec4(0.0, 0.0, 0.0, 1.0), linear); // 线性插值----【】关键一行 } 从数学角度，本质： step函数 ---> LinearStep函数 6.17.3. 其他 抗锯齿 圆角矩形 float linearstep(float edge0, float edge1, float x) { // 极小缓冲区, 宽度 edge1 - edge0 ------> 经验值！！！ float t = (x - edge0)/(edge1 - edge0); // 中心（edge1 + edge0）/2 ------> 由边界决定！！！！！ return clamp(t, 0.0, 1.0); // 输出 --> 换算到[0, 1]之间一个值 } float drawBox( in vec2 p, in vec2 b ){ // 矩形的距离函数 vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); } float opRound( in vec2 p, in float r ) // r 圆角 { return drawBox(p, vec2(0.4-2.0*r,0.3-2.0*r)) - r; } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y; // Time varying pixel color vec3 col = 0.5 + 0.5*cos(uv.xyx+vec3(0,2,4)); float Edgewidth = 0.002; col = mix(col,vec3(0.0), linearstep(0.0 - Edgewidth, 0.0 + Edgewidth, opRound(p, 0.05))); // Output to screen fragColor = vec4(col,1.0); } 6.18. OpenGL坐标系统 OpenGL之深入解析坐标系统_OpenGL ES-CSDN专栏 左下是原点？？？ 6.18.1. 画布坐标系（站在画布上看） 参考: Shadertoy的坐标转换 结论：shader内变量 是基于画布坐标系的 原始画布坐标系： 原点：位于画布左下角 自然： 方向： x正向向右，y正向向上 坐标范围：[0, 0] -----> iResolution.xy 画图：TODO 归一化后画布坐标系： 原点：位于画布中间 自然： 方向： x正向向右，y正向向上 坐标范围：[-1, -1] -----> [1, 1] 画图：TODO 例子： float drawBox( in vec2 p, in vec2 b ){ // 矩形的距离函数 vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y), 0.0); } float opRound( in vec2 p, in float weight, in float height, in float r ) // r 圆角; weight，归一化的 { return drawBox(p, vec2(weight-1.0*r, height-1.0*r)) - r; // 1.0*r：内矩形 到 目标矩形的距离 = 圆角半径 } // 0.4、0.3 矩形大小 void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // 【1】归一化短边坐标为[-1, 1], 中央为原点（其中，iResolution.xy是画布大小） // 画布长边对应放缩，不是[-1, 1] vec2 uv = (2.0*fragCoord-iResolution.xy)/min(iResolution.y, iResolution.x); // 待画矩形的尺寸 float weight = 200.0/min(iResolution.y, iResolution.x); // 200是真实尺寸,px float height = 200.0/min(iResolution.y, iResolution.x); // 待画矩形的中心(以画布左下角为原点) vec2 O1 = vec2(300.0, 300.0); // 真实 O1 = (2.0*O1-iResolution.xy)/min(iResolution.y, iResolution.x); uv = uv - O1; //uv = uv - vec2(-1.0, -1.0); // 移动矩形位置（其中 -1.0，是向左移动一半的画布距离） vec3 col = vec3(0,2,4); col = mix(col,vec3(0.0),step(0.0, opRound(uv, weight,height,0.05))); // Output to screen fragColor = vec4(col,1.0); } 6.18.2. 窗口坐标系（站在屏幕，看画布） 已经验证的结论： Rect的计算是屏幕坐标系： 即 以 左上角为原点 6.18.3. void glViewport(GLint x, GLint y, GLsizei width, GLsizei height); 参考： OpenGL 学了那么久了，glViewport 你真的会用吗？ 站在屏幕角度（左下为原点）：划出一个矩形，作为 渲染区域 结论： 1、可见，与窗口无关！！！！！！只与屏幕有关 TODO: glViewport本质是映射！！！！！！ （1）将纹理的（0,0,2,2） 映射到 屏幕的 (GLint x, GLint y, GLsizei width, GLsizei height)区域 （2）注意：纹理永恒不变，始终一张完整的图 见 左下为原点： 自然，向右，x正向 ​ 向上，y正向 拉伸weston桌面，可以改变 glViewport的宽高 但是移动，为啥x, y不变？？？ 6.19. OpenGL裁剪 glScissor(x, y, width, height) 6.20. 技巧： 用屏幕所有 7. 安卓GLSurfaceView源码分析 7.1. 抛开安卓，使用 EGL 绘图的基本步骤： EGL 作用：关联 OpenGL ES 与 本地窗口系统(native platform window system) 使用EGL的绘图的一般步骤： 获取 EGL Display 对象：eglGetDisplay() 初始化与 EGLDisplay 之间的连接：eglInitialize() 获取 EGLConfig 对象：eglChooseConfig() 创建 EGLContext 实例：eglCreateContext() 创建 EGLSurface 实例：eglCreateWindowSurface() 连接 EGLContext 和 EGLSurface：eglMakeCurrent() 使用 OpenGL ES API 绘制图形：gl_*() // 【7展开】 都是gl接口 切换 front buffer 和 back buffer 送显：eglSwapBuffer() 断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease() 删除 EGLSurface 对象 删除 EGLContext 对象 终止与 EGLDisplay 之间的连接 结论： 1、安卓GLSurfaceView框架：除了7，对EGL其他都做了封装 2、即使7，也做了生命周期约束，在on........接口里 详细说明： EGLHelper做的事情：创建环境、创建surface、创建gl 开发者接入点： on........: 即 【7展开】 ： 0、 glViewport 限定显示的大小 1、 创建g_programObject（用来承载 两个shader） 自然，使用glUseProgram(g_programObject) 2、glVertexAttribPointer 传顶点 (glEnableVertexAttribArray，顶点的属性) 3、绘制 glDrawArrays ( GL_TRIANGLES, 0, 3 ); （之前先clear掉之前画的， glClear(GL_COLOR_BUFFER_BIT)） 可选： 动态变化（比如，使用uniform变量 时间上改变颜色） 7.1.1. 补充：TODO, 如果有纹理的话: // gl_fbo_texture_init GLuint shadow_fbo; GLuint shadow_tex; glGenTextures(1, &shadow_tex); glBindTexture(GL_TEXTURE_2D, shadow_tex); glTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, format, type, NULL); ........... glBindTexture(GL_TEXTURE_2D, 0); glGenFramebuffers(1, &shadow_fbo); glBindFramebuffer(GL_FRAMEBUFFER, shadow_fbo); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, // 颜色、深度等信息通过纹理来存放，所以，有个绑定 GL_TEXTURE_2D, shadow_tex, 0); fb_status = glCheckFramebufferStatus(GL_FRAMEBUFFER); glBindFramebuffer(GL_FRAMEBUFFER, 0); https://blog.csdn.net/hankern/article/details/88770954 7.2. 0层流程框架 由 《EGL的绘图的一般步骤》，0层流程框架必然是： 图来源： 7.3. 0层 demo：GLSurfaceView基本使用与源码解析 ------------> 只看demo，不看这里源码分析 OpenGL升级打怪之 GLSurfaceView源码分析 -------------> 整个 核心： // GLSurfaceView.java guardedRun() throws InterruptedException { // -----------> 一个循环 while if (mEglHelper.createSurface()) { // 【】创建EGLSurface，本质：把后面所有的gl操作，绑定到 context里（） 见 .......... } // 【】Egl交互内存，opengl使用的双内存缓冲，一个进行显示，另一个则后台进行绘制，绘制OK后，交互内存进行显示 int swapError = mEglHelper.swap(); } 创建的内存，怎么给Opengl的？ 总结GLSurfaceView使用EGL的流程如下： 1.生成一个EGL实例 mEgl = (EGL10) EGLContext.getEGL(); 2.获取一个EGL Display mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY); 3.初始化EGL并返回版本号 if(!mEgl.eglInitialize(mEglDisplay, version)) {} 4.选取一个配置 mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay); 5.创建一个EGLContext mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig); 6.创建EGLSurface egl.eglCreateWindowSurface(display, config, nativeWindow, null); 7.通过swap将渲染内容显示到屏幕 mEgl.eglSwapBuffers(mEglDisplay, mEglSurface) ———————————————— 原文链接： 7.4. eglMakeCurrent 绑定、创造环境（为后续gl操作） 参考： eglMakeCurrent()详解-CSDN博客 中 eglMakeCurrent mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext) 作用，简言之，就是 为opengl es的所有api创造环境： 绑定后面gl（无论开发者使用哪种）操作 与 context（当前线程、当前display、当前draw surface、当前read surface） 即：后面所有操作，不再指定目的地（display、surface），限制线程 ---------> 创造环境的目的：就是为所有API调用化简 结论： mEgl（EGL10）是没有用的，开发者不一定会用（只是用来初始化环境，相当于静态（在EGL14.java里，就是静态方法）） 源码分析： eglMakeCurrent makeCurrent ogles_context_t* current = (ogles_context_t*)getGlThreadSpecific(); // 取得当前GlThread的context信息，进行校验 例子: 例1：后续操作不需要显式指定opengl画的surface（buffer）： KentTJ/andriod_cpp_openGL-Demo: openGL NDK Demo (github.com) 例2：onDrawFrame回调接口里，可以用 框架侧给定的gl，也可以不用。最终都是指定到绑定的surface上 public void onDrawFrame(GL10 gl) { //清除屏幕缓存和深度缓存 gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT); //启用顶点坐标数据 gl.glEnableClientState(GL10.GL_VERTE } public void onDrawFrame(GL10 gl) { GLES20.glDrawArrays(GLES20.GL_TRIANGLE_FAN,0,vSize); GLES20.glDisableVertexAttribArray(mPositionHandle); } public void onDrawFrame(GL10 gl) { glesRender(); } 例3: 当glclear被调用的时候，首先通过getGlThreadSpecific()获取到当前GlThread的context信息。而这个context就是在eglMakeCurrent的时候和GLThread绑定的context。 eglMakeCurrent 的反向操作： glFlush TODO: 0层结构图 见 eglMakeCurrent()详解-CSDN博客 7.5. 与Skia渲染比较 最后剩下的就是onDrawFrame(GL10 gl)的主体绘制的实现，这也是最重要的一个部分，因为涉及的内容较多，就不在这里陈述了。这里使用的就是opengl的绘制引擎进行渲染操作，跟之前View的渲染是使用的Skia渲染引擎。 https://blog.csdn.net/xiaozhude/article/details/78752608 Glsurfaceview的 onDrawFrame(GL10 gl) ------> opengl引擎渲染 View的绘制onDraw(Canvas canvas) ------> Skia引擎渲染 7.6. 双缓冲机制 glsurfaceview的双缓冲机制： TODO:两块surface的交换： 一块渲染mEglSurface，一块显示mEglDisplay ------------> mEgl.eglSwapBuffers 双缓冲，应该是两个buffer，不是两个surface！！ 7.7. 其他demo https://blog.csdn.net/zhangpengzp/article/details/88714034 另一个安卓cpp opengl框架 --------> 没有swap https://blog.csdn.net/zhangpengzp/article/details/89519416 glsurfaceview在native创建EGL环境并渲染 -----------------> （1）initEgl(holder.getSurface());// GLsurfaceView的surface给了 （2）将上下文，和 surface 和 display 关联!!!!!!!!! 并且在当前线程中启动当前的渲染环境 if(EGL_TRUE != eglMakeCurrent(display, surface, surface,context))// 2、3 2个surface 一个读 一个写，双缓冲 原文链接：https://blog.csdn.net/zhangpengzp/article/details/89519416 (3) 绘制完毕后，调用eglSwapBuffers(display,surface); 来将opengl绘制的纹理渲染到窗口 7.8. 疑问： opengl没看到使用buffer glsurfaceview的surface 与 opengl的使用，是如何绑定的？ 创建surface： // GLSurfaceView.java public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config, Object nativeWindow) { 5，创建mEglSurface，这个代表了将要被渲染的那段内存。请注意到createWindowSurface()的四个参数，尤其是最后一个参数view.getHolder()。 createSurface()上面有一句注解：Create an egl surface for the current SurfaceHolder surface.这个只能意会，很难言传。我理解是被渲染后的mEglSurface也是为了给mSurface来呈现的。总之mEglSurface和mSurface之间一定有着很重要的关系的，在一定程度上你也可以理解他们代表着同一块用来渲染的内存。 6，连接EGLContext和EGLSurface：eglMakeCurrent()。 ------------------> https://blog.csdn.net/xiaozhude/article/details/78752608 系列文章 问题： 1，GLSurfaceView继承了SurfaceView，它自己的mEglSurface和从父类继承的mSurface之间的关系？https://blog.csdn.net/xiaozhude/article/details/78752608 2，onDrawFrame是60FPS触发GPU对UI进行渲染-------> 如何触发GPU的？ 3.gpu的buffer数据，最后怎么返还给CPU的？ 7.9. TODO: OpenGL系列文章 Android GLSurfaceView详解-CSDN博客 GLSurfaceView渲染过程详解_壁纸服务如何绘制glsurfaceview-CSDN博客 mainActivity的surface 与 GLSurfaceView 的surface 如何做混合，显示底下的surface内容？------------即透明背景 https://juejin.cn/s/opengl设置背景透明 opengl设置背景透明 7.10. 参考 7.11. 背后的设计 安卓的设计，很多思想都是： 框架侧多做一些，让开发者少做（这里，框架侧封装了opengl创建surface、初始化环境部分） --------------> 实现的策略： 开发者的开发的部分，强制放到回调里，比如onDraw（同理，Activity的设计，onCreate等） 8. OpenGL状态机的理解 -1、OpenGL是状态机 所以，glBindTexture ，所以 makeCurentt 所以，glReadPixels没有指定读取的buffer，因为就是当前缓冲区 glReadPixels(rect->x, rect->y, rect->width, rect->height, fmt->gl_format, fmt->gl_type, out); 例1： // 使用glBindTexture绑定一张纹理后，如果不再绑定新的纹理，则OpenGL之后的操作都会对应此纹理，当一个纹理与目标绑定时，该目标之前的绑定关系将自动被打破。 mMixProgram.useProgram(); // 激活着色器程序（后续的绘制操作都会使用这个程序） glUniform1f(mMMixLoc, mix); // mMixProgram.getUniformLocation(\"uMix\"); uMix赋值 glActiveTexture(GL_TEXTURE0); // 激活纹理单元0 glBindTexture(GL_TEXTURE_2D, mLastDrawTarget->getTextureName()); // 状态机选择了 mLastDrawTarget的texture作为 操作纹理 // 绑到 纹理单元0 上 glUniform1i(mMTextureLoc, 0);// mMixProgram.getUniformLocation(\"uTexture\"); // uTexture赋值 glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, mCompositionFbo.getTextureName()); glUniform1i(mMCompositionTextureLoc, 1); // mMixProgram.getUniformLocation(\"uCompositionTexture\"); uCompositionTexture赋值 drawMesh(mMUvLoc, mMPosLoc); // glDrawArrays 2、既然是状态机，必然有唯一生效时机： glDrawArrays 对于贴图而言，状态机需要的设置： 9. shader编程实战 9.1. 本质理解 shader 也就是说我们只采样所有像素的中心点， 本质上： shader是不连续的产物（采样）--------因为屏幕本质就是不连续的点 而painter从用户侧，是连续的（比如画线） 从数学角度，离散与连续的处理不同---->最本质 ​ 离散-----------遍历方法 ​ 连续函数-------------函数 从软件硬件角度，硬件（离散） 软件（连续）的差异 从软件角度:opengl（shader）就是硬件处理，而painter就是软件处理 9.2. 在线网站 （教程 & 运行） https://www.shadertoy.com/ 9.3. 距离函数 https://zhuanlan.zhihu.com/p/365440831 Shader中使用距离函数（Distance Function）绘制二维图形 距离函数-------------空间中任何一个点到物体表面的最短距离 9.4. 基本素材---距离函数(圆、矩形、三角形........) 9.4.1. 2d距离函数 大全： 二维图形的距离函数 https://www.shadertoy.com/playlist/MXdSRf&from=0&num=12 -推论，通用公式： 2d 圆角............. : 圆角 = 内图形 + 圆角半径 2d环状............：TODO 9.4.2. 自然，推论:2d圆角(矩形、三角形.............) 圆角通用公式： 圆角矩形 = 内矩形（长-圆角半径，宽-圆角半径） + 圆角（圆角半径）： float drawBox( in vec2 p, in vec2 b ){ // 矩形的距离函数 vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); } float opRound( in vec2 p, in float r ) // r 圆角 { return drawBox(p, vec2(0.4-1.0*r,0.3-1.0*r)) - r; } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y; // Time varying pixel color vec3 col = vec3(0,2,4); col = mix(col,vec3(0.0),step(0.0, opRound(p, 0.05))); // Output to screen fragColor = vec4(col,1.0); } 效果： 其他例子： 见 9.4.3. 自然，推论：环----同心圆、同心圆角矩形 环通用公式： TODO: 同心圆-------三段 if else 方式: // 【】 if else 等价于 数学中的step函数 void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x); float r = 0.5; float len = length(uv); // length(uv)是距离原点的距离 // r是圆半径 if (len r && len 其他例子： 见 9.4.4. 3d距离函数 大全： https://iquilezles.org/articles/distfunctions/ https://www.shadertoy.com/playlist/43cXRl https://www.shadertoy.com/view/Xds3zN 球： float sdSphere( vec3 p, float s ) { return length(p)-s; } 柱体： -推论： 3d 圆角............. : 圆角 = 3d内图形 + 圆角半径 3d环状............：TODO 9.4.5. 自然：推论： 9.5. 酷炫的shader 大海 平滑圆 A Simple Circle (shadertoy.com) /** * @author jonobr1 / */ /** * Convert r, g, b to normalized vec3 */ vec3 rgb(float r, float g, float b) { return vec3(r / 255.0, g / 255.0, b / 255.0); } /** * Draw a circle at vec2 `pos` with radius `rad` and * color `color`. */ vec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) { float d = length(pos - uv) - rad; float t = clamp(d, 0.0, 1.0); return vec4(color, 1.0 - t); } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord.xy;25 vec2 center = iResolution.xy * 0.5; // TODO: 中心，为啥是这个值？ float radius = 0.25 * iResolution.y; // Background layer vec4 layer1 = vec4(rgb(210.0, 222.0, 228.0), 1.0); // Circle vec3 red = rgb(225.0, 95.0, 60.0); vec4 layer2 = circle(uv, center, radius, red); // Blend the two fragColor = mix(layer1, layer2, layer2.a); } 9.6. shade调试技巧 1、shader中数值判断： if ( 待判断数值 > 250.0) { // 改变颜色 color = ................ } 逼出来待判断数值： 调整 250.0这个数值 2、用固定值 替代 非固定值： 对比两者 //vec2 iResolution = vec2(1024.0, 600.0); vec2 iResolution = univiewPortSize; 3、多个窗口，选择一个观看即可 解构的万能方法： 多个变量中，取一个为固定值 10. OpenGL调试 10.1. glgetError 封装函数，每次执行gl操作，执行一行 --------------> 检查基本的使用错误 // .c 文件里添加 GLenum glCheckError_(const char *file, int line) { GLenum errorCode; while ((errorCode = glGetError()) != GL_NO_ERROR) { char* error; switch (errorCode) { case GL_INVALID_ENUM: error = \"INVALID_ENUM\"; break; case GL_INVALID_VALUE: error = \"INVALID_VALUE\"; break; case GL_INVALID_OPERATION: error = \"INVALID_OPERATION\"; break; // case GL_STACK_OVERFLOW: error = \"STACK_OVERFLOW\"; break; // case GL_STACK_UNDERFLOW: error = \"STACK_UNDERFLOW\"; break; case GL_OUT_OF_MEMORY: error = \"OUT_OF_MEMORY\"; break; case GL_INVALID_FRAMEBUFFER_OPERATION: error = \"INVALID_FRAMEBUFFER_OPERATION\"; break; default: error = \"other\"; break; } //std::cout 使用： glBindFramebuffer(GL_FRAMEBUFFER, go->blurFilter.mPingFbo.fbo); myglCheckError(); glViewport(0, 0, go->area.width, go->area.height); myglCheckError(); 10.2. 捞取实时图片：glReadpixels 从缓冲区里-------大招 大招：可以获取 任意Tex（buffer）在任意时刻 的图片 https://blog.csdn.net/June_we/article/details/123420398 https://blog.csdn.net/u013412391/article/details/120565095 https://download.csdn.net/blog/column/12324820/132423172 OpenGL调试时输出显存帧到图片的一些方法 从帧缓存读取像素 从纹理读取 GraphicBuffer或ANativeWindowBuffer保存 python批量将RGBA8888裸数据保存到png C代码： // 1、辅助函数 static int32_t * outputValues_debug; static int32_t w_debug = 1728; // 待捞出的图片大小 static int32_t h_debug = 1888; static bool debug_pixel = true; static int32_t times = 2; bool GLUtils_saveRender(int w, int h) { if (w == 0 || h == 0) { return false; } weston_log(\"kent, GLUtils_saveRender, %d: %d\\n\", w, h); // 使用malloc动态分配内存来替代std::vector if (outputValues_debug == NULL) { outputValues_debug = (int32_t *)malloc(w * h * sizeof(int32_t)); // TODO: 这里不停的malloc了 } memset(outputValues_debug, 0, w * h * sizeof(int32_t)); if (outputValues_debug == NULL) { fprintf(stderr, \"Failed to allocate memory for outputValues_debug\\n\"); return false; } // // 从帧缓冲区读取像素数据 glPixelStorei(GL_PACK_ALIGNMENT, 4); glPixelStorei(GL_PACK_REVERSE_ROW_ORDER_ANGLE, GL_TRUE); //glReadPixels(0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, outputValues_debug); glReadPixels(0, 0, w, h, 32993, GL_UNSIGNED_BYTE, outputValues_debug); // GL_UNSIGNED_BYTE = 5121 // 调用保存图像的函数 //bool result = savePicture(w, h, outputValues_debug); // 释放动态分配的内存 //free(outputValues_debug); //return result; // Save to image // if (times > 1) { // stbi_write_png(\"output.png\", w, h, sizeof(int32_t), outputValues_debug, 0); // weston_log(\"kent, stbi_write_png\\n\"); // times = times - 1; // } return true; } // 2、同时修改 gl_renderer_do_capture函数----------> 借助截屏流程，保存为png图片 //--------------------add start------------------- // if (rect->width == 1728) { // 选择屏幕 // w_debug = rect->width; h_debug = rect->height; // } weston_log(\"kent, gl_renderer_do_capture, rect->width: %d, rect->height: %d: \\n\", rect->width, rect->height); if (debug_pixel && outputValues_debug != NULL && rect->width == w_debug) { //read_target = outputValues; //memcpy(read_target, outputValues_debug, sizeof(rect->width * rect->height * sizeof(int32_t))); memcpy(read_target, outputValues_debug, rect->width * rect->height * sizeof(int32_t)); //--------------------add end------------------- } else { glReadPixels(rect->x, rect->y, rect->width, rect->height, fmt->gl_format, fmt->gl_type, read_target); } // glReadPixels(rect->x, rect->y, rect->width, rect->height, // fmt->gl_format, fmt->gl_type, read_target); ------------------> 使用： // 任意一个想要获取 GPU缓冲区图像的位置 加入： GLUtils_saveRender(w_debug, h_debug) 10.3. TODO 其他回捞函数 一些基础的获取接口： glGetBufferParameteriv 10.4. 向后输出-----颜色输出： 例1，判断颜色： if ((color.r > 0.0) || (color.g > 0.0) || (color.b > 0.0)) { // 黑屏时，判断color的值是不是0 gl_FragColor = color*0.01 + vec4(0.0, 0.4, 0.0, 0.8); } else { gl_FragColor = color; } 例2：观察alpha值： if (Alpha > 0.1 && Alpha 10.5. 像素级操作：TODO 查： 像素级 判断 改： 对比两张图片 10.6. 思想： 像素数据对应的fd（像素数据一直在内存里） ----> client ----> weston ----> GPU（opengl调用）----> 处理后weston ----> drm ----> 上屏 结论: 各个阶段，理论上都可以观察像素数据： 方式： 向后输出：shader 输出颜色观察 ------> 上屏 直接输出某个buffer或者Tex ------> 上屏 中间捞出来：glReadpixels 缓冲区 回读像素 ------> 反馈型！！！！王炸！！！ 向后输出前提： 上屏流程没有问题 11. 网站 正规的学习网站 https://learnopengl.com/ 学习网站 https://learnopengl-cn.github.io/ 对应的中文翻译网站 https://www.youtube.com/watch?v=1TVFHIQKCR0&list=PL0luF_aDUOooIB56NOFVTS4ahMzBHS_6z 视频教程 https://www.youtube.com/watch?v=W3gAzLwfIP0&list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2 英文视频教程 API网站： https://docs.gl/ API网站 es2 es3 gl2 gl3 gl4 https://blog.csdn.net/linjf520/article/details/106434989 中文 湖广午王 OpenGLES系列文章（21篇） OpenGL 基础 我的openGL demo Android C++ OpenGL视频课程 Android OpenGL ES教学视频-------------> TODO: 这里有教蒙板 OpenGL.Shader：1-重新认识Android上OpenGL（纯Cpp） 中文视频教程，shader的画法 西川善司的3D图形技术概念和渲染管线的处理 12. TODO： opengl 与surface的关系，尤其是opengl 与 GLSurfaceView 的关系 13. 书籍 OPENGL ES 3.0编程指南.pdf 14. opengl 与skia的联系与区别（个人理解） 1、联系： skia 底层是 cpu绘制（硬件加速时，底层OpenGL ,GPU绘制） 2、区别： skia OpenGL 优点 - skia标准化做的很好(画圆，画点 画线接口很好用) 能力非常强，3d酷炫能力 缺点 EGL接口很难用 & 画圆画线没有现成的接口 自然，所以client 用skia 画标准控件 自然，(1) 主要用来合成，用到了贴图Texture (2) client渲染酷炫的东西（标准化skia没法完成的，比如3d） ​ 详见Skia引擎API整理介绍)： [使用参考]: 15. Mesa(OpenGL的最优实现) 15.1. 与weston12的匹配关系： weston12 ----------------- OpenGL ES 3.1 Mesa 23.0.4 完美匹配 ​ OpenGL ES 2.0 Mesa 21 也可以匹配 15.2. 编译 代码下载： 依赖安装： sudo apt install clang llvm libclang-dev sudo apt install libclc-dev pkg-config sudo apt install libdrm-intel1 libdrm-dev libxcb-glx0-dev libxcb-dri2-0-dev libxshmfence-dev sudo apt install libxcb-dri3-dev libxcb-present-dev llvm-dev libxxf86vm-dev cargo install bindgen-cli -----> 似乎不重要！！！？？？ 切换到 remotes/origin/23.0 想要weston调用mesa的EGL库： 1、自然，就要把mesa编译结果安装到weston_install下 2、自然，先编译mesa，再编译weston（基于mesa的结果） 15.3. 参考 https://winddoing.github.io/post/39ae47e2.html mesa 框架与目录结构 https://blog.csdn.net/u012839187/article/details/120844766 Linux GPU系列-05-MESA架构 [转载] https://blog.csdn.net/HaoBBNuanMM/article/details/109054106 【架构分析】MESA （EGL/GLES）架构分析 ------> 好文！！！ https://crab2313.github.io/ MESA源码分析：EGL MESA源码分析：GBM https://blog.csdn.net/tkwxty/category_12685596.html Mesa框架学习 -----> 系列文章 Android环境下Mesa初始化流程重学习之eglCreateContext Mesa GL Dispatch分发分析与理解 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/2_窗口系统/":{"url":"0_图形系统/2_窗口系统/","title":"2_窗口系统","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/2_窗口系统/0_窗口系统总论/0_窗口系统总论.html":{"url":"0_图形系统/2_窗口系统/0_窗口系统总论/0_窗口系统总论.html","title":"0_窗口系统总论","keywords":"","body":" console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/2_窗口系统/次要/":{"url":"0_图形系统/2_窗口系统/次要/","title":"次要","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/2_窗口系统/次要/virtualDisplay.html":{"url":"0_图形系统/2_窗口系统/次要/virtualDisplay.html","title":"Virtual Display","keywords":"","body":"1.1.1. virtual display virtual display 【Android】VirtualDisplay创建流程及原理_createvirtualdisplay-CSDN博客 -----------> TODO: （1） 如何创建？ （2）哪里渲染的？底层渲染有什么区别？ 通过它创建VirtualDisplayDevice + LogicalDisplay来管理虚拟屏幕。 1.1.1. virtual display virtual display id 是hwc 上报给android 的，我们会一开始create 几条virtual display 出来 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/2_窗口系统/次要/自由窗口.html":{"url":"0_图形系统/2_窗口系统/次要/自由窗口.html","title":"自由窗口","keywords":"","body":"1. 目录2. 安卓自由窗口2.1. 参考：2.2. 0层功能2.3. UI结构2.4. 图形承载---跨进程显示：2.5. UI的事件2.6. 功能代码入口2.7. 功能之 可放缩2.8. 功能之 可移动2.9. 栈维护2.10. 功能之 装饰UI2.10.1. 阴影2.11. 补充操作入口3. 窗口的阴影和圆角 安卓自由窗口 参考： 0层功能 UI结构 图形承载---跨进程显示： UI的事件 功能代码入口 功能之 可放缩 功能之 可移动 栈维护 功能之 装饰UI 阴影 补充操作入口 窗口的阴影和圆角 1. 目录 2. 安卓自由窗口 2.1. 参考： https://blog.csdn.net/sunmmer123/article/details/118211623?spm=1001.2014.3001.5501 https://huaweicloud.csdn.net/64e5c3da6ffa5020257601d1.html android framework实战开发之WINDOWING_MODE_FREEFORM自由窗口相关 前提：自由窗口模式打开：（默认关闭） adb shell settings put global enable_freeform_support 1 adb shell settings put global force_resizable_activities 1 以自由窗口模式启动Activity: 以自由窗口模式启动系统所有应用 https://www.toscl.com/android_freeform/#小窗的边界 参考： https://www.toscl.com/android_freeform/#小窗的启动方式 https://zhuanlan.zhihu.com/p/645953575#:~:text=哥的视频，-,及视频配套资料,-。 android framework实战开发之WINDOWING_MODE_FREEFORM自由窗口相关 https://blog.csdn.net/kavin_ma/article/details/79000549 Android Freeform模式 -------> 好文，其中的图 2.2. 0层功能 freedom窗口是一组功能的集合： 1、永远置顶 2、可放缩 3、可移动 4、装饰（阴影、圆角） 5、启动动画---------> 是否是系统动画？与freedom无关？ 图： https://zhuanlan.zhihu.com/p/645953575#:~:text=哥的视频，-,及视频配套资料,-。 标志： /** Can be freely resized within its parent container. */ /** 可以在其父容器中自由调整大小。 */ WINDOWING_MODE_FREEFORM = 5; 为什么起名freedom？ -------> 可自由移动 & 自由缩放 2.3. UI结构 疑问：TODO: 装饰区域 最终的承载是一个window，还是surfaceview？？？？？ 以及如何插入的 进程结构： systemui进程里 从功能角度拆解： 系统侧生命周期的承载: CaptionWindowDecorViewModel （同时创建WindowDecoration） Decoration区域的UI & UI操作 承载: WindowDecoration WindowDecoration 1、UI图：TODO \" .................. 2、给 四个button + 根布局DecorCaptionView 设置监听器 caption.setOnTouchListener(mOnCaptionTouchListener); // DecorCaptionView设置touch监听 close.setOnClickListener(mOnCaptionButtonClickListener); // 四个button设置click监听 back.setOnClickListener(mOnCaptionButtonClickListener); minimize.setOnClickListener(mOnCaptionButtonClickListener); maximize.setOnClickListener(mOnCaptionButtonClickListener); 2.4. 图形承载---跨进程显示： TODO: 图形结构为什么是这样设计的？？？？目的在于？？？ //WindowDecoration.java // DecorationContainerSurface if (mDecorationContainerSurface == null) { final SurfaceControl.Builder builder = mSurfaceControlBuilderSupplier.get(); mDecorationContainerSurface = builder .setName(\"Decor container of Task=\" + mTaskInfo.taskId) .setContainerLayer() .setParent(mTaskSurface) // 【】 绑定 DecorationContainerSurface 与 mTaskSurface TODO: mTaskSurface这个是什么surface？ .build(); // CaptionContainerSurface, CaptionWindowManager if (mCaptionContainerSurface == null) { final SurfaceControl.Builder builder = mSurfaceControlBuilderSupplier.get();//【】创建mCaptionContainerSurface mCaptionContainerSurface = builder .setName(\"Caption container of Task=\" + mTaskInfo.taskId) .setContainerLayer() .setParent(mDecorationContainerSurface) // 【】至此，三个surface都绑定到一起了 .build(); } if (mViewHost == null) { mViewHost = mSurfaceControlViewHostFactory.create(mDecorWindowContext, mDisplay, mCaptionWindowManager); //mCaptionWindowManager 关联 mCaptionContainerSurface if (params.mApplyStartTransactionOnDraw) { mViewHost.getRootSurfaceControl().applyTransactionOnDraw(startT); } mViewHost.setView(outResult.mRootView, lp); // SurfaceControlViewHost 手段： 将本地的View hierarchy和远端的SurfaceView绑定起来，实现跨进程渲染 绘制/渲染（host承载） --------> 显示（远端client承载） 图： https://blog.csdn.net/april_12345/article/details/133749602#:~:text=是显示进程-,的一个view。,-具体实现 SurfacePackage的序列化： // SurfacePackage public void writeToParcel(@NonNull Parcel out, int flags) { mSurfaceControl.writeToParcel(out, flags); // 【】 传递给远端的是surface，不是view！ out.writeStrongBinder(mAccessibilityEmbeddedConnection.asBinder()); out.writeStrongBinder(mInputToken); out.writeStrongBinder(mRemoteInterface.asBinder()); // 【】 远端用来控制 viewHost的接口，ISurfaceControlViewHost } -----------------> 简言之，远端插入surface 关于跨进程传递surface的本质： 猜测，应该是同mem buffer的传递 -------------------fd传递，共享内存 所以，不太会有损耗 host端层级： - SurfaceControlViewHost： mSurfaceControl （contrainer layer) - WindowlessWindowManager.State.mSurfaceControl (buffer laye) TODO: --------> 画图 client端层级： // SurfaceView hierarchy： - ViewRootImpl surface // 【】应用绘制的那块surface（去除status bar宽度） - bounds layer (crops all child surfaces to parent surface insets) - SurfaceView surface (drawn relative to ViewRootImpl surface) - SurfaceControlViewHost.SurfacePackage surface // 【】 插入进来的 - Background color layer (drawn behind all SurfaceView surfaces) 原文链接： TODO: --------> 画图 维测： surfaceFlinger角度： Display 4630946523002478721 (active) HWC layers: --------------------------------------------------------------------------------------------------------------------------------------------------------------- Layer name Z | Window Type | Comp Type | Transform | Disp Frame (LTRB) | Source Crop (LTRB) | Frame Rate (Explicit) (Seamlessness) [Focused] --------------------------------------------------------------------------------------------------------------------------------------------------------------- Wallpaper BBQ wrapper#68 rel 0 | 0 | DEVICE | 0 | 0 0 1080 2340 | 21.0 47.0 451.0 977.0 | [ ] --------------------------------------------------------------------------------------------------------------------------------------------------------------- com.android.launcher3/com.android.launcher3.uioverrides.QuickstepLauncher#662 rel 0 | 1 | DEVICE | 0 | 0 0 1080 2340 | 0.0 0.0 1080.0 2340.0 | [ ] --------------------------------------------------------------------------------------------------------------------------------------------------------------- com.android.dialer/com.android.dialer.main.impl.MainActivity#663 rel 0 | 1 | DEVICE | 0 | 50 186 655 1356 | 0.0 0.0 605.0 1170.0 | [*] --------------------------------------------------------------------------------------------------------------------------------------------------------------- Caption of Task=37#670 rel 0 | 0 | DEVICE | 0 | 50 186 655 302 | 0.0 0.0 605.0 116.0 | [ ] --------------------------------------------------------------------------------------------------------------------------------------------------------------- //【】 -----------> 能够看到Caption的surface（dialer应用对应的） StatusBar#81 rel 0 | 2000 | DEVICE | 0 | 0 0 1080 136 | 0.0 0.0 1080.0 136.0 | [ ] --------------------------------------------------------------------------------------------------------------------------------------------------------------- NavigationBar0#77 rel 0 | 2019 | DEVICE | 0 | 0 2208 1080 2340 | 0.0 0.0 1080.0 132.0 | [ ] --------------------------------------------------------------------------------------------------------------------------------------------------------------- ScreenDecorOverlay#64 rel 0 | 2024 | DEVICE | 0 | 0 0 1080 216 | 0.0 0.0 1080.0 216.0 | [ ] --------------------------------------------------------------------------------------------------------------------------------------------------------------- ScreenDecorOverlayBottom#69 rel 0 | 2024 | DEVICE | 0 | 0 2103 1080 2340 | 0.0 0.0 1080.0 237.0 | [ ] --------------------------------------------------------------------------------------------------------------------------------------------------------------- -------------------> 结论： 0、 Caption Caption 的surface 1、Task=37是dialer应用所在Task ---------> 可见，surfaceFlinger在底层把 Caption的surface 插入到Task=37里了 2、层级是 670，比dialer应用高 window角度： 看不到caption： // dumpSys window Window #7 Window{6d69d9c u0 com.android.dialer/com.android.dialer.main.impl.MainActivity}: mDisplayId=0 //【】 rootTaskId=37 mSession=Session{b51bfd6 7784:u0a10070} mClient=android.os.BinderProxy@f8e090f mOwnerUid=10070 showForAllUsers=false package=com.android.dialer appop=NONE mAttrs={(0,0)(fillxfill) sim={state=always_hidden adjust=nothing forwardNavigation} ty=BASE_APPLICATION wanim=0x10302fe fl=LAYOUT_IN_SCREEN LAYOUT_INSET_DECOR SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS pfl=NO_MOVE_ANIMATION FORCE_DRAW_STATUS_BAR_BACKGROUND USE_BLAST FIT_INSETS_CONTROLLED vsysui=LIGHT_NAVIGATION_BAR apr=LIGHT_NAVIGATION_BARS bhv=DEFAULT fitSides=} host 与 client联系： final SurfaceControlViewHost host = new SurfaceControlViewHost(this, getDisplay(), hostInputToken); host.setView(suggestionRoot, lp); aidlClass.aidlFunction(host.getSurfacePackage()); //通过aidl接口将SurfacePackage交给显示进程即client端。 SurfaceHolder.Callback.surfaceCreated() { 从远程host中获取SurfaceControlViewHost.SurfacePackage。 可以显示进程调用aidl接口从绘制进程获取，或绘制进程调用aidl传入到显示进程。 SurfaceView.setChildSurfacePackage(SurfacePackage); } 为什么要这样做？ setParent会绑定两个surface的 transition？？？ WindowDecoration 初始化时机： %accordion% Transitions.onTransitionReady WindowDecoration.WindowDecoration(Context, DisplayController, ShellTaskOrganizer, RunningTaskInfo, SurfaceControl) (com.android.wm.shell.windowdecor) DesktopModeWindowDecoration.DesktopModeWindowDecoration(Context, DisplayController, ShellTaskOrganizer, RunningTaskInfo, SurfaceControl, Handler, Choreographer, ...) (com.android.wm.shell.windowdecor) create(Context, DisplayController, ShellTaskOrganizer, RunningTaskInfo, SurfaceControl, Handler, Choreographer, ...) in Factory in DesktopModeWindowDecoration (com.android.wm.shell.windowdecor) DesktopModeWindowDecorViewModel.createWindowDecoration(RunningTaskInfo, SurfaceControl, Transaction, Transaction) (com.android.wm.shell.windowdecor) DesktopModeWindowDecorViewModel.onTaskChanging(RunningTaskInfo, SurfaceControl, Transaction, Transaction) (com.android.wm.shell.windowdecor) // 【】 public FreeformTaskTransitionObserver.onToFrontTransitionReady(Change, Transaction, Transaction) (com.android.wm.shell.freeform) FreeformTaskTransitionObserver.onTransitionReady(IBinder, TransitionInfo, Transaction, Transaction) (com.android.wm.shell.freeform) // 【】 public Transitions.dispatchReady(ActiveTransition) (com.android.wm.shell.transition) Transitions.onTransitionReady(IBinder, TransitionInfo, Transaction, Transaction) // 【】 public %/accordion% TODO: forceDisableBLAST TODO: 事件是怎么过来的？ 上下window如何同步的？ 为啥上面不用window？不用的原因是什么？ 为啥要这样设计？传给cliet显示的作用是啥？好处是啥？ remote-surface demo： https://github.com/Felix-Dai/remote-surface 参考： https://blog.csdn.net/april_12345/article/details/133749602 Android SurfaceControlViewHost介绍及使用 https://www.jianshu.com/p/0f45fdb36631 使用SurfaceControlViewHost 实现跨进程UI渲染 https://commonsware.com/blog/2020/03/27/peek-surfacecontrolviewhost-android-r.html 牛人文章 2.5. UI的事件 事件是直接基于surface分发的? 还是 先分发到 client再传给host ？ 2.6. 功能代码入口 入口：应用（系统应用多任务、三方应用侧边栏） 多任务界面（属于launcher3界面）启动： 多任务里面，点击应用图标，选择小窗模式（安卓原生）： -------> 必然： 需求决定：触发点 & 确定点是 launcher3 // ActivityTaskSupervisor.java // TODO: 为啥log显示 system_server调用的这个接口？ startActivityFromRecents() { } 侧边栏： 三方应用启动，比如侧边栏（华为手机），通知栏等待 %accordion% 代码 // TODO: 侧边栏进程是？类？ TODO: 从0层来看，在此之前，要由pms判断，是否支持 public void startFreeFormActivity(View view) { ................... options.setLaunchWindowingMode(WINDOWING_MODE_FREEFORM); // 【】 自然，以FREEFORM startActivity startActivity(intent, options.toBundle()); } %/accordion% ------------------> 总结： 1、都是应用启动 2、都是应用指定了浮窗模式 妥协-----------白名单： 白名单位置：应用侧配置，系统侧Pms去解析 1、支持小窗的应用 ----------> 应用需要设置 android:resizeableActivity=\"true\" 系统侧判断：AndroidManifest.xml ---> PackageParser.ActivityInfo的privateFlags PMS解析： TODO: 从应用角度，需要做哪些事情呢？？？仅仅适配小窗的尺寸？ android:resizeableActivity=\"true\" 含义又是啥 2、不支持的应用： 系统侧如何处理的？似乎没有强制resize 2.7. 功能之 可放缩 国内厂商--------------只有一种长宽比（假的缩放）： -------------> 目的在于：避免适配无数种宽高比 resize 过程 通过矩阵变化中的缩放 -------> 事件、显示的映射？？？？surface大小变了没？ 安卓原生------------任意宽高比（真实的resize） 疑问：（1）应用如何保证可以无限resize？ （2） 触发： onDragPositioningEnd:89, FluidResizeTaskPositioner // 【2】 识别是resize后，交给 FluidResizeTaskPositioner 处理 handleMotionEvent:144, DragResizeInputListener$TaskResizeInputEventReceiver onMotionEvent:109, DragDetector // 【1】 DragDetector 识别是否是resize！！！！ onInputEvent:14, DragResizeInputListener$TaskResizeInputEventReceiver dispatchInputEvent:267, InputEventReceiver nativePollOnce:-1, MessageQueue next:335, MessageQueue loopOnce:162, Looper loop:294, Looper run:67, HandlerThread //【】 TODO: 最开始谁触发的？ 事件机制是怎么样的？ 参考： https://zhuanlan.zhihu.com/p/645953575#:~:text=插入图片描述-,自由窗口模式的拖拽变大,-frameworks/base 2.8. 功能之 可移动 结论：由 CaptionView 承载 frameworks/base/core/java/com/android/internal/widget/DecorCaptionView.java @Override public boolean onTouch(View v, MotionEvent e) { ............ case MotionEvent.ACTION_MOVE: //这里app进程发起startMovingTask调用 startMovingTask(e.getRawX(), e.getRawY()); // 【】 安卓的task对应kwin的Tile break; } public final boolean startMovingTask(float startX, float startY) { ............ try { //【】 这里最后通过Session进行跨进程调用到systemserver return mAttachInfo.mSession.startMovingTask(mAttachInfo.mWindow, startX, startY); } catch (RemoteException e) { ............ } ............ } TODO: 移动的同步： 底层窗口是如何同步移动的？ 参考： https://blog.csdn.net/learnframework/article/details/131130412?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-131130412-blog-135064522.235^v43^pc_blog_bottom_relevance_base7&spm=1001.2101.3001.4242.1&utm_relevant_index=3#:~:text=96-,自由窗口模式的移动,-自由窗口的 2.9. 栈维护 效果： 安卓原生: 可以多个自由窗口同时显示（类似于windows和linux） 华为：始终保持一个 2.10. 功能之 装饰UI 2.10.1. 阴影 2.11. 补充操作入口 adb shell settings put global enable_freeform_support 1 adb shell settings put global force_resizable_activities 1 3. 窗口的阴影和圆角 见《SF特效》 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/2_窗口系统/SurfaceControl.html":{"url":"0_图形系统/2_窗口系统/SurfaceControl.html","title":"Surface Control","keywords":"","body":"1. 目录2. 代码里截图 & 存储 代码里截图 & 存储 1. 目录 2. 代码里截图 & 存储 Rect crop = new Rect(0, 0, size.x, size.y); SurfaceControl.ScreenshotHardwareBuffer buffer = SurfaceControl.captureLayers(surfaceControl, crop, 1); // 【】 SurfaceControl.captureLayers if (buffer == null) { return 0; } mySecondBitmap = buffer.asBitmap(); //cg add. new Thread(new Runnable() { //3、在子线程里发消息 @Override public void run() { try { if (mySecondBitmap != null) { Log.d(\"\", \"myFisrtBitmap save to png\"); File f = new File(\"/data/local/tmp\" ,\"mySecondImage.png\");// /data/local/tmp f.createNewFile(); FileOutputStream out = new FileOutputStream(f); mySecondBitmap.compress(Bitmap.CompressFormat.PNG, 50, out); out.flush(); out.close(); } } catch (Exception e) { e.printStackTrace(); } } }).start(); TODO: 截图的底层实现： 大致是弄了一个虚拟屏，在虚拟屏上合成（因为存在部分密码等场景，有些surface不能合成进去） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/2_窗口系统/virtualDisplay.html":{"url":"0_图形系统/2_窗口系统/virtualDisplay.html","title":"Virtual Display","keywords":"","body":"1.1.1. virtual display virtual display 【Android】VirtualDisplay创建流程及原理_createvirtualdisplay-CSDN博客 -----------> TODO: （1） 如何创建？ （2）哪里渲染的？底层渲染有什么区别？ 通过它创建VirtualDisplayDevice + LogicalDisplay来管理虚拟屏幕。 1.1.1. virtual display virtual display id 是hwc 上报给android 的，我们会一开始create 几条virtual display 出来 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/2_窗口系统/wms_animination.html":{"url":"0_图形系统/2_窗口系统/wms_animination.html","title":"Wms Animination","keywords":"","body":"1. 目录2. 从功能角度看Animation3. 动画的种类4. Android 动画原理4.1. 一对组合---------Animation 和 Transform4.2. Choreographer4.3. Animation4.4. Animation的管理者 Animator5. 窗口动画6. 转场动画（过渡动画）7. 屏幕旋转动画7.1. 0层框架7.2. 旋转动画7.3. 0层纵向7.4. 动画素材来源----截图7.5. 横竖屏切换动画时间优化方案7.6. 旋转屏幕的一些认知8. View动画9. 参考10. 抛开动画代码11. 动画背后的思想 从功能角度看Animation 动画的种类 Android 动画原理 一对组合---------Animation 和 Transform Choreographer Animation Animation的管理者 Animator 窗口动画 转场动画（过渡动画） 屏幕旋转动画 0层框架 旋转动画 0层纵向 动画素材来源----截图 横竖屏切换动画时间优化方案 旋转屏幕的一些认知 View动画 参考 抛开动画代码 动画背后的思想 1. 目录 2. 从功能角度看Animation 本质就是一个插件： 衔接 两个静态的窗口画面 TODO: 什么是系统级 animation，什么是应用级 animation？ 3. 动画的种类 WMS的动画系统 https://juejin.cn/post/7021082548985921567 动画 Drawable ------帧动画（Frame 动画、Drawable 动画） view：view动画------原理view的变动 属性动画------ 窗口类：窗口动画 -------原理surface Toast的弹出动画 整个屏幕：原理截图 对于View动画，动画的目标就是View，而对于窗口来说，动画的目标其实都是Surface，对不同层级的SurfaceControl进行操纵，会产生不同的动画效果。 目标WindowContainer 名称 举例 WindowState 窗口动画 Toast的弹出动画、PopupWindow的弹出动画 ------------> 要做 AppWindowToken 过渡动画 App从桌面启动的动画 ------------> 要做 Task Task动画 Recents的动画，PIP动画 DisplayContent 全屏动画 转屏动画 ------------> 要做 参考： https://juejin.cn/post/7021082548985921567 4. Android 动画原理 Android中动画的工作过程： 在某一个时间点，调用getTransformation()，根据mStartTime和mDuration，计算出当前的进度，在根据mInterpolator计算出转换的进度，然后计算出属性的当前值，保存在matrix中。 再调用Matrix.getValues将属性值取出，运用在动画目标上。 4.1. 一对组合---------Animation 和 Transform Animation ：---------> 本质：时间 给定了初始状态、结束状态、启动时间与持续时间 ------> 用于计算 Transformation Transformation：--------> 本质：空间 Transformation 描述了一个变换，即：透明度和一个二维变换矩阵 补充Animation 子类： 子类：TranslateAnimation，ScaleAnimation，RotateAnimation，AlphaAnimation 4.2. Choreographer VSync信号驱动动画 4.3. Animation 从数学角度，看Animation种类： 1、变化的量： 位置（TranslateAnimation）、大小（ScaleAnimation）、角度（RotateAnimation）、透明度（AlphaAnimation，淡入淡出，改变透明度） ------------> 很自然，前三者可以用一个matrix来表示 2、如何变？--------插值器Interpolator Translate动画属性： android:fromXDelta：X轴的起始坐标android:toXDelta：X轴的结束坐标.....................android:duration：动画时长 参考： https://blog.csdn.net/weixin_34124577/article/details/90689619 Android过场动画基础教程 Scale动画的属性: ......................... 参考： https://blog.csdn.net/weixin_34124577/article/details/90689619 Android过场动画基础教程 Alpha动画的属性: ......................... 参考： https://blog.csdn.net/weixin_34124577/article/details/90689619 Android过场动画基础教程 插值器Interpolator： 1 在API21(5.0)中提供了三种基本的曲线运动插值器：2 fast_out_linear_in | 快速加速并持续加速到结束3 fast_out_slow_in | 快速加速但缓慢减速到结束4 linear_out_slow_in | 甩向前缓慢到达最终值5 6 7 在API11中提供的16种插值器：8 accelerate_cubic | 加速度_立方体9 accelerate_decelerate | 加速度_减速10 accelerate_quad | 加速度_二次11 accelerate_quint | 加速度_五重峰12 anticipate | 开始向后,然后向前13 anticipate_overshoot | 开始向后，然后向前并超过目标值，最后返回最终值14 bounce | 到达目标值时有回弹效果并逐渐减小回弹力15 cycle | 重复动画一个周期16 decelerate_cubic | 减速度_立方17 decelerate_quad | 减速度_二次18 decelerate_quint | 减速度_五重峰19 linear | 速度恒定20 overshoot | 向前并超过目标值，最后返回最终值 -------------------> TODO: 插值器的计算周期是多久？每一帧都会计算？没必要吧 代码角度： 自然，各种Animation的样式 由各个 Animation承载 Animation必然持有插值器 ------------------> 类图： TODO 结构： TODO: 谁来设置的Animation？哪个进程？Animation信息流 TODO: 应用内部的动画是什么？由vsync信号控制的！！！！ 动画的触发源： Vsync 信号 --------> WMS -------> 窗口级别的 Animation（应用启动的） --------> APP -------> 窗口内的 Animation，比如view的、drawable的 c/s结构，C端永远是配置set，S才是生效端（无论view的显示、canvas的绘制（其实就是配置，这一堆配置挪动到合成器，就是统一渲染）、window大小类型的设置、Animation的设置！！！！） https://blog.csdn.net/catzifeng/article/details/104179061 Android动画全篇系列（零）——动画总览 4.4. Animation的管理者 Animator Animation实际上是定义了样式（静态的样式）--------------> Animator才是真实的执行者，管理者 5. 窗口动画 https://blog.csdn.net/luoshengyang/article/details/8596449 Android窗口管理服务WindowManagerService切换Activity窗口（App Transition）的过程分析 6. 转场动画（过渡动画） https://www.51cto.com/article/685363.html Android转场动画深度解析 https://www.51cto.com/article/685363.html#:~:text=%E4%B8%A4%E4%B8%AAactivity%E5%88%87%E6%8D%A2%E6%97%B6%E7%9A%84%EF%BC%8C%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%8A%A8%E7%94%BB%EF%BC%8C%E4%BB%8Eactivity%20A%20%E5%88%87%E6%8D%A2%E5%88%B0activity%20B%E6%97%B6%EF%BC%8C%E4%BC%9A%E6%9C%89A%E7%9A%84%E9%80%80%E5%87%BA%E5%8A%A8%E7%94%BB%E5%92%8CB%E7%9A%84%E8%BF%9B%E5%85%A5%E5%8A%A8%E7%94%BB%3B ---------> TODO 英文 7. 屏幕旋转动画 参考：https://juejin.cn/post/7026611124482670600 触发点（自然时机）： ​ 屏幕旋转之后 注意：此时动画还没开启 代码触发点： TODO: 具体哪个模块？ OrientationListener#onProposedRotationChanged ​ -------> WMS#updateRotation 7.1. 0层框架 图片来源： https://www.jianshu.com/p/217d0239ca19 Android中的转屏流程_user_rotation_free-CSDN博客 TODO: 基于功能的模型设计思想： 7.2. 旋转动画 https://www.jianshu.com/p/217d0239ca19 Android 转屏机制 try { String filename = Environment.getExternalStorageDirectory().toString(); File f = new File(filename ,\"myImage.png\"); f.createNewFile(); System.out.println(\"file created \" + f.toString()); FileOutputStream out = new FileOutputStream(f); Bitmap bitmap = showImage(urlStr); bitmap.compress(Bitmap.CompressFormat.PNG, 90, out); } catch (Exception e) { e.printStackTrace(); } } 如何识别核心？ Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"updateRotation: display\"); final boolean rotationChanged = displayContent.updateRotationUnchecked(); Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); https://juejin.cn/post/7026611124482670600 WindowManagerService#startFreezingDisplay 冻屏旋转 https://www.cnblogs.com/dyufei/p/8081936.html https://www.cnblogs.com/dyufei/p/8075187.html Android 7.1 屏幕旋转流程分析 https://blog.csdn.net/qq_24604069/article/details/109694113 文字注释版 https://blog.csdn.net/u013087553/article/details/95999272 Android学习之Matrix 0层： 彩色，重点： /* *test */ wms.updateRotation 名誉 ├─updateRotationUnchecked ├─循环：DisplayContent.updateRotationUnchecked() 循环各个display。透传。有trace └─各自的DisplayRotation.updateRotationUnchecked （注：DisplayRotation删除） └─prepareNormalRotationAnimation() 名誉， 冻屏旋转 | WMS.startFreezingDisplay 冻屏（冻结input，不再分发） | mInputManagerCallback.freezeInputDispatchingLw(); //【】 | sra = new ScreenRotationAnimation //【】新建Screen旋转动画，整个屏幕截图 | setRotation(t, realOriginalRotation) 截图设置到最初的位置（实际上就是与屏幕重合，见链接） | displayContent.setRotationAnimation(sra) └─ mDisplayContent.setLayoutNeeded(); ATMS.notifyOnActivityRotation(displayId) 最终干啥去了？ WindowSurfacePlacer.performSurfacePlacement //【】 TODO，角度： 基于功能模块，过滤并记录各个关键trace点 mDisplayContent.getPendingTransaction(), ANIMATION_TYPE_SCREEN_ROTATION anim.start(); anim.doAnimationFrame(mChoreographer.getFrameTime()); anim.doAnimationFrame(mChoreographer.getFrameTime()); -----> 这个time mChoreographer.postFrameCallback(this::startAnimations); ------> 每一帧都会调用？？？ 循环之。。。。。。。。 apply:89, WindowAnimationSpec (com.android.server.wm) applyTransformation:242, SurfaceAnimationRunner (com.android.server.wm) startAnimation:146, SurfaceAnimationRunner (com.android.server.wm) startAnimation:56, LocalAnimationAdapter (com.android.server.wm) startAnimation:188, SurfaceAnimator (com.android.server.wm) startAnimation:2607, WindowContainer (com.android.server.wm) startAnimation:2614, WindowContainer (com.android.server.wm) startAnimation:2620, WindowContainer (com.android.server.wm) startAnimation:5631, WindowState (com.android.server.wm) startAnimation:5607, WindowState (com.android.server.wm) applyAnimationLocked:752, WindowStateAnimator (com.android.server.wm) hide:3532, WindowState (com.android.server.wm) hidePermanentlyLw:3665, WindowState (com.android.server.wm) handleMessage:5562, WindowManagerService$H (com.android.server.wm) dispatchMessage:106, Handler (android.os) loopOnce:214, Looper (android.os) loop:304, Looper (android.os) run:67, HandlerThread (android.os) run:44, ServiceThread (com.android.server) run:45, DisplayThread (com.android.server) t.setMatrix(leash, tmp.transformation.getMatrix(), tmp.floats); t.setAlpha(leash, tmp.transformation.getAlpha()); TODO:之间的关系？ WMS持有SurfaceAnimationRunner、WindowAnimator ScreenRotationAnimation 引用 wms wms是整个动画的主，其他都是辅助类 DisplayRotation.OrientationListener ----> wms.updateRotation( -----> displayContent.updateRotationUnchecked DisplayRotation.updateRotationUnchecked mService.mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_ACTIVE; mService.mH.sendNewMessageDelayed(WindowManagerService.H.WINDOW_FREEZE_TIMEOUT, 解除冻屏时，也会截图，启动动画： wms.stopFreezingDisplayLocked screenRotationAnimation.dismiss startAnimation startScreenRotationAnimation startColorAnimation StartLuma光圈变化？ startScreenshotRotationAnimation SurfaceAnimator.startAnimation WSA.applyAnimationLocked Log.d(TAG, \"setBuffer: in, sc:\" + sc + \", buffer:\" + buffer + \",getWidth: \" + buffer.getWidth() + \",getHeight: \" + buffer.getHeight() + \",getUsage: \" + buffer.getUsage()); Log.i(TAG, Log.getStackTraceString(new Throwable())); public void apply(Transaction t, SurfaceControl leash, long currentPlayTime) { Log.d(\"WindowAnimationSpec\", \"apply: in, t:\" + t + \", leash:\" + leash + \",currentPlayTime: \" + currentPlayTime); final TmpValues tmp = mThreadLocalTmps.get(); tmp.transformation.clear(); mAnimation.getTransformation(currentPlayTime, tmp.transformation); tmp.transformation.getMatrix().postTranslate(mPosition.x, mPosition.y); Log.d(\"WindowAnimationSpec\", \"t.setMatrix: t:\" + tmp.transformation.getMatrix().toString() + \",tmp.floats: \" + tmp.floats); 结束动画: screenRotaionAnimation mFinishAnimReady = trues 7.3. 0层纵向 基于0层框架，不得不： 1、屏幕旋转的核心 -----> 必然是wms：承载了window的新建，以及动画 2、when： 旋转的信号是谁通知的wms？传感器 ----> SensorService ----> WMS 3、what：做了啥事？ 7.4. 动画素材来源----截图 动画启动的最基本元素 来源， 截图： // ScreenRotationAnimation final SurfaceControl.Transaction t = mService.mTransactionFactory.get(); SurfaceControl.LayerCaptureArgs args = new SurfaceControl.LayerCaptureArgs.Builder(displayContent.getSurfaceControl()) .setCaptureSecureLayers(true) .setAllowProtected(true) .setSourceCrop(new Rect(0, 0, mWidth, mHeight)) .build(); SurfaceControl.ScreenshotHardwareBuffer screenshotBuffer = SurfaceControl.captureLayers(args); // 这一大段就是抓取截图绑定到mScreenshotLayer GraphicBuffer buffer = GraphicBuffer.createFromHardwareBuffer( screenshotBuffer.getHardwareBuffer()); t.setBuffer(mScreenshotLayer, buffer); 承载的surface： // mScreenshotLayer是真正用于旋转动画的surface mScreenshotLayer = displayContent.makeOverlay() setRotationTransform 中 mScreenshotLayer承载的数据，被旋转 t.setPosition(mScreenshotLayer, x, y); t.setMatrix(mScreenshotLayer, mTmpFloats[Matrix.MSCALE_X], mTmpFloats[Matrix.MSKEW_Y], mTmpFloats[Matrix.MSKEW_X], mTmpFloats[Matrix.MSCALE_Y]); t.setAlpha(mScreenshotLayer, (float) 1.0); t.show(mScreenshotLayer); 截图获取bitmap方法： final SurfaceControl.ScreenshotHardwareBuffer screenshotBuffer = SurfaceControl.captureDisplay(captureArgs); screenshot = screenshotBuffer == null ? null : screenshotBuffer.asBitmap(); // 参考： https://blog.csdn.net/weixin_46297800/article/details/131939823 // 转成png Bitmap bitmap = screenshotBuffer.asBitmap(); OutputStream os = new FileOutputStream(\"/sdcard/screen.png\"); bitmap.compress(Bitmap.CompressFormat.PNG, 100, os); os.flush(); os.close(); Bitmap bitmap = null; Class cls = Class.forName(\"android.view.SurfaceControl\"); Method method = cls.getMethod(\"screenshot\", Rect.class, int.class, int.class, int.class); Object obj = method.invoke(null, new Rect(0, 0, 500, 1000), 500, 1000, 0); bitmap = (Bitmap) obj; String name = \"app2\"; File cacheDir = context.getCacheDir(); Log.i(\"liuhongliang\",\"cacheDir\" + cacheDir.toString()); cachePath = \"/sdcard/\" + name + \".png\"; String cmd = \"screencap -p /sdcard/\" + name + \".png\"; // 权限设置 Process p = Runtime.getRuntime().exec(\"sh\"); //Process process = rt.exec(\"su\"); // 获取输出流 OutputStream outputStream = p.getOutputStream(); DataOutputStream dataOutputStream = new DataOutputStream( outputStream); // 将命令写入 dataOutputStream.writeBytes(cmd); // 提交命令 dataOutputStream.flush(); // 关闭流操作 dataOutputStream.close(); outputStream.close(); TODO: 冻屏动画或者无缝动画 最开始截图，需要调整一下初始位置： 参考： https://blog.csdn.net/learnframework/article/details/129972954 TODO：补充画面重新加载，方向变化的图 几个结论： 1、物理屏幕的旋转，是基于物理世界的，（想象是黑屏下）没有旋转中心 或者 以任意旋转中心 ------> 所以，对代码没有任何影响 ​ 物理屏幕没有 坐标原点的概念 2、没有重新加载的画面的旋转：-----> 即是动画截屏的第一帧 ​ （1）图片相对于屏幕完全静止 ​ （2）有坐标原点的概念：基于物理屏幕，坐标原点是物理屏幕的左上角 -----------> 给代码模型用的 ​ 3、1和2本质上是一个操作，即物理屏幕旋转 + 画面相对于物理屏没动 4、基于3，截图开始动 5、新的画面重新加载，方向也变化了 04-05 16:16:41.723 565 586 I WindowManager: createAnimationLeash type = screen_rotation 04-05 16:16:41.723 565 586 I WindowManager: java.lang.Exception 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.SurfaceAnimator.createAnimationLeash(SurfaceAnimator.java:458) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.SurfaceAnimator.startAnimation(SurfaceAnimator.java:184) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.SurfaceAnimator.startAnimation(SurfaceAnimator.java:213) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.ScreenRotationAnimation$SurfaceRotationAnimationController.startAnimation(ScreenRotationAnimation.java:697) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.ScreenRotationAnimation$SurfaceRotationAnimationController.startDisplayRotation(ScreenRotationAnimation.java:580) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.ScreenRotationAnimation$SurfaceRotationAnimationController.startScreenRotationAnimation(ScreenRotationAnimation.java:563) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.ScreenRotationAnimation.startAnimation(ScreenRotationAnimation.java:422) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.ScreenRotationAnimation.dismiss(ScreenRotationAnimation.java:440) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.WindowManagerService.doStopFreezingDisplayLocked(WindowManagerService.java:6157) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.WindowManagerService.stopFreezingDisplayLocked(WindowManagerService.java:6116) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.RootWindowContainer.performSurfacePlacementNoTrace(RootWindowContainer.java:890) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.RootWindowContainer.performSurfacePlacement(RootWindowContainer.java:784) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.WindowSurfacePlacer.performSurfacePlacementLoop(WindowSurfacePlacer.java:177) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.WindowSurfacePlacer.performSurfacePlacement(WindowSurfacePlacer.java:126) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.WindowSurfacePlacer.performSurfacePlacement(WindowSurfacePlacer.java:115) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.wm.WindowSurfacePlacer$Traverser.run(WindowSurfacePlacer.java:57) 04-05 16:16:41.723 565 586 I WindowManager: at android.os.Handler.handleCallback(Handler.java:942) 04-05 16:16:41.723 565 586 I WindowManager: at android.os.Handler.dispatchMessage(Handler.java:99) 04-05 16:16:41.723 565 586 I WindowManager: at android.os.Looper.loopOnce(Looper.java:201) 04-05 16:16:41.723 565 586 I WindowManager: at android.os.Looper.loop(Looper.java:288) 04-05 16:16:41.723 565 586 I WindowManager: at android.os.HandlerThread.run(HandlerThread.java:67) 04-05 16:16:41.723 565 586 I WindowManager: at com.android.server.ServiceThread.run(ServiceThread.java:44) 7.5. 横竖屏切换动画时间优化方案 https://zhuanlan.zhihu.com/p/265291842 7.6. 旋转屏幕的一些认知 1、横向永远是x（即旋转后，x值更大） 2、更新surface位置 布局窗口relayoutWindow 何时？ 最终逃不过的点，不得不： SurfaceControl.setPosition setPosition:2756, SurfaceControl$Transaction (android.view) lambda$new$1$WindowState:854, WindowState (com.android.server.wm) accept:-1, WindowState$$ExternalSyntheticLambda3 (com.android.server.wm) updateSurfacePosition:5547, WindowState (com.android.server.wm) updateSurfacePositionNonOrganized:3042, WindowContainer (com.android.server.wm) prepareSurfaces:5491, WindowState (com.android.server.wm) prepareSurfaces:2445, WindowContainer (com.android.server.wm) prepareSurfaces:2445, WindowContainer (com.android.server.wm) prepareSurfaces:2445, WindowContainer (com.android.server.wm) prepareSurfaces:644, DisplayArea$Dimmable (com.android.server.wm) prepareSurfaces:4879, DisplayContent (com.android.server.wm) applySurfaceChangesTransaction:4335, DisplayContent (com.android.server.wm) applySurfaceChangesTransaction:1068, RootWindowContainer (com.android.server.wm) performSurfacePlacementNoTrace:844, RootWindowContainer (com.android.server.wm) performSurfacePlacement:797, RootWindowContainer (com.android.server.wm) performSurfacePlacementLoop:177, WindowSurfacePlacer (com.android.server.wm) ------> 这里，所有 performSurfacePlacement:126, WindowSurfacePlacer (com.android.server.wm) relayoutWindow:2386, WindowManagerService (com.android.server.wm) relayout:235, Session (com.android.server.wm) onTransact:735, IWindowSession$Stub (android.view) onTransact:169, Session (com.android.server.wm) execTransactInternal:1184, Binder (android.os) execTransact:1143, Binder (android.os) 8. View动画 https://www.youtube.com/watch?v=S20kdGUOnAw 9. 参考 首要参考： https://blog.csdn.net/SSSxCCC/article/details/119324066 转屏动画 - 安卓R https://juejin.cn/post/6982153383880687624#heading-7 Android R WindowManagerService模块(7) 屏幕旋转流程(2) https://www.cnblogs.com/dyufei/p/8081936.html Android 7.1 WindowManagerService 屏幕旋转流程分析 https://www.zhihu.com/question/334061990 Android 做到 iOS 如丝般柔滑的过渡动画真的很难吗？ https://juejin.cn/post/6844903465211133959 Android 动画总结——View 动画、属性动画、帧动画 ---------> 好文： https://juejin.cn/post/7023676770016559118 Android WMS动画系统初探(二) ----------> 好文，系列文章！！！！！！ https://juejin.cn/post/7026611124482670600/ Android WMS动画系统初探(三) 屏幕旋转动画 ---------> 拿display去旋转的！！！！ https://www.cnblogs.com/Im-Victor/p/11445589.html Android 一共有多少种动画？准确告诉你！ 动画种类 Android 动画可以归纳为以下几种： 视图动画（View 动画） 帧动画（Frame 动画、Drawable 动画） 属性动画 触摸反馈动画（Ripple Effect） 揭露动画（Reveal Effect） 转场动画 & 共享元素（Activity 切换动画） 视图状态动画（Animate View State Changes） 矢量图动画（Vector 动画） 约束布局实现的关键帧动画（ConstraintSet 动画） 补充： 屏幕旋转动画 ------> 转场动画的一种？？？？ https://github.com/OCNYang/Android-Animation-Set?tab=readme-ov-file 《Android 动画详尽教程》系列 ---------> 好文 10. 抛开动画代码 11. 动画背后的思想 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/2_窗口系统/窗口管理之weston.html":{"url":"0_图形系统/2_窗口系统/窗口管理之weston.html","title":"窗口管理之weston","keywords":"","body":"1. 目录2. 窗口管理2.1. opaque region管理2.2. 窗口的移动----------system move2.3. 窗口设置位置 & 层级 ----> TODO: 扩展协议里？？？？？2.4. 坐标系3. 输入管理4. wayland协议4.1. Wayland核心协议，同安卓4.1.1. wayland-protocol.c 核心通信层4.2. 扩展协议4.3. kwayland协议4.4. 参考5. 配置(weston.ini)5.1. 大的ini配置流程：5.2. 具体weston.ini6. panel(状态栏)6.1. panel的配置6.2. 结构：panel走的是GPU合成7. 实操7.1. 虚拟机ubuntu安装weston桌面（走drm后端）7.2. 强制走drm后端-----启动weston_install/bin/weston8. 一些名词 TODO 目录 窗口管理 opaque region管理 窗口的移动----------system move 窗口设置位置 & 层级 ----> TODO: 扩展协议里？？？？？ 坐标系 输入管理 wayland协议 Wayland核心协议，同安卓 wayland-protocol.c 核心通信层 扩展协议 kwayland协议 参考 配置(weston.ini) 大的ini配置流程： 具体weston.ini panel(状态栏) panel的配置 结构：panel走的是GPU合成 实操 虚拟机ubuntu安装weston桌面（走drm后端） 强制走drm后端-----启动weston_install/bin/weston 一些名词 TODO 1. 目录 2. 窗口管理 2.1. opaque region管理 https://blog.csdn.net/u012839187/article/details/120050552 display: weston: opaque region笔记 2.2. 窗口的移动----------system move 图： todo system move功能实现逻辑的证明： move 即 （每一帧的）事件event-重绘 system move要解决的问题是（功能）： move的跟手性，即（2）保证 每一帧的 event-重绘 组合 -----> 必然：（1）在system侧 容易做到 由（1）必然要client给一个start ----------- （1_1） 由（2），必然：之后client不管了 ----------- （1_2） \"（1_1）client给一个start\" 流程： xdg_toplevel_move // client端 ----------------wayland协议------------------------- weston_desktop_xdg_toplevel_protocol_move weston_desktop_api_move desktop_surface_move (shell.c) surface_move (shell.c) shell_grab_start(move->base, &move_grab_interface, shsurf, // 【】必然给了初始位置 pointer, WESTON_DESKTOP_SHELL_CURSOR_MOVE) // 【】1_2之后不管，必然要：告诉compositor干什么(WESTON_DESKTOP_SHELL_CURSOR_MOVE)， 1_2_1 告诉compositor怎么干(move_grab_interface) 1_2_2 1_2_2 compositor具体怎么干： // 必然定义在shell.c static const struct weston_pointer_grab_interface move_grab_interface = { noop_grab_focus, move_grab_motion, //【】 move_grab_button, noop_grab_axis, noop_grab_axis_source, noop_grab_frame, move_grab_cancel, }; 其中 move_grab_motion， 必然出发compositor移动位置1_2_2_1，必然触发重绘1_2_2_2: weston_pointer_move_to (input.c) weston_pointer_move weston_view_set_position(shsurf->view, cx, cy) // 【】1_2_2_1 最终生效一行view->geometry.pos_offset && PAINT_NODE_VIEW_DIRTY weston_compositor_schedule_repaint(surface->compositor)； // 【】1_2_2_2 when，触发时机：必然是client端，收到down事件 static const struct wl_touch_listener touch_listener = { touch_handle_down, //【】 touch_handle_up, touch_handle_motion, touch_handle_frame, touch_handle_cancel, }; TODO: 触发存在 点击和move的 冲突问题： 怎么解决？ 2.3. 窗口设置位置 & 层级 ----> TODO: 扩展协议里？？？？？ 2.4. 坐标系 结论： 1、两个屏幕，共用一个坐标系： 2、一个屏幕 = 一个outPut // screen1: [12:55:06.684] gl_renderer_repaint_output, output: 0x58f59137bf80, glViewport:(0, 0, 564, 600) //【】------> 相对于screen1（output1）坐标系！！！！！！ [12:55:06.684] gl_shader_config_init_for_paint_node. go->area:(0, 0, 564, 600) [12:55:06.684] gl_shader_config_init_for_paint_node. surface->width: 1024, surface->height: 600, [12:55:06.684] gl_shader_config_init_for_paint_node. pnode->view->geometry.pos_offset: (1024.000000, 0.000000) [12:55:06.684] gl_shader_config_init_for_paint_node. pnode->output: (1024, 0, 564, 600) [12:55:06.684] gl_shader_config_init_for_paint_node. go->area:(0, 0, 564, 600) [12:55:06.684] gl_shader_config_init_for_paint_node. surface->width: 250, surface->height: 250, [12:55:06.684] gl_shader_config_init_for_paint_node. pnode->view->geometry.pos_offset: (848.000000, 112.000000) //【】---> simple-egl的surface 相对于screen0 左上角（而不是screen1） [12:55:06.684] gl_shader_config_init_for_paint_node. pnode->output: (1024, 0, 564, 600) [12:55:06.684] gl_shader_config_init_for_paint_node. go->area:(0, 0, 564, 600) [12:55:06.684] gl_shader_config_init_for_paint_node. surface->width: 32, surface->height: 32, [12:55:06.684] gl_shader_config_init_for_paint_node. pnode->view->geometry.pos_offset: (1015.000000, 508.000000) [12:55:06.684] gl_shader_config_init_for_paint_node. pnode->output: (1024, 0, 564, 600) //【】--> output1 相对于screen0！！！ ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- // screen0: [12:55:06.694] gl_renderer_repaint_output, output: 0x58f59134d460, glViewport:(0, 0, 1024, 600) [12:55:06.694] gl_shader_config_init_for_paint_node. go->area:(0, 0, 1024, 600) [12:55:06.694] gl_shader_config_init_for_paint_node. surface->width: 1024, surface->height: 600, [12:55:06.694] gl_shader_config_init_for_paint_node. pnode->view->geometry.pos_offset: (0.000000, 0.000000) [12:55:06.694] gl_shader_config_init_for_paint_node. pnode->output: (0, 0, 1024, 600) [12:55:06.694] gl_shader_config_init_for_paint_node. go->area:(0, 0, 1024, 600) [12:55:06.694] gl_shader_config_init_for_paint_node. surface->width: 250, surface->height: 250, [12:55:06.694] gl_shader_config_init_for_paint_node. pnode->view->geometry.pos_offset: (848.000000, 112.000000) [12:55:06.694] gl_shader_config_init_for_paint_node. pnode->output: (0, 0, 1024, 600) [12:55:06.695] surface_attach, buffer, (width:250, height:250), type:1 3. 输入管理 4. wayland协议 4.1. Wayland核心协议，同安卓 参考： 【Wayland】Wayland协议说明 位置： 系统中，自然，不在weston中（因为不是weston定义的！！！） ​ /usr/share/wayland/wayland.xml 在线：https://github.com/nobled/wayland/blob/master/protocol/wayland.xml 原理同 安卓AIDL： 图来源 图来源 关键：XXX 具体例子： 以 wl_surface_commit 接口为例： 位置：/home/chen/kde/usr/share/wayland/ wayland.xml ： ----------> 生成： // client wayland-client-protocol.h(应该是kde目录下的) wayland-protocol.c // 【】 核心通信层 // server wayland-server-protocol.h Linux编译，查找.h /usr/ 存放系统头文件的位置, 供编译器在编译过程中使用。 /home/chen/kde/usr/ 4.1.1. wayland-protocol.c 核心通信层 位置： 不在weston项目里 图： 图来源 // code\\wayland\\build\\src\\wayland-protocol.c WL_EXPORT const struct wl_interface wl_surface_interface = { \"wl_surface\", 6, 11, wl_surface_requests, // 4, wl_surface_events, // }; static const struct wl_message wl_surface_requests[] = { // 【requests】 ---> { \"destroy\", \"\", wayland_types + 0 }, { \"attach\", \"?oii\", wayland_types + 58 }, { \"damage\", \"iiii\", wayland_types + 0 }, { \"frame\", \"n\", wayland_types + 61 }, { \"set_opaque_region\", \"?o\", wayland_types + 62 }, { \"set_input_region\", \"?o\", wayland_types + 63 }, { \"commit\", \"\", wayland_types + 0 }, // 【】 对应 wl_surface_commit { \"set_buffer_transform\", \"2i\", wayland_types + 0 }, { \"set_buffer_scale\", \"3i\", wayland_types + 0 }, { \"damage_buffer\", \"4iiii\", wayland_types + 0 }, { \"offset\", \"5ii\", wayland_types + 0 }, }; 同理，wl_shell_surface_requests[] ----> move、resize、set_toplevel........... static const struct wl_message wl_surface_events[] = { // 【events】 【requests】的 具体实现------------weston实现： // 代码搜索： surface_interface // compositor.c static const struct wl_surface_interface surface_interface = { surface_destroy, surface_attach, surface_damage, surface_frame, surface_set_opaque_region, surface_set_input_region, surface_commit, // 【】 最终走到这里 surface_set_buffer_transform, surface_set_buffer_scale, surface_damage_buffer, surface_offset, }; 结论： client的 commit直接提交给compositor了！！！！！ TODO: 1、底层原理，基于socket？ 底层原理：桥梁是如何搭建起来的？ 2、如何处理并发？ 4.2. 扩展协议 位置： 自然，位于Weston工程中 westonProject/weston/protocol/ ​ weston-desktop-shell.xml -TODO: 重要！！！！！，为啥要扩展协议？，即： wayland协议包括哪些？（为什么只包括这些？） 还需要哪些？（为什么需要这些？）、如何扩展？ 4.3. kwayland协议 kwin扩展的 https://zhuanlan.zhihu.com/p/690561669#:~:text=%E5%90%8C%E6%97%B6wayland%2Dscanner%E4%B9%9F%E9%9C%80%E8%A6%81%E5%9C%A8%E7%94%9F%E6%88%90Weston%E4%B8%AD%E7%9A%84 对应用接口 ----> kwayland client端接口 ----> kwayland server端接口 ----> 系统侧server能力 代码层面看结构： 头文件名：kwyland-server- ...................h --------------> 处于这个里面的是server侧的接口 需要找 4.4. 参考 TODO: https://blog.csdn.net/jinzhuojun/article/details/40264449 Wayland中的跨进程过程调用浅析 https://wayland.arktoria.org/2-protocol-design/high-level.html The Wayland Protocol 中文版 https://wayland.app/protocols/ A better way to read Wayland documentation 5. 配置(weston.ini) 所有的配置可选项： Ubuntu Manpage: weston.ini - configuration file for Weston - the reference Wayland compositor https://blog.guoxiaozhong.cn/archives/1705288043757 有多屏管理的 ！！！！！好文！！！ weston.ini配置 详细解释：https://www.mankier.com/5/weston.ini 实战： weston_config_section_get_bool(s, \"color-management\", &color_management, false); // //【】 add by cg //weston_config_section_get_bool(s, \"color-management\", //&color_management, true); 5.1. 大的ini配置流程： 读取ini配置（weston_compositor_init_config流程），给到weston_output、weston_compositor 在创建output流程里：gl_renderer_output_create()流程中可以拿到上述对象。。。部分数据封装给 gl_output_state 在render流程里（gl_renderer_repaint_output）： draw_paint_node，拿到 gl_output_state里的配置 5.2. 具体weston.ini 配置panel： [shell] panel-color=0x90ff0000 panel-position=none // -----> 没有panel 6. panel(状态栏) 6.1. panel的配置 详细流程： Weston中panel的设置过程 ​ Weston中panel的渲染过程 配置panel： [shell] panel-color=0x90ff0000 panel-position=none // -----> 没有panel // 或 panel-position=top 没有panel在 软件层的标志： static void parse_panel_position(struct desktop *desktop, struct weston_config_section *s) { char *position; desktop->want_panel = 1; weston_config_section_get_string(s, \"panel-position\", &position, \"top\"); if (strcmp(position, \"top\") == 0) { desktop->panel_position = WESTON_DESKTOP_SHELL_PANEL_POSITION_TOP; } else if (strcmp(position, \"bottom\") == 0) { desktop->panel_position = WESTON_DESKTOP_SHELL_PANEL_POSITION_BOTTOM; } else if (strcmp(position, \"left\") == 0) { desktop->panel_position = WESTON_DESKTOP_SHELL_PANEL_POSITION_LEFT; } else if (strcmp(position, \"right\") == 0) { desktop->panel_position = WESTON_DESKTOP_SHELL_PANEL_POSITION_RIGHT; } else { /* 'none' is valid here */ if (strcmp(position, \"none\") != 0) fprintf(stderr, \"Wrong panel position: %s\\n\", position); desktop->want_panel = 0; // 【】没有panel在 软件层的标志 } free(position); } 特别注意：没有panel时，desktop->panel_position 值没有赋值，为0。 即 WESTON_DESKTOP_SHELL_PANEL_POSITION_TOP 注意： panel有功能：显示应用图标，点击可以拉起应用？ 疑问，TODO： panel的结构是怎样的？ 代码结构、进程结构、显示结构 6.2. 结构：panel走的是GPU合成 支撑的功能是啥？ 7. 实操 结论： （1）显示在哪个环境下 = 哪个合成器合成 ​ 决定于环境变量： WAYLAND_DISPLAY=\"wayland-1\" （2） 哪里启动进程 与 显示在哪个环境下，完全没有关系！！！！！ -----------------> 技巧： 在 ubuntu的 gnome桌面环境下，启动 weston-simple-egl： 可以显示在gnome桌面里（gnome的合成） 也可以显示在 weston桌面里 （weston合成） 7.1. 虚拟机ubuntu安装weston桌面（走drm后端） -不优：因为会改变/usr/local/ 1、备份ubuntu（因为会改变系统） 2、编译 & 安装： rm -rf build/ && meson build/ -Dimage-webp=false -Dbackend-vnc=false && ninja -C build/ install 不指定 安装目录 --prefix=$HOME/weston_install 默认安装到系统目录下（/usr/local/） 3、在Ubuntu 终端内验证 /usr/local/下weston是否OK $ which weston $ weston 报错： $ weston weston: error while loading shared libraries: libweston-12.so.0: cannot open shared object file: No such file or directory 解决： $ export LD_LIBRARY_PATH=/usr/local/lib/x86_64-linux-gnu ----------------> ok, 但是weston作为桌面启动，需要加到 ~/.bashrc文件中 4、log out，选择weston作为后端 -----> 大概率黑屏 -解决黑屏： （1）先切换到虚拟终端Ctrl+Alt+F4 /F3, 手动起weston，查看报错： weston --backend=drm 或者 jouranctl 查看报错 （2）添加环境变量： // ~/.bashrc export LD_LIBRARY_PATH=/usr/local/lib/x86_64-linux-gnu ------------------> 已经验证OK，在虚拟终端内可以启动weston桌面 （3）验证OK后，切换图形界面 Ctrl+Alt+F2 ​ log out， 重新登录 ----------------> 还是不行，可能跟vnc有关？？？？ 7.2. 强制走drm后端-----启动weston_install/bin/weston 必要性： 走drm，才与真机最接近 结论： 对于Linux，drm有独占性 所以： 1、退出其他图形界面（其实不退也可以，似乎自动切换了） 2、在虚拟终端Ctrl+Alt+F4 /F3, 手动启动source env.sh && /home/chen/weston_install/bin/weston 优点： 1、不会改变ubuntu系统，极优 ​ 不用修改~/.bashrc环境变量 2、与在x11桌面环境下，运行的脚本&命令完全一致！！！！ 8. 一些名词 TODO ivi-shell https://wiki.automotivelinux.org/_media/agl-distro/agl_amm_xdg_support_a04.pdf ivi-shell类似移动操作系统环境，窗口的大小位置完全由系统来布局，ivi-shell可以自己配置窗口的层级，并且每个窗口都可以默认分配一个id号来管理，在窗口管理上更加友好一些，但是没办法支持xdg-shell的一些协议，比如窗口拖动，窗口resize，还有drag操作。 desktop-shell就是一个类似PC多窗口的环境，只有固定的层级，进行层级扩展比较麻烦，并且窗口没有id号，只能通过窗口的name来管理窗口，但是desktop-shell和xdg是完全兼容的，所以现在做法其实就是在desktop的基础上扩展一些窗口管理的功能，这样比较好的兼容QT和Web。 不改变wayland对生态的兼容性，这个是我们现在最基础原则， 不然摊子就太大了。除非后面我们有了自己的应用框架，再考虑随意改造。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/2_窗口系统/窗口管理器WMS.html":{"url":"0_图形系统/2_窗口系统/窗口管理器WMS.html","title":"窗口管理器WMS","keywords":"","body":"1. 目录2. 功能0层------抛开WMS不谈3. 窗口管理----WMS3.1. 功能（目的）0层：3.1.1. 基于功能需要的对外接口（重要）3.2. 结构0层图（基于功能0层的）3.3. 显示的生活化比喻3.4. 功能1的纵向：添加窗口(纵向主线) : WMS侧----how3.4.1. APP侧: 添加窗口WindowManagerImpl.addView(纵向主线) 流程:3.4.2. 目标功能1的补充：3.5. 功能1_2的纵向：申请surface流程----how3.6. 关于session桥梁???3.7. 次要：功能1_1窗口的系统动画（基于窗口管理的辅助功能）4. del:window体系-----APP侧4.1. Window（次要）4.2. 常见window（次要）4.2.1. window的分类：4.2.2. 窗口的次序4.2.3. 窗口的标志4.3. WindowManger4.3.1. 接口ViewManager4.4. ViewRootImpl4.5. 对应关系 windowManagerGlobal、windowManagerImpl、viewRootImpl4.6. view Tree--------window的填充+显示5. window体系-----系统侧5.1. 持有关系-----重要5.2. 继承关系----类似view的继承关系5.3. 系统侧window体系 与 APP侧 view体系5.4. 参考：6. 框架的背后7. 自然法则8. 一些额外的理解8.1. wms对于显示不是必须的9. 面试题：10. 参考： 目录 功能0层------抛开WMS不谈 窗口管理----WMS 功能（目的）0层： 基于功能需要的对外接口（重要） 结构0层图（基于功能0层的） 显示的生活化比喻 功能1的纵向：添加窗口(纵向主线) : WMS侧----how APP侧: 添加窗口WindowManagerImpl.addView(纵向主线) 流程: 目标功能1的补充： 目标1：如何确定窗口的大小和位置呢？ 功能1_2的纵向：申请surface流程----how 关于session桥梁??? 次要：功能1_1窗口的系统动画（基于窗口管理的辅助功能） del:window体系-----APP侧 Window（次要） 常见window（次要） window的分类： 窗口的次序 窗口的标志 WindowManger 接口ViewManager 添加窗口addView 流程: APP侧 更新窗口 updateViewLayout ViewRootImpl 对应关系 windowManagerGlobal、windowManagerImpl、viewRootImpl view Tree--------window的填充+显示 window体系-----系统侧 持有关系-----重要 继承关系----类似view的继承关系 系统侧window体系 与 APP侧 view体系 参考： 框架的背后 自然法则 一些额外的理解 wms对于显示不是必须的 面试题： 参考： 1. 目录 2. 功能0层------抛开WMS不谈 证明： 无论哪个系统，窗口管理 隶属于 图形系统 不得不包括： （1）窗口的层级管理 （2）窗口的大小管理 （3）窗口焦点管理 （4）窗口增删（改） 3. 窗口管理----WMS 3.1. 功能（目的）0层： 参考： 《深入理解Andriiod内核设计思想》 WMS P386 从I/O的角度来看，WMS系统的输入与输出： (1) 功能1： 窗口管理 （输出） WMS 是窗口的管理者，它负责窗口的启动、添加和删除。另外窗口的大小和层级也是由 WMS 进行管理的。 功能1_1 窗口动画 ---> add 和 remove的附属功能 窗口间进行切换时，使用动画可以显得更炫一些，窗口动画由 WMS 的动画子系统来负责，动画子系统的管理者为 WindowAnimator。 功能1_2：Surface 管理 （自然，包括申请） 窗口不具备绘制功能，因此每个窗口都需要有一块 Surface 来供自己绘制，为每个窗口分配 Surface 是由WMS 来完成的。 (2) 功能2：输入系统中转站 （输入） 通过对窗口的触摸从而产生触摸事件，InputManagerService(IMS) 会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS 是窗口的管理者，它作为输入系统的中转站再合适不过了。 ------> 记忆锚点：WMS对window的： 1、widow的添加 即管理：增删改........ 大小计算、层级计算 2、window的输入 3、window的输出 3.1.1. 基于功能需要的对外接口（重要） 见 《超级0层图: AMS-APP-WMS》： APP 与 WMS之间，自然： 1、先有APP-> WMS: IWindowManager 2、IWindowManager 创建 IwindowSession桥梁 3、IwindowSession桥梁 创建 IWindow桥梁 源码： interface IWindowManager { IWindowSession openSession() //创建session桥梁 } 关于session的认识，见下面： 3.2. 结构0层图（基于功能0层的） 见AMS: 《超级0层: AMS-APP-WMS》 即： https://kenttj.github.io/-book/coding/0_Andriod/0_AMS.html#:~:text=2.-,%E8%B6%85%E7%BA%A70%E5%B1%82%E5%9B%BE%3A%20AMS%2DAPP%2DWMS,-https%3A//ericchows.github 见： https://kenttj.github.io/-book/coding/0_Andriod/0_AMS.html#:~:text=https%3A//ericchows.github.io/Android%2DWindow%2DMechanism/ https://ericchows.github.io/Android-Window-Mechanism/ 其中桥梁： IWindowManager和IAcitivityManger 是一个自然的桥梁，客户端对wms和AMS的引用~~ ----》系统服务 开机初始化 注册的缘故 IwindowSession桥梁是 桥梁 IWindowManager创建的。为什么要这一条？ 3.3. 显示的生活化比喻 整个显示的生活化比喻，就像一出由N 个演员参与的话剧： SurfaceFlinger 是摄像机， WMS 是导演， ViewRoot 则是演员个体。 摄像机（ SurfaceFlinger）一一它负责客观地捕获当前的画面，然后真实地呈现给观众； 导演（ WMS ） 则会考虑到话剧的舞台效果和视觉美感， 如他需要根据实际情况来安排各个演员的排序站位， 谁在前谁在后， 都会影响到演出的“ 画面效果”与“ 剧情编排” 各个演员 ViewRoot ，则更多地取决于他们自身的条件与努力（各种view组合）。 正是通过这三者的“各司其职”，才能最终为观众呈现出一场美妙绝伦的“视觉盛宴” 3.4. 功能1的纵向：添加窗口(纵向主线) : WMS侧----how 3.4.1. APP侧: 添加窗口WindowManagerImpl.addView(纵向主线) 流程: 图：《超级0层图: AMS-APP-WMS》 -始点：------when Activity的Create、Resume生命周期同步过来。见《startApp：APP 侧执行 生命周期同步transaction 的执行execute(关键数据结构)》 Resume可见，performResumeActivity 是真正始点。见： 见《startApp：APP 侧执行 生命周期同步transaction 的执行execute(关键数据结构)》 -目标 ： WMS.addWindow侧添加窗口 基于目标，和： 【1】自然，先要建立桥梁： ViewRootImpl到WMS的桥梁、WMS到 ViewRootImpl的。为啥这样设计？见 AMS 【2】自然通过桥梁Session，addWindow 。自然会携带数据： window外数据：把window的参数（位置、大小）WindowManager.LayoutParams：app侧---》WMS侧 windown内数据：window的内容区域数据： mAttachInfo.mContentInsets：app侧---》WMS侧 基于目标【1】【2】，自然，之前 先把自己APP侧搞好： 【3】自然，要先把APP本地的Activity、window（WindowManagerImpl）、view树（DecorView）建好 ----> performLaunchActivity 流程。见《startApp》 【4】 自然，因为Resume才是可见的，所以， performResumeActivity 是 添加窗口addView的 始点 见《startApp》 基于目标【1】【2】，自然，APP侧弄好后，建立一些交互性的管理类，以及桥梁： 【5】 比如ViewRootImpl，必然在Reusme流程（与Wms交互流程）里新建的 基于目标【5】： 【6】自然，ViewRootImpl建立过程，会绑定DecorView，所以 Activity、window、viewTree三者绑定了 对应调用关系,，只看，不记忆： handleLaunchActivity---> performLaunchActivity --->【1】 创建Activity，并 attach() 创建window-----> onCreate -----> 【2】 setContentView ​ Activity.attach（创建Window） （创建DecorView，viewTree） handleResumeActivity ---> performResumeActivity -----> 总结： 只有Resume流程 是与WMS交互的 后续见《添加窗口(纵向主线) : WMS侧》 一些疑问，自然了： APP侧addView 变为 WMS.addWindow侧添加窗口 ---> 所以，addView是添加窗口 Activity.onStart ----> 所以onStart 根本不可见，不可交互 resume ----> 可见可交互的 todo： WindowManagerImpl 与 Global 是 一对多的关系。WindowManagerImpl 是Activity级别的？ 如何证明？ Global 负责交互了，必然是个进程单例，。自然 代码级证明： 3.4.2. 目标功能1的补充： 目标1：如何确定窗口的大小和位置呢？ 计算模型： APP侧初始值（输入） ----> 给到wms侧（输出）：遍历所有窗口，然后计算出最终 其中： 初始值（客户端程序员设置的） --------> viewRootImpl.relayoutWindow --------> wms计算 3.5. 功能1_2的纵向：申请surface流程----how 见： 《申请surface的流程(APP向surfaceFlinger)》 3.6. 关于session桥梁??? 基于什么目的？为甚要有？对总目的有什么用？ WMS实现侧： //Session.java //属性 mCanAddInternalSystemWindow -----> 是否能增加系统窗口 3.7. 次要：功能1_1窗口的系统动画（基于窗口管理的辅助功能） 4. del:window体系-----APP侧 4.1. Window（次要） 一句话的大致理解：（1、很重要 2、自己的话 与 官方的话 相互结合） Window: 是一个碗，view才是碗里的东西，具体的视图实体 （官方：在Android视图体系中Window就是一个窗口 的概念。Android中所有的视图都是依赖于Window显示 的） WindowManager: 对Window的管理， 自然，add、 remove、更新等。 WMS: 窗口的最终管理者, 它负责窗口的启动、 添加和删除, 另外窗口的大小和层级也是由WMS 进行管理 ------》 见WMS具体章节 window什么情况下更新？ --------> 横竖屏切换，dialog的window的大小改变 4.2. 常见window（次要） 4.2.1. window的分类： Application Window: Activity、Dialog就是一个典型的应用程序窗口。-----> 从用户角度，想表达：常用的窗口 Sub Window: 子窗口, 顾名思义, 它不能独立存在,需要附着在其他窗口才可以, PopupWindow就属于子窗口。 -----> 从用户角度，想表达：依附 System Window: Toast、输入法窗口、系统音量条窗口、 系统错误窗口都属于系统窗口。 -----> 从用户角度，想表达：在所有应用窗口之上 自然，子窗口不能独立存在 注意：Dialog是应用程序窗口，可以独立存在的。比如： ​ Application window 应用程序窗口: 数字1~99 Sub Window : 4.2.2. 窗口的次序 1、窗口分组（按照类型）： APPlication window、sub window、System Window 顺序 ----》 非常自然 系统窗口、子窗口、应用窗口---------> 比如： Activity（应用窗口）弹起popDialog（子窗口），popDialog内有个输入框，点击输入框 ，弹起输入法面板（系统窗口） 2、同组之间，通过Type值来标志前后关系 Type值越大，越在前 -----> 自然 注意：所以，并不是根据dialog弹出的先后顺序定的前后关系 TODO: Type值是如何确定的呢？ 自然，Dialog的 Type要比 Activity的大 --------> 同组 4.2.3. 窗口的标志 // 当 Window 可见时允许锁屏 FLAG_ALLOW_LOCK_WHILE_SCREEN_ON // Window 不能获得输入焦点,即不接受任何按键或按钮事件,例如该 Window上有EditView,点击 EditView 是不会弹出软键 盘的 // Window 范围外的事件依旧为原窗口处理; 例如点击该窗口外的view,依然会有响应。另外只要设置了此Flag,都将会启用 FLAG_NOT_TOUCH_MODAL FLAG_NOT_FOCUSABLE = 0x00000008; // 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window处理, 而自己只会处理 Window 区域内的触摸事件 // Window 之外的view 也是可以响应 touch 事件。 FLAG_NOT_TOUCH_MODAL = 0x00000020; // 设置了该Flag,表示该 Window将不会接受任何 touch 事件,例如点击该 Window 不会有响应,只会传给下面有聚焦的窗口。 FLAG_NOT_TOUCHABLE; -------》 例子：ToastDialog // 只要 Window 可见时屏幕就会一直亮着 FLAG_KEEP_SCREEN_ON // 允许 Window 超过屏幕之外 FLAG_LAYOUT_NO_LIMITS // 当用户的脸贴近屏幕时(比如打电话) 不会去响应此事件 FLAG_IGNORE CHEEK PRESSES; // 窗口可以在锁屏的 Window 之上显示,使用 Activity#setShowWhenLocked(boolean) 方法代替 FLAG_SHOW_WHEN_LOCKED = 0x00080000; 4.3. WindowManger 窗口的操作类、实际上是接口类（addView、removeView、updateViewLayout），具体实现类是WindowMangerImpl 处于应用侧（进程） 《xiangxue》 为啥是桥接模式呢？ 桥：Window-WindowManager 好处：上层抽象进行关联，下层实现可以独立发展（下层可以灵活变动） 4.3.1. 接口ViewManager addView、removeView、updateViewLayout -------》自然，ViewGroup 需要这三个 为啥window需要呢？ 添加窗口addView 流程: APP侧 见 wms中 添加窗口流程 更新窗口 updateViewLayout 场景： 横竖屏切换 最终还是会走到，view刷新绘制流程----> 不得不 4.4. ViewRootImpl 1、管理view树： 2、触发view的绘制流程（最终目标：绘制，具体铺垫：测量、布局和绘制） 触发点：自然，viewRootImpl的performTraversales() 方法（最开始触发是 vsync信号, 这个方法是刷新、绘制的入口） ----> 自然，窗口的更新updateViewLayout 也会走到 performTraversales() 3、与wms交互 ----》 记忆图：《超级0层图: AMS-APP-WMS》 4.5. 对应关系 windowManagerGlobal、windowManagerImpl、viewRootImpl windowManagerImpl ----------acitvity级别（管理window，自然） windowManagerGlobal---------单例 （进程级别） viewRootImpl-----------window级别 推论： 1、windowManagerImpl 与 viewRootImpl数量基本一样 ​ 2、 多转一，再转多：通过decorView 建立映射关系 4.6. view Tree--------window的填充+显示 见 5. window体系-----系统侧 WindowContainer 5.1. 持有关系-----重要 https://blog.csdn.net/q1165328963/article/details/127746382?spm=1001.2101.3001.6650.9&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-9-127746382-blog-130015066.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-9-127746382-blog-130015066.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=10 参考： https://blog.csdn.net/lizhenjun114/article/details/130015066?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-130015066-blog-129101781.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-130015066-blog-129101781.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=8 5.2. 继承关系----类似view的继承关系 5.3. 系统侧window体系 与 APP侧 view体系 系统侧window体系 与 APP侧 view体系 极其相似： 如何认识view体系，就如何认识window体系 1、都是树结构： window树 、 view树 2、基于树结构： 有view的布局 relayout ​ 同样，window有布局： relayoutWindow 3、基于树结构： ​ 树的节点： windowContainer(集合)、viewGroup(集合) ​ 树根：windowState、 view 对比下的认知： view有测量measure，系统侧 window有测量嘛？ TODO： 系统侧window数据何时同步给 应用侧的？ - 5.4. 参考： https://blog.csdn.net/learnframework/article/details/129101781 https://blog.csdn.net/lizhenjun114/article/details/130015066?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-130015066-blog-129101781.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-130015066-blog-129101781.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=8 displayArea学习 6. 框架的背后 7. 自然法则 8. 一些额外的理解 8.1. wms对于显示不是必须的 从生活化比喻中看必然性（wms是导演、surfaceFlinger是摄像机、viewROOT是演员）： WMS不是必须的，窗口不是必须的，viewROOT也不是必须的 只有surfaceFlinger摄像机是必须的 例子： 参考： 《深入理解Andriiod内核设计思想》 WMS P386 另一个例子，结论： 仪表域 不需要 交互，也需要窗口管理 ------------> 所以，仪表域可以直接怼到drm（绕过窗口管理） 9. 面试题： 1、窗口的次序（见上） 2、子线程中 new 一个 Dialog，出现Token报错 Unable to add window token null is not valid is your activity running https://blog.csdn.net/meixi_android/article/details/106380069?spm=1001.2101.3001.6650.12&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-12-106380069-blog-78530491.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-12-106380069-blog-78530491.pc_relevant_recovery_v2&utm_relevant_index=13 10. 参考： console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/3_Display系统/":{"url":"0_图形系统/3_Display系统/","title":"3_Display系统","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/3_Display系统/Display系统.html":{"url":"0_图形系统/3_Display系统/Display系统.html","title":"Display系统","keywords":"","body":"1. Display1. Display 补充图：P314 两种 本地窗口（承载窗口的绘制功能）： 分别承载 APP侧的render，以及 sf的 合成结果 surface承载 FramebufferNativeWindow 所以，从opengl角度来看： APP 与 sf 没有任何区别，都是opengl的使用者（都是应用） SurfaceFlinger详解 -----------> 好文!!!!!!!! GUI显示系统之SurfaceFlinger---章节目录 系列文章 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/3_Display系统/DRM.html":{"url":"0_图形系统/3_Display系统/DRM.html","title":"DRM","keywords":"","body":"1. 目录2. why-从功能0层角度，DRM的作用是啥？3. what--基于why的what4. drm ------ 待整理4.1.1. 一些图4.1.2. 参考：5. 好文5.1. Drm 0层链路 目录 why-从功能0层角度，DRM的作用是啥？ what--基于why的what drm ------ 待整理 一些图 参考： 好文 Drm 0层链路 1. 目录 2. why-从功能0层角度，DRM的作用是啥？ 3. what--基于why的what 必然存在硬件图层（plane）： DRM_PLANE_TYPE_PRIMARY：主要图层，通常用于仅支持RGB格式的简单图层 DRM_PLANE_TYPE_OVERLAY：叠加图层，视频图层（YUV格式的）-----------> 现在也支持RGB格式的了，与PRIMARY无异 -------->了！！意味着 GPU实际上可以合成两个硬件层！！！！ DRM_PLANE_TYPE_CURSOR：光标图层，用于显示鼠标 本质上说，plane是硬件抽象------------- 功能： 承载硬件显示能力（对软件侧呈现） 图 4. drm ------ 待整理 4.1.1. 一些图 0层物理图 图片来源 图来源 TODO: FrameBuffer是 plane级别的？？？？？？？？？？ 0层调用图 图来源： 图不好，上下关系不对 drm框架分析---drm_mode_addfb2 drm_mode_addfb2调用流程： 图来源 4.1.2. 参考： https://download.csdn.net/blog/column/11175480/133747645 KWin、libdrm、DRM从上到下全过程 —— drmModeAddFBxxx（1） LCD DRM驱动框架分析一 5. 好文 https://mp.weixin.qq.com/s?__biz=MzA5NDE4OTkwMA==&mid=2247530526&idx=3&sn=ee61e7d090f02249c20ec0437dac031b&chksm=9050583da727d12be8b47ea5caed8cb327f65eedbd595ec60fff9b4e2ab559eb27e9b8719d9d&scene=27 【科普】linux驱动系列学习之DRM 各种概念： Framebuffer、CRTC，ENCODER，CONNECTOR，PLANE，VBLANK，property Framebuffer： 一个图层，display级别 CRTC： DRM（一）：什么是DRM-CSDN博客 5.1. Drm 0层链路 好文： Linux显示（三）：DRM子系统(以及LCDC/Panel/Backlight驱动) 系列文章 https://download.csdn.net/blog/column/11305753/120255137 图显系统DRM CRTC完全解析 图 图 https://blog.csdn.net/u012839187/article/details/106469038 display:weston渲染流程:commit 很详细！！ 非常好非常好的DRM系列文章：何小龙 最简单的DRM应用程序 （page-flip） 最简单的DRM应用程序 （plane-test） 结论： https://blog.csdn.net/hexiaolong2009/article/details/84934294 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/3_Display系统/sf特效.html":{"url":"0_图形系统/3_Display系统/sf特效.html","title":"sf特效","keywords":"","body":"1. 目录2. 窗口的阴影和圆角2.1. 对应的shader2.1.1. 方法一 安卓的shader：2.1.2. 主要流程：2.1.3. 方法二：2.1.4. weston 的shader.h 非 shadow？2.1.5. weston的shadow 与 from_blend_to_output关系2.2. App client侧画圆角&阴影：3. 高斯模糊3.1. 功能角度3.2. 应用层接口3.3. 功能实现----高斯模糊代码大纲：3.4. 待整理：高斯模糊3.5. shader3.6. 高斯模糊的数学原理3.7. TODO: how---------合成的承载（buffer）3.8. 性能4. TODO:逆向5. TODO: 动画与sf 目录 窗口的阴影和圆角 对应的shader 方法一 安卓的shader： 主要流程： 方法二： weston 的shader.h 非 shadow？ weston的shadow 与 from_blend_to_output关系 App client侧画圆角&阴影： 高斯模糊 功能角度 应用层接口 功能实现----高斯模糊代码大纲： 待整理：高斯模糊 shader 高斯模糊的数学原理 TODO: how---------合成的承载（buffer） 性能 TODO:逆向 TODO: 动画与sf 1. 目录 2. 窗口的阴影和圆角 阴影： SurfaceControl.setGlobalShadowSettings(@Size(4) float[] ambientColor, @Size(4) float[] spotColor, float lightPosY, float lightPosZ, float lightRadius) // 信息流 SurfaceControl.setShadowRadius --->nativeSetShadowRadius ---> SurfaceComposerClient::Transaction::setShadowRadius struct layer_state_t {shadowRadius, cornerRadius........} //【】 目前还是应用进程 -----> TODO: 最终生效给谁了？如何流向sf的？ 安卓控件阴影： Android开发中阴影效果的实现 - 掘金 (juejin.cn) --------> TODO: 画在哪个地方？ Android显示系统——Transaction基础功能： TODO: Transaction是应用系统框架层 与 SurfaceFlinger交流的方式之一 ​ Android显示系统——Transaction基础功能 TODO: 了解surfaceControl所有接口 SurfaceComposerClient_cpp: sf 在用户侧的代理 SurfaceControl（client与sf的桥梁）接口： captureLayers 截图 setCornerRadius 设置圆角 setGlobalShadowSettings 设置阴影 其中，事务（元）Transaction： （1）事务元，是原操作，setXXX操作 （2）多个原操作，之后，一笔commit才生效 t.apply() setCornerRadius ->nativeSetCornerRadius ->SurfaceComposerClient::Transaction 获取对应的 layer_state_t。设置属性 -> s->cornerRadius = cornerRadius 生效在apply()后： t.apply() -> SurfaceComposerClient::Transaction::apply ->ISurfaceComposer->setTransactionState ------------跨进程------------------- -> sf->setTransactionState queueTransaction(state); // sf 缓存事务 事务流转图： 图来源 下一帧vsync后： SurfaceFlinger处理事务（onMessageInvalidate函数）： 1、处理事务 2、自然，刷新图像 处理事务流程图： 图来源 图像合成并刷新图： 图 总之， 设置圆角：一行代码： GLESRenderEngine::drawMesh fragmentShader里面根据圆角的半径计算将在圆角之外的部分的alpha设为0使之完全透明： 位置：String8 ProgramCache::generateFragmentShader(const Key& needs) { gl_FragColor.a *= applyCornerRadius(outCropCoords); // 【】夹子函数，超过设置透明 } 参考：圆角绘制 - 安卓R TODO: sf系列文章 显示驱动系列文章 Bpxxx/Bnxxx： https://blog.csdn.net/fengchaochao123/article/details/134020217?spm=1001.2014.3001.5502#:~:text=%E6%A2%B3%E7%90%86%E4%BA%86%E4%B8%80%E4%B8%8B-,waitForService%E7%9A%84%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6,-%EF%BC%8C%E5%92%8CBpxxx/Bnxxx 系列好文： 安卓Framework 录屏流程 - 安卓R 转屏动画 - 安卓R 过渡动画 - 安卓R 2.1. 对应的shader shader结构： 级别：surfaceFlinger级别的 （自然：生成时机：一次性生成） 使用时机： 有圆角 & 有变化 & 每一帧 shader具体内容详解： 2.1.1. 方法一 安卓的shader： 1、VertexShader attribute lowp vec4 cropCoords; // 入参： 裁剪坐标， TODO: 来源哪里？？？ varying lowp vec2 outCropCoords; // 出参： 将要传递给 Fragment的 裁剪坐标 attribute vec4 position; // 【】入参：任意点坐标（自带） uniform mat4 projection; // 入参： 顶点变化矩阵，来源cpp uniform mat4 texture; void main(void) { gl_Position = projection * position; outCropCoords = cropCoords.st; // 【】 圆角相关的，即裁剪部分（st是水平和垂直坐标） } 信息流： cpp任意点坐标position --------> 变换后坐标 gl_Position cpp 顶点变换矩阵 传递给 Fragment的 裁剪坐标 2、FragmentShader precision mediump float; // 浮点运算的精度为中等 uniform float cornerRadius; // 入参：圆角半径，来源cpp uniform vec2 cropCenter; // 入参：裁剪中心，来源cpp varying vec2 outCropCoords; // 入参：裁剪坐标，来源 VertexShader /** * This function takes the current crop coordinates and calculates an alpha value based * on the corner radius and distance from the crop center. */ float applyCornerRadius(vec2 cropCoords) { vec2 position = cropCoords - cropCenter; // 基于圆心的坐标 // Scale down the dist vector here, as otherwise large corner // radii can cause floating point issues when computing the norm vec2 dist = (abs(position) - cropCenter + vec2(cornerRadius)) / 16.0; // 【】 TODO:abs(position)是一个二维的，分量求绝对值 // Once we've found the norm, then scale back up. float plane = length(max(dist, vec2(0.0))) * 16.0; return 1.0 - clamp(plane - cornerRadius, 0.0, 1.0); } uniform vec4 color; // 入参： 主要设置color的a值。。。。。这里没看懂！！！ void main(void) { gl_FragColor.rgb = color.rgb; gl_FragColor.a = 1.0; gl_FragColor *= color.a; // c乘以 gl_FragColor *= vec4(applyCornerRadius(outCropCoords)); // 乘以 1 或 0 -----> 0即被裁剪！！！ } 关于的使用：%3B) Shader中使用距离函数（Distance Function）绘制二维图形 2.1.2. 主要流程： 参考： 圆角绘制 - 安卓R status_t GLESRenderEngine::drawLayers(const DisplaySettings& display, const std::vector& layers, ANativeWindowBuffer* const buffer, const bool useFramebufferCache, base::unique_fd&& bufferFence, base::unique_fd* drawFence) { ...... for (auto const layer : layers) { // 遍历layers ...... // We only want to do a special handling for rounded corners when having rounded corners // is the only reason it needs to turn on blending, otherwise, we handle it like the // usual way since it needs to turn on blending anyway. else if (layer->geometry.roundedCornersRadius > 0.0 && color.a >= 1.0f && isOpaque) { handleRoundedCorners(display, *layer, mesh); } else { drawMesh(mesh); } ...... } ...... } 2.1.3. 方法二： 2.1.4. weston 的shader.h 非 shadow？ 核心一行代码： gl_renderer_use_program vertex-shader.glsl /* * Copyright 2012 Intel Corporation * Copyright 2015,2019 Collabora, Ltd. * Copyright 2016 NVIDIA Corporation * * Permission is hereby granted, free of charge, to any person obtaining * a copy of this software and associated documentation files (the * \"Software\"), to deal in the Software without restriction, including * without limitation the rights to use, copy, modify, merge, publish, * distribute, sublicense, and/or sell copies of the Software, and to * permit persons to whom the Software is furnished to do so, subject to * the following conditions: * * The above copyright notice and this permission notice (including the * next paragraph) shall be included in all copies or substantial * portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */ /* enum gl_shader_texcoord_input */ #define SHADER_TEXCOORD_INPUT_ATTRIB 0 #define SHADER_TEXCOORD_INPUT_SURFACE 1 /* Always use high-precision for vertex calculations */ precision highp float; #ifdef GL_FRAGMENT_PRECISION_HIGH #define FRAG_PRECISION highp #else #define FRAG_PRECISION mediump #endif uniform mat4 proj; uniform mat4 surface_to_buffer; attribute vec2 position; attribute vec2 texcoord; /* Match the varying precision to the fragment shader */ varying FRAG_PRECISION vec2 v_texcoord; void main() { gl_Position = proj * vec4(position, 0.0, 1.0); #if DEF_TEXCOORD_INPUT == SHADER_TEXCOORD_INPUT_ATTRIB v_texcoord = texcoord; #elif DEF_TEXCOORD_INPUT == SHADER_TEXCOORD_INPUT_SURFACE v_texcoord = vec2(surface_to_buffer * vec4(position, 0.0, 1.0)); #endif } fragmentShader.glsl /* * Copyright 2012 Intel Corporation * Copyright 2015,2019,2021 Collabora, Ltd. * Copyright 2016 NVIDIA Corporation // -------> NVIDIA！！！！！！！ * Copyright 2021 Advanced Micro Devices, Inc. * * Permission is hereby granted, free of charge, to any person obtaining * a copy of this software and associated documentation files (the * \"Software\"), to deal in the Software without restriction, including * without limitation the rights to use, copy, modify, merge, publish, * distribute, sublicense, and/or sell copies of the Software, and to * permit persons to whom the Software is furnished to do so, subject to * the following conditions: * * The above copyright notice and this permission notice (including the * next paragraph) shall be included in all copies or substantial * portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */ /* GLSL version 1.00 ES, defined in gl-shaders.c */ /* For annotating shader compile-time constant arguments */ #define compile_const const /* * Enumeration of shader variants, must match enum gl_shader_texture_variant. */ #define SHADER_VARIANT_RGBX 1 #define SHADER_VARIANT_RGBA 2 #define SHADER_VARIANT_Y_U_V 3 #define SHADER_VARIANT_Y_UV 4 #define SHADER_VARIANT_Y_XUXV 5 #define SHADER_VARIANT_XYUV 6 #define SHADER_VARIANT_SOLID 7 #define SHADER_VARIANT_EXTERNAL 8 /* enum gl_shader_color_curve */ #define SHADER_COLOR_CURVE_IDENTITY 0 #define SHADER_COLOR_CURVE_LUT_3x1D 1 #define SHADER_COLOR_CURVE_LINPOW 2 #define SHADER_COLOR_CURVE_POWLIN 3 /* enum gl_shader_color_mapping */ #define SHADER_COLOR_MAPPING_IDENTITY 0 #define SHADER_COLOR_MAPPING_3DLUT 1 #define SHADER_COLOR_MAPPING_MATRIX 2 #if DEF_VARIANT == SHADER_VARIANT_EXTERNAL #extension GL_OES_EGL_image_external : require #endif #if DEF_COLOR_MAPPING == SHADER_COLOR_MAPPING_3DLUT #extension GL_OES_texture_3D : require #endif #ifdef GL_FRAGMENT_PRECISION_HIGH #define HIGHPRECISION highp #else #define HIGHPRECISION mediump #endif precision HIGHPRECISION float; /* * These undeclared identifiers will be #defined by a runtime generated code * snippet. */ compile_const int c_variant = DEF_VARIANT; compile_const bool c_input_is_premult = DEF_INPUT_IS_PREMULT; compile_const bool c_green_tint = DEF_GREEN_TINT; compile_const int c_color_pre_curve = DEF_COLOR_PRE_CURVE; compile_const int c_color_mapping = DEF_COLOR_MAPPING; compile_const int c_color_post_curve = DEF_COLOR_POST_CURVE; compile_const bool c_need_color_pipeline = c_color_pre_curve != SHADER_COLOR_CURVE_IDENTITY || c_color_mapping != SHADER_COLOR_MAPPING_IDENTITY || c_color_post_curve != SHADER_COLOR_CURVE_IDENTITY; vec yuva2rgba(vec4 yuva) { vec4 color_out; float Y, su, sv; /* ITU-R BT.601 & BT.709 quantization (limited range) */ /* Y = 255/219 * (x - 16/256) */ Y = 1.16438356 * (yuva.x - 0.0625); /* Remove offset 128/256, but the 255/224 multiplier comes later */ su = yuva.y - 0.5; sv = yuva.z - 0.5; /* * ITU-R BT.601 encoding coefficients (inverse), with the * 255/224 limited range multiplier already included in the * factors for su (Cb) and sv (Cr). */ color_out.r = Y + 1.59602678 * sv; color_out.g = Y - 0.39176229 * su - 0.81296764 * sv; color_out.b = Y + 2.01723214 * su; color_out.a = yuva.w; return color_out; } #if DEF_VARIANT == SHADER_VARIANT_EXTERNAL uniform samplerExternalOES tex; #else uniform sampler2D tex; #endif varying HIGHPRECISION vec2 v_texcoord; uniform sampler2D tex1; uniform sampler2D tex2; uniform float view_alpha; uniform vec4 unicolor; #define MAX_CURVE_PARAMS 10 #define MAX_CURVESET_PARAMS (MAX_CURVE_PARAMS * 3) uniform HIGHPRECISION sampler2D color_pre_curve_lut_2d; uniform HIGHPRECISION vec2 color_pre_curve_lut_scale_offset; uniform HIGHPRECISION float color_pre_curve_params[MAX_CURVESET_PARAMS]; uniform bool color_pre_curve_clamped_input; uniform HIGHPRECISION sampler2D color_post_curve_lut_2d; uniform HIGHPRECISION vec2 color_post_curve_lut_scale_offset; uniform HIGHPRECISION float color_post_curve_params[MAX_CURVESET_PARAMS]; uniform bool color_post_curve_clamped_input; #if DEF_COLOR_MAPPING == SHADER_COLOR_MAPPING_3DLUT uniform HIGHPRECISION sampler3D color_mapping_lut_3d; uniform HIGHPRECISION vec2 color_mapping_lut_scale_offset; #endif uniform HIGHPRECISION mat3 color_mapping_matrix; vec4 sample_input_texture() { vec4 yuva = vec4(0.0, 0.0, 0.0, 1.0); /* Producing RGBA directly */ if (c_variant == SHADER_VARIANT_SOLID) return unicolor; if (c_variant == SHADER_VARIANT_RGBA || c_variant == SHADER_VARIANT_EXTERNAL) { return texture2D(tex, v_texcoord); } if (c_variant == SHADER_VARIANT_RGBX) return vec4(texture2D(tex, v_texcoord).rgb, 1.0); /* Requires conversion to RGBA */ if (c_variant == SHADER_VARIANT_Y_U_V) { yuva.x = texture2D(tex, v_texcoord).x; yuva.y = texture2D(tex1, v_texcoord).x; yuva.z = texture2D(tex2, v_texcoord).x; } else if (c_variant == SHADER_VARIANT_Y_UV) { yuva.x = texture2D(tex, v_texcoord).x; yuva.yz = texture2D(tex1, v_texcoord).rg; } else if (c_variant == SHADER_VARIANT_Y_XUXV) { yuva.x = texture2D(tex, v_texcoord).x; yuva.yz = texture2D(tex1, v_texcoord).ga; } else if (c_variant == SHADER_VARIANT_XYUV) { yuva.xyz = texture2D(tex, v_texcoord).bgr; } else { /* Never reached, bad variant value. */ return vec4(1.0, 0.3, 1.0, 1.0); } return yuva2rgba(yuva); } /* * Sample a 1D LUT which is a single row of a 2D texture. The 2D texture has * four rows so that the centers of texels have precise y-coordinates. * * Texture coordinates go from 0.0 to 1.0 corresponding to texture edges. * When we do LUT look-ups with linear filtering, the correct range to sample * from is not from edge to edge, but center of first texel to center of last * texel. This follows because with LUTs, you have the exact end points given, * you never extrapolate but only interpolate. * The scale and offset are precomputed to achieve this mapping. */ float sample_lut_1d(HIGHPRECISION sampler2D lut, vec2 scale_offset, float x, compile_const int row) { float tx = x * scale_offset.s + scale_offset.t; float ty = (float(row) + 0.5) / 4.0; return texture2D(lut, vec2(tx, ty)).x; } vec3 sample_lut_3x1d(HIGHPRECISION sampler2D lut, vec2 scale_offset, vec3 color) { return vec3(sample_lut_1d(lut, scale_offset, color.r, 0), sample_lut_1d(lut, scale_offset, color.g, 1), sample_lut_1d(lut, scale_offset, color.b, 2)); } vec3 lut_texcoord(vec3 pos, vec2 scale_offset) { return pos * scale_offset.s + scale_offset.t; } float linpow(float x, float g, float a, float b, float c, float d) { /* See WESTON_COLOR_CURVE_TYPE_LINPOW for details about LINPOW. */ if (x >= d) return pow((a * x) + b, g); return c * x; } float sample_linpow(float params[MAX_CURVESET_PARAMS], bool must_clamp, float x, compile_const int color_channel) { float g, a, b, c, d; /* * For each color channel we have MAX_CURVE_PARAMS parameters. * The parameters for the three curves are stored in RGB order. */ g = params[0 + color_channel * MAX_CURVE_PARAMS]; a = params[1 + color_channel * MAX_CURVE_PARAMS]; b = params[2 + color_channel * MAX_CURVE_PARAMS]; c = params[3 + color_channel * MAX_CURVE_PARAMS]; d = params[4 + color_channel * MAX_CURVE_PARAMS]; if (must_clamp) x = clamp(x, 0.0, 1.0); /* We use mirroring for negative input values. */ if (x = d) return a * pow(x, g) + b; return c * x; } float sample_powlin(float params[MAX_CURVESET_PARAMS], bool must_clamp, float x, compile_const int color_channel) { float g, a, b, c, d; /* * For each color channel we have MAX_CURVE_PARAMS parameters. * The parameters for the three curves are stored in RGB order. */ g = params[0 + color_channel * MAX_CURVE_PARAMS]; a = params[1 + color_channel * MAX_CURVE_PARAMS]; b = params[2 + color_channel * MAX_CURVE_PARAMS]; c = params[3 + color_channel * MAX_CURVE_PARAMS]; d = params[4 + color_channel * MAX_CURVE_PARAMS]; if (must_clamp) x = clamp(x, 0.0, 1.0); /* We use mirroring for negative input values. */ if (x 2.1.5. weston的shadow 与 from_blend_to_output关系 为啥要求 from_blend_to_output？--------> 通过获取 颜色转换： struct weston_color_transform { struct weston_color_manager *cm; int ref_count; uint32_t id; /* For debug */ /* for renderer or backend to attach their own cached objects */ struct wl_signal destroy_signal; /* Color transform is the series of steps: */ /** Step 1: color model change */ /* YCbCr→RGB conversion, but that is done elsewhere */ /** Step 2: color curve before color mapping */ struct weston_color_curve pre_curve; /** Step 3: color mapping */ struct weston_color_mapping mapping; /** Step 4: color curve after color mapping */ struct weston_color_curve post_curve; }; 2.2. App client侧画圆角&阴影： Google package com.google.android.material.shadow; public final class ShadowRenderer { public final void drawCornerShadow(Canvas canvas, Matrix matrix, RectF rectF, int i, float f, float f2) { boolean z; if (f2 3. 高斯模糊 3.1. 功能角度 高斯模糊的功能： 使某个窗口的外部背景 模糊 ------> 不是内部背景！自然，应用自己不能做 产品视角：模糊非焦点区域，突出焦点 物理角度： 保持自我，模糊他人 -------> 类似于Dialog的Dim层（实际上就是用了高斯模糊） ​ 自我：可以透明，也可以不透明 3.2. 应用层接口 two types for blur： https://source.android.com/docs/core/display/window-blurs 官网解释 Background blur： ​ 对应接口： SurfaceControl.Transaction.setBackgroundBlurRadius(dSurfaceControl.Transaction, blurRadius); Window.setBackgroundBlurRadius Blur behind： ​ 对应接口：WindowManager.LayoutParams.setBlurBehindRadius( int blurBehindRadius) SurfaceControl.Transaction.setBackgroundBlurRadius 接口： TODO: 图片 桌面上滑 流程： launcher3 调用了 Transaction setBackgroundBlurRadius，不断改变模糊半径 开关： vi /system/build.prop Transaction setBackgroundBlurRadius(SurfaceControl sc, int radius) 全局开关（Android S ）： // 需要打开ro.surface_flinger.supports_background_blur 才能使用模糊效果，默认是关闭的 property_get(\"ro.surface_flinger.supports_background_blur\", value, \"0\"); bool supportsBlurs = atoi(value); mSupportsBlur = supportsBlurs; 安卓的 模糊特性: 1、是窗口级的。跟着窗口走的 2、模糊的是背后，而不是自己的窗口 应用角度 使用例子：Launcher3 的模糊效果 Android12 弹窗外部、 内部高斯模糊效果实现 ------> 参考实现！！！ 快速测试场景： 1、AOSP原生手机，桌面上，向上滑动，出现下拉菜单：过程中会出现高斯模糊 2、下拉菜单也是有状态栏 https://blog.csdn.net/learnframework/article/details/130767893 观测日志： GLESRenderEngine::drawLayersInternal, blurLayersSize: 1 规定： 所有的功能，必须有简单的测试demo 必须写清楚测试方法 3.3. 功能实现----高斯模糊代码大纲： 参考： aosp11/12/13 壁纸高斯模糊，毛玻璃SurfaceFlinger层面原理-第二节千里马framework实战_千里马aosp-CSDN博客 总体依附于合成流程： └─ GLESRenderEngine::drawLayersInternal // 自下而上 ├─ for (const auto& layer : layers) 遍历出所有的blurLayers 即有backgroundBlurRadius ├─ . ├─ ---------------------上屏or 临时mCompositionFbo------------------------------- ├─ if (blurLayersSize > 0) 时：【】 关键行，一直绘制到mCompositionFbo里，没有上屏！！！！直到条件【if(blurLayersSize == 0)只有一层需要高斯模糊 】 │ └─ mBlurFilter->setAsDrawTarget(display, blurLayers.front().backgroundBlurRadius) │ └─ mCompositionFbo.bind(); ├─ if(blurLayersSize == 0) 没有需要高斯模糊 │ ├─ 自然，上屏：fbo = std::make_unique 0 && blurLayers.front() == layer) { // 当前遍历的layer是 blurLayers ├─ blurLayers.pop_front(); ├─ ---------------------上屏or 临时mCompositionFbo------------------------------- ├─ if (blurLayersSize > 0) 时：【】 关键行，一直绘制到mCompositionFbo里，没有上屏！！！！！！！！！ │ └─ mBlurFilter->setAsDrawTarget(display, blurLayers.front().backgroundBlurRadius) │ └─ mCompositionFbo.bind(); ├─ 【if(blurLayersSize == 0) 只有一层需要高斯模糊 】 // 逐渐减少 blurLayersSize │ ├─ 自然，上屏：fbo = std::make_uniqueprepare()】--------产生真正的高斯模糊mBlurProgram---------- │ ├─ --------------在ping上贴原始图？？？？---------------------------- │ ├─ mBlurProgram.useProgram(); │ ├─ glActiveTexture(GL_TEXTURE0); │ ├─ glUniform1i(mBTextureLoc, 0); │ ├─ glBindTexture(GL_TEXTURE_2D, mCompositionFbo.getTextureName()); // -------> TODO: mCompositionFbo 是底下所有layer合成的效果总和 │ ├─ glUniform2f(mBOffsetLoc, stepX, stepY); │ ├─ glViewport(0, 0, mPingFbo.getBufferWidth(), mPingFbo.getBufferHeight()); │ ├─ mPingFbo.bind(); │ ├─ BlurFilter::drawMesh(mBUvLoc, mBPosLoc) // 参数是UV信息和位置信息 │ │ ├─ glEnableVertexAttribArray(uv); │ │ ├─ glEnableVertexAttribArray(position); │ │ ├─ mMeshBuffer.bind(); │ │ ├─ glBindBuffer(GL_ARRAY_BUFFER, mBufferName); │ │ ├─ glVertexAttribPointer // 顶点属性 │ │ ├─ mMeshBuffer.unbind(); │ │ └─ glDrawArrays(GL_TRIANGLES, 0 /* first */, 3 /* count */); // 真正的draw │ ├─ ------------pingpong流程----------------------------- │ ├─ GLFramebuffer* read = &mPingFbo; // 初始化read和draw │ ├─ GLFramebuffer* draw = &mPongFbo; │ ├─ glViewport(0, 0, draw->getBufferWidth(), draw->getBufferHeight()); // TODO:视口为啥是？ │ ├─ 步进迭代for (auto i = 1; i bind(); // 绑定draw的buffer,TODO: 没有清？？？？？？？？？？！！！！！！！！！！！ │ │ ├─ glBindTexture(GL_TEXTURE_2D, read->getTextureName()); // texture, 自然绑定read的 │ │ ├─ glUniform2f(mBOffsetLoc, stepX * i, stepY * i); // 给GPU程序设置步长 │ │ ├─ BlurFilter::drawMesh(mBUvLoc, mBPosLoc); // 【】draw │ │ └─ 交换read和 draw的buffer │ └─ mLastDrawTarget = read // 【】 最终模糊的结果！！！ ├─ if (blurLayers.size() == 0) { //【】 底下没有其他需要模糊的layer了 │ ├─ 自然，fbo = std::make_unique 1)】关键行 blurLayersSize > 1 当底下没有 需要模糊的了，才上屏！ ├─ mMixProgram.useProgram(); // 自然mMixProgram ├─ glUniform1f(mMMixLoc, mix); ├─ glActiveTexture(GL_TEXTURE0); // 激活TEXTURE0 ├─ glBindTexture(GL_TEXTURE_2D, mLastDrawTarget->getTextureName()); // 把模糊结果和TEXTURE0 绑定 ├─ glUniform1i(mMTextureLoc, 0); ├─ glActiveTexture(GL_TEXTURE1); // 激活TEXTURE1 ├─ glBindTexture(GL_TEXTURE_2D, mCompositionFbo.getTextureName()); // ├─ glUniform1i(mMCompositionTextureLoc, 1); ├─ drawMesh(mMUvLoc, mMPosLoc); ├─ ------------清理操作----------------- ├─ glUseProgram(0); // 反激活 └─ glActiveTexture(GL_TEXTURE0); //清理操作，确保下次绑定纹理时从 GL_TEXTURE0 开始 以上逻辑核心只有一条： 1、只要上面有blurLayer，下面就不能绘制到屏幕上（污染屏幕） 2、自然， 直到blurLayersSize==0时，发生改变，开始上屏（否则，一直被模糊） （推论：①、多个应用都设置了blurLayerBehind，先看最底下的blurLayer，对下面高斯模糊。倒数第二个blurLayer，下面再被模糊 -------> 符合产品逻辑 ②、多个应用时，存在多次模糊的情形 ） hideContent GLESRenderEngine::drawLayersInternal // 自下而上 for (const auto& layer : layers) 遍历出所有的blurLayers 即有backgroundBlurRadius . ---------------------上屏or 临时mCompositionFbo------------------------------- if (blurLayersSize > 0) 时：【】 关键行，一直绘制到mCompositionFbo里，没有上屏！！！！直到条件【if(blurLayersSize == 0) 只有一层需要高斯模糊 】 mBlurFilter->setAsDrawTarget(display, blurLayers.front().backgroundBlurRadius) mCompositionFbo.bind(); if(blurLayersSize == 0) 没有需要高斯模糊 自然，上屏：fbo = std::make_unique 0 && blurLayers.front() == layer) { // 当前遍历的layer是 blurLayers blurLayers.pop_front(); ---------------------上屏or 临时mCompositionFbo------------------------------- if (blurLayersSize > 0) 时：【】 关键行，一直绘制到mCompositionFbo里，没有上屏！！！！！！！！！ mBlurFilter->setAsDrawTarget(display, blurLayers.front().backgroundBlurRadius) mCompositionFbo.bind(); 【if(blurLayersSize == 0) 只有一层需要高斯模糊 】 // 逐渐减少 blurLayersSize 自然，上屏：fbo = std::make_uniqueprepare()】--------产生真正的高斯模糊mBlurProgram---------- --------------在ping上贴原始图？？？？---------------------------- mBlurProgram.useProgram(); glActiveTexture(GL_TEXTURE0); glUniform1i(mBTextureLoc, 0); glBindTexture(GL_TEXTURE_2D, mCompositionFbo.getTextureName()); // -------> TODO: mCompositionFbo 是底下所有layer合成的效果总和 glUniform2f(mBOffsetLoc, stepX, stepY); glViewport(0, 0, mPingFbo.getBufferWidth(), mPingFbo.getBufferHeight()); mPingFbo.bind(); BlurFilter::drawMesh(mBUvLoc, mBPosLoc) // 参数是UV信息和位置信息 glEnableVertexAttribArray(uv); glEnableVertexAttribArray(position); mMeshBuffer.bind(); glBindBuffer(GL_ARRAY_BUFFER, mBufferName); glVertexAttribPointer // 顶点属性 mMeshBuffer.unbind(); glDrawArrays(GL_TRIANGLES, 0 /* first */, 3 /* count */); // 真正的draw ------------pingpong流程----------------------------- GLFramebuffer* read = &mPingFbo; // 初始化read和draw GLFramebuffer* draw = &mPongFbo; glViewport(0, 0, draw->getBufferWidth(), draw->getBufferHeight()); // TODO:视口为啥是？ 步进迭代for (auto i = 1; i bind(); // 绑定draw的buffer,TODO: 没有清？？？？？？？？？？！！！！！！！！！！！ glBindTexture(GL_TEXTURE_2D, read->getTextureName()); // texture, 自然绑定read的 glUniform2f(mBOffsetLoc, stepX * i, stepY * i); // 给GPU程序设置步长 BlurFilter::drawMesh(mBUvLoc, mBPosLoc); // 【】draw 交换read和 draw的buffer mLastDrawTarget = read // 【】 最终模糊的结果！！！ if (blurLayers.size() == 0) { //【】 底下没有其他需要模糊的layer了 自然，fbo = std::make_unique 1)】关键行 blurLayersSize > 1 当底下没有 需要模糊的了，才上屏！ mMixProgram.useProgram(); // 自然mMixProgram glUniform1f(mMMixLoc, mix); glActiveTexture(GL_TEXTURE0); // 激活TEXTURE0 glBindTexture(GL_TEXTURE_2D, mLastDrawTarget->getTextureName()); // 把模糊结果和 TEXTURE0 绑定 glUniform1i(mMTextureLoc, 0); glActiveTexture(GL_TEXTURE1); // 激活TEXTURE1 glBindTexture(GL_TEXTURE_2D, mCompositionFbo.getTextureName()); // glUniform1i(mMCompositionTextureLoc, 1); drawMesh(mMUvLoc, mMPosLoc); ------------清理操作----------------- glUseProgram(0); // 反激活 glActiveTexture(GL_TEXTURE0); //清理操作，确保下次绑定纹理时从 GL_TEXTURE0 开始 疑问： TODO: 上面流程明明是 Blur behind，但是为啥用判断？ backgroundBlurRadius TODO: 上面流程，从始至终，没有看到对几块buffer的清理过程（上屏的那块buffer有清理） -----------> 我理解，应该不用清理，只要图片不是透明的，会被覆盖！！！！！ 3.4. 待整理：高斯模糊 参考： Android R 原生模糊效果原理 SurfaceFlinger层原理-aosp11/12/13 壁纸高斯模糊毛玻璃-千里马framework实战 android13 FLAG_BLUR_BEHIND 壁纸高斯模糊，毛玻璃背景方案设计-千里马framework实战 setBlurBehindRadius接口，最终实现思路： 1、新加了一层dimLayer TODO:图 2、DimLayer 设置t.setBackgroundBlurRadius(d.mDimLayer, blurRadius);//对这个图层进行BlurRadius设置 ---------------> 最终实现，是一个接口！！ aosp11/12/13 壁纸高斯模糊，毛玻璃SurfaceFlinger层面原理-第二节千里马framework实战 --------> 垃圾，说的错的 https://juejin.cn/post/7157984562428002334 DimLayer实现和setRelativeLayer分析【Android12】 其他高斯模糊的实现： Shader 高斯模糊和 Bloom-------> 与aosp的实现，非常接近！！！！！ 高斯模糊 Shader 实现 app侧用力代码： http://681314.com/A/4XTmDHp2I0 腾讯技术工程官方号的专栏： 十种图像模糊算法的总结与实现 GPU 渲染管线和硬件架构浅谈 GPU 性能原理拆解： 不要在 Shader 中使用分支 结合实例深入理解C++对象的内存布局 https://cloud.tencent.com/developer/article/2442869 3.5. shader mMixProgram.compile(getVertexShader(), getMixFragShader()); mBlurProgram.compile(getVertexShader(), getFragmentShader()); 1、VertexShader #version 300 es precision mediump float; in vec2 aPosition; in highp vec2 aUV; out highp vec2 vUV; void main() { vUV = aUV; gl_Position = vec4(aPosition, 0.0, 1.0); } 2、FragmentShader: #version 300 es precision mediump float; uniform sampler2D uTexture; uniform vec2 uOffset; in highp vec2 vUV; out vec4 fragColor; void main() { fragColor = texture(uTexture, vUV, 0.0); fragColor += texture(uTexture, vUV + vec2( uOffset.x, uOffset.y), 0.0); fragColor += texture(uTexture, vUV + vec2( uOffset.x, -uOffset.y), 0.0); fragColor += texture(uTexture, vUV + vec2(-uOffset.x, uOffset.y), 0.0); fragColor += texture(uTexture, vUV + vec2(-uOffset.x, -uOffset.y), 0.0); fragColor = vec4(fragColor.rgb * 0.2, 1.0); } 3、MixFragShader： #version 300 es precision mediump float; in highp vec2 vUV; out vec4 fragColor; uniform sampler2D uCompositionTexture; uniform sampler2D uTexture; uniform float uMix; void main() { vec4 blurred = texture(uTexture, vUV); vec4 composition = texture(uCompositionTexture, vUV); fragColor = mix(composition, blurred, uMix); } 3.6. 高斯模糊的数学原理 数学角度： Android R 原生模糊效果原理 Android R模糊效果使用效率更高的 Kawase blur.具体见 3.7. TODO: how---------合成的承载（buffer） 图片来源 疑问： Blur的绘制目标，为啥要加一层？ Blur不是Gpu合成？ 3.8. 性能 结论： 1、VMware虚拟机内，OpenGL用的也是GPU 2、高斯模糊相当耗GPU loading（VMware虚拟机已经验证） TODO: 如何定量测？ （指标有哪些？） 4. TODO:逆向 关心大的结构： 1、进程树 2、文件系统 3、大的生命周期 4、窗口dump 5. TODO: 动画与sf TODO : skia的画圆画线的指令集 ------> 如何给到GPU 与 opengl有啥关系？用到了shader嘛？ Animation的本质： 视觉上的过渡（让人忽略突变） ----------> 所以，Animation要做的事情，渐变（即频率同人） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/3_Display系统/合成之surfaceFlinger.html":{"url":"0_图形系统/3_Display系统/合成之surfaceFlinger.html","title":"合成之surfaceFlinger","keywords":"","body":"1. 目录2. surfaceflinger的启动 之 .rc文件3. =====进入surfaceflinger main 之后======4. 合成4.1. why----------合成 存在的必然性4.2. how--------合成策略4.2.1. GPU合成，具体代码（字典）4.2.2. weston对应的4.3. 渲染与显示分离-----HWC4.3.1. weston一模一样：4.4. 从vsync角度来看 渲染 与合成4.5. 跨空间跨设备的同步机制-----Fence4.6. 维测5. who---选取什么引擎来render（RenderEngineType）6. SF合成之GPU合成7. 补充sf 贴图过程8. todo:安卓截屏9. 参考10. 疑问：11. TODO: HM的图形11.1. 方舟图形引擎11.2. 马良GPU11.3. 高德11.4. 晶核性能优化11.5. 方舟多媒体引擎 surfaceflinger的启动 之 .rc文件 =====进入surfaceflinger main 之后====== 合成 why----------合成 存在的必然性 how--------合成策略 GPU合成，具体代码（字典） weston对应的 渲染与显示分离-----HWC weston一模一样： 从vsync角度来看 渲染 与合成 跨空间跨设备的同步机制-----Fence 维测 who---选取什么引擎来render（RenderEngineType） SF合成之GPU合成 补充sf 贴图过程 todo:安卓截屏 参考 疑问： TODO: HM的图形 方舟图形引擎 马良GPU 高德 晶核性能优化 方舟多媒体引擎 1. 目录 2. surfaceflinger的启动 之 .rc文件 参考： android屏幕渲染之SurfaceFlinger的启动 系统文件： /system/bin/surfaceflinger 如何启动系统文件surfaceflinger： 1、配置 /system/etc/init/surfaceflinger.rc service surfaceflinger /system/bin/surfaceflinger // -----> 定义surfaceflinger服务 class core animation user system // ------> 用户 group graphics drmrpc readproc // -----> 用户组 onrestart restart zygote // -----> 重启条件 writepid /dev/stune/foreground/tasks // ------> surfaceflinger放到什么调频组 socket pdx/system/vr/display/client stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0 socket pdx/system/vr/display/manager stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0 socket pdx/system/vr/display/vsync stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0 2、按照配置启动 LoadBootScripts解析 ParseConfigDir 解析路径，files收集目录下所有文件 ----> 不得不 for (file : files) 遍历所有文件 ParseConfigFile 解析文件 ParseData 解析数据 ServiceParser::ParseLineSection 解析行时，根据不同的关键词，选择不同的SectionParser。比如：service 选择 ServiceParser；import 选择 ImportParser ServiceParser::ParseGroup service_->proc_attr.gid = gid; // 【】 最终赋值点 3. =====进入surfaceflinger main 之后====== 参考： 【安卓源码】SurfaceFlinger启动及其与应用通信 ----------> 源码注释 源码： TODO: 设计美好： 统一的配置，剥离成文件 4. 合成 4.1. why----------合成 存在的必然性 证明： 多个画家（App）各自画画，必然存在一个人去 张贴所有画 到 一个墙上，即合成 即使统一渲染（多个画家，指挥一个人画在墙上）： 也是存在隐式的 合成（多对一发指令）-------> 即绘图指令的合成 ----------------------> 总之，合成 是 “多对一” 的必然。 4.2. how--------合成策略 合成策略，图： 其中①和② 图来源：： 两种合成方式： 1、SF合成：重新draw（即SF 的client方式） ------ 最终GPU承载（软件部分：sf的openGl调用） 2、硬件合成（即SF 的device方式） ------ 最终显示硬件DPU承载（软部分：sf转发给hwc-drm，最终DPU计算） 对比： Device合成(HWC) Client合成(GPU) 耗电 耗电低 耗电高 性能 性能高 性能低 Alpha处理 很多Vendor的HWC不支持Alpha的处理和合成 能处理每个像素的Alpha及每个Layear的Alpha DRM内容处理 基本都能访问DRM内容 早期版本GPU不能访问DRM的内容 其他限制 能合成的Surface层数有限， 对每种Surface类型处理层数有限 没有处理层数限制 来源:Android P 图形显示系统（一）硬件合成HWC2 优缺点： 1、硬件合成： ​ 效率更高（不占GPU资源） ​ 但是有四层的限制？ 2、sf合成： ​ 自然 两种合成方式存在的必然性： 代码证明： Android P 图形显示系统（一）硬件合成HWC2 TODO: 用哪一种，判断准则： 代码证明 参考: 图解HWC的合成策略 - 简书 (jianshu.com) 假设该屏幕支持4个Planes： client合成，会占用一个屏幕 Plane 剩余 ----> 直接硬件合成 4.2.1. GPU合成，具体代码（字典） 代码大纲： └─ GLESRenderEngine::drawLayersInternal ├─ for (const auto& layer : layers) { │ ├─ status = mBlurFilter->render(); // 模糊特效 │ ├─ setupLayerTexturing // 配置贴图 │ ├─ │ ├─ if: handleShadow // 阴影特效 │ │ ├─ setupLayerTexturing // 【1】 TODO: 阴影也是贴图！！！！证明： │ │ └─ drawMesh │ ├─ elseif:handleRoundedCorners // 圆角特效 │ │ ├─ glScissor(topRect) // 限制绘制区域 │ │ ├─ drawMesh(mesh) // 【】这里shader包含贴图 │ │ ├─ │ │ ├─ setScissor(bottomRect) 1 │ │ ├─ drawMesh(mesh) │ │ ├─ │ │ ├─ setScissor(middleRect) │ │ ├─ mState.cornerRadius = 0.0; //【】画中间区域时，悄悄把圆角半径设为0 ----> 中间区域生成的shader，剔除了圆角的计算。其他都同圆角？？ │ │ └─ drawMesh(mesh) │ └─ else：drawMesh // 没有圆角和阴影时，直接drawMesh(贴图) │ └─ glVertexAttribPointer(mesh.getTexCoords()); // 获取 贴图坐标 │ ├─ glVertexAttribPointer(mesh.getCropCoords()); // 取圆角裁剪坐标 │ ├─ │ ├─ useProgram │ │ ├─ generateVertexShader // 【2】 根据不同的needs，配置不同shader │ │ └─ glUseProgram // 【3】 TODO: │ └─ glDrawArrays 或 glDrawElements // 最终一行绘制 ├─ └─ drawFence = GLESRenderEngine::flush // TODO: 原始 tree GLESRenderEngine::drawLayersInternal for (const auto& layer : layers) { status = mBlurFilter->render(); // 模糊特效 setupLayerTexturing // 配置贴图 if: handleShadow // 阴影特效 setupLayerTexturing // 【1】 TODO: 阴影也是贴图！！！！证明： drawMesh elseif:handleRoundedCorners // 圆角特效 glScissor(topRect) // 限制绘制区域 drawMesh(mesh) // 【】这里shader包含贴图 setScissor(bottomRect) 1 drawMesh(mesh) setScissor(middleRect) mState.cornerRadius = 0.0; //【】画中间区域时，悄悄把圆角半径设为0 ----> 中间区域生成的shader，剔除了圆角的计算。其他都同圆角？？ drawMesh(mesh) else：drawMesh // 没有圆角和阴影时，直接drawMesh(贴图) glVertexAttribPointer(mesh.getTexCoords()); // 获取 贴图坐标 glVertexAttribPointer(mesh.getCropCoords()); // 取圆角裁剪坐标 useProgram generateVertexShader // 【2】 根据不同的needs，配置不同shader glUseProgram // 【3】 TODO: glDrawArrays 或 glDrawElements // 最终一行绘制 drawFence = GLESRenderEngine::flush // TODO: 4.2.2. weston对应的 到底走overlay还是GPU： weston 代码： Assign_planes 纯软件合成（完全的CPU合成）：weston 的pixman-render ------> 安卓不存在这种方式！ 4.3. 渲染与显示分离-----HWC 图，同上。 图来源 有没有分离的判断标志-------------即有没有 上面一条路：GPU渲染完，直接到Display -----> 未分离 ​ GPU渲染完，回到sf 给到Dpu（HWC）进一步合成 分离的必要性：降低GPU功耗 4.3.1. weston一模一样： 硬件合成 ---> weston_plane相关流程 4.4. 从vsync角度来看 渲染 与合成 图： 图来源： TODO: 没懂 VSYNC OFFSET 与 DrawCallback 4.5. 跨空间跨设备的同步机制-----Fence 图 4.6. 维测 5. who---选取什么引擎来render（RenderEngineType） 参考：RenderEngineType简介 时机：自然， sf 初始化 sf 初始化 代码 SurfaceFlinger::init() if (auto type = chooseRenderEngineTypeViaSysProp()) { builder.setRenderEngineType(type.value()); } mRenderEngine = renderengine::RenderEngine::create(builder.build()); mCompositionEngine->setRenderEngine(mRenderEngine.get()); RenderEngineType 配置处： 1、持久化配置： 自然，配置文件 //文件/system/build.prop新增： debug.renderengine.backend=threaded 2、动态配置（需要重启进程）： adb root && adb remount adb shell setprop debug.renderengine.backend threaded adb shell getprop | grep renderengine Android实用技巧之adb命令：getprop,setprop命令使用 具体类型： enum class RenderEngineType { GLES = 1, //opengl THREADED = 2, //opengl异步线程 SKIA_GL = 3, //skia SKIA_GL_THREADED = 4, //skia异步线程 SKIA_VK = 5, // vulkan SKIA_VK_THREADED = 6, }; 即： 同步 异步 skia SKIA_GL SKIA_GL_THREADED opengl GLES THREADED vulkan ........ .......... 承载的类，继承关系： RenderEngine ------> 承载合成能力 ├─SkiaRenderEngine │ └─SkiaVkRenderEngine ├─RenderEngineThreaded └─GLESRenderEngine App侧： 渲染用的 SkiaOpenGLPipeline 和 SkiaVulkanPipeline -------> 作用：RenderNode（view）转化成 绘图指令 最后送给GPU 目录： frameworks/base/libs/hwui/pipeline/skia/SkiaPipeline.cpp hwui是目录 6. SF合成之GPU合成 Android下SF合成流程重学习之GPU合成 圆角绘制 - 安卓R Android下SF合成流程重学习之Refresh流程 合成 一行代码： glDrawRarry 重要结构：一个 Framebuffer（最终都是画到了这个上面） 1//创建GLFramebuffer mDrawingBuffer = createFramebuffer(); 创建并持有： 纹理glGenTextures、帧缓冲 glGenFramebuffer 作用： 1、与hwc的交互 2、承载sf的合成结果 参考 OpenGL 帧缓冲 重要结构之 BufferQueue（GraphicBuffer ）： 1、与APP的交互 2、承载APP的渲染 TODO: 信息流1： GraphicBuffer ----> Framebuffer 关键一行：准备合成原材料（输入的Buffer给到 RenderEngine） std::optional BufferLayer::prepareClientComposition( compositionengine::LayerFE::ClientCompositionTargetSettings& targetSettings) { ...... // 应用queue过来的Buffer layer.source.buffer.buffer = mBufferInfo.mBuffer; layer.source.buffer.isOpaque = isOpaque(s); // 创建BufferQueueLayer时创建的texture ID layer.source.buffer.textureName = mTextureName; ... } 生活化模型：---- 画家绘画 多个画家画画 最后SF贴图（Texture）到墙上（FrameBuffer） TODO: Framebuffer 与 GPU交互，熟悉的味道： dequeueBuffer ------------- 分配一个缓冲区作为GPU合成的暂存空间 queueBuffer ------------ 入队列已绘制好的图形缓存供HWC使用 参考 合成 ：主要流程 输入buffer ----> 生成纹理（贴图） ---> shader贴图（纹理）到最终的FrameBuffer上（glDrawArrays） 详细代码：GLESRenderEngine::drawLayers 文件：frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp status_t GLESRenderEngine::drawLayers(const DisplaySettings& display, const std::vector& layers, ANativeWindowBuffer* const buffer, const bool useFramebufferCache, base::unique_fd&& bufferFence, base::unique_fd* drawFence) { ... // 设置顶点和纹理坐标的size Mesh mesh = Mesh::Builder() .setPrimitive(Mesh::TRIANGLE_FAN) .setVertices(4 /* count */, 2 /* size */) .setTexCoords(2 /* size */) .setCropCoords(2 /* size */) .build(); for (auto const layer : layers) { //遍历outputlayer ... //获取layer的大小 const FloatRect bounds = layer->geometry.boundaries; Mesh::VertexArray position(mesh.getPositionArray()); // 设置顶点的坐标，逆时针方向 position[0] = vec2(bounds.left, bounds.top); position[1] = vec2(bounds.left, bounds.bottom); position[2] = vec2(bounds.right, bounds.bottom); position[3] = vec2(bounds.right, bounds.top); //设置crop的坐标 setupLayerCropping(*layer, mesh); // 设置颜色矩阵 setColorTransform(display.colorTransform * layer->colorTransform); ... // Buffer相关设置 if (layer->source.buffer.buffer != nullptr) { disableTexture = false; isOpaque = layer->source.buffer.isOpaque; // layer的buffer，理解为输入的buffer sp gBuf = layer->source.buffer.buffer; // textureName是创建BufferQueuelayer时生成的，用来标识这个layer， // fence是acquire fence bindExternalTextureBuffer(layer->source.buffer.textureName, gBuf, // 【】 layer->source.buffer.fence); ... // 设置纹理坐标，也是逆时针 renderengine::Mesh::VertexArray texCoords(mesh.getTexCoordArray()); texCoords[0] = vec2(0.0, 0.0); texCoords[1] = vec2(0.0, 1.0); texCoords[2] = vec2(1.0, 1.0); texCoords[3] = vec2(1.0, 0.0); // 设置纹理的参数，glTexParameteri setupLayerTexturing(texture); } // 【】处理圆角 if (radius > 0.0 && color.a >= 1.0f && isOpaque) { handleRoundedCorners(display, layer, mesh); } else { drawMesh(mesh); } status_t GLESRenderEngine::bindExternalTextureBuffer(uint32_t texName, const sp& buffer, const sp& bufferFence) { .............. bool found = false; { // 在ImageCache里面找有没有相同的buffer std::lock_guard lock(mRenderingMutex); auto cachedImage = mImageCache.find(buffer->getId()); found = (cachedImage != mImageCache.end()); } // If we couldn't find the image in the cache at this time, then either // SurfaceFlinger messed up registering the buffer ahead of time or we got // backed up creating other EGLImages. if (!found) { //【】如果ImageCache里面没有则需要重新创建一个EGLImage，创建输入的EGLImage是在ImageManager线程里面，利用notify唤醒机制 status_t cacheResult = mImageManager->cache(buffer); if (cacheResult != NO_ERROR) { return cacheResult; } } ... //【】把EGLImage转换成纹理，类型为GL_TEXTURE_EXTERNAL_OES bindExternalTextureImage(texName, *cachedImage->second); mTextureView.insert_or_assign(texName, buffer->getId()); } } void GLESRenderEngine::bindExternalTextureImage(uint32_t texName, const Image& image) { ATRACE_CALL(); const GLImage& glImage = static_cast(image); const GLenum target = GL_TEXTURE_EXTERNAL_OES; //绑定纹理，纹理ID为texName glBindTexture(target, texName); if (glImage.getEGLImage() != EGL_NO_IMAGE_KHR) { // 把EGLImage转换成纹理，纹理ID为texName glEGLImageTargetTexture2DOES(target, static_cast(glImage.getEGLImage())); } }文件：frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp status_t GLESRenderEngine::drawLayers(const DisplaySettings& display, const std::vector& layers, ANativeWindowBuffer* const buffer, const bool useFramebufferCache, base::unique_fd&& bufferFence, base::unique_fd* drawFence) { ... // 设置顶点和纹理坐标的size Mesh mesh = Mesh::Builder() .setPrimitive(Mesh::TRIANGLE_FAN) .setVertices(4 /* count */, 2 /* size */) .setTexCoords(2 /* size */) .setCropCoords(2 /* size */) .build(); for (auto const layer : layers) { //遍历outputlayer ... //获取layer的大小 const FloatRect bounds = layer->geometry.boundaries; Mesh::VertexArray position(mesh.getPositionArray()); // 设置顶点的坐标，逆时针方向 position[0] = vec2(bounds.left, bounds.top); position[1] = vec2(bounds.left, bounds.bottom); position[2] = vec2(bounds.right, bounds.bottom); position[3] = vec2(bounds.right, bounds.top); //设置crop的坐标 setupLayerCropping(*layer, mesh); // 设置颜色矩阵 setColorTransform(display.colorTransform * layer->colorTransform); ... // Buffer相关设置 if (layer->source.buffer.buffer != nullptr) { disableTexture = false; isOpaque = layer->source.buffer.isOpaque; // layer的buffer，理解为输入的buffer sp gBuf = layer->source.buffer.buffer; // textureName是创建BufferQueuelayer时生成的，用来标识这个layer， // fence是acquire fence bindExternalTextureBuffer(layer->source.buffer.textureName, gBuf, // 【】 layer->source.buffer.fence); ... // 设置纹理坐标，也是逆时针 renderengine::Mesh::VertexArray texCoords(mesh.getTexCoordArray()); texCoords[0] = vec2(0.0, 0.0); texCoords[1] = vec2(0.0, 1.0); texCoords[2] = vec2(1.0, 1.0); texCoords[3] = vec2(1.0, 0.0); // 设置纹理的参数，glTexParameteri setupLayerTexturing(texture); } // 【】处理圆角 if (radius > 0.0 && color.a >= 1.0f && isOpaque) { handleRoundedCorners(display, layer, mesh); } else { drawMesh(mesh); } status_t GLESRenderEngine::bindExternalTextureBuffer(uint32_t texName, const sp& buffer, const sp& bufferFence) { .............. bool found = false; { // 在ImageCache里面找有没有相同的buffer std::lock_guard lock(mRenderingMutex); auto cachedImage = mImageCache.find(buffer->getId()); found = (cachedImage != mImageCache.end()); } // If we couldn't find the image in the cache at this time, then either // SurfaceFlinger messed up registering the buffer ahead of time or we got // backed up creating other EGLImages. if (!found) { //【】如果ImageCache里面没有则需要重新创建一个EGLImage，创建输入的EGLImage是在ImageManager线程里面，利用notify唤醒机制 status_t cacheResult = mImageManager->cache(buffer); if (cacheResult != NO_ERROR) { return cacheResult; } } ... //【】把EGLImage转换成纹理，类型为GL_TEXTURE_EXTERNAL_OES bindExternalTextureImage(texName, *cachedImage->second); mTextureView.insert_or_assign(texName, buffer->getId()); } } void GLESRenderEngine::bindExternalTextureImage(uint32_t texName, const Image& image) { ATRACE_CALL(); const GLImage& glImage = static_cast(image); const GLenum target = GL_TEXTURE_EXTERNAL_OES; //绑定纹理，纹理ID为texName glBindTexture(target, texName); if (glImage.getEGLImage() != EGL_NO_IMAGE_KHR) { // 把EGLImage转换成纹理，纹理ID为texName glEGLImageTargetTexture2DOES(target, static_cast(glImage.getEGLImage())); } } 生活化模型---------见weixin TODO: drawMesh 画网格，来理解opengl： 1、drawMesh 结构： drawMesh2 -> 封装一堆gl操作，useProgram 2、drawMesh可以多次连续调用，即： （1）画网格可以多次在一个地方画 （2）很多gl操作（比如glUseProgram），可以连续调用 7. 补充sf 贴图过程 必然有，贴图过程（把client的图，贴到frameBuffer上）： status_t GLESRenderEngine::drawLayers( if (layer->source.buffer.buffer != nullptr) { ................. sp gBuf = layer->source.buffer.buffer->getBuffer(); // 获取client的buffer ................. bindExternalTextureBuffer(layer->source.buffer.textureName, gBuf, layer->source.buffer.fence); Texture texture(Texture::TEXTURE_EXTERNAL, layer->source.buffer.textureName); // 【】 贴图 weston的贴图： gl_shader_config_set_input_textures // 配置输入纹理的着色器 参考：Weston中shm window渲染 8. todo:安卓截屏 TODO:截屏接口也是等待返回 截屏 SurfaceControl.ScreenshotHardwareBuffer 要点： 截屏工具类ScreenCapture captureDisplay display维度 （captureLayers layer维度） nativeCaptureDisplay ComposerService::getComposerService()->captureDisplay // 【】 ComposerService（ISurfaceComposer）是sf的client端 IServiceManager ComposerService ---> sf 框架的搭建： 截屏流程 - 安卓R 录屏流程 - 安卓R 截图框架代码原理 android 11 9. 参考 Android 显示系统：SurfaceFlinger详解 -------------> 好文！！！！图很好 TODO：图很好，模仿他的图，为什么能画这么清晰，能承载的东西也多 显示图形系统分析之SurfaceFlinger启动流程 https://blog.csdn.net/sssxccc/category_11248337.html 很好的系列文章！！！ https://blog.csdn.net/tkwxty/article/details/136154204 Android下SF合成流程重学习之GPU合成 -------> 好文章！！！！！ Android graphic系列文章： https://blog.csdn.net/tkwxty/category_11464526.html 补充 surfaceFlinger 图： https://blog.csdn.net/gzzaigcnforever/article/details/22175829#:~:text=解释SurfaceFlinger从应用层到底层的整个绘图，显示的大致流程。 显示框架之深入Vsync原理 - 简书 (jianshu.com) 10. 疑问： 如何选择 两种合成方式？ 11. TODO: HM的图形 https://www.bilibili.com/video/BV1py411q7BV?t=5924.9 11.1. 方舟图形引擎 图片来源 shader: --------> 对高频shader检测 GPU的效率 ≈ shader的编译与执行 的效率 用户不感知的，不刷新 DSS是啥？ ------------------> 不懂 11.2. 马良GPU 11.3. 高德 shader本身优化： https://www.bilibili.com/video/BV1py411q7BV?t=7447.7 11.4. 晶核性能优化 原理：快速移动时，----------> 降低分辨率（空间），人眼分辨不出来 注意：静态的东西（不怎变化时），降低刷新率（时间） 静态的东西（不怎变化时），降低刷新率（时间） 变化剧烈的，提高刷新率（时间），降低分辨率（空间） 11.5. 方舟多媒体引擎 原因：网络的波动 TODO: https://www.bilibili.com/video/BV1py411q7BV?t=8148.3 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/3_Display系统/合成之weston.html":{"url":"0_图形系统/3_Display系统/合成之weston.html","title":"合成之weston","keywords":"","body":"1. Weston / wayland ----与A 无异1.1. 功能架构----0层1.2. when---生命周期图 0层1.3. 1层横向大图1.4. 1层纵向大图1.4.1. 发车atomic_flip_handler 代码大纲 TODO:1.4.2. 次要----output_repaint大纲字典1.4.3. 次要---给view分配plane（drm_assign_planes）大纲1.4.4. 主要----plane分配原则总结（物理级别）1.4.5. 从物理\\硬件角度看Plane1.4.6. 补充特例--------霸屏scanout1.4.7. 信息角度之 像素之旅1.5. lib依赖结构(功能导致的)1.6. ============1层=============1.7. 渲染流水线1.7.1. TODO:Commit相关流程1.8. 合成结果的处理 compositor backend1.9. 多屏渲染流水线------important1.9.1. 从trace看多屏渲染流水线1.9.2. 优化之 任务过于集中 -----> 模型之任务队列2. 能量----从驱动力来看图形2.1. client 与 server 之间的pingpong2.1.1. C-S 之间 buffer的传递2.1.2. C的 wl_surface_commit 与 S的 wl_callback2.1.3. c侧的帧率统计（驱动力的帧率）2.2. weston与drm之间的pingpong3. 物质---从buffer看图形 TODO:3.1. 待整理3.2. 图形数据的承载者-----buffer：3.3. 从buffer角度来看渲染流水线：3.3.1. 物理3.3.2. C-S3.3.3. gbm_surface buffer3.3.4. wl_buffer3.3.5. eglSwapBuffers接口实现说明3.3.6. dma-buf 文章3.4. 待整理23.4.1. 1. 从 wl_shm_buffer 转换为像素数据3.4.2. 2. 从 GBM/EGL buffer 转换为像素数据3.4.3. 3. 其他方式：通过 EGL 或 OpenGL 读取像素3.4.4. 总结4. 霸屏模式4.1. 必要条件（物理层面）4.2. 必要条件的代码大纲4.3. 关键性日志：4.4. TODO: weston 10上不生效5. 显示性能优化5.1. 优化之 只重绘damage区域5.1.1. 标记 damage区域----大纲之【计算damage】：5.1.2. 如何做到只重绘damage呢（how）6. TODO: 消息驱动模型？6.1. weston的消息循环驱动模型7. weston事件分发逻辑8. weston启动8.1. 启动代码大纲8.2. 代码目录结构8.3. TODO: 如何在启动时 观察到 各种plane的上下级关系？9. weston之多屏10. 休眠与唤醒10.1. weston12原生11. 其他 次要功能11.1. weston 截屏 & 录屏11.1.1. 操作11.1.2. 原理：11.1.3. 待整理11.2. 一些量的级别11.3. weston日志 关键标识12. 次要---GStreamer——gst-launch-1.012.1. 在Linux上播放视频12.2. 播放图片13. weston的client------能力展示&功能入口13.1. 图片查看 weston-image：13.2. weston-eventdemo 事件实时显示13.3. editor-----展示输入法框架能力13.4. dnd ------ 窗口之间传递13.5. constraint13.6. transformed13.7. scaler13.8. 其他：14. 维测14.1. 限定模块范围（SCOPE）的日志14.1.1. drm-backend日志14.2. 启动日志14.3. export WAYLAND_DEBUG=114.4. dump14.5. weston区域维测-----打印矩形15. TODO: 问题定位16. 资料17. 其他 待整理17.1.1. cursor_view的判断17.1.2. 硬件图层plane17.1.3. kanzi17.1.4. Weston中HDMI热拔插检测原理17.1.5. drm_output_find_special_plane 遍历查找 特定的plane Weston / wayland ----与A 无异 功能架构----0层 when---生命周期图 0层 1层横向大图 1层纵向大图 发车atomic_flip_handler 代码大纲 TODO: 次要----output_repaint大纲字典 draw_paint_node 画一个节点 大纲 次要---给view分配plane（drm_assign_planes）大纲 如何避免将屏幕1的plane分配给屏幕2的view呢？plane-output 绑定关系维护在哪里？ 次要 ------ compositor从drm获取plane信息 主要----plane分配原则总结（物理级别） 总结所有走GPU的（剩下走overlay） WESTON_BUFFER_SHM 强制GPU 从日志看assign_plane 从物理\\硬件角度看Plane 补充特例--------霸屏scanout 信息角度之 像素之旅 lib依赖结构(功能导致的) ============1层============= 渲染流水线 TODO:Commit相关流程 合成结果的处理 compositor backend 多屏渲染流水线------important 从trace看多屏渲染流水线 优化之 任务过于集中 -----> 模型之任务队列 能量----从驱动力来看图形 client 与 server 之间的pingpong C-S 之间 buffer的传递 待整理 C的 wl_surface_commit 与 S的 wl_callback c侧的帧率统计（驱动力的帧率） weston与drm之间的pingpong 物质---从buffer看图形 TODO: 待整理 图形数据的承载者-----buffer： 从buffer角度来看渲染流水线： 物理 C-S gbm_surface buffer wl_buffer eglSwapBuffers接口实现说明 dma-buf 文章 待整理2 ChatGPT said: 1. 从 wl_shm_buffer 转换为像素数据 步骤： 2. 从 GBM/EGL buffer 转换为像素数据 步骤： 3. 其他方式：通过 EGL 或 OpenGL 读取像素 总结 霸屏模式 必要条件（物理层面） 必要条件的代码大纲 关键性日志： TODO: weston 10上不生效 显示性能优化 优化之 只重绘damage区域 标记 damage区域----大纲之【计算damage】： 如何做到只重绘damage呢（how） TODO: 消息驱动模型？ weston的消息循环驱动模型 weston事件分发逻辑 weston启动 启动代码大纲 代码目录结构 TODO: 如何在启动时 观察到 各种plane的上下级关系？ weston之多屏 休眠与唤醒 weston12原生 其他 次要功能 weston 截屏 & 录屏 操作 原理： 待整理 一些量的级别 weston日志 关键标识 次要---GStreamer——gst-launch-1.0 在Linux上播放视频 播放图片 weston的client------能力展示&功能入口 图片查看 weston-image： weston-eventdemo 事件实时显示 editor-----展示输入法框架能力 dnd ------ 窗口之间传递 constraint transformed scaler 其他： 维测 限定模块范围（SCOPE）的日志 drm-backend日志 启动日志 export WAYLAND_DEBUG=1 dump weston区域维测-----打印矩形 TODO: 问题定位 资料 其他 待整理 cursor_view的判断 硬件图层plane Plane 的使用 kanzi Weston中HDMI热拔插检测原理 drm_output_find_special_plane 遍历查找 特定的plane 1. Weston / wayland ----与A 无异 1.1. 功能架构----0层 Weston从内部体系结构------------窗口管理（shell） ： WindowManagerService ​ 合成器（compositor）： SurfaceFlinger ​ 输入管理 input Manager ： InputManagerService 总之： weston = wms + IMS + SF ​ systemServer进程 + SF进程 从功能角度看： （1）任意一个系统功能是唯一确定的 （2）自然，唯一的不同就是 功能的组合方式不同，即结构上有差异 图： 图来源 TODO: 修改图，改变上下关系 TODO: server侧的shell具体是什么？？？？ 理解： （1）自然：wayland-server ---- wayland client 就是协议 1.2. when---生命周期图 0层 大的生命周期：上图1和2 目前不合理的地方：统一repaint & 统一提交commit ├─ wet_main ├─ wl_display_run └─ wl_event_loop_dispatch // 大的消息模型驱动 ├─ on_drm_input // 【发车】TODO: 真正drm来的PageFlip消息 -----------上图1----------------- │ └─ drmHandleEvent │ └─ atomic_flip_handler │ └─ drm_output_update_complete │ └─ weston_output_finish_frame // 为 output_repaint_timer_handler 计算time └─ wl_timer_heap_dispatch // timer 超时消息 -----------上图2----------------- └─ output_repaint_timer_handler // 【交货】timer启动 ├─ drm_repaint_begin // 打印scene_graph日志 ├─ 遍历output，weston_output_maybe_repaint └─ drm_repaint_flush // 【车子回程】 提交 hideContent wet_main wl_display_run wl_event_loop_dispatch // 大的消息模型驱动 on_drm_input // 【发车】TODO: 真正drm来的PageFlip消息 -----------上图1----------------- drmHandleEvent atomic_flip_handler drm_output_update_complete weston_output_finish_frame // 为 output_repaint_timer_handler 计算time wl_timer_heap_dispatch // timer 超时消息 -----------上图2----------------- output_repaint_timer_handler // 【交货】timer启动 drm_repaint_begin // 打印scene_graph日志 遍历output，weston_output_maybe_repaint drm_repaint_flush // 【车子回程】 提交 TODO: 真正drm来的PageFlip消息 ： ​ 到底是drm怎么发的消息？？？？？？ 1.3. 1层横向大图 字典 图： 图来源 1.4. 1层纵向大图 1.4.1. 发车atomic_flip_handler 代码大纲 TODO: atomic_flip_handler ----- 发车 1.4.2. 次要----output_repaint大纲字典 【repaint流程】承载：将client的damage区域提交给compositor，compositor进行合成 -repaint的唯一目的：就是拿到合成后大图（承载于drm_fb）与 简单图 ├─ 生命周期图 0层 ├─ weston_output_maybe_repaint(compositor.c) └─ weston_output_repaint(compositor.c) ├─ ------------------为views分配planes-------------------------- ├─ drm_assign_planes // 【】具体见下 ├─ ------------------【计算damage】--------------------------------- └─ drm_output_repaint └─ drm_output_render-----------------只做了一件事情，拿到fd（内核的buffer）---------------------- ├─ if (scanout_state->fb) return // 【】霸屏模式scanout -----> 利用client的fd ├─ if：drm_fb_ref 硬件合成 自然，条件：damage为空(也是gl被拦截的地方)？？？？？ ├─ eif:drm_output_render_pixman 软件合成 ├─ el：drm_output_render_gl //【】GPU合成 或 x11_output_repaint_gl backend-x11/x11.c---> weston合成器的output是X11 │ ├─ gl_renderer_repaint_output ----> 必然，在这里设置视口viewPort，视口是output级别的 │ │ ├─ get_surface_state(weston_surface) │ │ │ └─ gl_renderer_create_surface │ │ │ ├─ ------------------------attach？？？----------------------------------- │ │ │ └─ gl_renderer_attach(weston_surface, weston_buffer) // 【】核心 │ │ ├─ repaint_views // 【】这里遍历node，必然 从下往上叠图（合成的必然！！！） │ │ │ ├─ ------------------【3】OpenGL合成, 前提：分配了primary plane-------------------------- │ │ │ └─ draw_paint_node // 【】有些node会走gl，有些走pixman？ node级别的还是合成器级别的 ？ 必然：这里初始化shader的config │ │ │ ├─ gl_shader_config_init_for_paint_node // 必然：where---draw_paint_node之子，repaint_region之前 │ │ │ ├─ repaint_region //【】 │ │ │ └─ triangle_fan_debug 测试用的？？？ │ │ ├─ blit_shadow_to_output // 阴影。开关：\"color-management\"改为true │ │ └─ 【eglSwapBuffers】 // 关键一行，weston 与 drm侧交换buffer！！！！（不是与client侧！！！！！！！！） │ ├─ bo = gbm_surface_lock_front_buffer // 拿到gbm buffer---> 承载合成结果 │ ├─ drm_fb_get_from_bo(bo, BUFFER_GBM_SURFACE) │ │ └─ drm_fb_addfb(~bo) │ │ └─ drmModeAddFB2WithModifiers/drmModeAddFB2 //libdrm 【】通过gbm buffer创建帧缓冲区（FrameBuffer） │ │ └─ 实际上，已经将数据写给drm设备了。图：https://download.csdn.net/blog/column/11175480/133747645 │ └─ return drm_fb（指向DRM的FrameBuffer），并记录 ├─ scanout_state->fb = fb // 合成大图，由 drm_plane_state->drm_fb 承载 └─ drmModeCreatePropertyBlob // 【2】libdrm接口，创建属性（后续用来设置CRTC（Crtc）、连接器（Connector）、平面（Plane）） ​ 原大纲 生命周期图 0层 weston_output_maybe_repaint(compositor.c) weston_output_repaint(compositor.c) // output级 ------------------为views分配planes-------------------------- drm_assign_planes // 【】具体见下 ------------------计算damage--------------------------------- drm_output_repaint drm_output_render-----------------只做了一件事情，拿到fd（内核的buffer）---------------------- if (scanout_state->fb) return // 【】霸屏模式scanout -----> 利用client的fd if：drm_fb_ref 硬件合成 自然，条件：damage为空(也是gl被拦截的地方)？？？？？ eif:drm_output_render_pixman 软件合成 el：drm_output_render_gl //【】GPU合成 或 x11_output_repaint_gl backend-x11/x11.c---> weston合成器的output是X11 gl_renderer_repaint_output ----> 必然，在这里设置视口viewPort，视口是output级别的 use_output(output) // 自然，开始时，初始化EGL的环境，比如 eglMakeCurrent eglMakeCurrent get_surface_state(weston_surface) gl_renderer_create_surface ------------------------attach？？？----------------------------------- gl_renderer_attach(weston_surface, weston_buffer) // 【】核心 repaint_views // 【】这里遍历node，必然 ------------------【3】OpenGL合成, 前提：分配了primary plane-------------------------- 【draw_paint_node】展开见下。 有些node会走gl，有些走pixman？ node级别的还是合成器级别的 ？ 必然：这里初始化shader的config gl_shader_config_init_for_paint_node // 必然：where---draw_paint_node之子，repaint_region之前 repaint_region //【】 triangle_fan_debug 测试用的？？？ blit_shadow_to_output // 阴影。开关：\"color-management\"改为true 【eglSwapBuffers】 // 关键一行，weston 与 drm侧交换buffer！！！！（不是与client侧！！！！！！！！） bo = gbm_surface_lock_front_buffer // 拿到gbm buffer---> 承载合成结果 drm_fb_get_from_bo(bo, BUFFER_GBM_SURFACE) drm_fb_addfb(~bo) drmModeAddFB2WithModifiers/drmModeAddFB2 //libdrm 【】通过gbm buffer创建帧缓冲区（FrameBuffer） 实际上，已经将数据写给drm设备了。图：https://download.csdn.net/blog/column/11175480/133747645 return drm_fb（指向DRM的FrameBuffer），并记录 scanout_state->fb = fb // 合成大图，由 drm_plane_state->drm_fb 承载 drmModeCreatePropertyBlob // 【2】libdrm接口，创建属性（后续用来设置CRTC（Crtc）、连接器（Connector）、平面（Plane）） 【eglSwapBuffers】 eglSwapBuffers(gr->egl_display, go->egl_surface) 1、是个output级别的函数。weston 与 drm侧交换buffer！！！！（不是与client侧！！！！！！！） 2、client 也有 eglSwapBuffers 函数 3、weston的 耗时很久，大概 1~3ms --------> TODO: 不是交换地址吗？ =================大纲的证明================== drm_output_render唯一目的就是拿到合成后buffer对应的fd （1）自然，OpenGL合成后，拿到fd （2） 一个client霸屏了，自然直接用client的fd 。具体见《霸屏scanout》章节 为啥要拿到fd？ 因为这是commit的前提！！！！！ 【2】 GPU（CPU）合成结果的承载者-------drm_fb 其他小点： 1、直接overlay送的图的流程： （1）在 gl重绘窗口repaint_views时，过滤掉了 ------------> 即啥也没做！！！！ （2）scanout霸屏时，也是gl流程，直接return出去了 -【flush流程】目的：commit 大图与简单图 给DRM 生命周期图 0层 └─ drm_repaint_flush(drm.c) └─ drm_pending_state_apply(kms.c) └─ drm_pending_state_apply_atomic(kms.c) // 遍历 pending_state->output_list ├─ drm_output_apply_state_atomic(drm_output_state, drmModeAtomicReq) // 【2】必然：自然以plane_list维度，去commit │ └─ 遍历 drm_plane_state（repaint后的大图存储的地方） │ └─ plane_add_prop(req,plane_state->fb->fb_id); // 【】关键一行，关键出参：req 修改对应的配置参数 └─ drmModeAtomicCommit(req) // 【】关键一行：参数统一commit给drm（libdrm接口） hideContent output_repaint_timer_handler(compositor.c) // repaint的timer里 drm_repaint_flush(drm.c) drm_pending_state_apply(kms.c) drm_pending_state_apply_atomic(kms.c) // 遍历 pending_state->output_list drm_output_apply_state_atomic(drm_output_state, drmModeAtomicReq) // 【2】必然：自然以plane_list维度，去commit 遍历 drm_plane_state（repaint后的大图存储的地方） plane_add_prop(req,plane_state->fb->fb_id); // 【】关键一行，关键出参：req 修改对应的配置参数 drmModeAtomicCommit(req) // 【】关键一行：参数统一commit给drm（libdrm接口） 详解【1】：commit 与 repaint流程，一定不在一个loop触发里： -生活化模型： overlay ----------- 年轻人 GPU ------------- 有能力的老人 DPU 叠图 ----------考试结束，画挂墙（挂墙展示评分） （1）事件驱动（client的dirty） 触发重绘： 多个画家画画，画完送给 张贴人 （合成器），合成器触发重绘 （2）有些画 可能需要相框（圆角特效等），需要有能力的老人（GPU）来完成。有能力，但是干活慢。 ​ 老人装完相框，把多个画，贴到一张大纸上形成大图，最后交给年轻挂画的人。年轻人（DPU）最后把画挂到墙上 （3） 有些画，很简单，不需要额外的操作，直接交给年轻小白（DPU）直接挂墙。 无能力（只会粘贴），但是干活快 （4）when：大图与简单画（plane_list），何时 给到 年轻小白去挂墙？ ​ 自然是本轮考试结束的时候，timeOut的时候 ---------> 即commit是计时器触发 TODO: 一场考试需要多久？ 详解【2】： 必然以plane_list维度去commit： （1）GPU合成的结果，以primary_plane 去提交，提交给DPU （2） overlay对应的view，没有合成 ------> 直接以overlay_plane，送给DPU (3) cursor_plane ，也被提交给DPU ------------------------> 注意： 遍历 的plane_list，不代表硬件层级！！ draw_paint_node 画一个节点 大纲 使用gl 接口，调用GPU画： ​ -本质：就是GPU贴图 └─ draw_paint_node ├─ pixman_region32_intersect(&repaint, damage); // 次要：用damage更新 repaint区域 ├─ gl_shader_config_init_for_paint_node // 【】目的：需要参数封装到conf结构体里（用作shader） │ ├─ gl_shader_config_set_input_textures // 【】关键：把client的texture封装到conf里 │ │ └─ for: sconf->input_tex[i] = gb->textures[i] // 一个node，可能有多个Texture │ └─ gl_shader_config_set_color_transform 颜色变换？ ├─ pixman_region32_subtract(&surface_blend, &surface_blend, &pnode->surface->opaque); // 扣除 完全不透明区域？ └─ repaint_region(gr, pnode, &repaint, &surface_blend, &sconf); // 【】 ├─ 【texture_region(pnode, region, surf_region)】 矩形窗口可能被其他窗口遮挡，会被分割成多个小矩形进行绘制 ├─ /* position: */ ├─ glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof *v, &v[0]); ├─ /* texcoord: */ ├─ glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof *v, &v[2]); ├─ gl_renderer_use_program(gr, sconf) // 【】 │ ├─ gl_renderer_get_program(gr, &sconf->req) // 获取glProgram │ │ ├─ 做了缓存，不用每次都编译gl_shader_requirements_cmp(&reqs, &shader->key) │ │ └─ gl_shader_create(gr, &reqs) // 没有的话，创建 │ │ ├─ sources[2] = fragment_shader; 具体的fragment.glsl │ │ └─ glGetProgramiv(shader->program); //gl接口生成glProgram │ │ ├─ shader->proj_uniform = glGetUniformLocation(shader->program, \"proj\"); │ │ ├─ shader->tex_uniforms[0] = glGetUniformLocation(shader->program, \"tex\"); // 【】 拿到.glsl中全局变量的索引，后面CPU给GPU赋值 │ │ └─ shader->tex_uniforms[1] = glGetUniformLocation(shader->program, \"tex1\"); │ ├─ glUseProgram(shader->program); // 激活glProgram（激活一个着色器程序，所有后续的绘制调用将使用这个程序中定义的顶点着色器和片段着色器） │ └─ gl_shader_load_config(shader, sconf) // │ ├─ glUniform1f(shader->view_alpha_uniform, sconf->view_alpha); // 【】CPU真正给GPU赋值的地方 │ └─ for遍历，绑定纹理： // 贴图：一个client surface，只有一个（已经确认） │ ├─ glActiveTexture(GL_TEXTURE0 + i) 激活当前的纹理单元，使得后续的纹理操作会在这个纹理上进行 │ └─ glBindTexture(GL_TEXTURE_2D, sconf->input_tex[i]) //相当create 2d texture_obj对象，并设置了sconf->input_tex[i]; └─ 遍历所有矩形nfans， glDrawArrays(GL_TRIANGLE_FAN, first, vtxcnt[i]); //【】真正绘制 hideContent draw_paint_node pixman_region32_intersect(&repaint, damage); // 次要：用damage更新 repaint区域 gl_shader_config_init_for_paint_node // 【】目的：需要参数封装到conf结构体里（用作shader） gl_shader_config_set_input_textures // 【】关键：把client的texture封装到conf里 for: sconf->input_tex[i] = gb->textures[i] // 一个node，可能有多个Texture gl_shader_config_set_color_transform 颜色变换？ pixman_region32_subtract(&surface_blend, &surface_blend, &pnode->surface->opaque); // 扣除 完全不透明区域？ repaint_region(gr, pnode, &repaint, &surface_blend, &sconf); // 【】 【texture_region(pnode, region, surf_region)】 矩形窗口可能被其他窗口遮挡，会被分割成多个小矩形进行绘制 /* position: */ glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof *v, &v[0]); /* texcoord: */ glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof *v, &v[2]); gl_renderer_use_program(gr, sconf) // 【】 gl_renderer_get_program(gr, &sconf->req) // 获取glProgram 做了缓存，不用每次都编译gl_shader_requirements_cmp(&reqs, &shader->key) gl_shader_create(gr, &reqs) // 没有的话，创建 sources[2] = fragment_shader; 具体的fragment.glsl glGetProgramiv(shader->program); //gl接口生成glProgram shader->proj_uniform = glGetUniformLocation(shader->program, \"proj\"); shader->tex_uniforms[0] = glGetUniformLocation(shader->program, \"tex\"); // 【】 拿到.glsl中全局变量的索引，后面CPU给GPU赋值 shader->tex_uniforms[1] = glGetUniformLocation(shader->program, \"tex1\"); glUseProgram(shader->program); // 激活glProgram（激活一个着色器程序，所有后续的绘制调用将使用这个程序中定义的顶点着色器和片段着色器） gl_shader_load_config(shader, sconf) // glUniform1f(shader->view_alpha_uniform, sconf->view_alpha); // 【】CPU真正给GPU赋值的地方 for遍历，绑定纹理： // 贴图：一个client surface，只有一个（已经确认） glActiveTexture(GL_TEXTURE0 + i) 激活当前的纹理单元，使得后续的纹理操作会在这个纹理上进行 glBindTexture(GL_TEXTURE_2D, sconf->input_tex[i]) //相当create 2d texture_obj对象，并设置了sconf->input_tex[i]; 遍历所有矩形nfans， glDrawArrays(GL_TRIANGLE_FAN, first, vtxcnt[i]); //【】真正绘制 关于weston 如何使用OpenGL贴图，很好的参考： weston现有的 shadow的画法 高斯模糊的做法 1.4.3. 次要---给view分配plane（drm_assign_planes）大纲 repaint大纲字典 └─ drm_assign_planes ----------output级 ├─ try: mode = DRM_OUTPUT_PROPOSE_STATE_PLANES_ONLY //1、尝试只用 overlay ├─ try: mode = DRM_OUTPUT_PROPOSE_STATE_MIXED; // 2、只用overlay不成功，尝试 overlay + GPU ├─ try: mode = DRM_OUTPUT_PROPOSE_STATE_RENDERER_ONLY; // 上面两点都不成功, 自然，只用GPU └─ drm_output_propose_state(mode)-------output级-------------- └─ wl_list_for_each(pnode)------遍历pnode节点-----view级---------- ├─ ①忽略不合成的view(continue)： │ ├─ 1、不属于此output的 if (!(ev->output_mask & (1u base.id))) │ ├─ 2、必须需要颜色变换 TODO:没懂 if (!pnode->surf_xform_valid) │ ├─ 3、完全被遮挡的 if (totally_occluded) │ └─ 4、 ├─ ②强制走GPU render的(force_renderer = true)： │ ├─ 1、view存在于多个output上，if (ev->output_mask != (1u base.id)) │ ├─ 2、view 对应的GBM not available（drm侧）， if (!b->gbm) │ ├─ 3、view没有有效的buffer，if (!weston_view_has_valid_buffer(ev)) │ ├─ 4、view对应buffer类型是 WESTON_BUFFER_SOLID │ ├─ 5、需要做color变换的，(requires color transform) │ ├─ 6、view被GPU render view遮挡的， if (pixman_region32_not_empty(&surface_overlap)) ----> TODO:本质原因是啥！！！！！！ │ │ └─ 换言之，gpu view 以下（遮挡），必须是GPU！ │ └─ 7、view在保护content-protection的强制mode下 └─ ③--------对于非强制GPU的尝试分配plane：drm_output_find_plane_for_view ----------- ├─ 1、检查buffer是否有效。无效则 FAILURE_REASONS_FB_FORMAT_INCOMPATIBLE ├─ 2、buffer类型是WESTON_BUFFER_SOLID ，分配plane失败， FAILURE_REASONS_FB_FORMAT_INCOMPATIBLE ├─ 3、buffer类型是WESTON_BUFFER_SHM，只允许是cursor_plane： │ ├─ pixel_format格式是DRM_FORMAT_ARGB8888，失败，FAILURE_REASONS_FB_FORMAT_INCOMPATIBLE │ ├─ buffer的尺寸大于鼠标，失败 │ └─ 赋值：possible_plane_mask = (1 cursor_plane->plane_idx); ├─ 4、自然，尝试的mode = DRM_OUTPUT_PROPOSE_STATE_RENDERER_ONLY，失败 ├─ 5、wl_list_for_each(plane, &device->plane_list)遍历 硬件所有plane │ └─ 跳过CURSOR类型的plane │ └─ 赋值：possible_plane_mask |= 1 plane_idx; ├─ 6、没有对应的drm_fb（Framebuffer），失败 ├─ 7、有对应的drm_fb，赋值：possible_plane_mask &= fb->plane_mask ├─ ③_1--------真正的分配（对于③中可能分配的possible_plane）----------------------- └─ wl_list_for_each(plane, &device->plane_list)遍历plane_list： ├─ plane可得性检查：【drm_plane_is_available】 │ ├─ output如果是virtual的，不能分配plane！！ │ ├─ The plane still 存在 a request │ ├─ The plane is still active on another output │ └─ 检查 plane can be used with this CRTC // 【】屏幕和plane的绑定关系！！！！ ├─ 检查 view对应的buffer有效性：assert(fb) ├─ alpha已经安排过view，跳过： drm_output_check_plane_has_view_assigned() ├─ alpha 检查：如果view有alpha值，但是该plane不支持alpha，跳过 └─ 最终绑定plane与view：drm_output_prepare_cursor_paint_node/drm_output_try_paint_node_on_plane └─ plane_state->ev = view // TODO: 最终应该是，plane分配给view -结论的物理级证明： 1、物理上，必然：连续性结论：GPU合成的views必须连续（因为只有一个GPU） 推论：所以，代码策略：某view是GPU合成，以下（需要被遮挡）都必须是force-render 2、TODO： 上面所有策略的物理级的证明 hideContent drm_assign_planes ----------output级 try: mode = DRM_OUTPUT_PROPOSE_STATE_PLANES_ONLY //1、尝试只用 overlay try: mode = DRM_OUTPUT_PROPOSE_STATE_MIXED; // 2、只用overlay不成功，尝试 overlay + GPU try: mode = DRM_OUTPUT_PROPOSE_STATE_RENDERER_ONLY; // 上面两点都不成功, 自然，只用GPU drm_output_propose_state(mode)-------output级-------------- wl_list_for_each(pnode)------遍历pnode节点-----view级---------- ①忽略不合成的view(continue)： 1、不属于此output的 if (!(ev->output_mask & (1u base.id))) 2、必须需要颜色变换 TODO:没懂 if (!pnode->surf_xform_valid) 3、完全被遮挡的 if (totally_occluded) 4、 ②强制走GPU render的(force_renderer = true)： 1、view存在于多个output上，if (ev->output_mask != (1u base.id)) 2、view 对应的GBM not available（drm侧）， if (!b->gbm) 3、view没有有效的buffer，if (!weston_view_has_valid_buffer(ev)) 4、view对应buffer类型是 WESTON_BUFFER_SOLID 5、需要做color变换的，(requires color transform) 6、view被GPU render view遮挡的， if (pixman_region32_not_empty(&surface_overlap)) ----> TODO:本质原因是啥！！！！！！ 换言之，gpu view 以下（遮挡），必须是GPU！ 7、view在保护content-protection的强制mode下 ③--------对于非强制GPU的尝试分配plane：drm_output_find_plane_for_view ----------- 1、检查buffer是否有效。无效则 FAILURE_REASONS_FB_FORMAT_INCOMPATIBLE 2、buffer类型是WESTON_BUFFER_SOLID ，分配plane失败， FAILURE_REASONS_FB_FORMAT_INCOMPATIBLE 3、buffer类型是WESTON_BUFFER_SHM，只允许是cursor_plane： pixel_format格式是DRM_FORMAT_ARGB8888，失败，FAILURE_REASONS_FB_FORMAT_INCOMPATIBLE buffer的尺寸大于鼠标，失败 赋值：possible_plane_mask = (1 cursor_plane->plane_idx); 4、自然，尝试的mode = DRM_OUTPUT_PROPOSE_STATE_RENDERER_ONLY，失败 5、wl_list_for_each(plane, &device->plane_list)遍历 硬件所有plane 跳过CURSOR类型的plane 赋值：possible_plane_mask |= 1 plane_idx; 6、没有对应的drm_fb（Framebuffer），失败 7、有对应的drm_fb，赋值：possible_plane_mask &= fb->plane_mask ③_1--------真正的分配（对于③中可能分配的possible_plane）----------------------- wl_list_for_each(plane, &device->plane_list)遍历plane_list： plane可得性检查：drm_plane_is_available： output如果是virtual的，不能分配plane！！ The plane still 存在 a request The plane is still active on another output 检查 plane can be used with this CRTC 检查 view对应的buffer有效性：assert(fb) alpha已经安排过view，跳过： drm_output_check_plane_has_view_assigned() alpha 检查：如果view有alpha值，但是该plane不支持alpha，跳过 最终绑定plane与view：drm_output_prepare_cursor_paint_node/drm_output_try_paint_node_on_plane plane_state->ev = view // TODO: 最终应该是，plane分配给view 最终一行： 承载在哪个变量里？？？？ view->plane = primary_plane; // 把plane分配给view weston_compositor里的primary_plane; // 【】指明了GPU的plane 维测： 如何避免将屏幕1的plane分配给屏幕2的view呢？plane-output 绑定关系维护在哪里？ 必然是在驱动！！！因为plane的数据送给哪个屏幕，是drm决定的 -weston侧只是获取 绑定关系。具体代码： drm_plane_is_available(plane, output) { ................. if (plane->state_cur->output && plane->state_cur->output != output) // 第二次、第三次分配：维持第一次 plane与outPut的绑定关系 return false; /* Check whether the plane can be used with this CRTC; possible_crtcs * is a bitmask of CRTC indices (pipe), rather than CRTC object ID. */ return !!(plane->possible_crtcs & (1 crtc->pipe)); // 第一次分配 } 结论： 1、outPut与crtc 一 一对应。。。。TODO: 验证 2、plane->possible_crtcs，即对应的plane-crtc绑定关系。。TODO: outPut 与 crtc绑定关系在哪里？？？？ TODO: 难道一个plane，可以绑定多个关系？ plane->possible_crtcs来源： weston_backend_init drm_backend_create open_additional_devices drm_device_create create_sprites drm_plane_create //【】 通过drmModePlane，拿到plane对应的 possible_crtcs、plane->plane_id 次要 ------ compositor从drm获取plane信息 硬件： plane的来源： 不是跟着屏幕走的。而是硬件资源的限制（具体：CRTC、encode？？？？？？） 图来源 代码大纲： weston_backend_init(drm.c) drm_backend_create(drm.c) drm_device_create(drm.c) create_sprites(drm.c) sprites即overlay planes 关键一行： kplane_res = drmModeGetPlaneResources(device->drm.fd); // 得到plane资源集 for (i = 0; i count_planes; i++) { kplane = drmModeGetPlane(device->drm.fd, kplane_res->planes[i]); // 根据Plane ID得到Plane 在weston侧，最终维护在plane_list中 TODO: 物理级的理解： plane个数的限制，最终是来源哪里？硬件？具体哪个硬件 ​ 最终配置在哪里？ 日志： [17:26:13.604] drm_plane_create: plane->plane_id: 49 // 从drm获取的id 【1】乱七八糟？？ 【2】这个值，重启后变化 [17:26:13.605] drm_plane_create: plane->plane_id: 70 [17:26:13.605] drm_plane_create: plane->plane_id: 74 [17:26:13.606] drm_plane_create: plane->plane_id: 110 [17:26:13.606] drm_plane_create: plane->plane_id: 114 [17:26:13.606] drm_plane_create: plane->plane_id: 126 [17:26:13.607] drm_plane_create: plane->plane_id: 132 [17:26:13.607] drm_plane_create: plane->plane_id: 138 [17:26:13.608] drm_plane_create: plane->plane_id: 144 [17:26:13.609] drm_plane_create: plane->plane_id: 150 [17:26:13.609] create_sprites: drm_plane->plane_idx: 0 // weston，重新赋予的id值 [17:26:13.609] create_sprites: drm_plane->plane_idx: 1 [17:26:13.609] create_sprites: drm_plane->plane_idx: 2 [17:26:13.609] create_sprites: drm_plane->plane_idx: 3 [17:26:13.609] create_sprites: drm_plane->plane_idx: 4 [17:26:13.609] create_sprites: drm_plane->plane_idx: 5 [17:26:13.609] create_sprites: drm_plane->plane_idx: 6 [17:26:13.609] create_sprites: drm_plane->plane_idx: 7 [17:26:13.609] create_sprites: drm_plane->plane_idx: 8 [17:26:13.609] create_sprites: drm_plane->plane_idx: 9 1.4.4. 主要----plane分配原则总结（物理级别） 默认的view都是分给primary ------> 啥是默认的view？？？ video 占据sprite plane 大致： 1、overlay条件非常苛刻 2、GPU是用来兜底的。万能的 primary 层，物理上一定在下面 总结所有走GPU的（剩下走overlay） 从GPU角度： GPU是DRM的兜底者（比如，DRM不认识SHM） 代码中： ②强制走gpu的 ③尝试分配plane失败的 物理角度，只能GPU： WESTON_BUFFER_SHM ---------> cpu分配的内存，drm不认识。只能走GPU兜底转一道（cursor可以plane） WESTON_BUFFER_SOLID WESTON_BUFFER_SHM 强制GPU 代码证明： else if (buffer->type == WESTON_BUFFER_SHM) { if (!output->cursor_plane || device->cursors_are_broken) { pnode->try_view_on_plane_failure_reasons |= FAILURE_REASONS_FB_FORMAT_INCOMPATIBLE; // add by kent start drm_debug(b, \"\\t\\t\\t\\t ==kent==, drm_output_find_plane_for_view weston_view %p buffer->type == WESTON_BUFFER_SHM \\n\", ev); return NULL; } 例外：允许cursor的SHM 直接送drm drm_debug(b, \"\\t\\t\\t\\t[view] not placing view %p on \" \"plane; SHM buffers must be ARGB8888 for \" \"cursor view\\n\", ev); 从日志看assign_plane output 0尝试混合模式： [repaint] could not build planes-only state, trying mixed [state] using renderer FB ID 164 for mixed mode for output DSI-1 (0) [state] scanout will use for zpos 0 [view] evaluating view 0x55a6da1d40 for output DSI-1 (0) [plane] started with zpos 18446744073709551615 [view] view 0x55a6da1d40 will be placed on the renderer [view] evaluating view 0x55a6d9d1f0 for output DSI-1 (0) [view] not assigning view 0x55a6d9d1f0 to plane (occluded by renderer views) [view] view 0x55a6d9d1f0 will be placed on the renderer [view] evaluating view 0x55a6da2210 for output DSI-1 (0) [view] ignoring view 0x55a6da2210 (occluded on our output) [view] evaluating view 0x55a6d8e060 for output DSI-1 (0) [view] ignoring view 0x55a6d8e060 (occluded on our output) [view] evaluating view 0x55a6d8eaf0 for output DSI-1 (0) [view] ignoring view 0x55a6d8eaf0 (occluded on our output) [view] evaluating view 0x55a6d8ccd0 for output DSI-1 (0) [view] ignoring view 0x55a6d8ccd0 (occluded on our output) [view] evaluating view 0x55a6d8efc0 for output DSI-1 (0) [view] ignoring view 0x55a6d8efc0 (occluded on our output) [view] evaluating view 0x55a6d72740 for output DSI-1 (0) [view] ignoring view 0x55a6d72740 (occluded on our output) [view] evaluating view 0x55a6e73a60 for output DSI-1 (0) [view] not assigning view 0x55a6e73a60 to plane (occluded by renderer views) [view] not assigning view 0x55a6e73a60 to plane (layer is or under BOS_SURFACE_LAYER_POSITION_BELOW) [view] view 0x55a6e73a60 will be placed on the renderer [view] evaluating view 0x55a6da0370 for output DSI-1 (0) [view] not assigning view 0x55a6da0370 to plane (occluded by renderer views) [view] view 0x55a6da0370 will be placed on the renderer [view] evaluating view 0x55a6d9f750 for output DSI-1 (0) [view] ignoring view 0x55a6d9f750 (not on our output) [view] evaluating view 0x55a6d9eb30 for output DSI-1 (0) [view] ignoring view 0x55a6d9eb30 (not on our output) [view] evaluating view 0x55a6d9df10 for output DSI-1 (0) [view] ignoring view 0x55a6d9df10 (not on our output) 测试output 0状态： [atomic] testing output 0 (DSI-1) state [CRTC:78] 23 (MODE_ID) -> 163 (0xa3) [CRTC:78] 22 (ACTIVE) -> 1 (0x1) [CRTC:78] 24 (VRR_ENABLED) -> 0 (0x0) [CONN:34] 20 (CRTC_ID) -> 78 (0x4e) [PLANE:49] 17 (FB_ID) -> 164 (0xa4) [PLANE:49] 20 (CRTC_ID) -> 78 (0x4e) [PLANE:49] 9 (SRC_X) -> 0 (0x0) [PLANE:49] 10 (SRC_Y) -> 0 (0x0) [PLANE:49] 11 (SRC_W) -> 113246208 (0x6c00000) [PLANE:49] 12 (SRC_H) -> 123731968 (0x7600000) [PLANE:49] 13 (CRTC_X) -> 0 (0x0) [PLANE:49] 14 (CRTC_Y) -> 0 (0x0) [PLANE:49] 15 (CRTC_W) -> 1728 (0x6c0) [PLANE:49] 16 (CRTC_H) -> 1888 (0x760) [PLANE:49] FORMAT: XRGB8888 [PLANE:49] 51 (alpha) -> 65535 (0xffff) 最终提交：------> 所有outPut [atomic] drmModeAtomicCommit [repaint] Using mixed state composition ------> // TODO: 哪一个plane？？ [repaint] view 0x55a6da1d40 using renderer composition [repaint] view 0x55a6d9d1f0 using renderer composition [repaint] view 0x55a6da2210 using renderer composition [repaint] view 0x55a6d8e060 using renderer composition [repaint] view 0x55a6d8eaf0 using renderer composition [repaint] view 0x55a6d8ccd0 using renderer composition [repaint] view 0x55a6d8efc0 using renderer composition [repaint] view 0x55a6d72740 using renderer composition [repaint] view 0x55a6e73a60 using renderer composition [repaint] view 0x55a6da0370 using renderer composition [atomic] applying output 0 (DSI-1) state // 【】 ----> 真正提交 [CRTC:78] 23 (MODE_ID) -> 163 (0xa3) [CRTC:78] 22 (ACTIVE) -> 1 (0x1) [CRTC:78] 24 (VRR_ENABLED) -> 0 (0x0) [CONN:34] 20 (CRTC_ID) -> 78 (0x4e) [PLANE:49] 17 (FB_ID) -> 38 (0x26) [PLANE:49] 20 (CRTC_ID) -> 78 (0x4e) [PLANE:49] 9 (SRC_X) -> 0 (0x0) [PLANE:49] 10 (SRC_Y) -> 0 (0x0) [PLANE:49] 11 (SRC_W) -> 113246208 (0x6c00000) [PLANE:49] 12 (SRC_H) -> 123731968 (0x7600000) [PLANE:49] 13 (CRTC_X) -> 0 (0x0) [PLANE:49] 14 (CRTC_Y) -> 0 (0x0) [PLANE:49] 15 (CRTC_W) -> 1728 (0x6c0) [PLANE:49] 16 (CRTC_H) -> 1888 (0x760) [PLANE:49] FORMAT: XRGB8888 [PLANE:49] 51 (alpha) -> 65535 (0xffff) [atomic] drmModeAtomicCommit [CRTC:78] setting pending flip [repaint] flushed pending_state 0x55a6e45060 [atomic][CRTC:78] flip processing started [atomic][CRTC:78] flip processing completed 1.4.5. 从物理\\硬件角度看Plane 0、对于最终的显示（应用角度） ，显示Zorder = 窗口管理的Zorder = 软件配置 + 硬件调整 1、 GPU能叠一些奇怪的图（（1）、大于屏幕的图、（2）圆角 （3）subsurface）（这些overlay做不到） 2、对于软件：上面的view优先尝试分配overlay的 ​ 目的： 减少GPU的负载 推论： 2_1、：抛开项目， weston原生逻辑，primary一定要在overlay之下的（上面的view先分配的overlay，如果overlay在下面，那么上面的view显示到primary下面了---------->上面的view被遮挡） 2_2 、必然：某一层用了GPU，以下都必须是GPU（TODO: 必然性在哪里？因为background一定走GPU，所有GPU最终只能合成一层？？？？？） 一些结论： 自然情况下，设计理念： 先管重要的（上面的最重要）-------------------------遍历views选择从上往下遍历 年轻人在前，老人兜底 -------------------------为充分利用效率，自然先尽量分配给overlay ​ 老人兜底 --------- primary在下 B的方式，不自然、反常： 不自然的点： primary弄上面了（因为A的割裂导致weston上面与下面的plane永久隔离） -------------> 后果，下面的overlay只能用作被遮挡场景 ​ 老人放前面--------------1、效率变低 ​ 2、（大致）意味着下面的overlay 无用了（这也是强制某个应用走的原因） 1.4.6. 补充特例--------霸屏scanout 效果： 图来源 结论： 1、霸屏和GPU合成一样，都是用的那块 primary plane -----------> 自然的， （1）目的一样：GPU合成目的也是拿到FullScreen的df （2）因为primary是每个屏必须的 代码实现角度： scanout_plane一定是 primary—plane 类型 自然 scanout_state->fb 的指向不同：霸屏下，是指向Client的fd；GPU合成是指向frameBuffer 2、霸屏的判断：自然是FullScreen 4、霸屏的唯一目的就是 阻止 合成。见 5、优点：一个client霸屏了，自然直接用client的fd 6、TODO: 霸屏 与 走overlay的 图，有本质区别嘛？ 7、composition只会在primary plane上发生。自然 8、物理角度决定了 full-screen 和 overlay，没有GPU的合成 1.4.7. 信息角度之 像素之旅 参考：像素之旅 整个图形，就是像素的生命周期： client像素: 产生--->流转给合成器 --->流转plane --->crtc ---->encoder ---->connector ----> 屏幕 像素的承载：buffer 1、GPU buffer -----> client OpenGL画的 & GPU 合成时： 这个时候是共享buffer？共享纹理？ 2、CPU buffer -----> CPU绘制 & CPU合成 3、交叉---GPU buffer & CPU buffer：存在内存Copy: GPU buffer copy给CPU buffer ！！！！！！！ ​ 例子：client OpenGL画的， 软件合成器 ​ TODO: 待验证 来源 结论： -从本质上讲： 1、Full-screen 与 overlay，没有任何区别 -------------> 自然，处理流程没有区别 ​ 唯一区别：df 是不是全屏的？ 2、Full-screen 与 primary plane 没有任何区别 ​ 唯一区别：后者有个 合成过程，见上图的 4和5 TODO: 上图中的GBM是啥？ 1.5. lib依赖结构(功能导致的) 图来源 └─ weston ├─ libexec_weston.so.0 │ ├─ libweston-11.so.0 │ │ ├─ libwayland-server.so.0 │ │ │ └─ libffi.so.8--用于在运行时根据调用接口描述生成函数跳板并调用。 │ │ ├─ libpixman-1.so.0--//【】 用于像素操作的库，包括region, box等计算。用了许多平台相关的优化。 │ │ │ └─ librga.so.2 │ │ ├─ libdrm.so.2--DRM compositor backend相关库文件。 │ │ ├─ libxkbcommon.so.0--主要用于键盘处理。 │ │ ├─ libmali_hook.so.1--GPU相关库文件。 │ │ │ ├─ libmali.so.1 │ │ │ │ ├─ libdl.so.2 │ │ │ │ ├─ libpthread.so.0 │ │ │ │ ├─ libdrm.so.2 │ │ │ │ ├─ libwayland-client.so.0 │ │ │ │ │ └─ libffi.so.8 │ │ │ │ ├─ libwayland-server.so.0 │ │ │ │ ├─ libstdc++.so.6 │ │ │ │ └─ libgcc_s.so.1 │ │ │ └─ libdrm.so.2 │ │ └─ libmali.so.1 │ ├─ libwayland-client.so.0 │ ├─ libwayland-server.so.0 │ ├─ libinput.so.10--InputManager相关，负责各种Input事件处理。输入处理，依赖于mtdev, libudev, libevdev等库。 │ │ ├─ libmtdev.so.1 │ │ ├─ libudev.so.1 │ │ └─ libevdev.so.2 │ ├─ libevdev.so.2 │ └─ ld-linux-aarch64.so.1 └─ libc.so.6 ------------> 来源 hideContent weston 　　libexec_weston.so.0 libweston-11.so.0 libwayland-server.so.0 libffi.so.8--用于在运行时根据调用接口描述生成函数跳板并调用。 libpixman-1.so.0--//【】 用于像素操作的库，包括region, box等计算。用了许多平台相关的优化。 librga.so.2 libdrm.so.2--DRM compositor backend相关库文件。 libxkbcommon.so.0--主要用于键盘处理。 libmali_hook.so.1--GPU相关库文件。 libmali.so.1 libdl.so.2 libpthread.so.0 libdrm.so.2 libwayland-client.so.0 libffi.so.8 libwayland-server.so.0 libstdc++.so.6 libgcc_s.so.1 libdrm.so.2 libmali.so.1 libwayland-client.so.0 libwayland-server.so.0 libinput.so.10--InputManager相关，负责各种Input事件处理。输入处理，依赖于mtdev, libudev, libevdev等库。 libmtdev.so.1 libudev.so.1 libevdev.so.2 libevdev.so.2 ld-linux-aarch64.so.1 　　libc.so.6 TODO: 如何用工具分析依赖关系？ -------> 反推架构 画的专业工具是？ 1.6. ============1层============= 1.7. 渲染流水线 图来源 EGL用于将本地窗口系统与OpenGL关联起来 ------> TODO: 如何理解？ 来源 真正来源 ----> als2015_wayland_weston_v2.pdf 1.7.1. TODO:Commit相关流程 https://blog.csdn.net/eydwyz/article/details/105799813 Wayland源码分析-Commit相关流程 1.8. 合成结果的处理 compositor backend 图： 图来源 compositor backend主要决定了compositor合成完后的结果怎么处置 荣： compositor backend 相当于 HWC？？？？？ 1.9. 多屏渲染流水线------important 《weston.eddx》 核心点： 1、每个屏幕固定周期发车 2、每个屏幕发车时间，没有任何关系！！！ 生活化模型，站在drm角度看图形流程： -why----最终目的： 1、drm发车，拉回client提供的货物 2、希望screen1的车子拿到 货物后 能准时返回（其他屏幕同理） who： 1、DRM---------货车总站 2、货物------像素数据 3、screen ---- 发车员 4、weston ------ 货物交易中心（client送货、货车取货的地方） 5、min_timer ------------- 交易员（只有一个） 6、client ----------- 提供货物的人 when重要节点： output_repaint -------------- 真正进行交易，client的东西 交给 货车的过程 output_repaint_timer_handler ----- 发车排班的班长 page_flip ------ 发车时刻 + 硬件周期，强约束 （自然：如果之前车子没回来commit，可能这次没有发车，但是周期性，是强制的！！！） ​ 在代码里，发了新车 page_flip ，也意味着 上一帧weston_output_finish_frame的结束 ​ 自然，会在这里计算本次车辆返回的时刻 基本规则： 1、硬件周期（发车时间）是一个强约束，|------1h-------|------1h-------|------1h-------|------1h-------| 车回程时刻不是！！！！ 2、只有一辆车（一个屏幕）：需要等车子回来（commit，并且硬件处理完成后），才能发下一班车。 期望：车子的来回限制在一个小时里 3、硬件周期， 对于weston是PageFlip（硬件周期约束） 对于安卓是vsync（不同点：安卓vsync信号给了应用） weston的多屏策略： 希望多个车子可以同时回程（多个屏幕统一提交） 优点： > 1、出现一个窗口跨屏时，可以完整显示（其实也不一定，另一个屏幕可能还没发车） 缺点： 任务过于集中，交易员在16ms内，未必做的完 特殊的点： 这里的Timer，按道理是并行的 -----> weston的做法是 求了min_Timer，最后所有outPut统一绘制 物理级的原因： weston的软件屏（一个） 是 所有硬键屏的总和（解决的问题场景：一个窗口，占两个屏时，不会不同步） weston的一帧画面，是所有output绘制了一帧 结论： weston的一帧，是所有屏的一帧 1.9.1. 从trace看多屏渲染流水线 1.9.2. 优化之 任务过于集中 -----> 模型之任务队列 模型之任务队列 ---------> 解决的问题：把集中的任务，平均化 即把CPU的使用，高峰，平均化 ------> 即 削峰 最坏情况，直接for循环调用 最好情况：刚刚满负荷，即一个任务完全执行完，另一个任务才加入队列 应用： 例子1：可以应用于weston，把 多屏串行，改成任务队列，提交到一个render线程上运行 TODO: 比较好的做法是，屏幕是线程级别的： 各个屏幕之间完全无关 -------------> 一个屏幕，一个线程（但是需要切换EGLcontext，耗时） 更优化的做法：屏幕是进程级别的： 2. 能量----从驱动力来看图形 2.1. client 与 server 之间的pingpong 2.1.1. C-S 之间 buffer的传递 待整理 https://blog.csdn.net/qqzhaojianbiao/article/details/129796828 Wayland中跨进程调用过程 以Weston自带的例程simple-shm为例： 共享内存，图： https://blog.csdn.net/qqzhaojianbiao/article/details/129796828#:~:text=wl_proxy%E7%9A%84event%E3%80%82-,%E8%BF%99%E4%B8%AA%E6%98%A0%E5%B0%84%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80,-%E7%A4%BA(%E4%BB%A5wl_registry TODO: 安卓的buffer是共享内存嘛？ 2.1.2. C的 wl_surface_commit 与 S的 wl_callback TODO: 模型图 simple-egl ------------- EGL的swapbuffer ------wl_surface_commit-----------------> - weston ​ 循环读取 时机： wl_surface_commit 时机：必然是client侧 redraw的结束 wl_callback时机：必然是 compositor 侧 repaint_out 的结束 simple-shm： server侧过来wl_callback消息 --> redraw --> wl_surface_commit simple-egl: egl流程：也走了 wl_callback client -> server: EGL的eglSwapBuffers:包括 交换buffer + commit surface（所以client端，没有看到调用wl_surface_commit！） server -> client： 【compositor】weston_output_repaint wl_callback_send_done -------【simple-egl】EGL 封装了callback的listener------------------- 【simple-egl】wl_display_dispatch 循环读取消息，处理 处理完所有事件，就redraw一帧 mesa注解： wl_callback_add_listener(dri2_surf->throttle_callback） sync callback so that we always give a chance for the compositor to handle the commit and send a release event before checking for a free buffer 总结： egl 与 weston交互**没有特别之处**（与shm一样） 唯一区别： ​ client侧看不到显式的 提交wl_surface_commit和接受wl_callback （都被EGL封装了！！！！！！！） 一个极其重要的结论： 从wayland协议角度（即接口调用角度），openGL就是 shm 推论： 技巧：如何阅读openGL，从shm例子理解 自然，wayland协议，opengl也逃脱不了 2.1.3. c侧的帧率统计（驱动力的帧率） 自然是， 统计redraw的 次数/时间 redraw的本质，就是 合成器给的wl_callback 触发 2.2. weston与drm之间的pingpong pingpong： weston ------> drm: drmModeAtomicCommit drm ------> weston: atomic_flip_handler drm ------> weston: 定时触发 compositor： TODO: 发车（图形整体的pingpong）： 是由drm决定的 3. 物质---从buffer看图形 TODO: 3.1. 待整理 TODO: 焦点：simple-egl 如何申请buffer？ surface_attach // 应用侧调用 【weston_buffer_from_resource】 // 往 weston_buffer填充真正的buffer内容（从wl_resource中获取） if ((shm = wl_shm_buffer_get(buffer->resource)) // 判断是不是shm ef：dmabuf = linux_dmabuf_buffer_get(buffer->resource) // dma 判断 格式：WL_SHM_FORMAT_ARGB8888（即DRM_FORMAT_ARGB8888）、_XRGB8888（即DRM_FORMAT_XRGB8888）、WL_SHM_FORMAT_C8 = 0x20203843 ef：solid = single_pixel_buffer_get(buffer->resource) // 纯色判断 格式：DRM_FORMAT_XRGB8888、DRM_FORMAT_ARGB8888 else: ec->renderer->fill_buffer_info(ec, buffer) // EGL类型的buffer buffer->legacy_buffer = (struct wl_buffer *)buffer->resource //【】 直接把wl_resource赋值给了buffer！！！！！ 向EGL查询 legacy_buffer 宽高和格式（很多：DRM_FORMAT_XRGB8888、DRM_FORMAT_ARGB8888、DRM_FORMAT_YUYV、DRM_FORMAT_NV12、DRM_FORMAT_YUV420） gb->images[i] = gr->create_image(gr->egl_display, EGL_WAYLAND_BUFFER_WL, buffer->legacy_buffer); // 【】 buffer转化为opengl的Image weston_buffer->renderer_private = gl_buffer_state //【】封装了 EGLImageKHR、textures 【weston_buffer_from_resource】 1、是一个频繁调用函数！！！！！（第一次会填充buffer，后面都是直接返回） 2、TODO: 虚拟机上simple-egl这里送过来的buffer是dmabuf。所以，可能是虚拟机的EGL做的！！！！！为了兼容 gl_renderer_attach // 【】 可见，GL啥buffer都能画！！！！！！ gl_renderer_attach_shm gl_renderer_attach_dmabuf gl_renderer_attach_egl glBindTexture(target, gb->textures[i]); gr->image_target_texture_2d(target, gb->images[i]); // 【】texture 与 image的绑定！！！！！！！！ gl_renderer_attach_solid TODO: 格式与buffer是两回事 【重要节点：client的gb->textures来源】 gl_renderer_attach gl_renderer_attach_shm // shm格式,似乎是做了转化？ ensure_textures for glGenTextures(1, &gb->textures[i]); // 【从buffer生成纹理】 gl_renderer_attach_egl // gl_buffer_state *gb = buffer->renderer_private glBindTexture(target, gb->textures[i]); // TODO: 直接从weston_buffer里拿到纹理-----> 【共享纹理】 展开： 【从buffer生成纹理】 【共享纹理】 3.2. 图形数据的承载者-----buffer： client surface_commit给 weston的图形数据 ---------------> TODO: 修改标题，目的是什么，为什么，功能是什么 因为不同的buffer类型，处理的方式不同。 自然，区分： struct weston_buffer { enum { WESTON_BUFFER_SHM, WESTON_BUFFER_DMABUF, WESTON_BUFFER_RENDERER_OPAQUE, WESTON_BUFFER_SOLID, } type; union { struct wl_shm_buffer *shm_buffer; // 【】终极承载者 void *dmabuf; // 【】 void *legacy_buffer; // 【】 egl数据!!!!!!! struct weston_solid_buffer_values solid; // 【】 }; } 处理方式差异： gl_renderer_attach_shm // gl_renderer_attach_egl //创建对应surface buffer的egl_image，激活绑定纹理。 gl_renderer_attach_dmabuf //使用dmabuf时的函数 为什么处理方式会不一样？ 最最最本质的原因是什么？ 图形加速硬件要求： 1、物理连续且 2、符合对齐要求的内存 如果是普通共享内存，一般是物理不连续的----------->多数情况用软件渲染。 ------------->参考 gpt给出的对比： 缓冲区类型 描述 机制 物理层特性 用途 WESTON_BUFFER_SHM 共享内存缓冲区：使用共享内存机制进行数据存储和访问。 POSIX 或 System V 共享内存 通过标准操作系统机制共享内存 客户端和服务器之间的一般图像数据共享 WESTON_BUFFER_DMABUF DMA 缓冲区：使用 DMA-BUF 机制，在设备之间高效共享缓冲区数据。 DMA-BUF（直接内存访问缓冲区） 通过 DMA 共享内存，允许设备直接访问数据而无需复制 GPU 和显示设备之间的高性能数据共享 WESTON_BUFFER_RENDERER_OPAQUE 渲染器不透明缓冲区：由 OpenGL 等外部渲染器管理；数据对 Weston 不透明。 OpenGL 或类似图形渲染器 由外部渲染系统管理，数据不可直接访问 由外部系统管理的渲染任务 WESTON_BUFFER_SOLID 纯色缓冲区：存储单一颜色值，用于简单背景或覆盖。 颜色值存储 不存储实际图像数据，仅存储颜色值 简单的颜色填充 这些缓冲区类型在物理层面的本质区别主要在于它们的数据存储和访问机制，以及它们在不同使用场景中的性能和效率。 ——来自AI问答宝 https://ai.wendabao.net 3.3. 从buffer角度来看渲染流水线： 3.3.1. 物理 物理基础： 移动平台上，没有专门的显存 --------》 所以，GPU在移动平台上，使用的物理内存是CPU内存。来自 SHM（ 普通共享内存） 分配者： CPU malloc分配 -------> 自然，CPU认 ------> 自然，CPU软件渲染 ​ 例外：GPU也可以用，但是要做一次copy，转化为连续的？？？？ TODO 物理特性： 物理不连续的（CPU软件渲染的根本原因） 图像格式：RGBA ----CPU认识的格式 例外情况--------SHM的合成：因为DRM不认识（~~不是DRM分配的~~），只能GPU兜底。但是GPU又不能使用不连续内存，所以，有一次copy 总结，SHM的缺点： （1）DRM不认识（导致不能绑plane，必须GPU合成转一道） （2）GPU半认识（需要重新copy成连续内存） DMA: DMA传fd，0 copy，全程GPU用（从client到drm），CPU没有用； SHM GPU用不了，所以有copy GEM: 分配者： DRM驱动 分配的buffer ------> 自然，drm认识 ------> 自然，可以绑定plane（直接送drm） 补充：SHM，有许多格式： enum wl_shm_format { WL_SHM_FORMAT_ARGB8888 = 0, WL_SHM_FORMAT_XRGB8888 = 1, WL_SHM_FORMAT_YVYU WL_SHM_FORMAT_UYVY .................... } TODO: 物理级 区别是啥？ 影响是啥？ 3.3.2. C-S Client buffer： 类型 wl_buffer 向weston侧申请 具体物理：GPU????? FrameBuffer: 类型 gbm_surface 向GBM侧申请 output->gbm_surface = gbm_surface_create(gbm, mode->width, mode->height, output->format->format, output->gbm_bo_flags); 【4】从gbm 创建gbm_surface（封装了最终的FrameBuffer） 3.3.3. gbm_surface buffer 问题：怎么给weston侧的OpenGL使用的？？？？ drm_output_init_egl中，创建 指定了 (EGLNativeWindowType) output->gbm_surface; 所以，没有glBindFramebuffer之前，都是在gbm提供的缓冲区里操作的 切换缓冲区： glBindFramebuffer(GL_FRAMEBUFFER, fbo); // 使用新帧缓冲 【glBindFramebuffer(fbo)】 用作离屏渲染，TODO: 补充weston中例子。 glBindFramebuffer(GL_FRAMEBUFFER, 0); // 切换回默认帧缓冲 （不进行bind，走的就是默认！） 参考： https://blog.csdn.net/a277539277/article/details/129360001 【glBindFramebuffer(fbo)】 1、用作离屏渲染，TODO: 补充weston中例子。 2、自然，离屏渲染之后，还要切回默认，继续渲染屏幕内容 commit与swap什么关系？ https://www.jb51.net/article/264157.htm 3.3.4. wl_buffer TODO: 这块buffer是 client向weston申请的。。。。weston做了什么事情？最终应该是GPU的！！！TODO 结论： swap 是 client 告诉OpenGL（swap的对象是buffer，surface没变） commit是 client告诉 weston（commit的对象是 surface，buffer不用管） 补充： surface是对外呈现，buffer是被封装的。。。不会出现在weston接口里！！！！ 证明： 3.3.5. eglSwapBuffers接口实现说明 https://blog.csdn.net/qiuyun0214/article/details/54614892 双缓冲，是封装在内部，我们不用关心 buffer 但是需要知道swap时机------------------------即redraw完 图来源：https://blog.csdn.net/kongbaidepao/article/details/109904963 3.3.6. dma-buf 文章 好文： https://blog.csdn.net/hexiaolong2009/article/details/102596744 dma-buf 系列文章 https://blog.csdn.net/hexiaolong2009/category_10838100.html dma-buf 专题 3.4. 待整理2 从客户端发送过来的 wl_buffer，如何转化成 pixels数据呢 ChatGPT said: ChatGPT 在 Wayland 环境中，wl_buffer 代表客户端发送到显示服务器（compositor）的图像数据。为了将 wl_buffer 转换为像素数据，需要根据它的类型获取其内存地址，并解析出颜色和透明度等像素信息。通常，wl_buffer 可以来自共享内存 (wl_shm_buffer) 或图形驱动层（如 EGL 和 GBM）。以下介绍如何从 wl_buffer 获取像素数据，具体取决于 wl_buffer 的来源。 3.4.1. 1. 从 wl_shm_buffer 转换为像素数据 如果客户端通过 wl_shm 发送 wl_buffer，该缓冲区存储在共享内存中，通常以 WL_SHM_FORMAT_ARGB8888 或类似格式提供。可以通过 wl_shm_buffer_get() 获取共享内存缓冲区，并从中提取像素数据。 步骤： 检查 wl_buffer 是否是 wl_shm_buffer 使用 wl_shm_buffer_get() 来确定 wl_buffer 是否是通过共享内存传递的缓冲区。 cCopy codestruct wl_shm_buffer *shm_buffer = wl_shm_buffer_get(buffer->resource); if (!shm_buffer) { // buffer 不是 wl_shm_buffer，处理其他类型的 buffer（例如 GBM/EGL buffer） return; } 获取缓冲区格式、宽度、高度和步幅 获取缓冲区的格式、宽度、高度以及每行的字节数（步幅）。 cCopy codeenum wl_shm_format format = wl_shm_buffer_get_format(shm_buffer); int width = wl_shm_buffer_get_width(shm_buffer); int height = wl_shm_buffer_get_height(shm_buffer); int stride = wl_shm_buffer_get_stride(shm_buffer); 锁定缓冲区并读取像素数据 调用 wl_shm_buffer_begin_access() 来锁定共享内存缓冲区，然后通过 wl_shm_buffer_get_data() 获取原始像素数据指针。 cCopy codewl_shm_buffer_begin_access(shm_buffer); // 锁定缓冲区 void *data = wl_shm_buffer_get_data(shm_buffer); 解析像素值 根据缓冲区的格式解析每个像素的值。对于常见的 WL_SHM_FORMAT_ARGB8888 格式，32位的每个像素可以分解为 Alpha、Red、Green 和 Blue 通道。 cCopy codeif (format == WL_SHM_FORMAT_ARGB8888) { uint32_t *pixels = (uint32_t *)data; for (int y = 0; y > 24) & 0xFF; uint8_t red = (pixel >> 16) & 0xFF; uint8_t green = (pixel >> 8) & 0xFF; uint8_t blue = pixel & 0xFF; // 处理 alpha, red, green, blue 数据 } } } 解锁缓冲区 在解析完数据后，解锁缓冲区。 ``` c Copy code wl_shm_buffer_end_access(shm_buffer); // 解锁缓冲区 ``` 3.4.2. 2. 从 GBM/EGL buffer 转换为像素数据 如果 wl_buffer 是通过 EGL 或 GBM 传递的，那么这种缓冲区通常是由 GPU 管理的，不像 wl_shm 那样简单获取共享内存中的数据。要获取像素数据，需要使用与 GBM 相关的接口来处理这些缓冲区。 步骤： 使用 gbm_bo_import 导入 wl_buffer 通过 gbm_bo_import 函数，将 wl_buffer 转换为 GBM 缓冲区对象。 cCopy codestruct gbm_bo *bo = gbm_bo_import(gbm_device, GBM_BO_IMPORT_WL_BUFFER, buffer->resource, GBM_BO_USE_SCANOUT); if (!bo) { fprintf(stderr, \"Failed to import wl_buffer to gbm_bo\\n\"); return; } 获取 gbm_bo 的信息 获取导入的 gbm_bo 的宽度、高度和格式。 cCopy codeint width = gbm_bo_get_width(bo); int height = gbm_bo_get_height(bo); int stride = gbm_bo_get_stride(bo); uint32_t format = gbm_bo_get_format(bo); 映射 gbm_bo 缓冲区到CPU可访问的内存 使用 gbm_bo_map() 将 GPU 缓冲区映射到可访问的内存中，以便读取像素数据。 cCopy codevoid *data = gbm_bo_map(bo, 0, 0, width, height, GBM_BO_TRANSFER_READ, &stride, &map_data); if (!data) { fprintf(stderr, \"Failed to map gbm_bo to CPU accessible memory\\n\"); gbm_bo_destroy(bo); return; } 读取像素数据 解析映射后的数据，类似于 wl_shm_buffer。 cCopy codefor (int y = 0; y > 16) & 0xFF; uint8_t green = (pixel >> 8) & 0xFF; uint8_t blue = pixel & 0xFF; // 处理颜色数据 } } 解除映射并释放 gbm_bo 完成数据处理后，解除映射并释放 gbm_bo。 cCopy codegbm_bo_unmap(bo, map_data); gbm_bo_destroy(bo); 3.4.3. 3. 其他方式：通过 EGL 或 OpenGL 读取像素 对于通过 EGL 发送的 wl_buffer，如果你已经设置了 EGLContext，你可以使用 glReadPixels() 函数从 EGL 表面读取像素数据。 Copy code glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixel_data); 3.4.4. 总结 wl_shm_buffer：通过共享内存发送的缓冲区，可以直接访问内存中的像素数据。 GBM/EGL buffer：需要通过 gbm_bo_import 导入 wl_buffer，然后通过 gbm_bo_map 映射到 CPU 可访问的内存，才能读取像素数据。 EGL/OpenGL buffer：可以通过 OpenGL 的 glReadPixels 获取渲染后的像素数据。 根据 wl_buffer 的来源和格式，选择合适的处理方式。 4. 霸屏模式 4.1. 必要条件（物理层面） 1、全屏 & 不透明(opaque) 2、自然，层级要顶层，要遮住其他所有view 3、关键物理因素：drm要能识别对应buffer的fd（自然，weston能够拿到 client的buffer的fd） drm_fb_get_from_paint_node drm_fb_get_from_view 补充： 满足1和2，但是不满足3，显示上似乎是霸屏模式，但是实际还是GPU合成了！！！！！ 4.2. 必要条件的代码大纲 1、opaque：需要client告诉合成器： // 配置端----client： simple-egl.c if (window->opaque || window->fullscreen) { region = wl_compositor_create_region(window->display->compositor); wl_region_add(region, 0, 0, INT32_MAX, INT32_MAX); wl_surface_set_opaque_region(window->surface, region); // 关键一行 wl_region_destroy(region); // 生效端------compos, 绑定plane时 totally_occluded = !pixman_region32_not_empty(&surface_overlap); if (totally_occluded) { // 【】 关键一行：totally_occluded的view，会自动被忽略掉 drm_debug(b, \"\\t\\t\\t\\t[view] ignoring view %p \" \"(occluded on our output)\\n\", ev); // 【】 关键日志 pixman_region32_fini(&surface_overlap); pixman_region32_fini(&clipped_view); continue; } -总之，结论： 全屏opaque client，会霸屏，即： 1、被遮挡view----------合成器自动忽略 2、霸屏view，如果能被drm识别，会直接送给drm 4.3. 关键性日志： Layer 3 (pos 0xb0000000): View 0 (role xdg_toplevel, PID 4239, surface ID 20, top-level window 'simple-egl' of org.freedesktop.weston.simple-egl, 0x55723634e0): position: (0, 0) -> (1080, 1920) [fully opaque] // 【】完全opaque outputs: 0 (DSI-1) (primary) dmabuf buffer [2 references may use buffer content] format: 0x34324241 ABGR8888 modifier: LINEAR (0x0) width: 1080, height: 1920 View 1 (role (null), PID 0, surface ID 0, black background surface for top-level window 'simple-egl' of org.freedesktop.weston.simple-egl, 0x557239b8e0): position: (0, 0) -> (1080, 1920) [fully opaque] outputs: 0 (DSI-1) (primary) solid-colour buffer [R 0.000000, G 0.000000, B 0.000000, A 1.000000] [2 references may use buffer content] format: 0x34325258 XRGB8888 modifier: LINEAR (0x0) width: 1, height: 1 [repaint] trying planes-only build state ---------> // 【】 尝试plane-only一定要成功 //[repaint] could not build planes-only state, trying mixed // 没有mixed一行！！！！！！！！ 4.4. TODO: weston 10上不生效 原因，不详 5. 显示性能优化 5.1. 优化之 只重绘damage区域 5.1.1. 标记 damage区域----大纲之【计算damage】： 1、client设置 surface_damage 2、合成侧标记： weston_view_damage_below 3、移动窗口 -view->plane->damage 自然，我们的终极目的是plane的damage！！！！（view的damage，更新到plane的damage上！！！） 5.1.2. 如何做到只重绘damage呢（how） // 遍历node： draw_paint_node pixman_region32_intersect(&repaint, &pnode->view->transform.boundingbox, damage); // repaint 区域是 damage与 view的交集 pixman_region32_subtract(&repaint, &repaint, &pnode->view->clip); // 去掉clip区域 【】 -----------> 结论： 静止的窗口，repaint区域为空（每个view都会遍历到） TODO: pnode->view->transform.boundingbox 与 weston_surface的宽高区别 ​ pnode->view-> transform.position 以及 weston_view的位置，之间的区别 【】 clip区域是啥？ TODO： 似乎是不需要重绘的 6. TODO: 消息驱动模型？ epoll机制： 图来源 特点：串行 具体对比： binder weston事件机制 原理 epoll 是否并行化？ 基于线程的并行？？？ 串行 优点 不会有同步的开销 缺点 自然 有一个事件耗时，会阻塞其他 参考： 6.1. weston的消息循环驱动模型 参考： https://blog.csdn.net/qqzhaojianbiao/article/details/129796828 Wayland中跨进程调用过程 消息处理模型！！！！！！！ https://blog.csdn.net/goodboychina/article/details/26145175 Wayland消息队列 https://www.cnblogs.com/Arnold-Zhang/p/15915635.html wl_dispaly_dispatch线程安全分析 client接口： wl_display_dispatch 作用：读取消息Queue（结构：client侧，server侧放入） TODO: Queue 代码大纲： 【client接口】wl_display_dispatch wl_display_dispatch_queue ------------------\\code\\wayland\\src\\wayland-client.c------- wl_display_dispatch_queue_pending(display, queue) dispatch_queue(display, queue) 遍历queue，dispatch_event, 赋值给closure wl_closure_dispatch（即client设置的lisner） // 【listener 处理事件】 具体listener见下: server往client的Queue写： TODO: 补充【listener 处理事件】：client侧 wl_proxy listener wl_pointer_add_listener() 鼠标消息处理 wl_keyboard_add_listener() 键盘消息处理 wl_callback_add_listener() wl_callback 由wl_surface_frame() 创建，每当服务器显示下一帧使会给wl_callback发送一条消息。 原文链接：https://blog.csdn.net/goodboychina/article/details/26145175 7. weston事件分发逻辑 -基本原则： 事件分发层级 = 窗口管理层级（大调：weston layer层级，小调：weston view_list），即weston framework层的软件层级 技巧，可以判定 软件层级： 将两个窗口重叠，拖动 -----------> 拖动的窗口一定在上（事件是从上往下分发的） 注：可能是两个layer，也可能是同一layer，不同view_list层级 -显示层级 = 窗口管理层级 + 合成层级 + plane分配层级 + 硬件plane配置层级 8. weston启动 参考： https://linduo.blog.csdn.net/article/details/122790158 【Wayland】Weston启动流程分析 系统启动流程： 图来源 8.1. 启动代码大纲 compositor/executable.c/main()--> compositor/main.c-->wet_main() -->verify_xdg_runtime_dir()//XDG_RUNTIME_DIR环境变量检查 -->wl_display_create//创建wayland显示对象 -->wl_display_get_event_loop -->wl_event_loop_add_signal -->load_configuration //加载weston.ini -->weston_config_get_section \\ weston_config_section_get_bool\\ weston_config_section_get_string -->weston_choose_default_backend //x11-backend.so -->weston_compositor_create //创建 compositor 实例 -->weston_plane_init // 【】读取drm 的plane信息 -->wl_data_device_manager_init -->wl_display_init_shm -->weston_layer_init(&ec->fade_layer, ec); -->weston_layer_init(&ec->cursor_layer, ec); -->wl_display_add_protocol_logger -->weston_compositor_init_config -->load_backend //根据启动参数-b，显式加载后端显示接口 -->load_x11_backend //use-pixman? cpu:gpu -->weston_compositor_load_backend -->weston_load_module //x11-backend.so -->weston_backend_init -->x11_backend_create //use pixman?pixman_renderer_init:init_gl_renderer -->init_gl_renderer //weston_load_module(gl-renderer.so) //或： -->load_drm_backend -->weston_compositor_load_backend(c, WESTON_BACKEND_DRM,&config.base); -->weston_load_module(backend_map[backend], \"weston_backend_init\"); -->weston_compositor_log_capabilities -->wl_client_create -->weston_compositor_wake -->execute_autolaunch -->wl_display_run 参考： 03-weston启动过程 // output 对应的 possible_crtcs 时机： drm_output_create drm_output_enable(struct weston_output *base) // 屏幕级别 drm_output_attach_crtc(output) //【】output 与 crtc的 绑定 possible_crtcs &= drm_connector_get_possible_crtcs_mask(&head->connector); // 拿到屏幕对应的connector 遍历drmModeConnector获取encoder = drmModeGetEncoder 从 possible_crtcs |= encoder->possible_crtcs encoder中获取possible_crtcs //【】关键一行，拿到屏幕对应的 drm_output_init_planes(output) drm_output->scanout_plane = drm_output_find_special_plane 寻找的primary作为 drm_output_pageflip_timer_create(output) drm_output_init_egl(output, b) 挂output的各种钩子： output->base.start_repaint_loop = drm_output_start_repaint_loop output->base.repaint = drm_output_repaint output->base.assign_planes = drm_assign_planes weston进程拉起 shell 进程的细化： weston: 安卓systemServer + SF weston-desktop-shell : 安卓SystemUI + launcher ​ 即，系统全局的界面，比如panel, background, cursor, app launcher, lock screen等 weston-keyboard（软键盘面板）：安卓 输入法 weston-screenshooter： 安卓截屏 weston-screensaver：安卓屏保 一些思考： （1）从功能角度，为什么要剥离SystemUI逻辑呢？（从系统服务里）： 方便定制化修改这部分逻辑。系统服务逻辑，是稳定的 -----> 设计思路：稳定的逻辑放一起，不稳定的放一起 8.2. 代码目录结构 图来源 其中: ├── clients--包含weston-desktop-shell、weston-keyboard、weston-screenshooter，以及一些client示例。 ├── compositor--输出weston主程序，以及libexec_weston.so.0.0.0、screen-share.so等库文件。 ├── data ├── desktop-shell--desktop-shell.so ├── doc ├── fullscreen-shell--fullscreen-shell.so ├── include ├── ivi-shell--ivi-shell.so ├── kiosk-shell--kiosk-shell.so ├── libweston--输出libweston-11.so.0.0.0库文件，以及一系列compositor backend：drm-backend.so；render backend：gl-renderer.so。 ├── pam ├── pipewire ├── protocol--Wayland协议xml文件。 ├── README.md ├── releasing.md ├── remoting ├── shared ├── shell-utils ├── tests--测试程序。 └── xwayland--使用X11作为compositor backend的XWayland。 8.3. TODO: 如何在启动时 观察到 各种plane的上下级关系？ drm驱动给到weston的plane日志，但是似乎不是硬件的上下关系！！！！！！！！ [drm-backend] zpos property not found. Using invented immutable zpos values: [plane] primary plane 49, zpos_min 0, zpos_max 0 [plane] overlay plane 70, zpos_min 7, zpos_max 7 [plane] overlay plane 74, zpos_min 7, zpos_max 7 [plane] primary plane 110, zpos_min 0, zpos_max 0 [plane] overlay plane 114, zpos_min 7, zpos_max 7 [plane] primary plane 126, zpos_min 0, zpos_max 0 [plane] primary plane 132, zpos_min 0, zpos_max 0 [plane] primary plane 138, zpos_min 0, zpos_max 0 [plane] primary plane 144, zpos_min 0, zpos_max 0 [plane] primary plane 150, zpos_min 0, zpos_max 0 注： （1）正常屏幕，上面的窗口，优先分配overlay ----------> 所以overlay在上 ​ （2）驱动给的plane顺序 必须 等于物理层级顺序 （驱动寄存器配置错误时，就会颠倒） 所有display信息： [17:28:41.052] get screen_map info success, name = DSI-1, width = 1728, height = 1888, x = 0, y = 0, refresh = 59468 [17:28:41.052] get screen_map info success, name = eDP-1, width = 3840, height = 720, x = 1728, y = 0, refresh = 60000 [17:28:41.052] get screen_map info success, name = DP-1, width = 3840, height = 720, x = 5568, y = 0, refresh = 60000 [17:28:41.052] get screen_map info success, name = DP-2, width = 1920, height = 1080, x = 9408, y = 0, refresh = 60000 [17:28:41.052] get screen_map info success, name = DSI-2, width = 1920, height = 384, x = 11328, y = 0, refresh = 59999 [17:28:41.052] get screen_map info success, name = DSI-3, width = 1728, height = 1888, x = 13248, y = 0, refresh = 60032 9. weston之多屏 1、发车pageFlip不是统一 repaint和提交给drm，是统一的 见《when---生命周期图 0层》图 2、outPut-> viewlist 这个viewlist是系统级别的！！！！！不是屏幕级别的！！！！！ 10. 休眠与唤醒 10.1. weston12原生 使用keyboard唤醒的： session_notify ---------------------wake-------------------------- weston_compositor_wake weston_compositor_damage_all // 【】 所有output都damage ---------------------wake-------------------------- weston_compositor_offscreen; for遍历：output->repaint_needed = false; // 关闭所有的 11. 其他 次要功能 11.1. weston 截屏 & 录屏 11.1.1. 操作 截屏： 命令方式（需要debug模式运行）： weston --debug // 【】 weston-screenshooter 快捷键： Win+s -----------> 验证OK ------------------> 待完善功能，按照窗口截屏 录屏： 命令方式： TODO: 快捷键： Win+r 开始/停止屏幕录制 -----------> 验证OK 生成.wcap 格式的文件，这是一种低损耗的 weston 专有格式，可 以通过 wcap 工具进行解码: wcap-decode --yuv4mpeg2 capture.wcap > capture.y4m y4m 是一种原始格式，可以使用 vlc 打开，也可以使用 ffmpeg 进行编码: ffmpeg -y -i capture.y4m -c:v libx264 -pix_fmt yuv420p capture.mp4 11.1.2. 原理： 参考： 按键screenshot ------> 原理 Weston 桌面使用简介 weston桌面weston-screenshooter截图方法 图来源 11.1.3. 待整理 必然，初始化时机： weston_screenshooter_shoot 绑定frame_signal信号 和 screenshooter_frame_notify 触发信号 weston_capture_source_v1_capture(wl_resource *buffer_resource) // client来的buffer weston_capture_task_create // weston侧创建 截屏任务 weston_output_schedule_repaint // 强迫去绘制一帧 信号执行： gl_renderer_repaint_output // 或者gl_pixmal 一样 ----------------------绘制的动作-------------- gl_renderer_do_capture_tasks gl_renderer_do_capture(buffer) // 任务list里拿到空容器buffer assert(into->type == WESTON_BUFFER_SHM); // screenShoter给的buffer，一定要是shm类型的！！！ glReadPixels(read_target) // 【】关键一行，从GPU里拿 wl_signal_emit(&output->frame_signal, output_damage); frame_signal信号通知 screenshooter_frame_notify l->buffer->shm_buffer // 【】各种PIXMAN_格式数据，都被copy到shm_buffer（pixels） malloc 图像的buffer： stride = l->buffer->width * (PIXMAN_FORMAT_BPP(pixman_format) / 8); pixels = malloc(stride * l->buffer->height); weston_buffer *buffer = gs->buffer_ref.buffer // ------------------------------信号机制------------------ 绑定处理： 触发信号： wl_signal_emit(&output->frame_signal, output_damage); 11.2. 一些量的级别 weston_output /drm_output(自然scanout屏幕级别) ------------- 屏幕级 ​ drm_output--->drm_device 屏幕 plane_list ---- 系统级 （所有屏幕的） ---> 分配时，考虑了plane-output绑定关系（weston有拿到drm配置的 plane与crtc（output）绑定关系 drm_assign_planes(weston_output) --------------屏幕级别 output----->paint_node_z_order_list -------> outPut级别 drm_device ------> 即屏幕的软件抽象 struct drm_output { struct weston_output base; struct drm_backend *backend; struct drm_device *device; // 屏幕 struct drm_crtc *crtc; ----> // 【】硬件crtc，屏幕级！！！！ 11.3. weston日志 关键标识 output对应的屏幕 ----------> output->base.name 12. 次要---GStreamer——gst-launch-1.0 参考：GStreamer——gst-launch-1.0 作用： 调试工具 12.1. 在Linux上播放视频 例1： gst-launch-1.0 videotestsrc ! autovideosink 管道起始点 连接 管道的终点 gst-launch-1.0 videotestsrc ! autovideosink ! waylandsink sync=false render-rectangle=\"\" 效果: 图来源 例2：播放网络视频： gst-launch-1.0 playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm 图片来源 ---------> TODO: 基于此，可以看weston上视频是如何合成的！ 例3：指定分辨率 gst-launch-1.0 videotestsrc ! video/x-raw, width=1920, height=1080 ! autovideosink 功能、结构、配置，永恒的主题 都要（5w2h） 例4：播放本地视频 gst-launch-1.0 playbin uri=file:///home/kent/workingspace_disk2/scripts/gstream/image/Raindrops_Videvo.mp4 报错： missing element H.264 安装： sudo apt-get install gstreamer1.0-plugins-ugly gstreamer1.0-libav 12.2. 播放图片 法一： gst-launch-1.0 playbin uri=file:///home/workingspace_disk2/scripts/gstream/image/mountain.jpeg video-sink=\"imagefreeze ! videoconvert ! autovideosink\" & sleep 10000 ; kill $!其中 #其中 10000是时间 ----------------> weston上可以用 法二： weston-image 13. weston的client------能力展示&功能入口 参考： https://wiki.st.com/stm32mpu/wiki/Wayland_Weston_overview Wayland开发入门系列1： 运行测试程序 13.1. 图片查看 weston-image： weston-image rose-flower-blossom-bloom-39517.jpeg rose-flower-blossom-bloom-39517.jpeg 优点：可以 放大 & 移动 image 13.2. weston-eventdemo 事件实时显示 展示了 touch事件 和 key事件 技巧： 把client全屏，就可以像安卓一样，实时显示touch位置了 13.3. editor-----展示输入法框架能力 TODO: 居然有控件？？？？？ 13.4. dnd ------ 窗口之间传递 Drag and drop 13.5. constraint 限制鼠标出边界 展示了画连续线的能力： 13.6. transformed 13.7. scaler 13.8. 其他： “weston-terminal”是一个简单的终端模拟器，不是很兼容但工作得足够好的bash “weston-flower”在屏幕上画了一朵花，测试框架协议 “weston-gears” wayland的glxgears “weston-smoke”测试SHM缓冲区共享 “weston-image”加载在命令行上传递的图像文件并显示它们 “weston-view”对pdf文件也有同样的作用 “weston-resizor”显示窗口大小（使用上下键） “weston-eventdemo”报告libtoytoolkit的事件到控制台（参见weston-eventdemo --help） ———————————————— 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 原文链接：https://blog.csdn.net/qq_26056015/article/details/122216771 14. 维测 14.1. 限定模块范围（SCOPE）的日志 --logger-scopes=SCOPE 14.1.1. drm-backend日志 weston --logger-scopes=drm-backend --------> ok Output 0 (Virtual-1): // 【】 Output 0 信息 position: (0, 0) -> (1920, 970) mode: 1920x970@60.000Hz scale: 1 repaint status: repaint scheduled next repaint: 108788.723125666 Head 0 (Virtual-1): connected Layer 0 (pos 0xffffffff): View 0 (role (null), PID 0, surface ID 0, desktop shell fade surface for Virtual-1, 0x5a553ad5e1e0): position: (0, 0) -> (1920, 970) [not opaque] alpha: 0.039004 outputs: 0 (Virtual-1) (primary) solid-colour buffer // 【】view对应的buffer [R 0.000000, G 0.000000, B 0.000000, A 1.000000] [2 references may use buffer content] format: 0x34325258 XRGB8888 modifier: LINEAR (0x0) width: 1, height: 1 14.2. 启动日志 $ weston Date: 2024-07-15 HKT [14:46:44.556] weston 12.0.2 https://wayland.freedesktop.org Bug reports to: https://gitlab.freedesktop.org/wayland/weston/issues/ Build: 12.0.2 [14:46:44.556] Command line: weston [14:46:44.556] OS: Linux, 6.2.0-36-generic, #37~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Oct 9 15:34:04 UTC 2, x86_64 [14:46:44.556] Flight recorder: enabled [14:46:44.556] Starting with no config file. [14:46:44.556] Output repaint window is 7 ms maximum. [14:46:44.556] Loading module '/home/cjk/weston_install/lib/x86_64-linux-gnu/libweston-12/x11-backend.so' // 【】 这里说明了使用什么后端 [14:46:44.557] Loading module '/home/cjk/weston_install/lib/x86_64-linux-gnu/libweston-12/gl-renderer.so' [14:46:48.343] Using rendering device: /dev/dri/renderD128 [14:46:48.343] EGL version: 1.4 [14:46:48.343] EGL vendor: Mesa Project [14:46:48.343] EGL client APIs: OpenGL OpenGL_ES [14:46:48.343] EGL features: EGL Wayland extension: yes context priority: no buffer age: yes partial update: no swap buffers with damage: yes configless context: yes surfaceless context: yes dmabuf support: modifiers [14:46:48.345] GL version: OpenGL ES 3.0 Mesa 23.0.4-0ubuntu1~22.04.1 [14:46:48.345] GLSL version: OpenGL ES GLSL ES 3.00 // 【】说明 OpenGL ES的版本 [14:46:48.345] GL vendor: VMware, Inc. [14:46:48.345] GL renderer: SVGA3D; build: RELEASE; LLVM; [14:46:48.349] GL ES 3.0 - renderer features: read-back format: ARGB8888 // 【】 TODO glReadPixels supports y-flip: yes wl_shm 10 bpc formats: yes wl_shm 16 bpc formats: no wl_shm half-float formats: no internal R and RG formats: yes OES_EGL_image_external: yes [14:46:48.349] Using GL renderer [14:46:48.352] Registered plugin API 'weston_windowed_output_api_v2' of size 16 [14:46:48.352] Color manager: no-op [14:46:48.352] Output 'screen0' attempts EOTF mode: SDR [14:46:48.352] Output 'screen0' using color profile: built-in default sRGB SDR profile [14:46:48.352] Chosen EGL config details: id: 5 rgba: 8 8 8 0 buf: 24 dep: 0 stcl: 0 int: 0-1000 type: win|pix|pbf vis_id: 0x21 [14:46:48.352] x11 output 1024x600, window id 14680069 // 【】 output大小 [14:46:48.352] Output 'screen0' enabled with head(s) screen0 [14:46:48.352] Compositor capabilities: arbitrary surface rotation: yes screen capture uses y-flip: yes cursor planes: no arbitrary resolutions: no view mask clipping: yes explicit sync: yes color operations: no presentation clock: CLOCK_MONOTONIC_RAW, id 4 presentation clock resolution: 0.000000001 s [14:46:48.352] Loading module '/home/cjk/weston_install/lib/x86_64-linux-gnu/weston/desktop-shell.so' // 【】这里说明使用了什么桌面 [14:46:48.352] launching '/home/cjk/weston_install/libexec/weston-keyboard' [14:46:48.353] launching '/home/cjk/weston_install/libexec/weston-desktop-shell' TODO: 角度之启动日志 ​ 初始化日志 14.3. export WAYLAND_DEBUG=1 14.4. dump dump surfaceFlinger： weston-debug scene-graph 注意：只能在arm后端的环境下使用 14.5. weston区域维测-----打印矩形 pixman_region32_t 的打印： // 打印 pixman_box32_t static void print_box(pixman_box32_t* box) { if (box) { weston_log(\"Box: (%d, %d, %d, %d).\\n\", box->x1, box->y1, box->x2, box->y2); } } // 打印 pixman_region32_t static void print_region(char* tag, const pixman_region32_t* region) { if (region) { int num_rects; const pixman_box32_t* rects = pixman_region32_rectangles(region, &num_rects); weston_log(\"%s, Region has %d rectangles.\\n\", tag, num_rects); for (int i = 0; i 15. TODO: 问题定位 见微知著 之 突变点 有成功的，必然你能成功 有正常的，必然都能正常 大略能力， 见微知著能力 16. 资料 https://wayland.pages.freedesktop.org/weston/ weston官网 https://wayland.freedesktop.org/ wayland官网 https://gitlab.freedesktop.org/wayland 代码托管 https://cloud.tencent.com/developer/article/1445734 Wayland与Weston简介 https://wayland.arktoria.org/1-introduction/high-level-design.html The Wayland Protocol 中文版 Wayland-book的中文翻译 https://mazelinux.github.io/ Wayland-book原文链接:https://wayland-book.com/ https://blog.csdn.net/u012839187/article/details/116054755 agl-compositor display:weston:weston-simple-egl: server端-CSDN博客 display:weston渲染流程:buffer+attach+damage+frame_wayland渲染函数-CSDN博客 buffer+attach+damage+frame display:weston渲染流程:commit_weston display-CSDN博客 commit Wayland源码分析-Commit相关流程_wayland源码剖析-CSDN博客 commit Weston中shm window渲染_weston gbm-CSDN博客 ------> 整个渲染流程：从应用到repaint_output Wayland源码分析-repaint相关流程 (happyseeker.github.io) ------> repaint相关流程 OpenHarmony 图形子系统（二）weston compositor分析-鸿蒙开发者社区-51CTO.COM weston compositor分析 Weston中shm window渲染显示过程分析 https://fossies.org/dox/weston-13.0.3/structivi__shell.html struct的类图 17. 其他 待整理 17.1.1. cursor_view的判断 ​ if (output->cursor_view) { 17.1.2. 硬件图层plane 本质：硬件图层的层级 ​ 最终来源： My chips have four independent H/W overlays. 硬件图层分类： Primary Plane：主平面，负责显示桌面或主画面。每个 CRTC（显示控制器）至少有一个 Primary Plane。 Overlay Plane：覆盖平面，负责显示叠加在主画面上的图像，比如视频播放窗口、硬件加速的图形层等。一个显示控制器可以有多个 Overlay Plane。 Cursor Plane：光标平面，专门用于显示鼠标指针。 软件的标识： enum wdrm_plane_type { WDRM_PLANE_TYPE_PRIMARY = 0, // 用于GPU的plane WDRM_PLANE_TYPE_CURSOR, WDRM_PLANE_TYPE_OVERLAY, // 用于叠加的plane WDRM_PLANE_TYPE__COUNT }; 注意： Overlay 是一种特殊的 plane，用于叠加显示额外的图像内容。 Plane 的使用 在实际使用中，开发者可以通过 DRM 的 API 来配置和操作 plane。以下是一个基本的步骤概述： 获取 Plane 信息： 使用 drmModeGetPlaneResources 获取所有可用的 plane 资源。 使用 drmModeGetPlane 获取具体的 plane 信息。 设置 Plane： 使用 drmModeSetPlane 将图像数据设置到指定的 plane 上，并定义其在屏幕上的位置和大小。 17.1.3. kanzi Kanzi Engine C++ API: kanzi::wayland::XDGToplevel Class Reference 17.1.4. Weston中HDMI热拔插检测原理 https://zhuanlan.zhihu.com/p/434869796 17.1.5. drm_output_find_special_plane 遍历查找 特定的plane console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/其他/":{"url":"0_图形系统/其他/","title":"其他","keywords":"","body":"1. Your Book Title Your Book Title 1. Your Book Title 0_图形系统 0_Graphic系统总论 1_Render系统 Effect Opengl 2_窗口系统 次要 Virtual Display 自由窗口 0_窗口系统总论 Surface Control Virtual Display Wms Animination 窗口管理器WMS 3_Display系统 Display系统 合成器surfaceFlinger 其他 Android 多屏显示分析 QT Weston 0_输入系统 Input 全局手势 0_进程管理 0 AMS App保活的方式 后台杀进程 杀进程原理 进程与子进程 进程管理系列0_总论 进程管理系列1之进程的创建 进程管理系列2之进程的优先级 进程管理系列3之内存回收 Andriod 关键流程 Init System Start APP 其他核心服务 1 Input Method Multi Client Ime 无障碍_ 0 Andriod System log框架 Permissions 模型 Coding 0 Computor Base Design Pattern How To Read Code How Writecode Linux linux文件系统 Operate System Refactor 用户_用户组 解耦 0 IPC Andriod IPC IPC前提_序列化 Socket 线程间通信 0_性能 Profiler Systrace 内存 性能_ 1_稳定性 ANR Watch Dog Andriod Car Car Service Android Tool Hierarchy View App APK 64 Bit 32 Bit APP开发 Launcher 3 System UI 小程序 Coding Language C Cpp Java java反射 JNI Js Python R Features 其他特性 多用户 Kde Kwin Other OS Open Harmony Other OS Tool Aosp Building AS Building Chroot Clion Command Debug Skills Docker Gdb Git Phone Command Search Software Pc Settings Source Insight Tmux Linux 编译 多线程 多线程的模型 线程池与binder线程池 文件系统结构 虚拟化 Communication English Investment Naturalaw Reading And Thinking 修 Scriptures 金刚经 Check List console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/其他/QT.html":{"url":"0_图形系统/其他/QT.html","title":"QT","keywords":"","body":"1. QT能力1.1. 窗口几何坐标系统及几何布局1.2. window1.3. widget 窗口几何坐标系统及几何布局 window widget 1. QT能力 1.1. 窗口几何坐标系统及几何布局 图来源 其他参考： Qt 窗口几何坐标系统（示例程序）: geometry，frameGeometry 1.2. window 窗口部分区域： 显示透明化 & 事件透明化 & 不规则窗体的实现 setMask接口-官网 Qt之遮罩—实现不规则窗体 1.3. widget setStyleSheet用法 背景色设置： //background:red 背景图片设置： rootWidget->setStyleSheet(\"QWidget { background-image: url(/home/chen/workingSpace/QT/DEMO/png/gassi.png); }\"); // background-image: //border-radius 设定圆角的按钮 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_图形系统/其他/多屏显示分析.html":{"url":"0_图形系统/其他/多屏显示分析.html","title":"多屏显示分析","keywords":"","body":"1. 目录2. Android 多屏显示分析 Android 多屏显示分析 1. 目录 2. Android 多屏显示分析 https://blog.csdn.net/Jason_Lee155/article/details/116465425 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_输入系统/":{"url":"0_输入系统/","title":"0_输入系统","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_输入系统/Input.html":{"url":"0_输入系统/Input.html","title":"Input","keywords":"","body":"1. 目录2. input系统2.1. 0层结构2.1.1. 结构之线程角度2.2. 1层流程2.3. TouchEvent事件分发的点2.4. KeyEvent事件2.4.1. APP侧分发：2.4.2. 疑问：2.4.3. 处理2.5. Touch目标窗口的确定：2.6. （次要）例外之HOME事件的拦截3. 参考4. Android事件的分发------从viewRootImpl到Activity5. Android事件的分发------从Activity开始5.1. 简介5.2. 模型5.3. 基于模型，viewGroup的分发 详解5.4. 基于模型，view的分发 详解5.5. 基于模型，view的处理onTouchEvent 详解5.6. 从事件流的角度5.6.1. 面试题6. Android事件的处理7. 其他细节7.1. android 触摸(Touch)事件、点击(Click)事件的区别7.2. 从设计模式角度理解：8. 补充 中断9. 滑动冲突问题10. 疑问11. 方法12. 一切皆文件： 目录 input系统 0层结构 结构之线程角度 1层流程 TouchEvent事件分发的点 KeyEvent事件 APP侧分发： 疑问： 处理 Touch目标窗口的确定： （次要）例外之HOME事件的拦截 参考 Android事件的分发------从viewRootImpl到Activity Android事件的分发------从Activity开始 简介 模型 基于模型，viewGroup的分发 详解 基于模型，view的分发 详解 基于模型，view的处理onTouchEvent 详解 从事件流的角度 面试题 Android事件的处理 其他细节 android 触摸(Touch)事件、点击(Click)事件的区别 从设计模式角度理解： 补充 中断 滑动冲突问题 疑问 方法 一切皆文件： 1. 目录 2. input系统 2.1. 0层结构 参考的0层图 ---------------------> 方向比较好，上下方向；但是没有关系连线！ 2.1.1. 结构之线程角度 IMS线程结构： IMS.start(启动) nativeStart InputManager.start InputReaderThread->run InputDispatcherThread->run ------------->结论： IMS下是两个线程：读取和分发 启动的类顺序： InputManagerService(初始化) nativeInit NativeInputManager EventHub InputManager InputDispatcher Looper InputReader QueuedInputListener InputReaderThread InputDispatcherThread InputDispatch线程结构： 补充，参考： Input系统—事件处理全过程 - Gityuan博客 | 袁辉辉的技术博客 交互过程图---socket android input 点击 android input系统mob6454cc7966b9的技术博客51CTO博客 --------> 0层结构、1层结构用这里的！！！！ 2.2. 1层流程 参考的gityuan的input分发流程图： 图见： http://gityuan.com/2016/12/31/input-ipc/ -----------------> TODO: 流程图画的不好: (1) 没有基于结构图！！！！ (2) 方向不是事件的上下方向 2.3. TouchEvent事件分发的点 inputDispatcher 分发到哪个窗口： 代码：sp InputDispatcher::findTouchedWindowAtLocked 日志： ALOGD(\"debug_magic_input pos:[%d,%d], deviceId:%d, displayId:%d, pid:%d, %s\", x, y, touchState ? touchState->deviceId : -1, displayId, windowInfo->ownerPid, windowInfo->name.c_str()); inputDispatcher 怎么知道窗口信息的？ 2.4. KeyEvent事件 2.4.1. APP侧分发： InputDispatcher::dispatchKeyLocked -------> 找具体的进程 对于输入法，back键 KeyEvent走： 2.4.2. 疑问： TODO: 真正的分发点在哪里？上图，已经进入进程了 是否消费，即 event.dispatch 返回给了谁？ 与硬件键盘事件，是一个 IMS为啥要有两个线程？一个·线程从模型结构上看，有啥缺陷嘛？ 2.4.3. 处理 KeyEvent.java: public final boolean dispatch(Callback receiver, DispatcherState state, Object target) { switch (mAction) { case ACTION_DOWN: { mFlags &= ~FLAG_START_TRACKING; if (DEBUG) Log.v(TAG, \"Key down to \" + target + \" in \" + state + \": \" + this); //关键日志 关键日志： 对于输入法，处理： public boolean onKeyDown(int keyCode, KeyEvent event) { if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) { final ExtractEditText eet = getExtractEditTextIfVisible(); if (eet != null && eet.handleBackInTextActionModeIfNeeded(event)) { return true; } if (handleBack(false)) { // 这里去doHideWindow()了 event.startTracking(); return true; } return false; } return doMovementKey(keyCode, event, MOVEMENT_DOWN); } 2.5. Touch目标窗口的确定： --------------------------> 简言之，目标窗口的确定： 可以根据触摸事件的位置 + 窗口的属性 Touch事件，不是对焦点窗口分发的！！！！！！！！！！！！而是根据位置区分！！！！！----------------> 自然 ------------> 因为Touch不需要焦点，他知道对哪个窗口分发 key事件，自然是对焦点窗口 根据位置区分的证明： sp InputDispatcher::findTouchedWindowAtLocked(int32_t displayId, int32_t x, int32_t y, TouchState* touchState, bool addOutsideTargets, bool addPortalWindows, bool ignoreDragWindow) { if ((addPortalWindows || addOutsideTargets) && touchState == nullptr) { LOG_ALWAYS_FATAL( \"Must provide a valid touch state if adding portal windows or outside targets\"); } // Traverse windows from front to back to find touched window. const std::vector>& windowHandles = getWindowHandlesLocked(displayId); for (const sp& windowHandle : windowHandles) { if (ignoreDragWindow && haveSameToken(windowHandle, mDragState->dragWindow)) { continue; } const WindowInfo* windowInfo = windowHandle->getInfo(); if (windowInfo->displayId == displayId) { auto flags = windowInfo->flags; if (windowInfo->visible) { // 【】 窗口的属性1 visible if (!flags.test(WindowInfo::Flag::NOT_TOUCHABLE)) { // 【】 窗口的属性2 TOUCHABLE bool isTouchModal = !flags.test(WindowInfo::Flag::NOT_FOCUSABLE) && !flags.test(WindowInfo::Flag::NOT_TOUCH_MODAL); if (isTouchModal || windowInfo->touchableRegionContainsPoint(x, y)) { // 【】 触摸事件的位置 int32_t portalToDisplayId = windowInfo->portalToDisplayId; if (portalToDisplayId != ADISPLAY_ID_NONE && portalToDisplayId != displayId) { if (addPortalWindows) { // For the monitoring channels of the display. touchState->addPortalWindow(windowHandle); } return findTouchedWindowAtLocked(portalToDisplayId, x, y, touchState, addOutsideTargets, addPortalWindows); } //add dual windows ALOGD(\"debug_input pos:[%d,%d], deviceId:%d, displayId:%d, pid:%d, %s\", x, y, touchState ? touchState->deviceId : -1, displayId, windowInfo->ownerPid, windowInfo->name.c_str()); // Found window. return windowHandle; } } if (addOutsideTargets && flags.test(WindowInfo::Flag::WATCH_OUTSIDE_TOUCH)) { touchState->addOrUpdateWindow(windowHandle, InputTarget::FLAG_DISPATCH_AS_OUTSIDE, BitSet32(0)); } } } } return nullptr; } 窗口信息的获取： 一句话，简言之: wms注册给IMS的：windowHandles 具体： wms.addWindow ----> InputMonitor ---> IMS.updateInputWindowsLw ---> native ---> InputManager.setInputWindows ----> InputDispatcher..setInputWindows -----> 更新windowHandles 参考：android input 点击 android input系统mob6454cc7966b9的技术博客51CTO博客 2.6. （次要）例外之HOME事件的拦截 自然，HOME事件不能让它到应用层，所以会被提前拦截： 3. 参考 gityuan系列文章： Input系统—启动篇 Input系统—事件处理全过程 4. Android事件的分发------从viewRootImpl到Activity 总结为，先有一个环 5. Android事件的分发------从Activity开始 5.1. 简介 注意点： Q: 分发事件的对象是MotionEvent，没有touchevent与click事件？ A: 没有Touch事件（TouchEvent）， 没有click事件（ClickEvent）。原因： motion用的很恰当。手指触摸，必然是一段时间，一段距离 -------> 即 motion移动 click表示一瞬，其实是没有的 -------> 虽然有时候表达成 touch事件、click事件 5.2. 模型 参考，好文： Android面试题（27）-android的事件分发机制 生活化模型： 项目经理分发任务模型： 项目经理（Activity） 任务（事件） 主管(viewGroup) 员工（view） 友商安排进来的员工（Listener监听者） 继承表达的含义： 继承从功能的角度来看，表达 功能更多、更强 的意思 自然：主管继承员工（viewGroup继承view） 主管管理员工 ---》继承多出的功能，自然 基于模型自然有： 1、自然，每个角色都有两种能力：向下分发的任务的能力（dispatchTouchEvent）、处理事件的能力onTouchEvent 2、特例：拦截任务向下传递的能力onInterceptTouchEvent，只属于主管viewGroup。这是自然的，因为 项目经理要是拦截，项目不要干了。普通员工没有拦截必要，在最底层。 现在你所在的公司中有一项任务被派发下来了，项目经理把项目交给你的老大，你的老大老大手下有很多人，看了看觉得你做很合适，把这个任务交给你了；如果友商安排了间谍，那自然先被间谍抢去了（即view对外分发）。如果没有间谍，你一看觉得还行，你就接下来了； 5.3. 基于模型，viewGroup的分发 详解 参考： 从责任链模式看Android事件分发 ------> 好文 ViewGroup事件分发机制详解 Android View 事件分发机制源码详解(ViewGroup篇) 一句话总结： 安卓事件分发机制： 是双责任链（树责任链 + 链表责任链） ，见图 具体讨论见 设计模式----责任链模式 viewGroup分发核心问题： ViewGroup那么多view，dispatch如何找到对应消费的view？ A：dispatch流程里，对 根据 view可见的Z向位置，对各个子view进行排序： // ViewGroup.java buildTouchDispatchChildList() { final float currentZ = nextChild.getZ(); // insert ahead of any Views with greater Z int insertIndex = i; while (insertIndex > 0 && mPreSortedChildren.get(insertIndex - 1).getZ() > currentZ) { //找到对应的Z位置 insertIndex--; } mPreSortedChildren.add(insertIndex, nextChild); // 排序 } public boolean dispatchTouchEvent(MotionEvent ev) { final ArrayList preorderedList = buildTouchDispatchChildList(); // 排序 for (int i = childrenCount - 1; i >= 0; i--) { // 【1】倒着来遍历，自然 } } 【1】倒着来遍历，自然： 希望最上 层的View来响应的,而不是被覆盖这的底层的View来响应 ViewGroup的子元素成功处理事件的时候，mFirstTouchTarget会指向子元素，这里要留意一下 viewGroup中找view，结论： 如果down事件由某一个 view消耗了，同一个事件序列的其他所有事件也由其处理---》很自然，事件流是对一个控件的操作，不可能多个。证明: 5.4. 基于模型，view的分发 详解 参考： View的事件分发机制 问题：按道理说，叶子节点的view没有子view，那么为啥还存在分发dispatchTouchEvent呢？ A：因为要先向注册的Listener 先分发（即view对外分发），最后才是自己处理 // view.java public boolean dispatchTouchEvent(MotionEvent event) { ............. if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {// 【1】先给了监听器 result = true; } if (!result && onTouchEvent(event)) { // 【2】后自己处理 result = true; } } return result; } 5.5. 基于模型，view的处理onTouchEvent 详解 问题：onTouchEvent 分别处理了DOWN、MOVE、UP事件，如何处理的? View.onTouchEvent()其实处理了三种情况 处理长按事件: checkForLongClick，检测长按的机制:起了一个线程，长按的计时器postDelayed，到时间发现还没有UP事件，就为长按 case MotionEvent.ACTION_DOWN: if (isInScrolling Container) { } else { // 设置DOWN状态标志 setPressed(true, x, y); break; 处理点击事件:click 处理tap事件: 5.6. 从事件流的角度 参考： View的事件分发机制 事件传递的疑问: 1、事件指的是什么？实际上是事件流，不是单一事件。。。自然 2、为了解决多指触控的问题,TODO: 引入Pointer概念 5.6.1. 面试题 6. Android事件的处理 参考： Android事件分发机制 问题：事件是120HZ采样，绘制只有60HZ -----> 会产生问题：有两个move没有被 绘制采样 ----》 所谓的 界面不跟手 安卓处理（滑动跟手性）方法： 整体流程： 7. 其他细节 7.1. android 触摸(Touch)事件、点击(Click)事件的区别 参考： android 触摸(Touch)事件、点击(Click)事件的区别(详细解析) 完全理解android事件分发机制 简易理解： 1、onTouchEvent中3个事件就是：MotionEvent.ACTION_DOWN、ACTION_MOVE、ACTION_UP -----> 自然，因为手机速度必然慢，所以手指的touch过程必然是一个时间段，比如，手指滑动scroview 2、click来源： 一波touchEvent下发ACTION_DOWN 第二波touchEvent下发ACTION_MOVE ............... 第N波touchEvent下发ACTION_UP -> onClick的 上述过程非常自然：touch结束，必然有onClick？ 其实没有Touch，也没有click 7.2. 从设计模式角度理解： 事件分发，是责任链模式的应用 见 《DesignPattern》 8. 补充 中断 9. 滑动冲突问题 TODO ------->办法:事件拦截机制 10. 疑问 如果view重叠，如何找到对应的view？ 11. 方法 不讲代码，只讲逻辑 只画图 讲课视频，是按照 思维方式（1、目标-起点 2、遇到的问题）来讲的，而不是 技术文章的平铺直叙 ------> 会很深刻，从0创造知识的思维 ---------> TODO: 能否这样写技术文章呢？如果不能，能有借鉴意义嘛 数据在哪个进程的哪个线程 分析方法：1、目标-起点 2、目标到起点遇到的问题，解决问题的方法，便是核心思想-----》 实际上就是(方法、结构、流程)合理性的证明 ---------> 所以，理解的深刻与否，在于 ： （1）系统演进的历史 ，遇到了什么问题，导致这样演进的？ ----> 搜索，这一点很难知道 ​ （2）退而求其次。多问合理性的问题，为什么要这样设计？ 代码最最烂最烂的东西：没有重点、量太大、细节太多 ------> 只能作为字典 12. 一切皆文件： 参考：视频---------王小二图解Android【005】一切皆文件 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_输入系统/全局手势.html":{"url":"0_输入系统/全局手势.html","title":"全局手势","keywords":"","body":"1. 全局手势 全局手势 1. 全局手势 全局手势：不care 焦点 现状：事件分发，根据焦点 分发给安卓 关键问题： 1、如何区分 全局手势，与正常事件？ ----------> 从屏幕边缘起 TODO: 代码证明 2、全局手势，最终是生成一个keyEvent，比如：从屏幕边缘右滑 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_进程管理/":{"url":"0_进程管理/","title":"0_进程管理","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_进程管理/0_AMS.html":{"url":"0_进程管理/0_AMS.html","title":"0 AMS","keywords":"","body":"1. 目录2. 超级0层图: AMS-APP-WMS2.1. 桥梁 合理性证明2.1.1. AMS与APP2.1.2. WMS与APP2.2. 基于架构的结论：3. 基于0层架构图4. 启动流程---AMS4.1. 概述4.2. AMS startService之后4.2.1. AMS 让 zygote 创建 launcher进程5. AMS 启动APP startActivity6. AMS模块做了哪些事情7. AMS类做了哪些事情 ---从属性角度7.1. 相关重要类7.1.1. ProcessRecord 数据结构7.1.2. ProcessRecord容器7.1.3. 内部四大组件记录表的容器8. AMS如何管理进程的 TODO9. Activity 四种启动模式10. Task概念 ，即TaskRecord10.1. 1层结构10.2. Task前后台概念:10.3. 不同场景，任务栈的变化10.3.1. 总之：10.3.2. APP1 的Activity1 启动 APP2 的Activity210.3.3. launcher（APP1）启动 APP2 的Activity211. Activity的七大生命周期11.1. 一个Activity的生命周期11.1.1. 相邻状态之间的区别11.1.2. 场景：11.2. 两个的组合11.2.1. 场景（基于模型给出解释）11.2.2. 其他一些疑问11.3. 代码（与模型的对比）12. Activity的启动模式13. 其他次要14. TODO:14.1. appToken15. 参考：16. AMS相关的面试题目： 超级0层图: AMS-APP-WMS 桥梁 合理性证明 AMS与APP WMS与APP 基于架构的结论： 基于0层架构图 启动流程---AMS 概述 AMS startService之后 AMS 让 zygote 创建 launcher进程 AMS 启动APP startActivity AMS模块做了哪些事情 AMS类做了哪些事情 ---从属性角度 相关重要类 ProcessRecord 数据结构 ProcessRecord容器 内部四大组件记录表的容器 AMS如何管理进程的 TODO Activity 四种启动模式 Task概念 ，即TaskRecord 1层结构 Task前后台概念: 不同场景，任务栈的变化 总之： APP1 的Activity1 启动 APP2 的Activity2 launcher（APP1）启动 APP2 的Activity2 Activity的七大生命周期 一个Activity的生命周期 相邻状态之间的区别 场景： 锁屏 两个的组合 场景（基于模型给出解释） 前进：同进程 ActivityA 调用 ActivityB 后退：同进程 back键 ，ActivityB返回ActivityA 两个进程：ActivityA （比如launcher）调用 ActivityB 点击Home键 旋转屏幕 弹窗 其他一些疑问 代码（与模型的对比） Activity的启动模式 其他次要 TODO: appToken 参考： AMS相关的面试题目： 1. 目录 2. 超级0层图: AMS-APP-WMS https://ericchows.github.io/Android-Window-Mechanism/ 2.1. 桥梁 合理性证明 2.1.1. AMS与APP 其中桥梁： IWindowManager和IAcitivityManger 是一个自然的桥梁，客户端对wms和AMS的引用~~ ---->系统服务 开机初始化 注册的缘故 2.1.2. WMS与APP APP-> WMS两个桥梁： 【1】IWindowManager，进程级：System private interface to the window manager. 进程级的。窗口级不从这里过 【2】IWindowSession，进程级，但被参数限制了成了窗口级：System private per-application interface to the window manager. 证明： mWindowSession = WindowManagerGlobal.getWindowSession(); //cg: Single Instance in procsse 是单例，进程级 int addToDisplay(IWindow window,........) // IWindow解决了 mWindowSession 是一对多问题 void remove(IWindow window); WMS->APP 桥梁： 【3】IWindow 是窗口级 1、为什么要有两个APP-> AMS？ 一个级别，做一个级别的事情 2、为什么IWindowSession不能弄成像IWindow 真正是窗口级的？ 一个IWindowSession对应一个线程，多个就会有很多线程了 -----> 浪费资源 TODO: 从设计角度： 一个低级别的类（资源）一般来说会有多份，如果这个类是一个比较消耗资源的（内存、线程资源）。 设计思路：变成一个单例，以参数区分不同低级别 3、自然：【1】搭建【2】，【2】搭建【3】 TODO: mWindowSession所有方法的第一个参数，是IWindow 。 这样就？？？？？ 桥梁Iwindow1: 桥梁Iwindow2: 桥梁-----------------Iwindow2-----------> windowManagerIml----> WMS 有两条路： 1、路1：转到ViewRootIml ，走 IWindowSession 2、路2：直接走Iwindow 2.2. 基于架构的结论： 1、从系统角度来看，是看不到view的---------view体系只是window的一部分，是window的显示 TODO: 通过生活化模型，记忆流程性 图（动图）。。。。。那么如何记忆类图（静图）呢？ 3. 基于0层架构图 所处的位置：SystemServer进程，AMS运行在一个Binder线程里 ----> TODO: 这个Binder线程什么时候创建的？ Binder线程池？ 疑问：如果每个服务有一个Binder线程，那么线程肯定不够，90个服务 TODO: 个人理解：应该是 Binder线程池，谁要用谁用 // system_server的所有线程： \u001buThreads: 122 total, 0 running, 122 sleeping, 0 stopped, 0 zombie Mem: 3.6G total, 3.0G used, 672M free, 25M buffers Swap: 512M total, 0 used, 512M free, 1.4G cached 400%cpu 11%user 0%nice 37%sys 351%idle 0%iow 0%irq 0%sirq 0%host \u001b[7m TID USER PR NI VIRT RES SHR S[%CPU] %MEM TIME+ THREAD \u001b[0m 1441 system RT -8 7.5G 258M 186M S 2.8 6.8 0:02.35 SensorService 6791 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.15 Binder:1270_11 6103 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.15 Binder:1270_10 3865 system 20 0 7.5G 258M 186M S 0.0 6.8 1:11.68 Binder:1270_F 3716 system 20 0 7.5G 258M 186M S 0.0 6.8 0:03.74 Binder:1270_E 3519 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 AsyncQueryWorke 3149 system 20 0 7.5G 258M 186M S 0.0 6.8 1:35.48 Binder:1270_D 3127 system 16 -4 7.5G 258M 186M S 0.0 6.8 0:00.09 RenderThread 2641 system 30 10 7.5G 258M 186M S 0.0 6.8 0:00.24 backup-0 2636 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.31 Binder:1270_C 2635 system 20 0 7.5G 258M 186M S 0.0 6.8 0:18.02 Binder:1270_B 2606 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 pool-2-thread-1 2600 system 30 10 7.5G 258M 186M S 0.0 6.8 0:00.02 LazyTaskWriterT 2213 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 AdbDebuggingMan 2015 system 18 -2 7.5G 258M 186M S 0.0 6.8 0:00.00 queued-work-loo 1926 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 HwBinder:1270_5 1923 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 ConnectionSvrFo 1922 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 CallAudioModeSt 1920 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 uteStateMachine 1914 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.21 HwBinder:1270_4 AMS: 组件管理(虽然叫AMS) : Activity service provider broadcast android10增加了 : ATMS(ActivityTaskManagerService)，目的AMS管理太多了，把Activity 的管理抽出来给ATMS。自然 ActvityManagerServcie的重要功能: start() 函数知道: 1)启动 CPU 监控线程; 2) 注册电池状态和权限管理服务 startObservingNativeCrashes（） 函数知道： 监听所有的crash事件 setSystemProcess()函数知道： 添加各种管理app状态信息的服务还有进程等等信息 SystemServiceManager忽略掉，只是SystemServer startService功能的抽取，自然 4. 启动流程---AMS 4.1. 概述 AMS startService之前： 都是在SystemServer中，通过SytemServiceManager启动的 -----> 见系统启动流程 AMS startService之后：见下 4.2. AMS startService之后 参考： 具体函数级别分析，见： https://gityuan.com/2016/02/21/activity-manager-service/ -------> TODO：暂时允许，各种函数分析，来自链接？ 4.2.1. AMS 让 zygote 创建 launcher进程 5. AMS 启动APP startActivity 见，应用启动流程 6. AMS模块做了哪些事情 基于 超级0层图: AMS-APP-WMS 1、IActivityManager接口： 引用 AMS的Binder 具体做了：比如： attachApplication //塞App的binder给AMS startActivity // 启动一个Actvity finishActivity startService // stopService\\ bindService 2、socket 7. AMS类做了哪些事情 ---从属性角度 TODO: 从属性总结，可以得到精华 参考：《 AMS预习资料.pdf 》 ----> 非常好的资料 TODO: 如何认识一个模块？-----角度： 1、从哪里来： 2、是什么？ 3、模块内核心类 4、重要的纵向流程 7.1. 相关重要类 7.1.1. ProcessRecord 数据结构 一句话功能： 主要是在 AMS侧记录 进程相关信息 ，自然，很直白，ProcessRecord 站在AMS角度来看，Record Process 的目的，就是管理APP ，自然 ProcessRecord （AMS） = APP进程 绑定关系：AMS: 一个进程列表ProcessList（系统级）: 多个 ProcessRecord（应用级）: 一个applicationThread（AMS侧）------最初由APP侧流转到AMS侧 // ProcessList.java /** * List of running applications, sorted by recent usage. * The first entry in the list is the least recently used. */ final ArrayList mLruProcesses = new ArrayList(); // List of running, 自然，不得不这样 /** * The currently running isolated processes. */ final SparseArray mIsolatedProcesses = new SparseArray<>(); // TODO: isolated processes是啥？？？ /** * Processes that are being forcibly torn down. */ final ArrayList mRemovedProcesses = new ArrayList(); // -----> 结论：ProcessRecord，从数据结构角度：是多个ArrayList。 具体记录的信息有： 第一类数据：描述身份的数据 1.ApplicationInfo info：AndroidManifest.xml中定义的Application信息 2.boolean isolated：是不是isolated进程 3.int uid：进程uid 4.int userId：这个是android做的多用户系统id，就像windows可以登录很多用户一样，android 也希望可以实现类似的多用户 5.String processName：进程名字，默认情况下是包名 6.UidRecord uidRecord：记录已经使用的uid 7.IApplicationThread thread：这个很重要，它是ApplicationThread的客户端，AMS就是通过这 个对象给apk进程发送异步消息的（管理四大组件的消息），所以只有这个对象不为空的情况下， 才代表apk进程可是使用了 8.int pid：进程的pid 9.String procStatFile：proc目录下每一个进程都有一个以pid命名的目录文件，这个目录下记载着 进程的详细信息，这个目录及目录下的文件是内核创建的， proc是内核文件系统，proc就是 process的缩写，涉及的目的就是导出进程内核信息 10.int[] gids：gid组 11.CompatibilityInfo compat : 兼容性信息 12.String requiredAbi : abi信息 13.String instructionSet : 指令集信息 第二类数据：描述进程中组件的数据 第三类数据：描述进程状态的数据 第四类数据：和pss相关的数据 第五类数据：和时间相关的数据 第六类数据：crash和anr相关的数据 第八类数据：电源信息和调试信息 .............见： AMS 预习资料.pdf 7.1.2. ProcessRecord容器 永久性容器 临时性容器 一个特别的容器 7.1.3. 内部四大组件记录表的容器 8. AMS如何管理进程的 TODO 图： AMS管理和启动Application流程.pdf AMS如何管理进程的 --------> 见 《进程管理.md》 9. Activity 四种启动模式 说明： 1、自下而上越来越严格 2、栈顶复用模式singleTop：即该Activity处于任务栈栈顶，即下图： 3、singleInstance单实例：所有栈只有一个实例 ----> 自然，次再使用的时候，直接使用这个栈。比如打电话应用就是一个singleStance模式启动的activity 各种模式的应用场景： 具体 TODO 10. Task概念 ，即TaskRecord 参考： https://blog.csdn.net/Smile_729day/article/details/122241576 https://blog.csdn.net/Jason_Lee155/article/details/116571487 ActivityRecord、TaskRecord、ActivityStack相互关系以及Activity启动模式 https://www.jianshu.com/p/eb2ff0bc64a0 AMS重要的数据结构解析（三）：ActivityStack 图： Activity代码属于Application，但是Task属于Android操作系统，跨越了不同的process Task概念: 从用户角度来看，Task 应该就是跳跳跳 (任务级,可能多个APP进程) ~~正式表述：用户在执行某项工作时与之互动的一系列 Activity 的集合~~ 从用户角度来看， 即是一个Task对应一个TaskRecord ----> 所以，程序员应该从TaskRecord角度理解各种 场景 查看task的命令： adb shell dumpsys activity activities adb shell dumpsys activity activities | sed -En -e '/Stack #/p' -e '/Running activities/,/Run #0/p' dump出的一个stack进行分析: Display #0 (activities from top to bottom): // Display #0 代表第一个屏幕。安卓可能存在多个屏幕，投屏 Stack #4: type=standard mode=fullscreen //Stack信息 isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #51 //Task信息 mBounds=Rect(0, 0 - 0, 0) mMinWidth=-1 mMinHeight=-1 mLastNonFullscreenBounds=null * TaskRecord{e0bdfdf #51 A=android.tplink.sjj.teststack U=0 StackId=4 sz=2} userId=0 effectiveUid=u0a128 mCallingUid=u0a28 mUserSetupComplete=true mCallingPackage=com.cyanogenmod.trebuchet affinity=android.tplink.sjj.teststack intent={act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=android.tplink.sjj.teststack/.MainActivity} //启动信息，包括启动源和被启动app的MainActivity realActivity=android.tplink.sjj.teststack/.MainActivity autoRemoveRecents=false isPersistable=true numFullscreen=2 activityType=1 rootWasReset=true mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE **Activities=[ActivityRecord{4542de6 u0 android.tplink.sjj.teststack/.MainActivity t51}, ActivityRecord{898d92a u0 android.tplink.sjj.teststack/.FirstActivity t51}]** //当前栈中Activity记录 askedCompatMode=false inRecents=true isAvailable=true mRootProcess=ProcessRecord{ebe742c 31812:android.tplink.sjj.teststack/u0a128} stackId=4 hasBeenVisible=true mResizeMode=RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION mSupportsPictureInPicture=false isResizeable=true lastActiveTime=256734507 (inactive for 30s) * Hist #1: ActivityRecord{898d92a u0 android.tplink.sjj.teststack/.FirstActivity t51} //栈中Activity调用历史（最近的） packageName=android.tplink.sjj.teststack processName=android.tplink.sjj.teststack launchedFromUid=10128 launchedFromPackage=android.tplink.sjj.teststack userId=0 app=ProcessRecord{ebe742c 31812:android.tplink.sjj.teststack/u0a128} Intent { flg=0x10000000 cmp=android.tplink.sjj.teststack/.FirstActivity } frontOfTask=false task=TaskRecord{e0bdfdf #51 A=android.tplink.sjj.teststack U=0 StackId=4 sz=2} taskAffinity=android.tplink.sjj.teststack realActivity=android.tplink.sjj.teststack/.FirstActivity baseDir=/data/app/android.tplink.sjj.teststack-Cu_ETALVG7u-Plh9vUC5Ug==/base.apk dataDir=/data/user/0/android.tplink.sjj.teststack splitDir=[/data/app/android.tplink.sjj.teststack-Cu_ETALVG7u-Plh9vUC5Ug==/split_lib_dependencies_apk.apk, ......................................... fullscreen=true noDisplay=false immersive=false launchMode=2 frozenBeforeDestroy=false forceNewConfig=false mActivityType=standard waitingVisible=false nowVisible=true lastVisibleTime=-33s65ms resizeMode=RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION mLastReportedMultiWindowMode=false mLastReportedPictureInPictureMode=false * Hist #0: ActivityRecord{4542de6 u0 android.tplink.sjj.teststack/.MainActivity t51} //同上，这是在上个历史之前的 packageName=android.tplink.sjj.teststack processName=android.tplink.sjj.teststack launchedFromUid=10028 launchedFromPackage=com.cyanogenmod.trebuchet userId=0 app=ProcessRecord{ebe742c 31812:android.tplink.sjj.teststack/u0a128} Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=android.tplink.sjj.teststack/.MainActivity bnds=[24,204][192,398] } frontOfTask=true task=TaskRecord{e0bdfdf #51 A=android.tplink.sjj.teststack U=0 StackId=4 sz=2} taskAffinity=android.tplink.sjj.teststack realActivity=android.tplink.sjj.teststack/.MainActivity baseDir=/data/app/android.tplink.sjj.teststack-Cu_ETALVG7u-Plh9vUC5Ug==/base.apk dataDir=/data/user/0/android.tplink.sjj.teststack splitDir=[/data/app/android.tplink.sjj.teststack-Cu_ETALVG7u-Plh9vUC5Ug==/split_lib_dependencies_apk.apk, fullscreen=true noDisplay=false immersive=false launchMode=0 frozenBeforeDestroy=false forceNewConfig=false mActivityType=standard waitingVisible=false nowVisible=false lastVisibleTime=-36s658ms resizeMode=RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION mLastReportedMultiWindowMode=false mLastReportedPictureInPictureMode=false ....................................... Running activities (most recent first): //最近该任务栈中活动了的Activity，按最近时间排列 TaskRecord{e0bdfdf #51 A=android.tplink.sjj.teststack U=0 StackId=4 sz=2} Run #1: ActivityRecord{898d92a u0 android.tplink.sjj.teststack/.FirstActivity t51} Run #0: ActivityRecord{4542de6 u0 android.tplink.sjj.teststack/.MainActivity t51} mResumedActivity: ActivityRecord{898d92a u0 android.tplink.sjj.teststack/.FirstActivity t51} //当前页面Activity mLastPausedActivity: ActivityRecord{4542de6 u0 android.tplink.sjj.teststack/.MainActivity t51} //最后一个退出前台的Activity .......................... task启动方式: launcher(第三方应用跳转不会)、通知 task恢复的方式: Recents与back button 10.1. 1层结构 参见：https://blog.csdn.net/Jason_Lee155/article/details/116571487 好文 通常情况下： 一个APP---->最多一个ActivityStack（可能其他APP启动的，则没有自己的ActivityStack）--------对应一个 TaskRecord（例外：存在多个） 一个 ActivityStack 对应多个 TaskRecord的情况： 见： https://www.jianshu.com/p/eb2ff0bc64a0 AMS重要的数据结构解析（三）：ActivityStack 10.2. Task前后台概念: 如果这时候用户按下Home键,则这个Task 会从前台切换到后台 --->即1层结构中 HomeStack与FocusedStack交 换? 10.3. 不同场景，任务栈的变化 10.3.1. 总之： 1、Launcher与普通的startActivity差异在于: 是否会创建任务栈? -------> 只有这样才自然, 想表达的点: 任务是从laucher点击开 始的 跳跳跳 TODO: 如何证明？ 2、结论：（1）不论是否同进程，**同一个任务栈**变化基本上都是： （3）注意back时，栈顶的 activty会destroyed 3、生命周期： 1、Task新建: launcher启动 launcher启动 打开另外一个新的应用, 默认情况下,这个新的应用期望加入到 Task name为自己包名的Task 中, （自然） 如果该Task 不存在,则创建一个新的Task,并且该Task 的默认 name 和该应用的包名相同, --> 自然，推论 如果期望的 Task 存在,则直接复用原有的 Task, 如果该 Task 处于后台, 则需要把整个Task 转移到前台 --> 自然，推论 2、 Task的切换 ： 即 3、 Activity的切换 ： Activity向前跳转： 在当前 Activity 启动另一个Activity时, 新的Activity 将被推送到 TaskRecord 顶部并获得焦点（TODO: 焦点具体什么概念呢）。上一个 Activity 仍保留在堆栈中, 但会停止（TODO: pause还是stop？）。当 Activity 停止时, 系统会保留其界面的当前状态。自然 当用户按 Back： 当前 Activity 会从 TaskRecord 顶部退出(该 Activity 销毁 destroyed，自然)， 上一个Activity 会恢复(界面会恢复到上一个状态)。TaskRecord 中的 Activity 永远不会重新排列, 只会被送入和退出(自然,这是栈结构,只能如此), 4、销毁 移除 TaskRecord 中的所有Activity后,该 Task 将不复存在。自然 10.3.2. APP1 的Activity1 启动 APP2 的Activity2 结论： 任务栈还是APP1的，自然 证明： Display #0 (activities from top to bottom): Stack #16: type=standard mode=fullscreen isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #25 mBounds=Rect(0, 0 - 0, 0) mMinWidth=-1 mMinHeight=-1 mLastNonFullscreenBounds=null * TaskRecord{d75f457 #25 A=com.example.myhandlerdemo U=0 StackId=16 sz=2} // 第一个应用的 任务栈TaskRecord userId=0 effectiveUid=u0a128 mCallingUid=u0a80 mUserSetupComplete=true mCallingPackage=com.android.launcher3 affinity=com.example.myhandlerdemo intent={act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.example.myhandlerdemo/.MainActivity} mActivityComponent=com.example.myhandlerdemo/.MainActivity autoRemoveRecents=false isPersistable=true numFullscreen=2 activityType=1 rootWasReset=true mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE Activities=[ActivityRecord{5105c0f u0 com.example.myhandlerdemo/.MainActivity t25}, ActivityRecord{b2a437e u0 com.example.sourceCode/.MainActivity t25}] Running activities (most recent first): TaskRecord{d75f457 #25 A=com.example.myhandlerdemo U=0 StackId=16 sz=2} // 第一个应用的 任务栈TaskRecord Run #1: ActivityRecord{b2a437e u0 com.example.sourceCode/.MainActivity t25} // 第二个应用的 处于栈顶 Run #0: ActivityRecord{5105c0f u0 com.example.myhandlerdemo/.MainActivity t25} 10.3.3. launcher（APP1）启动 APP2 的Activity2 则会启动 新的任务栈。自然，launcher是任务栈的起点 从任务栈角度来看：基于1层结构图 新增了一个任务栈，即 ActivityStackSupervisor中的 mFocusedStack 11. Activity的七大生命周期 11.1. 一个Activity的生命周期 实际上，永远不存在一个孤立的activty的 化简： 杀掉进程场景，见下 onPause 阶段返回，极端场景 ----->因为onPause 下台，是个暂时态，很短时间 可见，只考虑一个activity，其状态是很简单的：就两条路 按组记忆： 图：从4个视角理解安卓activity的启动模式pptx 11.1.1. 相邻状态之间的区别 1.onCreate和onStart之间有什么区别？ （1）可见与不可见的区别。前者不可见，后者可见。 自然，可见性 （2）执行次数的区别， 自然。onCreate方法只在Activity创建时执行一次，而onStart方法在Activity的切换以及按Home键返回桌面再切回应用的过程中被多次调用。因此Bundle数据的恢复在onStart中进行比onCreate中执行更合适。（3）onCreate能做的事onStart其实都能做，但是onstart能做的事onCreate却未必适合做。如前文所说的，setContentView和资源初始化在两者都能做，然而想动画的初始化在onStart中做比较好。 2.onStart方法和onResume方法有什么区别？ （1）是否在前台。onStart方法中Activity可见但不在前台，不可交互，而在onResume中在前台 （2）职责不同，onStart方法中主要还是进行初始化工作，而onResume方法，根据官方的建议，可以做开启动画和独占设备的操作。 3.onPause方法和onStop方法有什么区别？ （1）是否可见。onPause时Activity可见，onStop时Activity不可见，但Activity对象还在内存中。 （2）在系统内存不足的时候可能不会执行onStop方法，因此程序状态的保存、独占设备和动画的关闭、以及一些数据的保存最好在onPause中进行，但要注意不能太耗时 ---> 自然，瞬态 4.onStop方法和onDestroy方法有什么区别？ onStop阶段Activity还没有被销毁，对象还在内存中，此时可以通过切换Activity再次回到该Activity，而onDestroy阶段Acivity被销毁 11.1.2. 场景： 锁屏 从onPause---------> onStop 11.2. 两个的组合 Todo：场景有哪些 1、组合对一个的影响 2、组合对两个的影响 生活类比： 舞台演员演出模型： onCreate 舞台后刚招来一个人，作为演员 onStart 开始化妆，但是还没有到前台 onResume 这个人到前台表演 运行runing onPause 导演说要换人，演员退到后台 onstop 不演了，卸妆 onDestroy 杀人，撵人滚蛋（Activity即将被销毁） onRestart 很自然，让stop重新回到start：即卸完妆又化妆 规则一： 所有演员下到后台，有一个stack。因为结束后，要按照上场相反顺序，重新亮相 ----> 模拟back键 导演： 所有Activity生命周期 幕后的操作者Ams： --->生命周期的方法都由其触发调用（通过Binder） Activity的状态在AMS侧是ActivitySatck维护的 ----->同步到 APP，即生命周期函数 由模型，一些不得不的东西： 1、onCreate 招人 与 onDestroy 撵人滚蛋 是一组 创建过程，比如整个view树，绑定 --->自然 2、onStart 开始化妆 与 onStop 卸妆 ，是一组 这两组标志着是否 TODO: 已经渲染好了？？？，只是没有到前台 3、onResume 到前台 与 onPause 到后台，是一组 这两组标志着是否到前台 --->自然 这两组是一个暂时态，一般时间很短 --->自然 11.2.1. 场景（基于模型给出解释） 前进：同进程 ActivityA 调用 ActivityB 基于模型，自然·： A先下台onPause（A后面的事情先不管） B招进来onCreate，化妆 onStart，到舞台表演onResume A 卸妆onStop A下台之后，为啥不安排A 卸妆onStop呢？ 这是自然的，因为是串行，优先让B 上台表演（观众是上帝），最后执行A的 卸妆 注：如果ActivityB之前已经启动(已经在栈里了)： ActivityB走onRestart，其他不变 --->自然 后退：同进程 back键 ，ActivityB返回ActivityA 基于模型，自然·： B下台 （B后面的事情先不管） A 重新化妆onRestart，化妆 onStart , 上台onResume B 实际上没有用了，走完最后生命周期：卸妆onStop，走人onDestroy 后退比前进多了一个onDestroy，原因在于： 因为栈的原因， 后退的时候，当前页面没有用了，销毁掉 前进的时候，当前页面要保存在栈里 两个进程：ActivityA （比如launcher）调用 ActivityB 由APP启动流程知道： ActivityA 先onPause，之后ActivityB走...... ----->结论： 与同进程的生命周期一样 注：如果ActivityB之前已经启动(已经在栈里了)： ActivityB走onRestart，其他不变 --->结论： 与同进程的生命周期一样 点击Home键 退出舞台，演员卸妆 即 Activity将会处于不可见的状态，当前Activity会执行生命周期onStop 旋转屏幕 参考： https://www.jianshu.com/p/eff8496dbf0e 旋转屏幕 ，即 一个演员先下台，走人后，明天再上台 onPause() -> onStop() -> onDestroy() onCreate() -> onStart() -> onResume() ------>结论： 自然，相当于先关闭再重启 弹窗 弹出 Dialog 对生命周期有什么影响 1、我们知道，生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以不会对生命周期有任何影响。 如果是启动一个 Theme 为 Dialog 的 Activity , 则生命周期为： A.onPause -> B.onCrete -> B.onStart -> B.onResume 注意这边没有前一个 Activity 不会回调 onStop，因为只有在 Activity 切到后台不可见才会回调 onStop；而弹出 Dialog 主题的 Activity 时前一个页面还是可见的，只是失去了焦点而已所以仅有 onPause 回调。 11.2.2. 其他一些疑问 https://zhuanlan.zhihu.com/p/190151810 给 onPause 一个精准的描述的话，应该是 非前台，不可交互，但不一定不可见 。 ---> 符合模型 11.3. 代码（与模型的对比） 12. Activity的启动模式 四种启动模式： 13. 其他次要 《状态保存分析，待合并》 根本目的： 用户体验一致性 场景： 1、低内存场景:----------- 真 可以想象的一个场景是：用户正在编辑一段日记的时候，来了一个电话，当通话结束之后（假设此刻处于后台的编辑日记的Activity由于内存不足被销毁了），那么返回到App的时候，用户会发现花了很多时间编辑的日记已经全部丢失，这样的App逻辑是无法接受的。 -------------------> 场景！！！！！！！！ https://zhuanlan.zhihu.com/p/666144089 安卓现代化开发系列——从状态保存到SavedState 到底是回收activity还是整个进程？ 模拟不保留activities（模拟内存不足时的系统行为）：https://www.jianshu.com/p/90cf59f22f40 2、横竖屏切换（进程没有销毁场景）--------假 这个时候，实际上，进程没有销毁（必然：既然进程没有销毁场景，则数据不会给到AMS） 3、应用升级更新后------- 真 安卓的保存，是在界面的切换时机 特别注意： 应用异常杀死、ANR ----> 这种场景似乎不合适，因为应用已经卡死：没法执行保存流程 --------> 所以，必然：状态保存的时机是，AMS主动杀的时候 参考： https://zhuanlan.zhihu.com/p/666144089 安卓现代化开发系列——从状态保存到SavedState 14. TODO: 14.1. appToken what，作用： token--------本质：activity包名？ 作用： TODO: 表征哪个activity：在APP、AMS、WMS 三个线程中，表征当前的window是哪个activity的？ when，生于： 参考： https://www.bilibili.com/video/BV1pb4y1B7TW/?spm_id_from=333.337.search-card.all.click&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 15. 参考： https://www.jianshu.com/p/eb2ff0bc64a0 AMS重要的数据结构解析（三）：ActivityStack 16. AMS相关的面试题目： 请描述 Android 中的 Activity 生命周期。 见上 解释一下 Android 中的任务（Task）和返回栈（Back Stack） 请描述如何使用 Android AMS 启动新活动。 请描述 Android AMS 如何管理应用程序的内存。 解释一下 Android AMS 如何处理多窗口（Multi-Window）支持。 请详细说明 Android AMS 的工作原理。 解释一下 Android AMS 如何创建新活动实例。 请描述 Android AMS 如何管理活动的状态。 请描述如何使用 Android AMS 关闭不再使用的活动。 解释一下 Android AMS 如何处理应用程序间的消息传递。 请描述如何在 Android 中使用 AMS 管理多个进程。 请说明 Android AMS 如何处理应用程序的安装和卸载。 请描述如何使用 Android AMS 管理应用程序的权限。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_进程管理/App保活的方式.html":{"url":"0_进程管理/App保活的方式.html","title":"App保活的方式","keywords":"","body":"1. 目录2. 参考：3. 前台服务4. 借助广播唤醒 参考： 前台服务 借助广播唤醒 1. 目录 2. 参考： https://blog.csdn.net/u010351988/article/details/131061566 3. 前台服务 应用侧配置： startForeground() 启动前台服务的时候，需要发送一个前台的通知 ------------> TODO: 这个才是真正的约束？（startForeground不是真正的约束，因为应用可以无条件使用） 真正的约束：一定是要有代价的 限制 比如，需要用户手动确认给权限 4. 借助广播唤醒 参考： https://www.jianshu.com/p/647a50447bac console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_进程管理/后台杀进程.html":{"url":"0_进程管理/后台杀进程.html","title":"后台杀进程","keywords":"","body":"1. Android后台杀死系列-----文章参考2. 0层 0层 1. Android后台杀死系列-----文章参考 https://sq.sf.163.com/blog/article/193127728117825536 Android后台杀死系列之一：FragmentActivity及PhoneWindow后台杀死处理机制（上篇） https://sq.sf.163.com/blog/article/193127674185461760 Android后台杀死系列之一：FragmentActivity及PhoneWindow后台杀死处理机制（下篇） https://sq.sf.163.com/blog/article/193130044973854720 Android后台杀死系列之二：ActivityManagerService与App现场恢复机制（上篇） https://sq.sf.163.com/blog/article/193129960244719616 Android后台杀死系列之二：ActivityManagerService与App现场恢复机制（下篇） https://sq.sf.163.com/blog/article/193132570932527104 Android后台杀死系列之三：LowMemoryKiller原理（4.3-6.0）上篇 https://sq.sf.163.com/blog/article/193132514978508800 Android后台杀死系列之三：LowMemoryKiller原理（4.3-6.0）下篇 2. 0层 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_进程管理/杀进程原理.html":{"url":"0_进程管理/杀进程原理.html","title":"杀进程原理","keywords":"","body":"1. 目录2. 杀进程原理----Process.killProcess(int pid)3. 从调用号来看 TODO：4. am force-stop pkgName 杀进程原理----Process.killProcess(int pid) 从调用号来看 TODO： am force-stop pkgName 1. 目录 2. 杀进程原理----Process.killProcess(int pid) 0层： 前提：kill -9 完全参考： https://gityuan.com/2016/04/16/kill-signal/ 几个方法区别： Process.killProcess(int pid): 杀pid进程 Process.killProcessQuiet(int pid)：杀pid进程，且不输出log信息 Process.killProcessGroup(int uid, int pid)：杀同一个uid下同一进程组下的所有进程 相同点： 都是kill -9 调用栈： -------> 最终 kill(pid, sig); （用户空间的Native层） 3. 从调用号来看 TODO： //Process.java public static final int SIGNAL_QUIT = 3; //用于输出线程trace public static final int SIGNAL_KILL = 9; //用于杀进程/线程 public static final int SIGNAL_USR1 = 10; //用于强制执行GC kill -9 则由内核直接处理：见上 kill -3 和 kill -10 由Art虚拟机处理： 调用栈： 实例分析： 4. am force-stop pkgName 完全参考： https://gityuan.com/2016/10/22/force-stop/ 纵向： 图见：https://gityuan.com/2016/10/22/force-stop/ TODO：总结具体做的事情，见 https://gityuan.com/2016/10/22/force-stop/ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_进程管理/进程与子进程.html":{"url":"0_进程管理/进程与子进程.html","title":"进程与子进程","keywords":"","body":"1. 进程与子进程2. 进程组2.1. linux进程组2.1.1. 编程角度：2.2. 进程组视角：SCHED_GROUP/ProcessGroup/SchedPolicy组/cpuset2.2.1. del:临时扩展：set_cpuset_policy(int tid, SchedPolicy policy)2.2.2. del:临时扩展：set_sched_policy(int tid, SchedPolicy policy)2.3. process视角：/proc/5770/task/ 记录一个process(linux & android)2.4. del：临时补充： cgroups机制中的cpu/cpuset/schedtune子系3. 一些结论：3.1. TODO:【1】init时创建调度组processGroup3.2. 疑问： setThreadPriority 与 setProcessGroup的关系？3.3. linux本身提供的机制： 进程组 linux进程组 编程角度： 进程组视角：SCHED_GROUP/ProcessGroup/SchedPolicy组/cpuset del:临时扩展：set_cpuset_policy(int tid, SchedPolicy policy) del:临时扩展：set_sched_policy(int tid, SchedPolicy policy) process视角：/proc/5770/task/ 记录一个process(linux & android) del：临时补充： cgroups机制中的cpu/cpuset/schedtune子系 一些结论： TODO:【1】init时创建调度组processGroup 疑问： setThreadPriority 与 setProcessGroup的关系？ linux本身提供的机制： 1. 进程与子进程 参考： C++ 多进程，父进程监控子进程 - 代码先锋网 (codeleading.com) https://codeleading.com/article/60953963187/ #include #include #include #include #include #include //子进程个数 #define SUB_PRO_COUNT 10 //处理子进程的退出信号 void sub_quit_signal_handle(int sig); //父进程的事件循环 void ParentCycle(); //子进程的事件循环 void ChildCycle(); int main(void) { pid_t pid; int i; //创建SUB_PRO_COUNT个子进程 for(i=0; i -----------------> 一行关键代码： signal(SIGCHLD, sub_quit_signal_handle); // 父进程，收到child的信号 ------>【1】 为啥这行不会阻塞？ 次要：调用处理，获取具体信息 //获取退出的那个子进程的状态 int quit_pid = wait(&status); printf(\"sub process %d quit, exit status %d\\\\n\", quit_pid, status); TODO: 【1】为什么没有阻塞？后面SIGCHLD却可以唤醒 主进程！！！！！ 【信号】SIGCHLD信号-CSDN博客 https://blog.csdn.net/isunbin/article/details/84032708?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-84032708-blog-127649401.235^v38^pc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-84032708-blog-127649401.235^v38^pc_relevant_sort_base1&utm_relevant_index=2 结论： 父进程可以感知到子进程的死亡 2. 进程组 2.1. linux进程组 参考： https://blog.csdn.net/jinking01/article/details/126925313?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-126925313-blog-128064414.235^v38^pc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-126925313-blog-128064414.235^v38^pc_relevant_sort_base1&utm_relevant_index=2 Linux基础概念--进程、子进程、进程组和会话 概念： 站在进程角度 ： 进程号pid, 父进程号 ppid, 进程组号pgid 参考： 2.1.1. 编程角度： 参考： https://blog.csdn.net/chen_y09/article/details/130869886 Linux C 查询当前进程号、父进程号、进程组号_c语言获取当前进程号-CSDN博客 #include #include #include int main(int argc,char *argv[]) { pid_t pid,ppid,pgid; pid = getpid(); printf(\"pid = %d\\\\\\\\n\",pid); ppid = getppid(); printf(\"father pid = %d\\\\\\\\n\",ppid); pgid = getpgid(pid); printf(\"group pid = %d\\\\\\\\n\",pgid); return 0; } 2.2. 进程组视角：SCHED_GROUP/ProcessGroup/SchedPolicy组/cpuset Activity调度组： -------> 安卓组件的概念（因为安卓是组件，必须有）、AMS层的东西 SCHED_GROUP_BACKGROUND = 0 // 后台进程组 SCHED_GROUP_RESTRICTED = 1 // 限制 SCHED_GROUP_DEFAULT = 2 // 默认进程组 SCHED_GROUP_TOP_APP = 3 // top进程组 SCHED_GROUP_TOP_APP_BOUND = 4 thread group： ---------> 进程组，linux范畴（必须对接）、linux层的东西 THREAD_GROUP_DEFAULT = -1 THREAD_GROUP_BG_NONINTERACTIVE = 0 THREAD_GROUP_FOREGROUND = 1 THREAD_GROUP_SYSTEM = 2 THREAD_GROUP_AUDIO_APP = 3 THREAD_GROUP_AUDIO_SYS = 4 THREAD_GROUP_TOP_APP = 5 THREAD_GROUP_RT_APP = 6 THREAD_GROUP_RESTRICTED = 7 大致映射关系： Activity调度组（安卓AMS）SCHED_GROUP 进程组 THREAD_GROUP（安卓模仿linux创造的） SchedPolicy （linux） SP_ SCHED_GROUP_DEFAULT(2) THREAD_GROUP_DEFAULT(-1) SP_DEFAULTSP_DEFAULT = -1 SCHED_GROUP_BACKGROUND(0) THREAD_GROUP_BG_NONINTERACTIVE(0) SP_BACKGROUND = 0 SP_FOREGROUND = 1 SCHED_GROUP_TOP_APP（3） SCHED_GROUP_TOP_APP_BOUND（4） THREAD_GROUP_TOP_APP(5)同上 SP_ ............. = 3 SCHED_GROUP_RESTRICTED(1) THREAD_GROUP_RESTRICTED(7) SP_ ............. = 7 目标：Activity调度组SCHEDGROUP ----> 进程组THREAD_GROUP -----> SchedPolicy （linux） SP ------------------> 结论： 1、右边两个是完全一致的关系： /* Keep in sync with THREAD_GROUP_* in frameworks/base/core/java/android/os/Process.java */ typedef enum { SP_DEFAULT = -1, SP_BACKGROUND = 0, SP_FOREGROUND = 1, SP_SYSTEM = 2, // can't be used with set_sched_policy() SP_AUDIO_APP = 3, SP_AUDIO_SYS = 4, SP_TOP_APP = 5, SP_RT_APP = 6, SP_RESTRICTED = 7, SP_CNT, SP_MAX = SP_CNT - 1, SP_SYSTEM_DEFAULT = SP_FOREGROUND, } SchedPolicy; ------------------> 其实没明白： TODO: 从设计角度： 设置进程组setProcessGroup的作用是啥？ 不是有了setThreadPriority设置优先级嘛？ ------> TODO: 类似于用户组？ 设置 Activity调度组SCHED_GROU流程： // OomAdjuster.applyOomAdjLocked流程中： 目标：Activity调度组SCHED_GROUP ----> 进程组THREAD_GROUP ---》 SchedPolicy （linux） SP_ 设置 Activity调度组SCHED_GROUP： Process.setProcessGroup 透传 android_os_Process_setProcessGroup 具体做的事情： SchedPolicy sp = (SchedPolicy) grp; // 调度组，转化成调度策略 set_cpuset_policy(t_pid, sp); ----> SetTaskProfiles(\"CPUSET_SP_BACKGROUND\") // 目标：设置cpuset（Cgroup范畴） ------》 TODO: 具体做了啥？【1】 set_sched_policy(t_pid, sp) ---> SetTaskProfiles(\"SCHED_SP_BACKGROUND\") //------> TODO: 具体做了啥？ sprintf(proc_path, \"/proc/%d/task\", pid); -------> // 创建目录: /proc/5770/task/14372 【1】写cpuset对应的task节点配置，添加对应的pid: // task下pid ------> 运行时决定 sailfish:/dev/cpuset/top-app # cat tasks | grep 5770 -----> [//com.example.myapplication在前台](http://com.example.xn--myapplication-1l3vp4qw0o) 5770 sailfish:/dev/cpuset/top-app # cat tasks | grep 5770 -----> [//com.example.myapplication在后台](http://com.example.xn--myapplication-ne8v3my32b) //top-app组使用的 cpuset 的核心 --------> TODO: 按道理，是初始化时决定的 sailfish:/dev/cpuset/top-app # cat cpus 0-3 参考： https://www.jianshu.com/p/0532e4239703 Android 进程管理篇（四）-cpu限制 总之： (1) 进入组：SCHED_GROUP调度组 ----> 进程组 -----> cpuset 节点（基于cgroup），加入task (2) 限制组里的成员：而 cpuset 节点本身就有对组的限制-------cpuset/top-app/cpus 注释： Profiles 配置文件 2.2.1. del:临时扩展：set_cpuset_policy(int tid, SchedPolicy policy) int set_cpuset_policy(int tid, SchedPolicy policy) { if (tid == 0) { tid = GetThreadId(); } policy = _policy(policy); switch (policy) { case SP_BACKGROUND: return SetTaskProfiles(tid, {\"CPUSET_SP_BACKGROUND\", \"BlkIOBackground\"}, true) ? 0 : -1; case SP_FOREGROUND: case SP_AUDIO_APP: case SP_AUDIO_SYS: return SetTaskProfiles(tid, {\"CPUSET_SP_FOREGROUND\"}, true) ? 0 : -1; case SP_TOP_APP: return SetTaskProfiles(tid, {\"CPUSET_SP_TOP_APP\"}, true) ? 0 : -1; case SP_SYSTEM: return SetTaskProfiles(tid, {\"CPUSET_SP_SYSTEM\"}, true) ? 0 : -1; case SP_RESTRICTED: return SetTaskProfiles(tid, {\"CPUSET_SP_RESTRICTED\"}, true) ? 0 : -1; default: break; } return 0; } ---------> /dev/cpuset/backgroud/各种后台应用的pid sailfish:/dev/cpuset/background # ls -la //cpuset 含义？ drwxr-xr-x 2 system system 0 1971-05-11 00:47 . dr-xr-xr-x 11 system system 0 1971-05-11 00:47 .. -rw-r--r-- 1 root root 0 2023-10-16 04:12 cgroup.clone_children -rw-r--r-- 1 root root 0 2023-10-16 04:12 cgroup.procs -rw-r--r-- 1 root root 0 2023-10-16 04:12 cpu_exclusive -rw-r--r-- 1 root root 0 2023-10-11 17:19 cpus // 【1】主要作用：限制background可以使用的核心，比如0 -r--r--r-- 1 root root 0 2023-10-16 04:12 effective_cpus -r--r--r-- 1 root root 0 2023-10-16 04:12 effective_mems -rw-r--r-- 1 root root 0 2023-10-16 04:12 mem_exclusive -rw-r--r-- 1 root root 0 2023-10-16 04:12 mem_hardwall -rw-r--r-- 1 root root 0 2023-10-16 04:12 memory_migrate -r--r--r-- 1 root root 0 2023-10-16 04:12 memory_pressure -rw-r--r-- 1 root root 0 2023-10-16 04:12 memory_spread_page -rw-r--r-- 1 root root 0 2023-10-16 04:12 memory_spread_slab -rw-r--r-- 1 root root 0 1971-05-11 00:47 mems -rw-r--r-- 1 root root 0 2023-10-16 04:12 notify_on_release -rw-r--r-- 1 root root 0 2023-10-16 04:12 sched_load_balance -rw-r--r-- 1 root root 0 2023-10-16 04:12 sched_relax_domain_level -rw-rw-r-- 1 system system 0 1971-05-11 00:47 tasks // 记录属于background的各种pid，比如：12186，5770，14345 注： 【1】cpuset是linux原本就有的机制，但是目录不一样： cpuset -------- 根据前后台状态，把后台应用进程限制在特定的cpu核上 echo \"0-3,6\" > /sys/fs/cgroup/cpuset/mygroup/cpuset.cpus 核心0-3 和 6 2.2.2. del:临时扩展：set_sched_policy(int tid, SchedPolicy policy) 完全参考：https://www.jianshu.com/p/06aab76bb7da 没懂 TODO: 图 调用，最终生效，作用 set_sched_policy --------> 设置cpu/schedtune两个子系统，子系统节点和SchedPolicy类型对应如下： 最终生效： https://www.jianshu.com/p/06aab76bb7da （1）cpuctl： -----> 似乎啥也没做 /dev/cpuctl/tasks // TODO: 一堆pid。作用是啥？ SP_FOREGROUND SP_AUDIO_APP SP_AUDIO_SYS /dev/cpuctl/bg_non_interactive/tasks // SP_BACKGROUND （2）stune：调频 /dev/stune/top-app/tasks SP_TOP_APP /schedtune.boost ----> 10 【2_1】 /dev/stune/foreground/tasks SP_FOREGROUND SP_AUDIO_APP SP_AUDIO_SYS /dev/stune/background/tasks SP_BACKGROUND 参考： Android/Linux EAS优化-schedtune-CSDN博客 https://blog.csdn.net/liaochaoyun/article/details/122377605 补充： 【2_1】 schedtune.boost的值在 init.rc 中设置的： 参考： https://blog.csdn.net/liaochaoyun/article/details/122377605 // / init.rc # set default schedTune value for foreground/top-app (only affects EAS) write /dev/stune/foreground/schedtune.prefer_idle 1 write /dev/stune/top-app/schedtune.boost 10 write /dev/stune/top-app/schedtune.prefer_idle 1 write /dev/stune/rt/schedtune.boost 30 write /dev/stune/rt/schedtune.prefer_idle 1 2.3. process视角：/proc/5770/task/ 记录一个process(linux & android) 现状： /proc/5770/task/目录 ------> 是linux的机制 -----> 安卓所做： 给进程设定特定的进程组 以com.example.myapplication为例，pid：5770; renderTread Tid: 14372 文件目录结构： sailfish:/proc/5770 # ls -la dr-xr-xr-x 2 u0_a103 u0_a103 0 2023-11-20 14:35 attr -r-------- 1 u0_a103 u0_a103 0 2023-11-20 14:35 auxv -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 cgroup // 【1】 --w------- 1 u0_a103 u0_a103 0 2023-11-20 14:35 clear_refs -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:14 cmdline // 即：com.example.myapplication -rw-r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:14 comm -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 concurrent_active_time // -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 concurrent_policy_time -rw-r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 coredump_filter -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 cpuset lrwxrwxrwx 1 u0_a103 u0_a103 0 2023-11-20 14:35 cwd -> / -r-------- 1 u0_a103 u0_a103 0 2023-11-20 14:35 environ lrwxrwxrwx 1 u0_a103 u0_a103 0 2023-11-20 14:35 exe -> /system/bin/app_process64 dr-x------ 2 u0_a103 u0_a103 0 2023-11-20 14:14 fd dr-x------ 2 u0_a103 u0_a103 0 2023-11-20 14:35 fdinfo -r-------- 1 u0_a103 u0_a103 0 2023-11-20 14:35 io -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 limits -rw-r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 loginuid -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 maps -rw------- 1 u0_a103 u0_a103 0 2023-11-20 14:35 mem -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 mountinfo -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 mounts -r-------- 1 u0_a103 u0_a103 0 2023-11-20 14:35 mountstats dr-xr-xr-x 10 u0_a103 u0_a103 0 2023-11-20 14:35 net dr-x--x--x 2 u0_a103 u0_a103 0 2023-11-20 14:35 ns -r-------- 1 u0_a103 u0_a103 0 2023-11-20 14:35 oom_adj -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 oom_score -r-------- 1 u0_a103 u0_a103 0 2023-11-20 14:14 oom_score_adj -r-------- 1 u0_a103 u0_a103 0 2023-11-20 14:35 pagemap -r-------- 1 u0_a103 u0_a103 0 2023-11-20 14:35 personality lrwxrwxrwx 1 u0_a103 u0_a103 0 2023-11-20 14:35 root -> / -rw-r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 sched -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 schedstat -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 sessionid -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 smaps -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:20 smaps_rollup -r-------- 1 u0_a103 u0_a103 0 2023-11-20 14:35 stack -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:14 stat -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:20 statm -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:14 status -r-------- 1 u0_a103 u0_a103 0 2023-11-20 14:35 syscall dr-xr-xr-x 19 u0_a103 u0_a103 0 2023-11-20 14:14 task -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 time_in_state -r--r--r-- 1 u0_a103 u0_a103 0 2023-11-20 14:35 wchan // 【1】cgroup（ linux & android）： sailfish:/proc/5770 # cat cgroup 4:schedtune:/background ------> //调频限制组 3:cpuset:/background ------> //cpu核set限制，限制组background 2:cpuacct:/uid_10103/pid_5770 1:cpu:/ 2.4. del：临时补充： cgroups机制中的cpu/cpuset/schedtune子系 cgroups机制： cpuset cpuctl schedtune CPU调频 3. 一些结论： 1、Android系统认为“重要”的进程主要有三类： 系统进程 前台与用户交互的进程 前台进程所使用到的进程 完全参考： https://blog.csdn.net/weixin_47465999/article/details/132043377 2、AMS层面的 进程优先级 有三个方面： app.curAdj = app.modifyRawOomAdj(adj); app.curSchedGroup = schedGroup; app.curProcState = procState; app.foregroundActivities = foregroundActivities; 三方面的 生效点： ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj); 将计算出来的adj值写入到procfs中，即：/proc/[pid]/oom_score_adj 这个文件中。 Process.setProcessGroup(app.pid, processGroup); 用来设置进程的调度组（【1】调度组processGroup是机器init时创建的） app.thread.setProcessState(app.repProcState); 这个方法会最终调用到 VMRuntime.getRuntime().updateProcessState();将进程的状态设置到虚拟机中。 原文链接： linux处的生效点： 3.1. TODO:【1】init时创建调度组processGroup 原文链接：https://www.jianshu.com/p/ee2f2344658f // init.rc 有关 foreground 和 background的设置 mkdir /dev/cpuset/foreground write /dev/cpuset/foreground/cpus 0 write /dev/cpuset/foreground/mems 0 mkdir /dev/cpuset/foreground/boost write /dev/cpuset/foreground/boost/cpus 0 write /dev/cpuset/foreground/boost/mems 0 mkdir /dev/cpuset/background write /dev/cpuset/background/cpus 0 write /dev/cpuset/background/mems 0 # system-background is for system tasks that should only run on # little cores, not on bigs # to be used only by init, so don't change system-bg permissions mkdir /dev/cpuset/system-background write /dev/cpuset/system-background/cpus 0 write /dev/cpuset/system-background/mems 0 # change permissions for all cpusets we'll touch at runtime chown system system /dev/cpuset chown system system /dev/cpuset/foreground chown system system /dev/cpuset/foreground/boost chown system system /dev/cpuset/background chown system system /dev/cpuset/tasks chown system system /dev/cpuset/foreground/tasks chown system system /dev/cpuset/foreground/boost/tasks chown system system /dev/cpuset/background/tasks chmod 0664 /dev/cpuset/foreground/tasks chmod 0664 /dev/cpuset/foreground/boost/tasks chmod 0664 /dev/cpuset/background/tasks chmod 0664 /dev/cpuset/tasks 3.2. 疑问： setThreadPriority 与 setProcessGroup的关系？ 必然要求： 调度组，不涉及nice的设置 3.3. linux本身提供的机制： 例如： 通过fork来创建进行 通过信号量来管理进程 通过proc文件系统来查询和调整进程状态 等 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_进程管理/进程管理系列0_总论.html":{"url":"0_进程管理/进程管理系列0_总论.html","title":"进程管理系列0_总论","keywords":"","body":"1. 目录2. 基础知识----线程与进程维测：2.1. 维测----进程树查看：2.2. del:pstree 命令详解：2.3. del：临时扩展：前提: busybox的二进制形式安装---> 常用3. 基础知识----进程3.1. 关于pid = fork();3.2. C 语言库函数 - signal() TODO:3.3. c语言pause()函数（让进程暂停直到信号出现） TODO:4. 进程管理 基础知识----线程与进程维测： 维测----进程树查看： del:pstree 命令详解： del：临时扩展：前提: busybox的二进制形式安装---> 常用 基础知识----进程 关于pid = fork(); C 语言库函数 - signal() TODO: c语言pause()函数（让进程暂停直到信号出现） TODO: 进程管理 1. 目录 2. 基础知识----线程与进程维测： 其实在 Linux 中，同一进程中的不同线程就是由共享资源的不同进程来实现的；---------> 所以，pstree包括了线程 https://blog.csdn.net/hegan2010/article/details/79352594 2.1. 维测----进程树查看： 完全参考： https://blog.csdn.net/hegan2010/article/details/79352594 pstree 命令查看 Android 用户进程树 安卓下： /system/bin/busybox pstree /system/bin/busybox pstree -p 0 命令可以查看 Android 系统的所有进程树（内核进程+用户进程） /system/bin/busybox pstree -p 2 命令可以查看 Android 系统的内核进程树 andriod 10 全部进程树 ?(0)-+-init(1)-+-ATFWD-daemon(3416)-+-{ATFWD-daemon}(3433) | | `-{ATFWD-daemon}(3434) | |-Binder:489_2(489)-+-{Binder:489_1}(496) | | |-{Binder:489_2}(497) | | `-{Binder:489_3}(498) | |-Binder:634_3(634)-+-ip6tables-resto(862) | | |-iptables-restor(861) | | |-{Binder:634_1}(896) | | |-{Binder:634_2}(897) | | |-{Binder:634_2}(898) | | |-{Binder:634_2}(899) | | |-{Binder:634_4}(1472) | | |-{HwBinder:634_1}(901) | | |-{NFLogListener}(892) | | |-{netd}(863) | | |-{netd}(889) | | |-{netd}(890) | | |-{netd}(891) | | `-{netd}(893) | |-Binder:688_2(688)---{Binder:688_1}(784) | |-Binder:806_2(806)-+-{Binder:806_1}(839) | | |-{Binder:806_3}(1202) | | `-{Binder:806_4}(1203) | |-Binder:810_2(810)-+-{Binder:810_1}(827) | | `-{Binder:810_3}(829) | |-Binder:811_2(811)-+-{Binder:811_1}(834) | | |-{Binder:811_3}(1199) | | |-{Binder:811_4}(2426) | | |-{Binder:811_5}(2427) | | `-{Binder:811_6}(2428) | |-Binder:822_2(822)-+-{Binder:822_1}(846) | | |-{Binder:822_2}(848) | | |-{Binder:822_3}(853) | | |-{HwBinder:822_1}(851) | | `-{statsd.writer}(852) | |-adbd(3690)-+-busybox(4212) | | |-{UsbFfs-monitor}(3692) | | |-{UsbFfs-worker}(3693) | | |-{shell svc 4212}(4213) | | `-{usb ffs open}(3691) | |-adsprpcd(826)-+-{adsprpcd}(849) | | `-{adsprpcd}(850) | |-allocator@1.0-s(651) | |-allocator@2.0-s(521)-+-{HwBinder:521_1}(532) | | `-{HwBinder:521_2}(1842) | |-apexd(604)-+-{Binder:604_1}(608) | | `-{Binder:604_2}(609) | |-ashmemd(684) | |-atrace@1.0-serv(511) | |-audio@2.0-servi(654)-+-{Binder:654_1}(690) | | |-{Binder:654_2}(758) | | |-{HwBinder:654_1}(760) | | |-{HwBinder:654_2}(764) | | |-{HwBinder:654_2}(1035) | | |-{HwBinder:654_3}(1109) | | |-{HwBinder:654_4}(2208) | | |-{audio@2.0-serv}(1001) | | `-{writer}(3444) | |-audioserver(685)-+-{ApmAudio}(902) | | |-{ApmOutput}(903) | | |-{AudioOut_15}(1043) | | |-{AudioOut_1D}(1045) | | |-{AudioOut_25}(1051) | | |-{AudioOut_2D}(1053) | | |-{AudioOut_D}(1038) | | |-{Binder:685_1}(920) | | |-{Binder:685_2}(922) | | |-{Binder:685_3}(1321) | | |-{Binder:685_4}(1461) | | |-{Binder:685_5}(1589) | | |-{FastMixer}(1037) | | |-{FastMixer}(1042) | | |-{FastMixer}(1050) | | |-{FastMixer}(1052) | | |-{HwBinder:685_1}(885) | | |-{HwBinder:685_2}(907) | | |-{TimeCheckThrea}(1317) | | `-{soundTrigger c}(1207) | |-bluetooth@1.0-s(655)-+-{POSIX timer 0}(2003) | | |-{POSIX timer 1}(2035) | | |-{POSIX timer 2}(2105) | | |-{POSIX timer 3}(2112) | | |-{POSIX timer 4}(2113) | | |-{POSIX timer 5}(2150) | | `-{bluetooth@1.0-}(2104) | |-boot@1.0-servic(512) | |-cameraserver(804)-+-{Binder:804_1}(1206) | | |-{Binder:804_2}(1453) | | |-{Binder:804_3}(1586) | | |-{Binder:804_4}(2522) | | |-{HwBinder:804_1}(900) | | |-{HwBinder:804_2}(906) | | `-{HwBinder:804_3}(1178) | |-cas@1.1-service(658)---{HwBinder:658_1}(677) | |-cnd(855)-+-{cnd}(882) | | |-{cnd}(888) | | |-{cnd}(1229) | | `-{cnd}(1239) | |-cnss-daemon(856)-+-{cnss-daemon}(875) | | |-{cnss-daemon}(876) | | `-{cnss-daemon}(3619) | |-cnss_diag(847)---{cnss_diag}(865) | |-composer@2.1-se(517)-+-{Binder:517_1}(527) | | |-{Binder:517_2}(530) | | |-{HWC_UeventThre}(574) | | |-{HwBinder:517_1}(576) | | |-{HwBinder:517_2}(580) | | |-{HwBinder:517_3}(581) | | |-{SDM_EventThrea}(534) | | `-{composer@2.1-s}(573) | |-configstore@1.1(518)-+-{HwBinder:518_1}(525) | | `-{HwBinder:518_2}(3586) | |-contexthub@1.0-(659)-+-{contexthub@1.0}(1344) | | `-{contexthub@1.0}(1345) | |-drm@1.0-service(660)---{HwBinder:660_1}(678) | |-drm@1.1-service(661)---{HwBinder:661_1}(682) | |-drmserver(805)---{Binder:805_1}(838) | |-fingerprint@2.1(844)---{fingerprint@2.}(985) | |-gatekeeper@1.0-(662) | |-gatekeeperd(837) | |-gnss@1.0-servic(663)-+-{Loc_hal_worker}(1528) | | |-{Loc_hal_worker}(1530) | | |-{Loc_hal_worker}(1534) | | |-{Loc_hal_worker}(1536) | | |-{Loc_hal_worker}(1545) | | |-{Loc_hal_worker}(1546) | | |-{Loc_hal_worker}(1547) | | |-{Loc_hal_worker}(1548) | | |-{Loc_hal_worker}(1549) | | |-{Loc_hal_worker}(1608) | | `-{gnss@1.0-servi}(1529) | |-health@2.0-serv(664) | |-healthd(653) | |-hwservicemanage(484) | |-imsdatadaemon(879)---{imsdatadaemon}(895) | |-imsqmidaemon(828)---{imsqmidaemon}(842) | |-init(471) | |-init(472) | |-keymaster@3.0-s(513) | |-keystore(812)---{HwBinder:812_1}(845) | |-light@2.0-servi(665) | |-lmkd(689) | |-loc_launcher(857)-+-lowi-server(1210)-+-{lowi-server}(1213) | | | |-{lowi-server}(1214) | | | |-{lowi-server}(1215) | | | |-{lowi-server}(1216) | | | |-{lowi-server}(2062) | | | |-{lowi-server}(2063) | | | |-{lowi-server}(2066) | | | `-{lowi-server}(3620) | | |-slim_daemon(1211)-+-{HwBinder:1211_}(1223) | | | |-{Loc_hal_worker}(1219) | | | |-{Loc_hal_worker}(1221) | | | |-{Loc_hal_worker}(1226) | | | |-{Loc_hal_worker}(1233) | | | `-{NDK}(1218) | | |-xtra-daemon(1212)-+-{LocTimerMsgTas}(1228) | | | |-{LocTimerPollTa}(1227) | | | |-{pcid-loc-api}(1217) | | | |-{pcid-loc-api}(1222) | | | |-{pcid-loc-api}(1225) | | | `-{pcid-loc-api}(1232) | | `-{loc_launcher}(872) | |-logd(482)-+-{logd.auditd}(507) | | |-{logd.control}(493) | | |-{logd.daemon}(487) | | |-{logd.klogd}(506) | | |-{logd.writer}(492) | | `-{logd}(491) | |-main(641)-+-.localtransport(3001)-+-{ADB-JDWP Conne}(3010) | | | |-{Binder:3001_1}(3015) | | | |-{Binder:3001_2}(3016) | | | |-{Binder:3001_3}(3022) | | | |-{FinalizerDaemo}(3013) | | | |-{FinalizerWatch}(3014) | | | |-{HeapTaskDaemon}(3011) | | | |-{Jit thread poo}(3004) | | | |-{Profile Saver}(3032) | | | |-{ReferenceQueue}(3012) | | | |-{Signal Catcher}(3009) | | | `-{queued-work-lo}(3061) | | |-.qualcomm.embms(3417)-+-{ADB-JDWP Conne}(3439) | | | |-{Binder:3417_1}(3446) | | | |-{Binder:3417_2}(3449) | | | |-{FinalizerDaemo}(3442) | | | |-{FinalizerWatch}(3443) | | | |-{HeapTaskDaemon}(3440) | | | |-{Jit thread poo}(3427) | | | |-{Profile Saver}(3457) | | | |-{ReferenceQueue}(3441) | | | `-{Signal Catcher}(3432) | | |-ackageinstaller(3199)-+-{ADB-JDWP Conne}(3217) | | | |-{Binder:3199_1}(3222) | | | |-{Binder:3199_2}(3225) | | | |-{Binder:3199_3}(3227) | | | |-{FinalizerDaemo}(3220) | | | |-{FinalizerWatch}(3221) | | | |-{HeapTaskDaemon}(3218) | | | |-{Jit thread poo}(3210) | | | |-{Profile Saver}(3233) | | | |-{ReferenceQueue}(3219) | | | `-{Signal Catcher}(3215) | | |-android.smspush(2534)-+-{ADB-JDWP Conne}(2562) | | | |-{Binder:2534_1}(2567) | | | |-{Binder:2534_2}(2578) | | | |-{Binder:2534_3}(2598) | | | |-{FinalizerDaemo}(2565) | | | |-{FinalizerWatch}(2566) | | | |-{HeapTaskDaemon}(2563) | | | |-{Jit thread poo}(2545) | | | |-{Profile Saver}(2620) | | | |-{ReferenceQueue}(2564) | | | `-{Signal Catcher}(2554) | | |-android.traceur(3345)-+-{ADB-JDWP Conne}(3358) | | | |-{Binder:3345_1}(3363) | | | |-{Binder:3345_2}(3365) | | | |-{Binder:3345_3}(3368) | | | |-{FinalizerDaemo}(3361) | | | |-{FinalizerWatch}(3362) | | | |-{HeapTaskDaemon}(3359) | | | |-{Jit thread poo}(3352) | | | |-{Profile Saver}(3374) | | | |-{ReferenceQueue}(3360) | | | `-{Signal Catcher}(3357) | | |-com.android.nfc(2436)-+-{ADB-JDWP Conne}(2449) | | | |-{AsyncTask #1}(2652) | | | |-{AsyncTask #1}(2665) | | | |-{AsyncTask #1}(2667) | | | |-{Binder:2436_1}(2456) | | | |-{Binder:2436_2}(2457) | | | |-{Binder:2436_3}(2690) | | | |-{Binder:2436_4}(2715) | | | |-{CCodecWatchdog}(2685) | | | |-{FinalizerDaemo}(2453) | | | |-{FinalizerWatch}(2454) | | | |-{HeapTaskDaemon}(2451) | | | |-{HwBinder:2436_}(2668) | | | |-{Jit thread poo}(2443) | | | |-{NDK MediaCodec}(2686) | | | |-{Profile Saver}(2543) | | | |-{ReferenceQueue}(2452) | | | |-{Signal Catcher}(2448) | | | |-{SoundPoolThrea}(2680) | | | `-{SoundPool}(2679) | | |-com.android.se(2469)-+-{ADB-JDWP Conne}(2484) | | | |-{Binder:2469_1}(2489) | | | |-{Binder:2469_2}(2495) | | | |-{FinalizerDaemo}(2487) | | | |-{FinalizerWatch}(2488) | | | |-{HeapTaskDaemon}(2485) | | | |-{Jit thread poo}(2477) | | | |-{Profile Saver}(2561) | | | |-{ReferenceQueue}(2486) | | | |-{Signal Catcher}(2482) | | | `-{queued-work-lo}(2614) | | |-csbootstraputil(2499)-+-{ADB-JDWP Conne}(2519) | | | |-{Binder:2499_1}(2529) | | | |-{Binder:2499_2}(2533) | | | |-{Binder:2499_3}(3476) | | | |-{FinalizerDaemo}(2527) | | | |-{FinalizerWatch}(2528) | | | |-{HeapTaskDaemon}(2525) | | | |-{Jit thread poo}(2509) | | | |-{Profile Saver}(2619) | | | |-{ReferenceQueue}(2526) | | | |-{Signal Catcher}(2514) | | | `-{queued-work-lo}(3494) | | |-d.process.acore(2274)-+-{ADB-JDWP Conne}(2287) | | | |-{Binder:2274_1}(2292) | | | |-{Binder:2274_2}(2297) | | | |-{Binder:2274_3}(2442) | | | |-{FinalizerDaemo}(2290) | | | |-{FinalizerWatch}(2291) | | | |-{HeapTaskDaemon}(2288) | | | |-{Jit thread poo}(2281) | | | |-{Profile Saver}(2312) | | | |-{ReferenceQueue}(2289) | | | `-{Signal Catcher}(2286) | | |-d.process.media(2546)-+-{ADB-JDWP Conne}(2580) | | | |-{Binder:2546_1}(2589) | | | |-{Binder:2546_2}(2594) | | | |-{Binder:2546_3}(2600) | | | |-{FinalizerDaemo}(2583) | | | |-{FinalizerWatch}(2584) | | | |-{HeapTaskDaemon}(2581) | | | |-{Jit thread poo}(2568) | | | |-{Profile Saver}(2649) | | | |-{ReferenceQueue}(2582) | | | |-{Signal Catcher}(2573) | | | |-{android.bg}(2933) | | | |-{queued-work-lo}(2694) | | | `-{sAsyncHandlerT}(2683) | | |-droid.bluetooth(1402)-+-{ADB-JDWP Conne}(1415) | | | |-{AdapterState}(1592) | | | |-{AsyncTask #1}(1660) | | | |-{AudioPortEvent}(1633) | | | |-{BT Service Cal}(1627) | | | |-{BT Service Cal}(2167) | | | |-{Binder:1402_1}(1420) | | | |-{Binder:1402_2}(1422) | | | |-{Binder:1402_3}(1450) | | | |-{Binder:1402_4}(2177) | | | |-{Binder:1402_5}(2670) | | | |-{BluetoothActiv}(1629) | | | |-{BluetoothAdver}(1983) | | | |-{BluetoothDatab}(1648) | | | |-{BluetoothMapHa}(2187) | | | |-{BluetoothScanM}(1991) | | | |-{BondStateMachi}(1973) | | | |-{FinalizerDaemo}(1418) | | | |-{FinalizerWatch}(1419) | | | |-{HeapTaskDaemon}(1416) | | | |-{HwBinder:1402_}(2002) | | | |-{Jit thread poo}(1409) | | | |-{POSIX timer 0}(1616) | | | |-{POSIX timer 1}(1617) | | | |-{PbapHandlerThr}(2194) | | | |-{Profile Saver}(1484) | | | |-{ReferenceQueue}(1417) | | | |-{SapAcceptThrea}(2204) | | | |-{Signal Catcher}(1414) | | | |-{Thread-2}(2189) | | | |-{Thread-3}(2190) | | | |-{Thread-5}(2200) | | | |-{Thread-6}(2201) | | | |-{Thread-8}(2205) | | | |-{Thread-9}(2206) | | | |-{alarm_default_}(1618) | | | |-{alarm_dispatch}(1619) | | | |-{bt_a2dp_source}(2184) | | | |-{bt_hci_thread}(2000) | | | |-{bt_main_thread}(2109) | | | |-{bt_stack_manag}(1601) | | | |-{bt_startup_thr}(2106) | | | |-{btif_sock}(2168) | | | |-{e.StateMachine}(2178) | | | |-{e.StateMachine}(2180) | | | `-{queued-work-lo}(1994) | | |-droid.dynsystem(2973)-+-{ADB-JDWP Conne}(2985) | | | |-{Binder:2973_1}(2990) | | | |-{Binder:2973_2}(2991) | | | |-{FinalizerDaemo}(2988) | | | |-{FinalizerWatch}(2989) | | | |-{HeapTaskDaemon}(2986) | | | |-{Jit thread poo}(2979) | | | |-{Profile Saver}(2998) | | | |-{ReferenceQueue}(2987) | | | `-{Signal Catcher}(2984) | | |-droid.launcher3(1975)-+-{ADB-JDWP Conne}(2005) | | | |-{Binder:1975_1}(2012) | | | |-{Binder:1975_2}(2029) | | | |-{Binder:1975_3}(2034) | | | |-{Binder:1975_4}(2742) | | | |-{FinalizerDaemo}(2008) | | | |-{FinalizerWatch}(2009) | | | |-{GrallocUploadT}(2732) | | | |-{HeapTaskDaemon}(2006) | | | |-{Jit thread poo}(1995) | | | |-{Profile Saver}(2048) | | | |-{ReferenceQueue}(2007) | | | |-{RenderThread}(2574) | | | |-{Signal Catcher}(2001) | | | |-{TaskThumbnailI}(2521) | | | |-{UiThreadHelper}(2053) | | | |-{android.bg}(2051) | | | |-{hwuiTask0}(3498) | | | |-{hwuiTask1}(3499) | | | |-{launcher-loade}(2655) | | | |-{magnifier pixe}(2688) | | | |-{pool-1-thread-}(3530) | | | |-{pool-2-thread-}(2491) | | | |-{pool-2-thread-}(2672) | | | `-{queued-work-lo}(2508) | | |-droid.messaging(3120)-+-{ADB-JDWP Conne}(3135) | | | |-{AsyncTask #4}(3168) | | | |-{Binder:3120_1}(3140) | | | |-{Binder:3120_2}(3143) | | | |-{Binder:3120_3}(3276) | | | |-{FinalizerDaemo}(3138) | | | |-{FinalizerWatch}(3139) | | | |-{HeapTaskDaemon}(3136) | | | |-{Jit thread poo}(3126) | | | |-{Profile Saver}(3151) | | | |-{ReferenceQueue}(3137) | | | |-{Signal Catcher}(3134) | | | `-{queued-work-lo}(3163) | | |-elephonyservice(1635)-+-{ADB-JDWP Conne}(1655) | | | |-{Binder:1635_1}(1663) | | | |-{Binder:1635_2}(1678) | | | |-{Binder:1635_3}(1685) | | | |-{FinalizerDaemo}(1658) | | | |-{FinalizerWatch}(1659) | | | |-{HeapTaskDaemon}(1656) | | | |-{HwBinder:1635_}(1757) | | | |-{Jit thread poo}(1649) | | | |-{Profile Saver}(1705) | | | |-{ReferenceQueue}(1657) | | | |-{Signal Catcher}(1654) | | | `-{queued-work-lo}(1758) | | |-gedprovisioning(3090)-+-{ADB-JDWP Conne}(3102) | | | |-{Binder:3090_1}(3107) | | | |-{Binder:3090_2}(3108) | | | |-{Binder:3090_3}(3113) | | | |-{FinalizerDaemo}(3105) | | | |-{FinalizerWatch}(3106) | | | |-{HeapTaskDaemon}(3103) | | | |-{Jit thread poo}(3096) | | | |-{Profile Saver}(3118) | | | |-{ReferenceQueue}(3104) | | | `-{Signal Catcher}(3101) | | |-gs.intelligence(3545)-+-{ADB-JDWP Conne}(3557) | | | |-{Binder:3545_1}(3562) | | | |-{Binder:3545_2}(3563) | | | |-{Binder:3545_3}(3565) | | | |-{Binder:3545_4}(3566) | | | |-{FinalizerDaemo}(3560) | | | |-{FinalizerWatch}(3561) | | | |-{HeapTaskDaemon}(3558) | | | |-{Jit thread poo}(3551) | | | |-{Profile Saver}(3581) | | | |-{ReferenceQueue}(3559) | | | |-{Signal Catcher}(3556) | | | `-{queued-work-lo}(3594) | | |-id.ext.services(1762)-+-{ADB-JDWP Conne}(1785) | | | |-{AsyncTask #1}(2027) | | | |-{Binder:1762_1}(1791) | | | |-{Binder:1762_2}(1797) | | | |-{Binder:1762_3}(1812) | | | |-{Binder:1762_4}(2030) | | | |-{FinalizerDaemo}(1788) | | | |-{FinalizerWatch}(1790) | | | |-{HeapTaskDaemon}(1786) | | | |-{Jit thread poo}(1775) | | | |-{Profile Saver}(1847) | | | |-{ReferenceQueue}(1787) | | | |-{Signal Catcher}(1780) | | | |-{android.bg}(2033) | | | `-{queued-work-lo}(2031) | | |-id.networkstack(1620)-+-{ADB-JDWP Conne}(1661) | | | |-{Binder:1620_1}(1669) | | | |-{Binder:1620_2}(1683) | | | |-{FinalizerDaemo}(1666) | | | |-{FinalizerWatch}(1667) | | | |-{HeapTaskDaemon}(1664) | | | |-{IpClient.wlan0}(2083) | | | |-{Jit thread poo}(1642) | | | |-{Profile Saver}(1743) | | | |-{ReferenceQueue}(1665) | | | `-{Signal Catcher}(1647) | | |-id.printspooler(2735)-+-{ADB-JDWP Conne}(2749) | | | |-{AsyncTask #1}(3507) | | | |-{Binder:2735_1}(2754) | | | |-{Binder:2735_2}(2755) | | | |-{Binder:2735_3}(2756) | | | |-{FinalizerDaemo}(2752) | | | |-{FinalizerWatch}(2753) | | | |-{HeapTaskDaemon}(2750) | | | |-{Jit thread poo}(2743) | | | |-{Profile Saver}(2764) | | | |-{ReferenceQueue}(2751) | | | |-{Signal Catcher}(2748) | | | `-{queued-work-lo}(3508) | | |-lcomm.telephony(3386)-+-{ADB-JDWP Conne}(3399) | | | |-{Binder:3386_1}(3405) | | | |-{Binder:3386_2}(3406) | | | |-{Binder:3386_3}(3408) | | | |-{CTSA Inject Th}(3424) | | | |-{FinalizerDaemo}(3402) | | | |-{FinalizerWatch}(3403) | | | |-{HeapTaskDaemon}(3400) | | | |-{HwBinder:3386_}(3425) | | | |-{Jit thread poo}(3393) | | | |-{Profile Saver}(3414) | | | |-{ReferenceQueue}(3401) | | | |-{Signal Catcher}(3398) | | | |-{Thread-2}(3423) | | | `-{queued-work-lo}(3426) | | |-m.android.email(3033)-+-{ADB-JDWP Conne}(3047) | | | |-{AsyncTask #11}(3110) | | | |-{Binder:3033_1}(3053) | | | |-{Binder:3033_2}(3062) | | | |-{Binder:3033_3}(3066) | | | |-{Binder:3033_4}(3879) | | | |-{EmailNotificat}(3156) | | | |-{FinalizerDaemo}(3050) | | | |-{FinalizerWatch}(3051) | | | |-{HeapTaskDaemon}(3048) | | | |-{Jit thread poo}(3039) | | | |-{Profile Saver}(3071) | | | |-{ReferenceQueue}(3049) | | | |-{Signal Catcher}(3044) | | | `-{queued-work-lo}(3084) | | |-m.android.phone(1668)-+-{ADB-JDWP Conne}(1693) | | | |-{AsyncTask #1}(2073) | | | |-{AudioTrack}(2344) | | | |-{Binder:1668_1}(1698) | | | |-{Binder:1668_2}(1703) | | | |-{Binder:1668_3}(1723) | | | |-{Binder:1668_4}(2071) | | | |-{Binder:1668_5}(2245) | | | |-{Binder:1668_6}(2270) | | | |-{Binder:1668_7}(2345) | | | |-{Binder:1668_8}(2886) | | | |-{Binder:1668_9}(3382) | | | |-{CdmaInboundSms}(2023) | | | |-{CdmaServiceCat}(2026) | | | |-{CellBroadcastH}(2022) | | | |-{CellularDataSe}(2171) | | | |-{CellularNetwor}(2170) | | | |-{ConnectivityTh}(2049) | | | |-{DataService}(2108) | | | |-{DcHandlerThrea}(2041) | | | |-{FinalizerDaemo}(1696) | | | |-{FinalizerWatch}(1697) | | | |-{GsmCellBroadca}(1987) | | | |-{GsmInboundSmsH}(2011) | | | |-{HeapTaskDaemon}(1694) | | | |-{HwBinder:1668_}(1930) | | | |-{IFMsg_Rxr}(2153) | | | |-{IFMsg_Sender}(2148) | | | |-{ImsConfigImplH}(2156) | | | |-{ImsServiceCont}(2091) | | | |-{ImsServiceSubR}(2155) | | | |-{Jit thread poo}(1687) | | | |-{NetworkService}(2103) | | | |-{ONSNetworkScan}(3204) | | | |-{ONSProfileSele}(3209) | | | |-{Profile Saver}(1789) | | | |-{ReferenceQueue}(1695) | | | |-{Signal Catcher}(1692) | | | |-{android.bg}(2054) | | | |-{ervice.Executo}(2853) | | | `-{queued-work-lo}(1900) | | |-mm.embms:remote(3460)-+-{ADB-JDWP Conne}(3477) | | | |-{Binder:3460_1}(3483) | | | |-{Binder:3460_2}(3484) | | | |-{Binder:3460_3}(3488) | | | |-{FinalizerDaemo}(3480) | | | |-{FinalizerWatch}(3481) | | | |-{HeapTaskDaemon}(3478) | | | |-{Jit thread poo}(3470) | | | |-{Profile Saver}(3493) | | | |-{ReferenceQueue}(3479) | | | |-{Signal Catcher}(3475) | | | `-{queued-work-lo}(3501) | | |-ndroid.keychain(3622)-+-{ADB-JDWP Conne}(3634) | | | |-{Binder:3622_1}(3639) | | | |-{Binder:3622_2}(3640) | | | |-{Binder:3622_3}(3645) | | | |-{Binder:3622_4}(3650) | | | |-{FinalizerDaemo}(3637) | | | |-{FinalizerWatch}(3638) | | | |-{HeapTaskDaemon}(3635) | | | |-{Jit thread poo}(3628) | | | |-{ReferenceQueue}(3636) | | | |-{Runtime worker}(3629) | | | |-{Runtime worker}(3630) | | | |-{Runtime worker}(3631) | | | |-{Runtime worker}(3632) | | | |-{Signal Catcher}(3633) | | | `-{queued-work-lo}(3651) | | |-ndroid.settings(3316)-+-{ADB-JDWP Conne}(3329) | | | |-{AsyncTask #2}(3543) | | | |-{Binder:3316_1}(3334) | | | |-{Binder:3316_2}(3335) | | | |-{Binder:3316_3}(3337) | | | |-{Binder:3316_4}(3878) | | | |-{ConnectivityTh}(3532) | | | |-{FinalizerDaemo}(3332) | | | |-{FinalizerWatch}(3333) | | | |-{HeapTaskDaemon}(3330) | | | |-{Jit thread poo}(3323) | | | |-{Profile Saver}(3340) | | | |-{ReferenceQueue}(3331) | | | |-{RenderThread}(3527) | | | |-{SettingsIntell}(3531) | | | |-{Signal Catcher}(3328) | | | |-{pool-3-thread-}(3544) | | | `-{queued-work-lo}(3585) | | |-ndroid.systemui(1429)-+-{ADB-JDWP Conne}(1446) | | | |-{AsyncTask #3}(2078) | | | |-{AudioTrack}(3385) | | | |-{Binder:1429_1}(1452) | | | |-{Binder:1429_2}(1454) | | | |-{Binder:1429_3}(1475) | | | |-{Binder:1429_4}(1479) | | | |-{Binder:1429_5}(2210) | | | |-{Binder:1429_6}(2213) | | | |-{Binder:1429_7}(2225) | | | |-{CCodecWatchdog}(2092) | | | |-{ConnectivityTh}(2070) | | | |-{FinalizerDaemo}(1449) | | | |-{FinalizerWatch}(1451) | | | |-{FlashlightCont}(2181) | | | |-{GrallocUploadT}(3509) | | | |-{HeapTaskDaemon}(1447) | | | |-{HwBinder:1429_}(2094) | | | |-{ImageWallpaper}(1741) | | | |-{Jit thread poo}(1436) | | | |-{Keyboard}(2209) | | | |-{NDK MediaCodec}(2093) | | | |-{Profile Saver}(1485) | | | |-{ReferenceQueue}(1448) | | | |-{RenderThread}(2061) | | | |-{ScreenDecorati}(2212) | | | |-{Signal Catcher}(1443) | | | |-{SoundPoolThrea}(1934) | | | |-{SoundPool}(1933) | | | |-{SysUiBg}(1916) | | | |-{Thread-2}(2349) | | | |-{TimeTick}(2086) | | | |-{VolumeDialogCo}(1959) | | | |-{WifiTracker{2e}(2072) | | | |-{async_sensor}(2067) | | | |-{hwuiTask0}(2347) | | | |-{hwuiTask1}(2348) | | | |-{pool-2-thread-}(1815) | | | |-{pool-3-thread-}(2239) | | | |-{pool-4-thread-}(2249) | | | |-{pool-6-thread-}(2248) | | | |-{queued-work-lo}(2056) | | | `-{recents.fg}(2211) | | |-putmethod.latin(1858)-+-{ADB-JDWP Conne}(1892) | | | |-{AsyncTask #1}(2044) | | | |-{Binder:1858_1}(1899) | | | |-{Binder:1858_2}(1904) | | | |-{Binder:1858_3}(1908) | | | |-{Binder:1858_4}(2050) | | | |-{Binder:1858_5}(3591) | | | |-{ExecutorUtils}(2047) | | | |-{FinalizerDaemo}(1897) | | | |-{FinalizerWatch}(1898) | | | |-{HeapTaskDaemon}(1895) | | | |-{InputLogicHand}(2431) | | | |-{Jit thread poo}(1884) | | | |-{Profile Saver}(1938) | | | |-{ReferenceQueue}(1896) | | | `-{Signal Catcher}(1889) | | |-ssioncontroller(3236)-+-{ADB-JDWP Conne}(3248) | | | |-{AsyncTask #1}(3587) | | | |-{Binder:3236_1}(3253) | | | |-{Binder:3236_2}(3254) | | | |-{Binder:3236_3}(3575) | | | |-{FinalizerDaemo}(3251) | | | |-{FinalizerWatch}(3252) | | | |-{HeapTaskDaemon}(3249) | | | |-{Jit thread poo}(3242) | | | |-{Profile Saver}(3262) | | | |-{ReferenceQueue}(3250) | | | |-{Signal Catcher}(3247) | | | `-{queued-work-lo}(3621) | | |-system_server(926)-+-{ADB-JDWP Conne}(945) | | | |-{AccountManager}(1249) | | | |-{ActivityManage}(974) | | | |-{ActivityManage}(975) | | | |-{ActivityManage}(976) | | | |-{AdbDebuggingMa}(2355) | | | |-{AlarmManager}(1251) | | | |-{AsyncQueryWork}(2852) | | | |-{AsyncTask #2}(2246) | | | |-{AudioDeviceBro}(1320) | | | |-{AudioPortEvent}(1718) | | | |-{AudioService}(1319) | | | |-{AudioTrack}(3523) | | | |-{BatteryStats_w}(1008) | | | |-{Binder:926_1}(952) | | | |-{Binder:926_2}(953) | | | |-{Binder:926_3}(1289) | | | |-{Binder:926_4}(1298) | | | |-{Binder:926_5}(1323) | | | |-{Binder:926_6}(1468) | | | |-{Binder:926_7}(1805) | | | |-{Binder:926_8}(1814) | | | |-{Binder:926_9}(1957) | | | |-{Binder:926_A}(1968) | | | |-{Binder:926_B}(1974) | | | |-{Binder:926_C}(3268) | | | |-{Binder:926_D}(3695) | | | |-{BluetoothRoute}(1702) | | | |-{CCodecWatchdog}(2114) | | | |-{CallAudioModeS}(1744) | | | |-{CameraService_}(1355) | | | |-{ClientModeImpl}(1274) | | | |-{ConnectionSvrF}(1745) | | | |-{ConnectivitySe}(1299) | | | |-{ConnectivityTh}(1341) | | | |-{CpuTracker}(1004) | | | |-{DeviceStorageM}(1313) | | | |-{EmergencyAffor}(1487) | | | |-{EthernetServic}(1373) | | | |-{FileObserver}(1003) | | | |-{FinalizerDaemo}(948) | | | |-{FinalizerWatch}(949) | | | |-{GraphicsStats-}(1347) | | | |-{HealthServiceR}(1245) | | | |-{HeapTaskDaemon}(946) | | | |-{HwBinder:926_1}(1007) | | | |-{HwBinder:926_2}(1255) | | | |-{HwBinder:926_3}(1256) | | | |-{HwBinder:926_4}(1257) | | | |-{HwBinder:926_5}(1259) | | | |-{InputDispatche}(1260) | | | |-{InputReader}(1261) | | | |-{Jit thread poo}(938) | | | |-{LazyTaskWriter}(2429) | | | |-{NDK MediaCodec}(2121) | | | |-{NetworkPolicy}(1270) | | | |-{NetworkStatsOb}(1480) | | | |-{NetworkStats}(1269) | | | |-{NetworkTimeUpd}(1520) | | | |-{NetworkWatchli}(1262) | | | |-{NsdService}(1305) | | | |-{OomAdjuster}(977) | | | |-{OsuServerHandl}(1388) | | | |-{PackageInstall}(1201) | | | |-{PackageManager}(1012) | | | |-{PackageManager}(1013) | | | |-{PhotonicModula}(1378) | | | |-{PowerManagerSe}(1006) | | | |-{RedirectListen}(1368) | | | |-{ReferenceQueue}(947) | | | |-{RenderThread}(3694) | | | |-{RollbackManage}(1246) | | | |-{RollbackPackag}(1247) | | | |-{Runtime worker}(939) | | | |-{Runtime worker}(940) | | | |-{Runtime worker}(941) | | | |-{Runtime worker}(942) | | | |-{SensorEventAck}(1208) | | | |-{SensorService}(1209) | | | |-{SettingsProvid}(1250) | | | |-{Signal Catcher}(943) | | | |-{SliceManagerSe}(1354) | | | |-{SoundPoolThrea}(1464) | | | |-{SoundPool}(1463) | | | |-{StatsCompanion}(1356) | | | |-{StorageManager}(1267) | | | |-{SyncHandler-0}(1366) | | | |-{SyncManager}(1396) | | | |-{TaskSnapshotPe}(1377) | | | |-{Thread-4}(1459) | | | |-{UEventObserver}(1254) | | | |-{UsbService hos}(1425) | | | |-{WifiP2pService}(1275) | | | |-{WifiScanningSe}(1295) | | | |-{WifiService}(1273) | | | |-{android.anim.l}(969) | | | |-{android.anim}(968) | | | |-{android.bg}(973) | | | |-{android.displa}(967) | | | |-{android.fg}(964) | | | |-{android.io}(966) | | | |-{android.ui}(965) | | | |-{backup-0}(2434) | | | |-{backup}(1343) | | | |-{batterystats-w}(980) | | | |-{hidl_ssvc_poll}(1258) | | | |-{mDnsConnector}(1307) | | | |-{notification-s}(1308) | | | |-{onProviders.EC}(1311) | | | |-{pool-3-thread-}(1346) | | | |-{queued-work-lo}(1977) | | | |-{ranker}(1309) | | | |-{roid.pacmanage}(1301) | | | |-{tworkPolicy.ui}(1271) | | | |-{uteStateMachin}(1734) | | | |-{watchdog}(970) | | | `-{wifiRttService}(1370) | | |-timeinitializer(3169)-+-{ADB-JDWP Conne}(3181) | | | |-{Binder:3169_1}(3186) | | | |-{Binder:3169_2}(3187) | | | |-{FinalizerDaemo}(3184) | | | |-{FinalizerWatch}(3185) | | | |-{HeapTaskDaemon}(3182) | | | |-{Jit thread poo}(3175) | | | |-{Profile Saver}(3195) | | | |-{ReferenceQueue}(3183) | | | `-{Signal Catcher}(3180) | | |-viders.calendar(3269)-+-{ADB-JDWP Conne}(3287) | | | |-{Binder:3269_1}(3292) | | | |-{Binder:3269_2}(3295) | | | |-{Binder:3269_3}(3300) | | | |-{FinalizerDaemo}(3290) | | | |-{FinalizerWatch}(3291) | | | |-{HeapTaskDaemon}(3288) | | | |-{Jit thread poo}(3281) | | | |-{Profile Saver}(3308) | | | |-{ReferenceQueue}(3289) | | | |-{Signal Catcher}(3286) | | | `-{queued-work-lo}(3517) | | |-{FinalizerDaemo}(3625) | | |-{FinalizerWatch}(3626) | | |-{HeapTaskDaemon}(3623) | | |-{Jit thread poo}(3627) | | `-{ReferenceQueue}(3624) | |-main(642)-+-webview_zygote(1819)-+-{FinalizerDaemo}(1836) | | | |-{FinalizerWatch}(1837) | | | |-{HeapTaskDaemon}(1834) | | | |-{Jit thread poo}(1838) | | | `-{ReferenceQueue}(1835) | | |-{FinalizerDaemo}(1822) | | |-{FinalizerWatch}(1823) | | |-{HeapTaskDaemon}(1820) | | |-{Jit thread poo}(1824) | | `-{ReferenceQueue}(1821) | |-mediadrmserver(813)---{Binder:813_1}(830) | |-mediaextractor(815)-+-{Binder:815_1}(915) | | |-{Binder:815_2}(2139) | | `-{Binder:815_3}(2145) | |-mediametrics(819)---{Binder:819_1}(878) | |-mediaserver(820)-+-{Binder:820_1}(933) | | |-{Binder:820_2}(1949) | | |-{Binder:820_3}(1950) | | |-{Binder:820_4}(2763) | | `-{HwBinder:820_1}(1489) | |-mediaswcodec(836)-+-{HwBinder:836_1}(917) | | |-{HwBinder:836_1}(2017) | | |-{HwBinder:836_2}(2079) | | |-{HwBinder:836_3}(2081) | | |-{HwBinder:836_4}(2082) | | |-{HwBinder:836_5}(2084) | | |-{HwBinder:836_6}(2088) | | |-{HwBinder:836_7}(2101) | | `-{HwBinder:836_7}(2115) | |-memtrack@1.0-se(666) | |-msm_irqbalance(730) | |-nanohub_slpi(854)-+-{nanohub_slpi}(867) | | |-{nanohub_slpi}(868) | | `-{nanohub_slpi}(916) | |-netmgrd(833)-+-{netmgrd}(883) | | |-{netmgrd}(908) | | |-{netmgrd}(909) | | |-{netmgrd}(910) | | |-{netmgrd}(911) | | |-{netmgrd}(1127) | | |-{netmgrd}(1128) | | |-{netmgrd}(1129) | | |-{netmgrd}(1230) | | |-{netmgrd}(1277) | | |-{netmgrd}(1278) | | |-{netmgrd}(1279) | | |-{netmgrd}(1280) | | |-{netmgrd}(1288) | | |-{netmgrd}(1290) | | |-{netmgrd}(1291) | | |-{netmgrd}(1293) | | |-{netmgrd}(1297) | | |-{netmgrd}(1300) | | |-{netmgrd}(1302) | | |-{netmgrd}(1304) | | |-{netmgrd}(1312) | | |-{netmgrd}(1314) | | |-{netmgrd}(1316) | | |-{netmgrd}(1318) | | |-{netmgrd}(1325) | | |-{netmgrd}(1326) | | |-{netmgrd}(1328) | | |-{netmgrd}(1329) | | |-{netmgrd}(1333) | | |-{netmgrd}(1336) | | |-{netmgrd}(1337) | | |-{netmgrd}(1339) | | |-{netmgrd}(1348) | | |-{netmgrd}(1350) | | |-{netmgrd}(1351) | | |-{netmgrd}(1352) | | |-{netmgrd}(1359) | | |-{netmgrd}(1360) | | |-{netmgrd}(1361) | | |-{netmgrd}(1362) | | |-{netmgrd}(1367) | | |-{netmgrd}(1369) | | |-{netmgrd}(1372) | | |-{netmgrd}(1374) | | |-{netmgrd}(1380) | | |-{netmgrd}(1382) | | |-{netmgrd}(1383) | | |-{netmgrd}(1384) | | |-{netmgrd}(1387) | | |-{netmgrd}(1390) | | |-{netmgrd}(1391) | | |-{netmgrd}(1392) | | |-{netmgrd}(1395) | | |-{netmgrd}(1397) | | |-{netmgrd}(1399) | | |-{netmgrd}(1400) | | |-{netmgrd}(1421) | | |-{netmgrd}(1424) | | |-{netmgrd}(1426) | | |-{netmgrd}(1427) | | |-{netmgrd}(1457) | | |-{netmgrd}(1458) | | |-{netmgrd}(1462) | | |-{netmgrd}(1467) | | |-{netmgrd}(1488) | | |-{netmgrd}(1501) | | |-{netmgrd}(1502) | | |-{netmgrd}(1506) | | |-{netmgrd}(1531) | | |-{netmgrd}(1535) | | |-{netmgrd}(1538) | | |-{netmgrd}(1541) | | |-{netmgrd}(1576) | | |-{netmgrd}(1578) | | |-{netmgrd}(1579) | | |-{netmgrd}(1584) | | `-{netmgrd}(1585) | |-nfc@1.1-service(669)-+-{POSIX timer 0}(2669) | | |-{POSIX timer 1}(2676) | | |-{nfc@1.1-servic}(2674) | | |-{nfc@1.1-servic}(2675) | | `-{nfc@1.1-servic}(2677) | |-omx@1.0-service(825)-+-{Binder:825_1}(913) | | |-{Binder:825_2}(914) | | |-{HwBinder:825_1}(923) | | |-{HwBinder:825_2}(924) | | |-{HwBinder:825_3}(1511) | | `-{HwBinder:825_4}(1555) | |-perfd(2400)-+-{POSIX timer 0}(2417) | | `-{perfd}(2413) | |-pm-proxy(796)-+-{Binder:796_1}(816) | | |-{Binder:796_2}(817) | | `-{Binder:796_3}(818) | |-pm-service(701)-+-{Binder:701_1}(795) | | |-{Binder:701_2}(807) | | |-{Binder:701_3}(918) | | |-{Binder:701_4}(921) | | |-{POSIX timer 0}(790) | | |-{POSIX timer 1}(792) | | `-{pm-service}(794) | |-port-bridge(832)-+-{port-bridge}(858) | | `-{port-bridge}(859) | |-power@1.1-servi(670) | |-provider@2.4-se(656)-+-{CAM_gyro_sens}(1102) | | |-{CAM_imgTh}(1055) | | |-{CAM_imgTh}(1056) | | |-{CAM_imgTh}(1057) | | |-{CAM_imgTh}(1058) | | |-{CAM_imgTh}(1059) | | |-{CAM_imgTh}(1060) | | |-{CAM_imgTh}(1061) | | |-{CAM_imgTh}(1062) | | |-{CAM_imgTh}(1063) | | |-{CAM_imgTh}(1064) | | |-{CAM_imgTh}(1065) | | |-{CAM_imgTh}(1066) | | |-{CAM_imgTh}(1067) | | |-{CAM_imgTh}(1068) | | |-{CAM_imgTh}(1069) | | |-{CAM_imgTh}(1070) | | |-{CAM_imgTh}(1071) | | |-{CAM_imgTh}(1072) | | |-{CAM_imgTh}(1073) | | |-{CAM_imgTh}(1074) | | |-{HwBinder:656_1}(1111) | | |-{HwBinder:656_2}(1115) | | |-{cp_thread}(1078) | | |-{cp_thread}(1080) | | |-{cp_thread}(1081) | | `-{cp_thread}(1082) | |-qseecomd(486)---qseecomd(499)-+-{qseecomd}(500) | | |-{qseecomd}(502) | | |-{qseecomd}(504) | | |-{qseecomd}(505) | | |-{qseecomd}(508) | | |-{qseecomd}(509) | | `-{qseecomd}(510) | |-rild(835)-+-{Binder:835_1}(982) | | |-{Binder:835_2}(984) | | |-{HwBinder:835_1}(995) | | |-{rild}(887) | | |-{rild}(894) | | |-{rild}(983) | | |-{rild}(993) | | |-{rild}(994) | | |-{rild}(996) | | |-{rild}(997) | | |-{rild}(998) | | |-{rild}(999) | | |-{rild}(1000) | | |-{rild}(1002) | | |-{rild}(1231) | | |-{rild}(2214) | | |-{rild}(2215) | | |-{rild}(2216) | | |-{rild}(2217) | | |-{rild}(2218) | | |-{rild}(2219) | | |-{rild}(2220) | | |-{rild}(2221) | | |-{rild}(2222) | | |-{rild}(2229) | | |-{rild}(2230) | | |-{rild}(2231) | | |-{rild}(2232) | | |-{rild}(2235) | | |-{rild}(2236) | | |-{rild}(2250) | | |-{rild}(2251) | | |-{rild}(2252) | | |-{rild}(2253) | | |-{rild}(2254) | | |-{rild}(2256) | | |-{rild}(2257) | | |-{rild}(2258) | | |-{rild}(2259) | | |-{rild}(2260) | | `-{rild}(2261) | |-rmt_storage(729)-+-{rmt_storage}(989) | | |-{rmt_storage}(990) | | |-{rmt_storage}(991) | | `-{rmt_storage}(992) | |-sensors@1.0-ser(671)-+-{HubConnection}(869) | | |-{HwBinder:671_1}(871) | | `-{ddad_file}(870) | |-servicemanager(483) | |-storaged(823)-+-{Binder:823_1}(951) | | |-{HwBinder:823_1}(1242) | | `-{storaged}(950) | |-subsystem_ramdu(802) | |-surfaceflinger(515)-+-{Binder:515_1}(540) | | |-{Binder:515_2}(541) | | |-{Binder:515_3}(657) | | |-{Binder:515_4}(1009) | | |-{Binder:515_5}(3576) | | |-{DispSync}(542) | | |-{HwBinder:515_1}(578) | | |-{app}(544) | | |-{sf}(545) | | |-{surfaceflinger}(543) | | |-{surfaceflinger}(546) | | `-{surfaceflinger}(547) | |-suspend@1.0-ser(652)-+-{Binder:652_1}(667) | | |-{Binder:652_2}(668) | | `-{Binder:652_2}(3696) | |-thermal-engine(680)-+-{POSIX timer 0}(770) | | |-{POSIX timer 1}(771) | | |-{POSIX timer 2}(772) | | |-{POSIX timer 3}(773) | | |-{thermal-engine}(692) | | |-{thermal-engine}(695) | | |-{thermal-engine}(696) | | |-{thermal-engine}(697) | | |-{thermal-engine}(698) | | |-{thermal-engine}(699) | | |-{thermal-engine}(700) | | |-{thermal-engine}(702) | | |-{thermal-engine}(703) | | |-{thermal-engine}(704) | | |-{thermal-engine}(705) | | |-{thermal-engine}(706) | | |-{thermal-engine}(707) | | |-{thermal-engine}(708) | | |-{thermal-engine}(709) | | |-{thermal-engine}(710) | | |-{thermal-engine}(711) | | |-{thermal-engine}(712) | | |-{thermal-engine}(713) | | |-{thermal-engine}(714) | | |-{thermal-engine}(715) | | |-{thermal-engine}(716) | | |-{thermal-engine}(717) | | |-{thermal-engine}(718) | | |-{thermal-engine}(719) | | |-{thermal-engine}(720) | | |-{thermal-engine}(721) | | |-{thermal-engine}(722) | | |-{thermal-engine}(723) | | |-{thermal-engine}(724) | | |-{thermal-engine}(725) | | |-{thermal-engine}(726) | | |-{thermal-engine}(728) | | |-{thermal-engine}(732) | | |-{thermal-engine}(734) | | |-{thermal-engine}(735) | | |-{thermal-engine}(736) | | |-{thermal-engine}(737) | | |-{thermal-engine}(739) | | |-{thermal-engine}(740) | | |-{thermal-engine}(741) | | |-{thermal-engine}(742) | | |-{thermal-engine}(743) | | |-{thermal-engine}(744) | | |-{thermal-engine}(745) | | |-{thermal-engine}(746) | | |-{thermal-engine}(748) | | |-{thermal-engine}(749) | | |-{thermal-engine}(750) | | |-{thermal-engine}(751) | | |-{thermal-engine}(752) | | |-{thermal-engine}(753) | | |-{thermal-engine}(754) | | |-{thermal-engine}(756) | | |-{thermal-engine}(761) | | |-{thermal-engine}(763) | | |-{thermal-engine}(765) | | |-{thermal-engine}(766) | | |-{thermal-engine}(767) | | |-{thermal-engine}(768) | | |-{thermal-engine}(769) | | `-{thermal-engine}(1017) | |-thermal@2.0-ser(672)---{FileWatcherThr}(755) | |-time_daemon(538)-+-{time_daemon}(551) | | |-{time_daemon}(552) | | |-{time_daemon}(553) | | |-{time_daemon}(554) | | |-{time_daemon}(555) | | `-{time_daemon}(1191) | |-tombstoned(840) | |-traced(791)---{traced}(808) | |-traced_probes(793)---{traced_probes}(809) | |-ueventd(473) | |-update_engine(841) | |-usb@1.1-service(673)---{usb@1.1-servic}(1338) | |-vibrator@1.0-se(674) | |-vndservicemanag(485) | |-vr@1.0-service(675) | |-wifi@1.0-servic(676)-+-{wifi@1.0-servi}(2065) | | `-{wifi@1.0-servi}(2069) | |-wificond(824) | `-wpa_supplicant(1590) `-kthreadd(2)-+-9-0022(291) |-9-0022(292) |-DATA1(1236) |-DATA11(1241) |-DATA2(1237) |-DATA3(1238) |-DATA4(1240) |-DIAG_CNTL_SOCKE(241) |-DIAG_SMD_LPASS_(206) |-DIAG_SMD_LPASS_(207) |-DIAG_SMD_LPASS_(208) |-DIAG_SMD_LPASS_(209) |-DIAG_SMD_LPASS_(210) |-DIAG_SMD_MODEM_(201) |-DIAG_SMD_MODEM_(202) |-DIAG_SMD_MODEM_(203) |-DIAG_SMD_MODEM_(204) |-DIAG_SMD_MODEM_(205) |-DIAG_SMD_SENSOR(216) |-DIAG_SMD_SENSOR(217) |-DIAG_SMD_SENSOR(218) |-DIAG_SMD_SENSOR(219) |-DIAG_SMD_SENSOR(220) |-DIAG_SMD_WCNSS_(211) |-DIAG_SMD_WCNSS_(212) |-DIAG_SMD_WCNSS_(213) |-DIAG_SMD_WCNSS_(214) |-DIAG_SMD_WCNSS_(215) |-DIAG_SOCKLPASS_(226) |-DIAG_SOCKLPASS_(227) |-DIAG_SOCKLPASS_(228) |-DIAG_SOCKLPASS_(229) |-DIAG_SOCKLPASS_(230) |-DIAG_SOCKMODEM_(221) |-DIAG_SOCKMODEM_(222) |-DIAG_SOCKMODEM_(223) |-DIAG_SOCKMODEM_(224) |-DIAG_SOCKMODEM_(225) |-DIAG_SOCKSENSOR(236) |-DIAG_SOCKSENSOR(237) |-DIAG_SOCKSENSOR(238) |-DIAG_SOCKSENSOR(239) |-DIAG_SOCKSENSOR(240) |-DIAG_SOCKWCNSS_(231) |-DIAG_SOCKWCNSS_(232) |-DIAG_SOCKWCNSS_(233) |-DIAG_SOCKWCNSS_(234) |-DIAG_SOCKWCNSS_(235) |-DIAG_USB_diag(198) |-DS(864) |-FILE_FREE(413) |-HTC_BATTERY_FB(319) |-IPCRTR(169) |-IPCRTR(171) |-IPCRTR(173) |-IPCRTR_dsps_smd(172) |-IPCRTR_lpass_sm(170) |-IPCRTR_mpss_smd(168) |-LOOPBACK(615) |-LOOPBACK(1019) |-SSM_RTR_MODEM_A(981) |-VosMCThread(1851) |-VosTlshimRxThre(1854) |-VosWDThread(1845) |-ad_calc_wq(156) |-adsp(365) |-apr_driver(174) |-batt_timer(318) |-binder(354) |-bioset(75) |-bioset(435) |-bioset(437) |-bioset(438) |-bioset(439) |-bioset(456) |-bioset(458) |-bioset(459) |-bioset(460) |-bond0(279) |-cfg80211(105) |-clnt_req(430) |-clnt_req(432) |-clnt_resp(431) |-crypto(74) |-deferwq(53) |-devfreq_wq(102) |-diag_cntl_wq(199) |-diag_dci_wq(200) |-diag_real_time_(196) |-diag_wq(197) |-dm_bufio_cache(353) |-dsps_IPCRTR(613) |-dsps_smd_trans_(36) |-dsps_smem_glink(49) |-dsx_exp_workque(300) |-dsx_rebuild_wor(298) |-ecryptfs-kthrea(133) |-ext4-rsv-conver(441) |-ext4-rsv-conver(453) |-ext4-rsv-conver(461) |-ext4-rsv-conver(470) |-ext4-rsv-conver(536) |-f_mtp(426) |-fsnotify_mark(132) |-fwu_workqueue(303) |-glink_lbsrv(166) |-glink_pkt_wq(178) |-glink_ssr_wq(165) |-glink_xprt_wq(167) |-governor_msm_ad(103) |-hdcp_tz_lib(163) |-hdmi_hdcp2p2(164) |-hdmi_tx_workq(161) |-hwrng(194) |-ipa_A7_svc(428) |-ipa_holb_wq(90) |-ipa_interrupt_w(89) |-ipa_power_mgmt(78) |-ipa_rm_wq(88) |-iparepwq13(87) |-iparepwq14(82) |-iparepwq47(85) |-iparepwq48(1283) |-ipawq13(86) |-ipawq14(81) |-ipawq47(84) |-ipawq48(1282) |-ipv6_addrconf(360) |-irq/10-spdm_bw_(359) |-irq/171-hs_phy_(371) |-irq/172-ss_phy_(372) |-irq/173-msm_dwc(373) |-irq/185-bcl_iba(107) |-irq/186-bcl_vba(106) |-irq/19-408000.q(2394) |-irq/190-chg-err(378) |-irq/194-chg-p2f(382) |-irq/195-chg-rec(381) |-irq/196-chg-tap(379) |-irq/197-chg-tcc(380) |-irq/198-batt-ho(383) |-irq/199-batt-wa(384) |-irq/200-batt-co(386) |-irq/201-batt-co(385) |-irq/203-batt-lo(388) |-irq/204-batt-mi(387) |-irq/206-usbin-u(389) |-irq/207-usbin-o(390) |-irq/208-usbin-s(391) |-irq/209-otg-fai(393) |-irq/210-otg-oc(394) |-irq/211-aicl-do(392) |-irq/212-usbid-c(395) |-irq/213-dcin-uv(396) |-irq/215-power-o(397) |-irq/216-temp-sh(398) |-irq/217-wdog-ti(399) |-irq/223-full-so(313) |-irq/225-delta-s(314) |-irq/229-soft-co(315) |-irq/230-soft-ho(316) |-irq/235-batt-mi(317) |-irq/239-qpnp_sc(358) |-irq/244-tsens_i(334) |-irq/245-tsens_c(335) |-irq/260-cpr3(54) |-irq/261-cpr3_ce(55) |-irq/262-cpr3(56) |-irq/281-arm-smm(91) |-irq/285-arm-smm(92) |-irq/286-arm-smm(563) |-irq/287-arm-smm(564) |-irq/288-arm-smm(93) |-irq/291-arm-smm(94) |-irq/292-arm-smm(306) |-irq/293-arm-smm(307) |-irq/294-arm-smm(308) |-irq/295-arm-smm(309) |-irq/299-arm-smm(95) |-irq/300-arm-smm(647) |-irq/301-arm-smm(649) |-irq/302-arm-smm(96) |-irq/303-arm-smm(648) |-irq/304-arm-smm(650) |-irq/305-arm-smm(97) |-irq/309-arm-smm(98) |-irq/310-arm-smm(414) |-irq/311-arm-smm(415) |-irq/312-arm-smm(416) |-irq/313-arm-smm(417) |-irq/314-arm-smm(418) |-irq/315-arm-smm(419) |-irq/316-arm-smm(420) |-irq/317-arm-smm(421) |-irq/318-arm-smm(617) |-irq/322-arm-smm(99) |-irq/330-arm-smm(100) |-irq/335-arm-smm(101) |-irq/352-tsens_i(344) |-irq/353-tsens_c(345) |-irq/409-wcd9xxx(632) |-irq/417-vl53l0_(301) |-irq/441-soc:fp_(247) |-irq/472-nanohub(356) |-irq/478-nanohub(355) |-irq/479-fsc_int(293) |-irq/480-synapti(297) |-irq/638-modem(370) |-irq/670-adsp(362) |-irq/702-slpi(367) |-jbd2/sda33-8(469) |-jbd2/sda35-8(535) |-jbd2/sdd3-8(452) |-k_bam_data(425) |-k_gbridge(290) |-k_gserial(287) |-k_hsuart(183) |-k_ipa_usb(288) |-kauditd(494) |-kblockd(76) |-kdmflush(433) |-kdmflush(455) |-kgsl-events(245) |-kgsl-mementry(243) |-kgsl-workqueue(242) |-kgsl_devfreq_wq(246) |-kgsl_worker_thr(244) |-khelper(32) |-khungtaskd(72) |-kschedfreq:0(777) |-kschedfreq:2(785) |-ksoftirqd/0(3) |-ksoftirqd/1(17) |-ksoftirqd/2(23) |-ksoftirqd/3(29) |-kswapd0(131) |-kverityd(436) |-kverityd(457) |-kworker/0:0(4) |-kworker/0:0H(5) |-kworker/0:1(42) |-kworker/0:1H(445) |-kworker/0:2(451) |-kworker/0:3(519) |-kworker/0:4(526) |-kworker/1:0(18) |-kworker/1:0H(19) |-kworker/1:1(104) |-kworker/1:1H(1192) |-kworker/1:2(374) |-kworker/1:3(376) |-kworker/1:4(1243) |-kworker/2:0(24) |-kworker/2:0H(25) |-kworker/2:1(278) |-kworker/2:1H(434) |-kworker/2:2(747) |-kworker/2:3(759) |-kworker/2:4(3076) |-kworker/3:0(30) |-kworker/3:0H(31) |-kworker/3:1(294) |-kworker/3:1H(440) |-kworker/3:2(475) |-kworker/3:3(480) |-kworker/3:4(3661) |-kworker/u8:0(6) |-kworker/u8:1(52) |-kworker/u8:10(3445) |-kworker/u8:11(3525) |-kworker/u8:12(3526) |-kworker/u8:2(58) |-kworker/u8:3(59) |-kworker/u8:4(283) |-kworker/u8:5(295) |-kworker/u8:6(296) |-kworker/u8:7(299) |-kworker/u8:8(302) |-kworker/u8:9(361) |-kworker/u9:0(80) |-kworker/u9:1(83) |-kworker/u9:2(442) |-kworker/u9:3(443) |-kworker/u9:4(444) |-kworker/u9:5(548) |-kworker/u9:6(881) |-lpass_IPCRTR(614) |-lpass_smd_trans(37) |-lpass_smem_glin(47) |-mdss_dsi_dba(160) |-mdss_dsi_event(159) |-mem_share_svc(175) |-memory_wq(248) |-migration/0(12) |-migration/1(15) |-migration/2(21) |-migration/3(27) |-mpm(57) |-mpss_IPCRTR(978) |-mpss_smd_trans_(38) |-mpss_smem_glink(45) |-msm_cci_wq(310) |-msm_cci_wq(311) |-msm_cpp_workque(312) |-msm_ipc_router(177) |-msm_serial_hs_0(184) |-msm_serial_hs_0(185) |-msm_slim_qmi_cl(625) |-msm_thermal:fre(775) |-msm_thermal:hot(774) |-msm_thermal:the(779) |-msm_vidc_worker(304) |-msm_watchdog(41) |-nanohub(357) |-netns(33) |-ngd_notify_sl1(424) |-ngd_rx_thread1(423) |-perf(34) |-pm_workerq_venu(305) |-pmi8994_wq(427) |-power_off_alarm(130) |-qcrypto_seq_res(249) |-qmi_hndl0000000(176) |-qmi_hndl0000000(282) |-qmi_hndl0000000(429) |-qmi_hndl0000000(623) |-qmi_hndl0000000(626) |-qmi_hndl0000000(627) |-qmi_hndl0000000(988) |-qmi_hndl0000000(1047) |-qmi_svc_event_w(364) |-rcu_bh(9) |-rcu_preempt(7) |-rcu_sched(8) |-rcub/0(11) |-rcuc/0(10) |-rcuc/1(16) |-rcuc/2(22) |-rcuc/3(28) |-rot_thread_0(157) |-rot_thread_1(158) |-rpm_requests(43) |-rpm_smd_trans_g(40) |-rpm_smem_glink_(51) |-rq_stats(412) |-sb-1(422) |-scsi_eh_0(270) |-scsi_tmf_0(271) |-sharedmem_qmi_w(281) |-slpi(368) |-smd_channel_clo(35) |-smem_native_dsp(48) |-smem_native_lpa(46) |-smem_native_mps(44) |-smem_native_rpm(50) |-spi0(274) |-spi6(275) |-sps_ipa_power_m(79) |-sys_mon(366) |-sys_mon(369) |-sysmon_wq(363) |-system(77) |-tfa98xx(644) |-therm_core:noti(320) |-therm_core:noti(321) |-therm_core:noti(322) |-therm_core:noti(323) |-therm_core:noti(324) |-therm_core:noti(325) |-therm_core:noti(326) |-therm_core:noti(327) |-therm_core:noti(328) |-therm_core:noti(329) |-therm_core:noti(330) |-therm_core:noti(331) |-therm_core:noti(332) |-therm_core:noti(333) |-therm_core:noti(336) |-therm_core:noti(337) |-therm_core:noti(338) |-therm_core:noti(339) |-therm_core:noti(340) |-therm_core:noti(341) |-therm_core:noti(342) |-therm_core:noti(343) |-therm_core:noti(346) |-therm_core:noti(347) |-therm_core:noti(348) |-therm_core:noti(349) |-therm_core:noti(350) |-therm_core:noti(351) |-therm_core:noti(352) |-therm_core:noti(377) |-tty_worker_thre(179) |-tty_worker_thre(180) |-tty_worker_thre(181) |-tty_worker_thre(182) |-tty_worker_thre(186) |-tty_worker_thre(187) |-tty_worker_thre(188) |-tty_worker_thre(189) |-tty_worker_thre(190) |-tty_worker_thre(191) |-tty_worker_thre(192) |-tty_worker_thre(193) |-uether(289) |-ufs_clk_ungatin(273) |-ufs_pm_qos_0(272) |-usb_bam_wq(375) |-usbnet(280) |-vsync_retire_wo(162) |-watchdog/0(13) |-watchdog/1(14) |-watchdog/2(20) |-watchdog/3(26) |-wcnss_smd_trans(39) |-wlan_logging_th(1839) `-writeback(73) Android 10 进程 删减版 ?(0)-+-init(1)-+-ATFWD-daemon(3416)-+-{ATFWD-daemon}(3433) | | `-{ATFWD-daemon}(3434) | |-adbd(3690)-+-busybox(4212) | | |-{UsbFfs-monitor}(3692) | | |-{UsbFfs-worker}(3693) | | |-{shell svc 4212}(4213) | | `-{usb ffs open}(3691) | |-adsprpcd(826)-+-{adsprpcd}(849) | | `-{adsprpcd}(850) | |-allocator@1.0-s(651) | |-allocator@2.0-s(521)-+-{HwBinder:521_1}(532) | | `-{HwBinder:521_2}(1842) | |-apexd(604)-+-{Binder:604_1}(608) | | `-{Binder:604_2}(609) | |-ashmemd(684) | |-atrace@1.0-serv(511) | |-audio@2.0-servi(654)-+-{Binder:654_1}(690) | | |-{Binder:654_2}(758) | | |-{HwBinder:654_1}(760) | | |-{HwBinder:654_2}(764) | | |-{HwBinder:654_2}(1035) | | |-{HwBinder:654_3}(1109) | | |-{HwBinder:654_4}(2208) | | |-{audio@2.0-serv}(1001) | | `-{writer}(3444) | |-audioserver(685)-+-{ApmAudio}(902) | | |-{ApmOutput}(903) | | |-{AudioOut_15}(1043) | | |-{AudioOut_1D}(1045) | | |-{AudioOut_25}(1051) | | |-{AudioOut_2D}(1053) | | |-{AudioOut_D}(1038) | | |-{Binder:685_1}(920) | | |-{Binder:685_2}(922) | | |-{Binder:685_3}(1321) | | |-{Binder:685_4}(1461) | | |-{Binder:685_5}(1589) | | |-{FastMixer}(1037) | | |-{FastMixer}(1042) | | |-{FastMixer}(1050) | | |-{FastMixer}(1052) | | |-{HwBinder:685_1}(885) | | |-{HwBinder:685_2}(907) | | |-{TimeCheckThrea}(1317) | | `-{soundTrigger c}(1207) | |-bluetooth@1.0-s(655)-+-{POSIX timer 0}(2003) | | |-{POSIX timer 1}(2035) | | |-{POSIX timer 2}(2105) | | |-{POSIX timer 3}(2112) | | |-{POSIX timer 4}(2113) | | |-{POSIX timer 5}(2150) | | `-{bluetooth@1.0-}(2104) | |-boot@1.0-servic(512) | |-cameraserver(804)-+-{Binder:804_1}(1206) | | |-{Binder:804_2}(1453) | | |-{Binder:804_3}(1586) | | |-{Binder:804_4}(2522) | | |-{HwBinder:804_1}(900) | | |-{HwBinder:804_2}(906) | | `-{HwBinder:804_3}(1178) | |-cas@1.1-service(658)---{HwBinder:658_1}(677) | |-drm@1.0-service(660)---{HwBinder:660_1}(678) | |-drm@1.1-service(661)---{HwBinder:661_1}(682) | |-drmserver(805)---{Binder:805_1}(838) | |-fingerprint@2.1(844)---{fingerprint@2.}(985) | |-gatekeeper@1.0-(662) | |-gatekeeperd(837) | |-init(471) | |-init(472) | |-keymaster@3.0-s(513) | |-keystore(812)---{HwBinder:812_1}(845) | |-light@2.0-servi(665) | |-lmkd(689) | |-loc_launcher(857)-+-lowi-server(1210)-+-{lowi-server}(1213) | | | |-{lowi-server}(1214) | | | |-{lowi-server}(1215) | | | |-{lowi-server}(1216) | | | |-{lowi-server}(2062) | | | |-{lowi-server}(2063) | | | |-{lowi-server}(2066) | | | `-{lowi-server}(3620) | | |-slim_daemon(1211)-+-{HwBinder:1211_}(1223) | | | |-{Loc_hal_worker}(1219) | | | |-{Loc_hal_worker}(1221) | | | |-{Loc_hal_worker}(1226) | | | |-{Loc_hal_worker}(1233) | | | `-{NDK}(1218) | | |-xtra-daemon(1212)-+-{LocTimerMsgTas}(1228) | | | |-{LocTimerPollTa}(1227) | | | |-{pcid-loc-api}(1217) | | | |-{pcid-loc-api}(1222) | | | |-{pcid-loc-api}(1225) | | | `-{pcid-loc-api}(1232) | | `-{loc_launcher}(872) | |-logd(482)-+-{logd.auditd}(507) | | |-{logd.control}(493) | | |-{logd.daemon}(487) | | |-{logd.klogd}(506) | | |-{logd.writer}(492) | | `-{logd}(491) | |-main(641)-+-.localtransport(3001)-+-{ADB-JDWP Conne}(3010) | | | |-{Binder:3001_1}(3015) | | | |-{Binder:3001_2}(3016) | | | |-{Binder:3001_3}(3022) | | | |-{FinalizerDaemo}(3013) | | | |-{FinalizerWatch}(3014) | | | |-{HeapTaskDaemon}(3011) | | | |-{Jit thread poo}(3004) | | | |-{Profile Saver}(3032) | | | |-{ReferenceQueue}(3012) | | | |-{Signal Catcher}(3009) | | | `-{queued-work-lo}(3061) | | |-ackageinstaller(3199)-+-{ADB-JDWP Conne}(3217) | | | |-{Binder:3199_1}(3222) | | | |-{Binder:3199_2}(3225) | | | |-{Binder:3199_3}(3227) | | | |-{FinalizerDaemo}(3220) | | | |-{FinalizerWatch}(3221) | | | |-{HeapTaskDaemon}(3218) | | | |-{Jit thread poo}(3210) | | | |-{Profile Saver}(3233) | | | |-{ReferenceQueue}(3219) | | | `-{Signal Catcher}(3215) | | | |-{Binder:2469_1}(2489) | | | |-{Binder:2469_2}(2495) | | | |-{FinalizerDaemo}(2487) | | | |-{FinalizerWatch}(2488) | | | |-{HeapTaskDaemon}(2485) | | | |-{Jit thread poo}(2477) | | | |-{Profile Saver}(2561) | | | |-{ReferenceQueue}(2486) | | | |-{Signal Catcher}(2482) | | | `-{queued-work-lo}(2614) | | |-d.process.media(2546)-+-{ADB-JDWP Conne}(2580) | | | |-{Binder:2546_1}(2589) | | | |-{Binder:2546_2}(2594) | | | |-{Binder:2546_3}(2600) | | | |-{FinalizerDaemo}(2583) | | | |-{FinalizerWatch}(2584) | | | |-{HeapTaskDaemon}(2581) | | | |-{Jit thread poo}(2568) | | | |-{Profile Saver}(2649) | | | |-{ReferenceQueue}(2582) | | | |-{Signal Catcher}(2573) | | | |-{android.bg}(2933) | | | |-{queued-work-lo}(2694) | | | `-{sAsyncHandlerT}(2683) | | |-droid.launcher3(1975)-+-{ADB-JDWP Conne}(2005) | | | |-{Binder:1975_1}(2012) | | | |-{Binder:1975_2}(2029) | | | |-{Binder:1975_3}(2034) | | | |-{Binder:1975_4}(2742) | | | |-{FinalizerDaemo}(2008) | | | |-{FinalizerWatch}(2009) | | | |-{GrallocUploadT}(2732) | | | |-{HeapTaskDaemon}(2006) | | | |-{Jit thread poo}(1995) | | | |-{Profile Saver}(2048) | | | |-{ReferenceQueue}(2007) | | | |-{RenderThread}(2574) | | | |-{Signal Catcher}(2001) | | | |-{TaskThumbnailI}(2521) | | | |-{UiThreadHelper}(2053) | | | |-{android.bg}(2051) | | | |-{hwuiTask0}(3498) | | | |-{hwuiTask1}(3499) | | | |-{launcher-loade}(2655) | | | |-{magnifier pixe}(2688) | | | |-{pool-1-thread-}(3530) | | | |-{pool-2-thread-}(2491) | | | |-{pool-2-thread-}(2672) | | | `-{queued-work-lo}(2508) | | |-droid.messaging(3120)-+-{ADB-JDWP Conne}(3135) | | | |-{AsyncTask #4}(3168) | | | |-{Binder:3120_1}(3140) | | | |-{Binder:3120_2}(3143) | | | |-{Binder:3120_3}(3276) | | | |-{FinalizerDaemo}(3138) | | | |-{FinalizerWatch}(3139) | | | |-{HeapTaskDaemon}(3136) | | | |-{Jit thread poo}(3126) | | | |-{Profile Saver}(3151) | | | |-{ReferenceQueue}(3137) | | | |-{Signal Catcher}(3134) | | | `-{queued-work-lo}(3163) | | | `-{Signal Catcher}(1647) | | |-lcomm.telephony(3386)-+-{ADB-JDWP Conne}(3399) | | | |-{Binder:3386_1}(3405) | | | |-{Binder:3386_2}(3406) | | | |-{Binder:3386_3}(3408) | | | |-{CTSA Inject Th}(3424) | | | |-{FinalizerDaemo}(3402) | | | |-{FinalizerWatch}(3403) | | | |-{HeapTaskDaemon}(3400) | | | |-{HwBinder:3386_}(3425) | | | |-{Jit thread poo}(3393) | | | |-{Profile Saver}(3414) | | | |-{ReferenceQueue}(3401) | | | |-{Signal Catcher}(3398) | | | |-{Thread-2}(3423) | | | `-{queued-work-lo}(3426) | | |-m.android.email(3033)-+-{ADB-JDWP Conne}(3047) | | | |-{AsyncTask #11}(3110) | | | |-{Binder:3033_1}(3053) | | | |-{Binder:3033_2}(3062) | | | |-{Binder:3033_3}(3066) | | | |-{Binder:3033_4}(3879) | | | |-{EmailNotificat}(3156) | | | |-{FinalizerDaemo}(3050) | | | |-{FinalizerWatch}(3051) | | | |-{HeapTaskDaemon}(3048) | | | |-{Jit thread poo}(3039) | | | |-{Profile Saver}(3071) | | | |-{ReferenceQueue}(3049) | | | |-{Signal Catcher}(3044) | | | `-{queued-work-lo}(3084) | | |-ndroid.keychain(3622)-+-{ADB-JDWP Conne}(3634) | | | |-{Binder:3622_1}(3639) | | | |-{Binder:3622_2}(3640) | | | |-{Binder:3622_3}(3645) | | | |-{Binder:3622_4}(3650) | | | |-{FinalizerDaemo}(3637) | | | |-{FinalizerWatch}(3638) | | | |-{HeapTaskDaemon}(3635) | | | |-{Jit thread poo}(3628) | | | |-{ReferenceQueue}(3636) | | | |-{Runtime worker}(3629) | | | |-{Runtime worker}(3630) | | | |-{Runtime worker}(3631) | | | |-{Runtime worker}(3632) | | | |-{Signal Catcher}(3633) | | | `-{queued-work-lo}(3651) | | |-ndroid.settings(3316)-+-{ADB-JDWP Conne}(3329) | | | |-{AsyncTask #2}(3543) | | | |-{Binder:3316_1}(3334) | | | |-{Binder:3316_2}(3335) | | | |-{Binder:3316_3}(3337) | | | |-{Binder:3316_4}(3878) | | | |-{ConnectivityTh}(3532) | | | |-{FinalizerDaemo}(3332) | | | |-{FinalizerWatch}(3333) | | | |-{HeapTaskDaemon}(3330) | | | |-{Jit thread poo}(3323) | | | |-{Profile Saver}(3340) | | | |-{ReferenceQueue}(3331) | | | |-{RenderThread}(3527) | | | |-{SettingsIntell}(3531) | | | |-{Signal Catcher}(3328) | | | |-{pool-3-thread-}(3544) | | | `-{queued-work-lo}(3585) | | |-ndroid.systemui(1429)-+-{ADB-JDWP Conne}(1446) | | | |-{AsyncTask #3}(2078) | | | |-{AudioTrack}(3385) | | | |-{Binder:1429_1}(1452) | | | |-{Binder:1429_2}(1454) | | | |-{Binder:1429_3}(1475) | | | |-{Binder:1429_4}(1479) | | | |-{Binder:1429_5}(2210) | | | |-{Binder:1429_6}(2213) | | | |-{Binder:1429_7}(2225) | | | |-{CCodecWatchdog}(2092) | | | |-{ConnectivityTh}(2070) | | | |-{FinalizerDaemo}(1449) | | | |-{FinalizerWatch}(1451) | | | |-{FlashlightCont}(2181) | | | |-{GrallocUploadT}(3509) | | | |-{HeapTaskDaemon}(1447) | | | |-{HwBinder:1429_}(2094) | | | |-{ImageWallpaper}(1741) | | | |-{Jit thread poo}(1436) | | | |-{Keyboard}(2209) | | | |-{NDK MediaCodec}(2093) | | | |-{Profile Saver}(1485) | | | |-{ReferenceQueue}(1448) | | | |-{RenderThread}(2061) | | | |-{ScreenDecorati}(2212) | | | |-{Signal Catcher}(1443) | | | |-{SoundPoolThrea}(1934) | | | |-{SoundPool}(1933) | | | |-{SysUiBg}(1916) | | | |-{Thread-2}(2349) | | | |-{TimeTick}(2086) | | | |-{VolumeDialogCo}(1959) | | | |-{WifiTracker{2e}(2072) | | | |-{async_sensor}(2067) | | | |-{hwuiTask0}(2347) | | | |-{hwuiTask1}(2348) | | | |-{pool-2-thread-}(1815) | | | |-{pool-3-thread-}(2239) | | | |-{pool-4-thread-}(2249) | | | |-{pool-6-thread-}(2248) | | | |-{queued-work-lo}(2056) | | | `-{recents.fg}(2211) | | |-putmethod.latin(1858)-+-{ADB-JDWP Conne}(1892) | | | |-{AsyncTask #1}(2044) | | | |-{Binder:1858_1}(1899) | | | |-{Binder:1858_2}(1904) | | | |-{Binder:1858_3}(1908) | | | |-{Binder:1858_4}(2050) | | | |-{Binder:1858_5}(3591) | | | |-{ExecutorUtils}(2047) | | | |-{FinalizerDaemo}(1897) | | | |-{FinalizerWatch}(1898) | | | |-{HeapTaskDaemon}(1895) | | | |-{InputLogicHand}(2431) | | | |-{Jit thread poo}(1884) | | | |-{Profile Saver}(1938) | | | |-{ReferenceQueue}(1896) | | | `-{Signal Catcher}(1889) | | |-system_server(926)-+-{ADB-JDWP Conne}(945) | | | |-{AccountManager}(1249) | | | |-{ActivityManage}(974) | | | |-{ActivityManage}(975) | | | |-{ActivityManage}(976) | | | |-{AdbDebuggingMa}(2355) | | | |-{AlarmManager}(1251) | | | |-{AsyncQueryWork}(2852) | | | |-{AsyncTask #2}(2246) | | | |-{AudioDeviceBro}(1320) | | | |-{AudioPortEvent}(1718) | | | |-{AudioService}(1319) | | | |-{AudioTrack}(3523) | | | |-{BatteryStats_w}(1008) | | | |-{Binder:926_1}(952) | | | |-{Binder:926_2}(953) | | | |-{Binder:926_3}(1289) | | | |-{Binder:926_4}(1298) | | | |-{Binder:926_5}(1323) | | | |-{Binder:926_6}(1468) | | | |-{Binder:926_7}(1805) | | | |-{Binder:926_8}(1814) | | | |-{Binder:926_9}(1957) | | | |-{Binder:926_A}(1968) | | | |-{Binder:926_B}(1974) | | | |-{Binder:926_C}(3268) | | | |-{Binder:926_D}(3695) | | | |-{BluetoothRoute}(1702) | | | |-{CCodecWatchdog}(2114) | | | |-{CallAudioModeS}(1744) | | | |-{CameraService_}(1355) | | | |-{ClientModeImpl}(1274) | | | |-{ConnectionSvrF}(1745) | | | |-{ConnectivitySe}(1299) | | | |-{ConnectivityTh}(1341) | | | |-{CpuTracker}(1004) | | | |-{DeviceStorageM}(1313) | | | |-{EmergencyAffor}(1487) | | | |-{EthernetServic}(1373) | | | |-{FileObserver}(1003) | | | |-{FinalizerDaemo}(948) | | | |-{FinalizerWatch}(949) | | | |-{GraphicsStats-}(1347) | | | |-{HealthServiceR}(1245) | | | |-{HeapTaskDaemon}(946) | | | |-{HwBinder:926_1}(1007) | | | |-{HwBinder:926_2}(1255) | | | |-{HwBinder:926_3}(1256) | | | |-{HwBinder:926_4}(1257) | | | |-{HwBinder:926_5}(1259) | | | |-{InputDispatche}(1260) | | | |-{InputReader}(1261) | | | |-{Jit thread poo}(938) | | | |-{LazyTaskWriter}(2429) | | | |-{NDK MediaCodec}(2121) | | | |-{NetworkPolicy}(1270) | | | |-{NetworkStatsOb}(1480) | | | |-{NetworkStats}(1269) | | | |-{NetworkTimeUpd}(1520) | | | |-{NetworkWatchli}(1262) | | | |-{NsdService}(1305) | | | |-{OomAdjuster}(977) | | | |-{OsuServerHandl}(1388) | | | |-{PackageInstall}(1201) | | | |-{PackageManager}(1012) | | | |-{PackageManager}(1013) | | | |-{PhotonicModula}(1378) | | | |-{PowerManagerSe}(1006) | | | |-{RedirectListen}(1368) | | | |-{ReferenceQueue}(947) | | | |-{RenderThread}(3694) | | | |-{RollbackManage}(1246) | | | |-{RollbackPackag}(1247) | | | |-{Runtime worker}(939) | | | |-{Runtime worker}(940) | | | |-{Runtime worker}(941) | | | |-{Runtime worker}(942) | | | |-{SensorEventAck}(1208) | | | |-{SensorService}(1209) | | | |-{SettingsProvid}(1250) | | | |-{Signal Catcher}(943) | | | |-{SliceManagerSe}(1354) | | | |-{SoundPoolThrea}(1464) | | | |-{SoundPool}(1463) | | | |-{StatsCompanion}(1356) | | | |-{StorageManager}(1267) | | | |-{SyncHandler-0}(1366) | | | |-{SyncManager}(1396) | | | |-{TaskSnapshotPe}(1377) | | | |-{Thread-4}(1459) | | | |-{UEventObserver}(1254) | | | |-{UsbService hos}(1425) | | | |-{WifiP2pService}(1275) | | | |-{WifiScanningSe}(1295) | | | |-{WifiService}(1273) | | | |-{android.anim.l}(969) | | | |-{android.anim}(968) | | | |-{android.bg}(973) | | | |-{android.displa}(967) | | | |-{android.fg}(964) | | | |-{android.io}(966) | | | |-{android.ui}(965) | | | |-{backup-0}(2434) | | | |-{backup}(1343) | | | |-{batterystats-w}(980) | | | |-{hidl_ssvc_poll}(1258) | | | |-{mDnsConnector}(1307) | | | |-{notification-s}(1308) | | | |-{onProviders.EC}(1311) | | | |-{pool-3-thread-}(1346) | | | |-{queued-work-lo}(1977) | | | |-{ranker}(1309) | | | |-{roid.pacmanage}(1301) | | | |-{tworkPolicy.ui}(1271) | | | |-{uteStateMachin}(1734) | | | |-{watchdog}(970) | | | `-{wifiRttService}(1370) | | |-{FinalizerDaemo}(3625) | | |-{FinalizerWatch}(3626) | | |-{HeapTaskDaemon}(3623) | | |-{Jit thread poo}(3627) | | `-{ReferenceQueue}(3624) | |-main(642)-+-webview_zygote(1819)-+-{FinalizerDaemo}(1836) | | | |-{FinalizerWatch}(1837) | | | |-{HeapTaskDaemon}(1834) | | | |-{Jit thread poo}(1838) | | | `-{ReferenceQueue}(1835) | | |-{FinalizerDaemo}(1822) | | |-{FinalizerWatch}(1823) | | |-{HeapTaskDaemon}(1820) | | |-{Jit thread poo}(1824) | | `-{ReferenceQueue}(1821) | |-mediadrmserver(813)---{Binder:813_1}(830) | |-mediaextractor(815)-+-{Binder:815_1}(915) | | |-{Binder:815_2}(2139) | | `-{Binder:815_3}(2145) | |-mediametrics(819)---{Binder:819_1}(878) | |-mediaserver(820)-+-{Binder:820_1}(933) | | |-{Binder:820_2}(1949) | | |-{Binder:820_3}(1950) | | |-{Binder:820_4}(2763) | | `-{HwBinder:820_1}(1489) | |-mediaswcodec(836)-+-{HwBinder:836_1}(917) | | |-{HwBinder:836_1}(2017) | | |-{HwBinder:836_2}(2079) | | |-{HwBinder:836_3}(2081) | | |-{HwBinder:836_4}(2082) | | |-{HwBinder:836_5}(2084) | | |-{HwBinder:836_6}(2088) | | |-{HwBinder:836_7}(2101) | | `-{HwBinder:836_7}(2115) | |-surfaceflinger(515)-+-{Binder:515_1}(540) | | |-{Binder:515_2}(541) | | |-{Binder:515_3}(657) | | |-{Binder:515_4}(1009) | | |-{Binder:515_5}(3576) | | |-{DispSync}(542) | | |-{HwBinder:515_1}(578) | | |-{app}(544) | | |-{sf}(545) | | |-{surfaceflinger}(543) | | |-{surfaceflinger}(546) | | `-{surfaceflinger}(547) | |-tombstoned(840) | |-traced(791)---{traced}(808) | |-traced_probes(793)---{traced_probes}(809) | |-ueventd(473) | |-update_engine(841) | |-usb@1.1-service(673)---{usb@1.1-servic}(1338) | |-vibrator@1.0-se(674) | |-vndservicemanag(485) | |-vr@1.0-service(675) | |-wifi@1.0-servic(676)-+-{wifi@1.0-servi}(2065) | | `-{wifi@1.0-servi}(2069) | |-wificond(824) | `-wpa_supplicant(1590) `-kthreadd(2)-+-9-0022(291) |-ufs_clk_ungatin(273) |-ufs_pm_qos_0(272) |-usb_bam_wq(375) |-usbnet(280) |-vsync_retire_wo(162) |-watchdog/0(13) |-watchdog/1(14) |-watchdog/2(20) |-watchdog/3(26) |-wcnss_smd_trans(39) |-wlan_logging_th(1839) `-writeback(73) 2.2. del:pstree 命令详解： 1、实际上是线程树 2、查看一个进程的 线程树 $ pstree -p 6791 my-gtk-app(6791)-+-{my-gtk-app}(6793) `-{my-gtk-app}(6794) https://blog.csdn.net/qq_21688871/article/details/130230118 常用选项： -p：显示进程ID -------> 记忆 -u：显示进程的用户名 -a：显示进程的命令行参数 -h：在输出中高亮显示当前进程 --------------------> 极优： 轻松知道 2.3. del：临时扩展：前提: busybox的二进制形式安装---> 常用 adb push busybox-armv8l /system/bin/busybox adb shell chmod a+x /system/bin/busybox /system/bin/busybox pstree 完全参考： https://blog.csdn.net/hegan2010/article/details/79352594 pstree 命令查看 Android 用户进程树 3. 基础知识----进程 R: 子进程死亡不会影响父进程，但在子进程死亡时，会向它的父进程发送死亡信号。 R: 父进程死亡会影响子进程 父进程探测到子进程死亡: 图： 见 https://blog.csdn.net/lingshengxueyuan/article/details/127913042 https://blog.csdn.net/lingshengxueyuan/article/details/127913042 https://blog.csdn.net/hyl999/article/details/106869997?spm=1001.2101.3001.6650.11&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-11-106869997-blog-101620236.235^v38^pc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-11-106869997-blog-101620236.235^v38^pc_relevant_sort_base1&utm_relevant_index=12 -------------> 好文 C++ 多进程，父进程监控子进程 3.1. 关于pid = fork(); 结论：父返子，子返0： 父返回，子进程号，自然 子进程返回，0（只是为了标识，本返回是在子程里！！！） 注意：pid只是标识在哪个进程，不是进程号！！！！ -----> 运行态中，代码如何区分 https://blog.csdn.net/hyl999/article/details/106869997?spm=1001.2101.3001.6650.11&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-11-106869997-blog-101620236.235^v38^pc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-11-106869997-blog-101620236.235^v38^pc_relevant_sort_base1&utm_relevant_index=12 -------------> 好文 C++ 多进程，父进程监控子进程 3.2. C 语言库函数 - signal() TODO: SIGCHLD 信号 ------------ 子进程结束时, 父进程会收到这个信号 https://www.twle.cn/l/yufei/cstdlib/cstdlib-basic-function-signal.html http://www.manongjc.com/detail/30-wkhgnwtyyplxvwt.html https://blog.51cto.com/liangchaoxi/4053743 信号机制！！！！！好文 #include #include #include #include #include #include //子进程个数 #define SUB_PRO_COUNT 10 //处理子进程的退出信号 void sub_quit_signal_handle(int sig); //父进程的事件循环 void ParentCycle(); //子进程的事件循环 void ChildCycle(); int main(void) { pid_t pid; int i; //创建SUB_PRO_COUNT个子进程 for(i=0; i 3.3. c语言pause()函数（让进程暂停直到信号出现） TODO: 4. 进程管理 1、进程的创建，见《》 2、进程的优先级，见《》 3、内存回收，见《》 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_进程管理/进程管理系列1之进程的创建.html":{"url":"0_进程管理/进程管理系列1之进程的创建.html","title":"进程管理系列1之进程的创建","keywords":"","body":"1. 目录2. 其他 目录 其他 1. 目录 2. 其他 线程优化-----------线程池 https://www.codenong.com/cs106895580/ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_进程管理/进程管理系列2之进程的优先级.html":{"url":"0_进程管理/进程管理系列2之进程的优先级.html","title":"进程管理系列2之进程的优先级","keywords":"","body":"1. 目录2. linux进程优先级---cpu2.1. 0层(linux进程管理)2.2. cpu调度----调度策略SCHED_FIFO2.3. cgroup限制 cpu 内存 I/O（目标cpuset）2.3.1. Q & A：既然有了调度策略+ 优先级，为什么还要有cgroup？2.4. 维测-----调度策略(目标nice值 )2.5. TODO 合并：3. Android 进程优先级----cpu3.1. 0层--(Android 进程管理)3.2. cpu调度----策略+优先级3.3. 补充：安卓Process.setThreadPriority(int tid, int priority)详解3.4. 进程移除：3.4.1. 疑问：3.4.2. 0层3.4.3. 关注ADJ3.4.4. LRU列表3.4.5. updateLruProcessLocked3.4.6. adj3.4.7. 展开updateOomAdjLocked3.4.8. 杀应用3.4.9. 维测-----进程ADJ值查看3.5. cpu调度----可调度范围cpuset3.5.1. 背景：3.5.2. cpuset设置3.5.3. 维测3.6. 参考：3.7. TODO:4. AMS杀进程场景4.1. 后台cpu/电量使用checkExcessivePowerUsageLocked4.1.1. 规则：4.1.2. 具体细节&证明：4.1.3. 一些结论：4.2. adb shell am force-stop5. 目标---nice值设置5.1. java代码setThreadPriority----setThreadScheduler5.2. 经典调用路径-------前后台切换5.2.1. 目标：myappliaction 线程优先级降低、launcher的提高5.3. del:inux 接口 setpriority5.4. del:命令设置nice值5.5. nice值维测5.6. 例子---安卓修改nice值的线程：5.6.1. RenderThread线程5.6.2. 应用主线程5.6.3. SurfaceFlinger线程6. 一些结论：6.1. Linux上，各线程nice值大多一样7. Linux cgroup 实操7.1.1. 使用 cgroup v2 绑定进程到特定 CPU 核的方法7.1.2. 示例7.1.3. 总结7.1.4. 实现 CPU 核独占的步骤7.1.5. 总结7.1.6. 1. 创建 systemd 服务文件7.1.7. 2. 编写预启动脚本7.1.8. 3. 启用和启动服务7.1.9. 4. 验证 Weston 是否独占 CPU 27.1.10. 总结7.2. 既然通过 CPUAffinity 参数绑定进程到指定的 CPU，为啥还需要cgroup呢7.2.1. 区别与简化解释7.2.2. 在你的场景中7.2.3. 使用 systemd 和 CPUAffinity 实现 Weston 独占 CPU 27.2.4. 3. 验证效果：7.2.5. 总结8. TODO： 整理 linux进程优先级---cpu 0层(linux进程管理) cpu调度----调度策略SCHED_FIFO cgroup限制 cpu 内存 I/O（目标cpuset） Q & A：既然有了调度策略+ 优先级，为什么还要有cgroup？ 维测-----调度策略(目标nice值 ) TODO 合并： Android 进程优先级----cpu 0层--(Android 进程管理) cpu调度----策略+优先级 补充：安卓Process.setThreadPriority(int tid, int priority)详解 进程移除： 疑问： 0层 关注ADJ LRU列表 updateLruProcessLocked adj 展开updateOomAdjLocked 杀应用 维测-----进程ADJ值查看 cpu调度----可调度范围cpuset 背景： cpuset设置 维测 参考： TODO: AMS杀进程场景 后台cpu/电量使用checkExcessivePowerUsageLocked 规则： 具体细节&证明： 一些结论： adb shell am force-stop 目标---nice值设置 java代码setThreadPriority----setThreadScheduler 经典调用路径-------前后台切换 目标：myappliaction 线程优先级降低、launcher的提高 del:inux 接口 setpriority del:命令设置nice值 nice值维测 例子---安卓修改nice值的线程： RenderThread线程 应用主线程 SurfaceFlinger线程 一些结论： Linux上，各线程nice值大多一样 Linux cgroup 实操 使用 cgroup v2 绑定进程到特定 CPU 核的方法 1. 确保 cgroup v2 已经挂载 2. 创建并配置 cpuset 控制组 3. 配置 cpuset.cpus 和 cpuset.mems 4. 启动或将进程加入到 cgroup 5. 验证进程是否绑定到指定的 CPU 核 示例 总结 You said: ChatGPT said: 实现 CPU 核独占的步骤 1. 确保 cgroup v2 已挂载 2. 创建两个 cgroup 控制组 3. 配置 cpuset.cpus 和 cpuset.mems 4. 将特定进程加入 exclusive_group 5. 将其他进程加入 other_group 6. 验证 CPU 独占情况 总结 You said: ChatGPT said: 1. 创建 systemd 服务文件 2. 编写预启动脚本 3. 启用和启动服务 4. 验证 Weston 是否独占 CPU 2 总结 既然通过 CPUAffinity 参数绑定进程到指定的 CPU，为啥还需要cgroup呢 ChatGPT said: 区别与简化解释 在你的场景中 使用 systemd 和 CPUAffinity 实现 Weston 独占 CPU 2 3. 验证效果： 总结 TODO： 整理 1. 目录 2. linux进程优先级---cpu 2.1. 0层(linux进程管理) 《linux进程管理.emmx》 2.2. cpu调度----调度策略SCHED_FIFO 概念: cpu调度---------即 线程调度 参考： https://www.jianshu.com/p/1d2f6a5bbe76 Android 进程管理篇（五）-调度策略与优先级 https://blog.csdn.net/aqrsxiao/article/details/84070223 linux进程调度策略 linux调度策略（部分依赖于优先级），即： 详细： 实时调度：针对0-99的RT(实时)进程 SCHED FIFO: 1、高优先级的终止低优先级的cpu（自然） 2、相同优先级， 先到先服务（Fisrt in First Out，自然） 3、相同优先级下，一旦占据CPU就要到跑完为止（自然，不是轮转） SCHED RR: 1、高优先级的会终止低优先级的cpu（自然） 2、 相同优先级，时间片轮询（） ​ --------------> 总之，FIFO和RR 根据相同优先级下，起的名字 分时调度: 针对100-139的普通进程，他们按nice值 -20 - 19来算优先级，越nice优先级越低 SCHED_NOMAL(SCHED OTHER) : 时间片轮询，优先级越高抢占能力越强，越容易获得更多时间片 ----> 感觉更合理，所以NOMAL SCHED BATCH 批处理进程，唤醒不频繁的使用SCHED BATCH，频繁的适合 实时与分时的区别： 分时：雨露均沾。任意进程都有机会获得cpu？ 优先级：承载的量：TODO: 优先级号？？？？？还是nice值？？？？？？ TODO: 具体实现 或者 实现原理 设置链路： 调度策略设置, 链路: int sched_setscheduler(pid_t pid, int policy,conststruct sched_param *param); ​ ------------> 优先级设置，链路： ​ int setpriority(int which, int who, int prio); -------> nice值的设置 参考：https://www.kancloud.cn/alex_wsc/android-deep2/413496 应用例子：TODO：https://blog.csdn.net/aqrsxiao/article/details/84070223 2.3. cgroup限制 cpu 内存 I/O（目标cpuset） 主要参考： https://blog.csdn.net/shift_wwx/article/details/131854291 Android 中 cgroup抽象层详解 cgroups (全称：control groups) 位置： Linux 内核 作用： 限制单个进程或者多个进程所使用资源（CPU、memory）的机制。 2.3.1. Q & A：既然有了调度策略+ 优先级，为什么还要有cgroup？ https://www.codenong.com/cs106895580/ 为什么要有cgroup -防止 “聚沙成塔”： 只有nice值实际上并不能满足所有场景，比如某个应用有一个前台的UI线程，同时它还有10个后台线程，虽然后台线程的优先级比较低，但是数量较多，合起来这些后台线程对CPU的消耗也会影响到前台线程的性能。 -----------> 所以对于Android来说又引入了另外一套机制来处理这种特殊的情况——cgroup 背后的背后：与内存限制一个思路，即： 单个限制 + 总的限制 2.4. 维测-----调度策略(目标nice值 ) --nice值的本质： 硬件角度：即 nice值 代表的是 cpu 时间片的比例 方法一： ps -p -o nice 方法二：top命令 priority + nice： 方法三：chrt 方式 SurfaceFlinge线程---> FIFO, 优先级1 https://blog.csdn.net/renjianhhong/article/details/129196400 Linux优先级、调度策略（查看与设置大全） https://www.cnblogs.com/Chary/p/16394567.html Top命令详解 2.5. TODO 合并： cpu调度---------即 线程调度： 因为：任一时刻，只有一个线程占用CPU，处于运行状态 多线程并发： 轮流获取CPU使用权 线程调度模型： 1、分时调度模型：轮流获取、均分CPU时间 2、抢占式调度模型：优先级好的获取，JVM采用这种方式。 nice值、cgroup --------->TODO: 谁管理的？最终生效在哪里？ nice值： 1）Process中定义 2）值越小，优先级越高 3）默认是THREAD_PRIORITY_DEFAULT,0 cgroup： 1) 更严格的群组调度策略。 2) 保证前台线程可以获取到更多的CPU 注意点： 线程过多会导致CPU频繁切换，降低线程运行效率 正确认识任务重要性决定哪种优先级。 （工作量越大优先级越低） 优先级具有继承性 参考： https://blog.51cto.com/u_16213654/7243574 -------->TODO: 线程池 3. Android 进程优先级----cpu 3.1. 0层--(Android 进程管理) 《Android进程管理 .emmx》 AMS： 负责Android四大组建的启动和管理，进程的创建和调度。 (任意一个系统) 进程管理, 角度: 调度策略、优先级以及 可调度CPU范围 进程管理： 1、CPU调度： cpu调度策略-----------进程调度优先级nice值（linux量）：决定CPU资源调度的优先级 2、内存管理： 进程存活策略---------- 杀死应用，即内存释放优先级ADJ（安卓量）：系统根据一定策略先杀优先级最低的进程 当内存小于X时，结束“oom_adj”大于Y的进程 -----> 如何确定X与Y？ 如何确定oom_adj值？ 3.2. cpu调度----策略+优先级 linux侧： 见上 安卓侧调用栈：（基于linux） ​ AMS + PMS -----> Process ---- > 来源： https://blog.51cto.com/u_12218/7412595 3.3. 补充：安卓Process.setThreadPriority(int tid, int priority)详解 使用点： 在AMS进程中使用，设置APP某些线程的优先级 调用： Process.setThreadPriority(int tid, int priority) -------> androidSetThreadPriority(pid_t tid, int pri) Threads.cpp setpriority(PRIO_PROCESS, tid, pri) # include 实现setpriority.c syscall(SYS_setpriority, which, who, prio) SYSCALL_DEFINE2(setpriority, int, which, int, who) /kernel/sys.c set_one_prio(p, niceval, error); https://zhuanlan.zhihu.com/p/491874949?utm_id=0 如何正确的理解和获取Linux中进程/线程的PID/TID https://blog.csdn.net/zhwenx3/article/details/86662733 Linux环境下进程pid、线程tid和线程pid pthread_self 与 getpid TODO: .h的理解：协议。。。。使用者和定义者之间的协议（自然，使用者和定义者都要 # include ） 3.4. 进程移除： 3.4.1. 疑问： 参考： https://juejin.cn/post/7220775341605568570#heading-16 AMS的内存管理ADJ算法（Android12） 疑问： adj值 与 进程优先级SYSTEM_ADJ之间是什么关系？ adj值 与 进程组 之间是什么关系？ Android 中，对一个进程 是否会被杀 有三个定义： 进程优先级（越小越重要，越大越容易被杀）CPU调度组 SCHED_GROUP_BACKGROUND （越大越重要，adj 算法只会杀 SCHED_GROUP_BACKGROUND 进程组的进程）进程状态（表示当前进程的运行状态） 答： 1、进程优先级---------adj值 即 优先级的承载 adj值的更新时机：四大组件状态改变时，updateOomAdjLocked。比如：TODO: 2、进程状态 ---------- BACKUP_APP_ADJ = 300 是 adj值 的一个大致的取值。待细化，比如 adj值 = 301 -------> 理解有问题 3、CPU调度组 ------- SCHED_GROUP_BACKGROUND 、 SCHED_GROUP_RESTRICTED、 ​ ---------------> 这个影响进程 影响进程的CPU资源调度????? 疑问： 具体如何融合这三个？ 来源：https://gityuan.com/2018/05/19/android-process-adj/ LMK侧： （1） LMK侧拿到AMS给的 一堆adj值的集合 -进程移除的阈值：根据ADJ--剩余Memory（内存阈值）表，如果此时系统内存（比如147MB）小于 221MB，则 900~906 范围都是可杀的 --------> 自然先从adj最大的进程开始，看杀了是否够 自然，剩余内存非常非常小的时候，才杀ADJ = 0 来源：https://gityuan.com/2018/05/19/android-process-adj/ 其中，进程移除的阈值表 dumpsys activity o 3.4.2. 0层 https://sq.sf.163.com/blog/article/193132570932527104 疑问： 更新优先级，到底指的更新的是啥？ 3.4.3. 关注ADJ NATIVE_ADJ(-1000)：是由init进程fork出来的Native进程，并不受system管控； --------> 牛 SYSTEM_ADJ(-900)：是指system_server进程； 3.4.4. LRU列表 LRU列表结构： 3.4.5. updateLruProcessLocked ​ ------------> 作用是啥 3.4.6. adj 3.4.7. 展开updateOomAdjLocked 3.4.8. 杀应用 3.4.9. 维测-----进程ADJ值查看 查看一个进程的adj 值： cat proc/[pid]/oom_score_adj -------> TODO: 为啥会写进文件里？不应该是实时的嘛？这里是整数，比如-900 例1：surfaceFlinger进程（ ps -ef | grep surface） 例2：抖音分别在前台和后台时ADJ值(变动值): 前台：0 后台：700 查看阈值： dumpsys activity o：要杀的进程级别 OOM levels: -900: SYSTEM_ADJ ( 73,728K) -800: PERSISTENT_PROC_ADJ ( 73,728K) -700: PERSISTENT_SERVICE_ADJ ( 73,728K) 0: FOREGROUND_APP_ADJ ( 73,728K) 100: VISIBLE_APP_ADJ ( 92,160K) 200: PERCEPTIBLE_APP_ADJ ( 110,592K) 250: PERCEPTIBLE_LOW_APP_ADJ ( 129,024K) 300: BACKUP_APP_ADJ ( 221,184K) 400: HEAVY_WEIGHT_APP_ADJ ( 221,184K) 500: SERVICE_ADJ ( 221,184K) 600: HOME_APP_ADJ ( 221,184K) 700: PREVIOUS_APP_ADJ ( 221,184K) 800: SERVICE_B_ADJ ( 221,184K) 900: CACHED_APP_MIN_ADJ ( 221,184K) 999: CACHED_APP_MAX_ADJ ( 322,560K) 其他维测： dumpsys meminfo dumpsys activity p 3.5. cpu调度----可调度范围cpuset 3.5.1. 背景： 完全参考： https://www.jianshu.com/p/0532e4239703 cpuset负载均衡在AMS中是如何应用的 背景： TODO:这里因此逻辑不懂？ 3.5.2. cpuset设置 cpuset设置-------AMS阶段： 计算curSchedGroup ： 设置curSchedGroup ： cpuset设置-------最终生效： 根据不同的cgroup写cpuset对应节点： 最终生效节点： 比如：MTK6875，总共7个核心: top app 满核随便跑 background只能跑在小核上 总之： （1）AMS计算cgroup （2）根据不同的cgroup写cpuset对应节点： 其他： cpuset开关 TODO： 举例子，其如何应用，以及 实际解决的问题 3.5.3. 维测 top-app组 ： 限定哪些核心使用： adb shell cat /dev/CPUset/top-app/CPUs 0-7 -------> 0-7都可以被top-app使用 top-app组 ：有哪些进程和线程是跑在这个组里面： adb shell cat /dev/CPUset/top-app/tasks cpu: cat /proc/cpuinfo CPU的架构、cpu的名称、核心数 其他方式，限定任务跑在哪个核心上：参考：https://www.cnblogs.com/mikaelzero/p/16916730.html taskset -pc 3 pid 表示将进程pid绑定到第3个核上 3.6. 参考： https://juejin.cn/post/7174713775944138809 AMS是如何动态管理进程的？ https://www.cnblogs.com/andy-songwei/p/9845771.html 【朝花夕拾】Android性能篇之（六）Android进程管理机制 ----> 优秀文章 https://gityuan.com/2018/05/19/android-process-adj/ 解读Android进程优先级ADJ算法 https://blog.51cto.com/u_16213654/7243574 android cpu调度策略 修改 安卓cpu调度模式 https://blog.51cto.com/u_12218/7412595 android 调试看实时cpu android cpu调度 https://sq.sf.163.com/blog/article/187631163406041088 利用cgroup来限制进程的资源使用量 防止出现资源泄漏影响其他应用 https://xiaozhuanlan.com/topic/4135276908 https://sq.sf.163.com/blog/article/193127728117825536 Android后台杀死系列之一：FragmentActivity及PhoneWindow后台杀死处理机制（上篇） https://sq.sf.163.com/blog/article/193127674185461760 Android后台杀死系列之一：FragmentActivity及PhoneWindow后台杀死处理机制（下篇） https://sq.sf.163.com/blog/article/193130044973854720 Android后台杀死系列之二：ActivityManagerService与App现场恢复机制（上篇） https://sq.sf.163.com/blog/article/193129960244719616 Android后台杀死系列之二：ActivityManagerService与App现场恢复机制（下篇） https://sq.sf.163.com/blog/article/193132570932527104 Android后台杀死系列之三：LowMemoryKiller原理（4.3-6.0）上篇 --------> 注意图 https://sq.sf.163.com/blog/article/193132514978508800 Android后台杀死系列之三：LowMemoryKiller原理（4.3-6.0）下篇 https://www.jianshu.com/p/221f4a246b45?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation Android进程系列第六篇---LowmemoryKiller机制分析(上) 3.7. TODO: 向linux侧oom_adj的设置（类似API）：(注意：oom_adj是安卓魔改的linux才有) 向 /proc/进程id/oom_adj文件中写入对应的oom_adj值 本质： 进程id ------oom_adj 的映射 4. AMS杀进程场景 4.1. 后台cpu/电量使用checkExcessivePowerUsageLocked 4.1.1. 规则： 完全参考： https://www.jianshu.com/p/ee027ed53724 AMS 每 5分钟 检查一下异常耗电情况： 简言之： 1、随着时间延长，后台应用，占用CPU必须越来越少(30min之后，占用不能超2%) 2、检测频率：5min ---------------> 在曲线以上，会触发杀进程 计算方式： rate = cputimeUsed*100/uptimeSince 一个检查周期内CPU的使用时长 / 检查周期时长 4.1.2. 具体细节&证明： 检测频率：5min，即checkExcessivePowerUsageLocked调用频率： TODO: 4.1.3. 一些结论： checkExcessivePowerUsageLocked ----> 与 mLruProcesses 关系不大 4.2. adb shell am force-stop 5. 目标---nice值设置 5.1. java代码setThreadPriority----setThreadScheduler 参数： Process.setThreadPriority(int tid, int priority) --------> tid 线程id priority： -20 ~ 19 -setThreadPriority调用点： AMS.setRenderThread ----------> 自然(要提高render线程的优先级) 时机：HardwareRenderer初始化时 详解：见下 ​ setThreadPriority(proc.getRenderThreadTid(), THREAD_PRIORITY_TOP_APP_BOOST); AMS侧OomAdjuster.applyOomAdjLSP -----------> 主要调用点 ： 各种情况调用 ​ // setThreadPriority(app.getPid(), THREAD_PRIORITY_TOP_APP_BOOST); 提高UI线程优先级 ​ // setThreadPriority(renderThreadTid, THREAD_PRIORITY_TOP_APP_BOOST); 提高renderThread优先级 -setThreadScheduler调用点： ​ AMS侧OomAdjuster.applyOomAdjLSP ------> scheduleAsFifoPriority(renderThreadTid, true) -------> FIFO级别 调用流程： Process.setThreadPriority(int tid, int priority) android_os_Process_setThreadPriority -----------jni-------------- Threads::androidSetThreadPriority(pid, pri) SetTaskProfiles(tid, {\"SCHED_SP_SYSTEM\"}, true) //processgroup.cpp TODO: 设置了profiles TaskProfiles::SetTaskProfiles(int tid, const std::vector& profiles, bool use_fd_cache) setpriority(PRIO_PROCESS, tid, pri) // 即设置nice值 问题： 既然是设置给线程的，那么不同进程之间怎么调度？ 调度是以线程，还是按照进程维度去分配资源的？ 5.2. 经典调用路径-------前后台切换 前台myappliaction 退到 后台 （自然，launcher进入前台） 5.2.1. 目标：myappliaction 线程优先级降低、launcher的提高 时机： TODO： applyOomAdjLocked:1817, OomAdjuster (com.android.server.am) updateOomAdjLocked:447, OomAdjuster (com.android.server.am) updateOomAdjLocked:16947, ActivityManagerService (com.android.server.am) updateProcessInfo:1304, ProcessRecord (com.android.server.am) accept:-1, -$$Lambda$BEx3OWenCvYAaV5h_J2ZkZXhEcY (com.android.server.wm) doInvoke:300, PooledLambdaImpl (com.android.internal.util.function.pooled) invoke:195, PooledLambdaImpl (com.android.internal.util.function.pooled) run:86, OmniFunction (com.android.internal.util.function.pooled) handleCallback:883, Handler (android.os) dispatchMessage:100, Handler (android.os) loop:214, Looper (android.os) run:67, HandlerThread (android.os) run:44, ServiceThread (com.android.server) //OomAdjuster applyOomAdjLocked 方法： //1、提高launcher的 // Boost priority for top app UI and render threads setThreadPriority(app.pid, TOP_APP_PRIORITY_BOOST); setThreadPriority(app.renderThreadTid, TOP_APP_PRIORITY_BOOST); //2、降低myappliaction 的 setThreadPriority(app.pid, 0); setThreadPriority(app.renderThreadTid, 0); ------------> TODO: 了解app.renderThreadTid != 0 系统侧如何判断 APP有没有render线程的！！！！！！ 5.3. del:inux 接口 setpriority #include #include int setpriority(int which, id_t who, int value); 5.4. del:命令设置nice值 nice -n TODO： 实战验证 5.5. nice值维测 见linux章节 5.6. 例子---安卓修改nice值的线程： 5.6.1. RenderThread线程 详解setRenderThread ： -1、默认情况下 每个进程的绘画线程RenderThread的调度策略是SCHED_OTHER, 并且优先级为-10. 2、mUseFifoUiScheduling = true下: （即设置系统属性sys.use_fifo_ui为1（TODO: 手机和车机，暂时没看到这样做）） 每个进程的绘画线程RenderThread的调度策略变更为SCHED_FIFO,并且实时优先级为1.(其实，只是在硬件加速时，会设置setRenderThread 。但是默认硬件加速) --------------> 无论哪种，RenderThread都提高了优先级 https://blog.csdn.net/hdxx2022/article/details/127630906 关于Android进程调度浅谈 (Android系统在以下几个地方设置了SCHED_FIFO调度策略) setThreadScheduler ------> 调度策略 + 优先级 5.6.2. 应用主线程 TODO: 哪里设置的？ 5.6.3. SurfaceFlinger线程 SurfaceFlinger设置为FIFO linux + KDE桌面环境： kwin_x11 -------> 是KDE的图形合成器 renderThread -------> KDE 也有 6. 一些结论： 6.1. Linux上，各线程nice值大多一样 linux ： 应用火狐浏览器： PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND [m17632 chen 20 0 2550392 176168 100700 S 6.7 2.9 633:26.35 Xorg [m17633 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-0 [m17634 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-1 [m17635 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-2 [m17636 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-3 [m17637 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-4 [m17638 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-5 [m17639 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-6 [m17640 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-7 [m17641 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-8 [m17642 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-9 [m17643 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-10 [m17644 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-11 [m17645 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-12 [m17646 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 llvmpipe-13 [m17647 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17648 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.01 Xorg [m17649 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17650 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17651 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17652 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17653 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17654 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17655 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17656 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17657 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17658 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17659 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17660 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:00.00 Xorg [m17663 chen 20 0 2550392 176168 100700 S 0.0 2.9 0:17.93 InputThread linux ：整个系统： 安卓：应用进程com.huawei.notepad render线程和主线程，比较优先级高 安卓整个系统： 初步结论： 安卓上：com.huawei.notepad应用的各个线程的nice值不一样 ​ 比如 RenderThread----------> 设置点：AMS.setRenderThread， Linux上，各线程明显一样 7. Linux cgroup 实操 目的：隔离资源（CPU、Mem）--------> 从而优化性能 在 Linux 中，使用 cgroup v2 可以限制或绑定进程到特定的 CPU 核（即 CPU 亲和性）。通过 cgroup v2 的 cpuset 控制组，能够将某个或多个进程限制在指定的 CPU 核上执行。 7.1.1. 使用 cgroup v2 绑定进程到特定 CPU 核的方法 1. 确保 cgroup v2 已经挂载 首先，检查是否已经挂载了 cgroup v2。 bash Copy code mount | grep cgroup2 如果没有看到类似 /sys/fs/cgroup 的挂载信息，则需要挂载 cgroup v2： bash Copy code sudo mount -t cgroup2 none /sys/fs/cgroup 2. 创建并配置 cpuset 控制组 在 cgroup v2 中，cpuset 用于控制进程可以使用的 CPU 和内存节点。首先，创建一个 cgroup 目录来限制进程的 CPU 使用。 bashCopy codecd /sys/fs/cgroup mkdir cpuset_group 3. 配置 cpuset.cpus 和 cpuset.mems cpuset.cpus：指定进程可以使用的 CPU 核。 cpuset.mems：指定进程可以使用的内存节点（通常只需要设为 0，表示使用默认的内存节点）。 例如，将进程绑定到 CPU 0 和 CPU 1： bashCopy codeecho 0-1 > cpuset_group/cpuset.cpus echo 0 > cpuset_group/cpuset.mems 4. 启动或将进程加入到 cgroup 你可以通过以下方式，将特定的进程放入这个控制组： 启动一个新的进程： 使用 echo $$ 或 pgrep 获取进程的 PID，然后将 PID 添加到 cgroup.procs 文件。 ``` bash Copy code echo > cpuset_group/cgroup.procs ``` 将现有进程加入到 cgroup： 假设你想让 PID 为 1234 的进程绑定到特定 CPU 核： ``` bash Copy code echo 1234 > cpuset_group/cgroup.procs ``` 现在，进程 1234 将只能在 CPU 0 和 CPU 1 上运行。 5. 验证进程是否绑定到指定的 CPU 核 你可以通过以下方式检查进程的 CPU 亲和性： bash Copy code taskset -cp 这将显示进程的 CPU 绑定情况，应该只显示你在 cpuset.cpus 中指定的 CPU 核。 7.1.2. 示例 假设你想绑定进程 4567 到 CPU 2 和 CPU 3，执行步骤如下： 创建 cpuset 控制组： bashCopy codecd /sys/fs/cgroup mkdir cpuset_test 配置 cpuset： bashCopy codeecho 2-3 > cpuset_test/cpuset.cpus echo 0 > cpuset_test/cpuset.mems 将进程 4567 添加到 cgroup 中： ``` bash Copy code echo 4567 > cpuset_test/cgroup.procs ``` 验证绑定情况： ``` bash Copy code taskset -cp 4567 ``` 这个命令将显示进程 4567 只在 CPU 2 和 CPU 3 上运行。 7.1.3. 总结 通过 cgroup v2 的 cpuset，你可以方便地将进程绑定到特定的 CPU 核上，从而控制进程的 CPU 使用。这样的方法非常适用于性能优化、隔离系统资源以及确保多核系统上进程的执行效率。 4o You said: 上述方式，可以将某个核被 特定进程独占吗 ChatGPT said: ChatGPT 是的，通过 cgroup v2 的 cpuset 控制组，可以将某个或某些 CPU 核分配给特定的进程，并且确保其他进程无法使用这些 CPU 核，从而实现 CPU 核的独占。 为了实现某个 CPU 核被特定进程独占，通常需要以下两个步骤： 将指定的 CPU 核分配给目标进程的 cgroup，即将该进程绑到特定的 CPU 核上。 确保其他进程不能使用这些 CPU 核，即将其他进程的 CPU 使用限制在剩余的 CPU 核上。 7.1.4. 实现 CPU 核独占的步骤 1. 确保 cgroup v2 已挂载 与之前相同，首先确保 cgroup v2 已挂载。 bash Copy code mount | grep cgroup2 如果没有看到类似 /sys/fs/cgroup 的挂载信息，则挂载 cgroup v2： bash Copy code sudo mount -t cgroup2 none /sys/fs/cgroup 2. 创建两个 cgroup 控制组 创建两个 cgroup 控制组，一个用于将特定进程绑到目标 CPU 核，另一个用于将所有其他进程限制在剩余的 CPU 核上。 bashCopy codecd /sys/fs/cgroup mkdir exclusive_group # 用于绑定独占的进程 mkdir other_group # 用于限制其他进程 3. 配置 cpuset.cpus 和 cpuset.mems exclusive_group：将要独占的进程绑定到特定的 CPU 核上，比如 CPU 2。 other_group：将所有其他进程限制在其他 CPU 核上（例如 CPU 0 和 CPU 1）。 bashCopy code# 独占 CPU 2 的进程 echo 2 > exclusive_group/cpuset.cpus echo 0 > exclusive_group/cpuset.mems # 限制其他进程只能使用 CPU 0 和 CPU 1 echo 0-1 > other_group/cpuset.cpus echo 0 > other_group/cpuset.mems 4. 将特定进程加入 exclusive_group 假设你希望进程 1234 独占 CPU 2，可以通过以下命令将该进程添加到 exclusive_group 中： bash Copy code echo 1234 > exclusive_group/cgroup.procs 5. 将其他进程加入 other_group 对于其他进程，可以将它们限制在 other_group，这样它们就只能使用 CPU 0 和 CPU 1。你可以通过如下命令，将其他系统进程加入这个 cgroup： bash Copy code echo > other_group/cgroup.procs 也可以通过脚本自动将所有当前运行的进程限制在 other_group 中： bashCopy codefor pid in $(pgrep -v -P 1); do echo $pid > other_group/cgroup.procs done 这个脚本会将所有非根进程加入到 other_group，并让它们只使用 CPU 0 和 CPU 1。 6. 验证 CPU 独占情况 你可以通过以下命令验证特定进程是否只运行在指定的 CPU 核上： bash Copy code taskset -cp 该命令应显示进程 1234 只绑定在 CPU 2 上。 7.1.5. 总结 通过 cgroup v2 的 cpuset 控制组，可以将某个 CPU 核独占分配给特定进程，并将其他进程限制在剩余的 CPU 核上，实现特定进程对 CPU 核的独占。 4o You said: 我不喜欢手动添加，可以结合systemd，在系统启动的时候，启动weston进程后，weston进程自动独占cpu2嘛 ChatGPT said: ChatGPT Memory updated 是的，你可以通过 systemd 配置来实现自动在系统启动时，将 Weston 进程绑定到特定的 CPU（如 CPU 2），并确保它独占该 CPU。下面是实现这一目的的步骤。 7.1.6. 1. 创建 systemd 服务文件 首先，创建或编辑一个 systemd 服务文件，使其启动 Weston 并将其绑定到 CPU 2。 假设你希望创建一个自定义的 Weston 启动服务文件，比如 /etc/systemd/system/weston-cpuset.service，内容如下： iniCopy code[Unit] Description=Start Weston and bind to CPU 2 After=network.target [Service] Type=simple ExecStartPre=/usr/bin/cgroup2-cpuset-setup.sh ExecStart=/usr/bin/weston CPUAffinity=2 [Install] WantedBy=multi-user.target ExecStartPre：用于执行一个预启动脚本，在启动 Weston 之前设置 CPU 亲和性。 ExecStart：启动 Weston 的命令。 CPUAffinity=2：systemd 原生支持通过 CPUAffinity 参数绑定进程到指定的 CPU（这里是 CPU 2）。 7.1.7. 2. 编写预启动脚本 在 ExecStartPre 中提到的脚本 /usr/bin/cgroup2-cpuset-setup.sh 是为了确保 cgroup v2 的 CPU 亲和性设置能够自动化，下面是脚本的内容： bashCopy code#!/bin/bash # 创建 cpuset 控制组目录 CGROUP_PATH=\"/sys/fs/cgroup/cpuset_weston\" if [ ! -d \"$CGROUP_PATH\" ]; then mkdir \"$CGROUP_PATH\" fi # 将 Weston 进程绑定到 CPU 2，并设置内存节点 echo 2 > \"$CGROUP_PATH/cpuset.cpus\" echo 0 > \"$CGROUP_PATH/cpuset.mems\" # 启动后将所有其他进程限制在 CPU 0 和 CPU 1 CGROUP_OTHER=\"/sys/fs/cgroup/cpuset_others\" if [ ! -d \"$CGROUP_OTHER\" ]; then mkdir \"$CGROUP_OTHER\" fi echo 0-1 > \"$CGROUP_OTHER/cpuset.cpus\" echo 0 > \"$CGROUP_OTHER/cpuset.mems\" 确保该脚本具有执行权限： bash Copy code sudo chmod +x /usr/bin/cgroup2-cpuset-setup.sh 7.1.8. 3. 启用和启动服务 保存并退出后，使用以下命令重新加载 systemd 并启用该服务： bashCopy codesudo systemctl daemon-reload sudo systemctl enable weston-cpuset.service sudo systemctl start weston-cpuset.service 7.1.9. 4. 验证 Weston 是否独占 CPU 2 启动后，可以使用以下命令验证 Weston 是否被绑定到 CPU 2： bash Copy code ps -eo pid,cmd,psr | grep weston psr 列应显示 Weston 进程运行在 CPU 2 上。 7.1.10. 总结 通过结合 systemd 和 cgroup v2，你可以在系统启动时自动将 Weston 进程绑定到指定的 CPU（如 CPU 2），并通过 systemd 的 CPUAffinity 选项确保进程的独占性。这种方法自动化了进程的 CPU 亲和性设置，避免了手动操作。 7.2. 既然通过 CPUAffinity 参数绑定进程到指定的 CPU，为啥还需要cgroup呢 ChatGPT said: ChatGPT 你的疑问很有道理！CPUAffinity 和 cgroup 的确都能实现进程的 CPU 亲和性控制，但它们的用途和功能范围稍有不同。根据你的目标（让 Weston 独占 CPU 2），我们可以选择使用 CPUAffinity 参数，而无需额外使用 cgroup 来绑定 CPU，因为 CPUAffinity 已经能够很好地完成这个任务。 7.2.1. 区别与简化解释 CPUAffinity：这是 systemd 提供的一个选项，能够简单快捷地将服务绑定到指定的 CPU 核。例如，在服务文件中设置 CPUAffinity=2，就可以让 Weston 进程只在 CPU 2 上运行，而不会运行在其他 CPU 核上。这种方式适用于较为简单的场景，主要是绑定进程到指定 CPU。 cgroup 的作用：cgroup v2 提供了更精细的资源控制，比如 CPU 使用权、内存限制等。通过 cgroup，你不仅可以限制进程使用的 CPU 核，还可以实现更多复杂的资源管理，比如控制一组进程的总 CPU 使用、内存和 I/O 限制等。在你希望更灵活地管理一组进程，或需要实现多种资源控制时，cgroup 更有用。 7.2.2. 在你的场景中 如果你只想让 Weston 独占 CPU 2，完全可以只使用 systemd 提供的 CPUAffinity 参数，这样配置更简单，且无需引入 cgroup。 7.2.3. 使用 systemd 和 CPUAffinity 实现 Weston 独占 CPU 2 你可以简化之前的流程，直接使用 systemd 的 CPUAffinity 参数。 创建或修改 systemd 服务文件： sudo nano /etc/systemd/system/weston-cpuset.service 内容如下： iniCopy code[Unit] Description=Start Weston and bind to CPU 2 After=network.target [Service] Type=simple ExecStart=/usr/bin/weston CPUAffinity=2 [Install] WantedBy=multi-user.target 启用并启动服务： bashCopy codesudo systemctl daemon-reload sudo systemctl enable weston-cpuset.service sudo systemctl start weston-cpuset.service 7.2.4. 3. 验证效果： 你可以使用以下命令查看 Weston 是否运行在 CPU 2： ps -eo pid,cmd,psr | grep weston 如果 psr 列中显示 2，说明 Weston 已成功绑定到 CPU 2。 7.2.5. 总结 在你的场景中，通过 systemd 的 CPUAffinity 参数已经可以非常简洁地实现进程绑定到特定的 CPU 核上，不需要使用 cgroup。 8. TODO： 整理 进程管理系列3进程的优先级: https://paul.pub/android-process-priority/ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"0_进程管理/进程管理系列3之内存回收.html":{"url":"0_进程管理/进程管理系列3之内存回收.html","title":"进程管理系列3之内存回收","keywords":"","body":"1. 目录2. 单个APP进程内存的限制2.1. APP进程内存限制---配置2.2. APP进程内存限制--原理：2.3. 维测2.3.1. 整体内存 ------ procrank2.3.2. 指定进程 --------- dumpsys meminfo (包名或者PID)2.3.3. 占用内存最多的进程或线程3. 维测dumpsys meminfo 目录 单个APP进程内存的限制 APP进程内存限制---配置 APP进程内存限制--原理： 维测 整体内存 ------ procrank 指定进程 --------- dumpsys meminfo (包名或者PID) 占用内存最多的进程或线程 维测dumpsys meminfo 1. 目录 2. 单个APP进程内存的限制 2.1. APP进程内存限制---配置 java程序 跑在jvm（dalvik或者art）上 ： https://zhuanlan.zhihu.com/p/655658126 1、一个java APP 对应一个 jvm 2、jvm必须限制内存，比如AS 就会设置最大内存 ------> 安卓： 设置位置： 代码态：/dalvik/vm/alloc/HeapSource.cpp下找到原型 https://www.cnblogs.com/mengfanrong/p/5186418.html 系统文件态：/system/build.prop 运行态： val manager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager manager.memoryClass 2.2. APP进程内存限制--原理： 超出512M，抛出OOM异常 机制具体代码级流程：TODO: 谁检测，谁抛异常 https://zhuanlan.zhihu.com/p/652086402 Java OOM 演示 注意： 以上设置是针对于 dalvik的---------> 自然，不包括native申请的内存 https://zhuanlan.zhihu.com/p/652086402 2.3. 维测 https://blog.csdn.net/jscese/article/details/37928823 Android——内存调试 2.3.1. 整体内存 ------ procrank https://blog.csdn.net/qinhai1989/article/details/88112715 procrank 安卓命令 几种内存： VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存） PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存） USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存） 2.3.2. 指定进程 --------- dumpsys meminfo (包名或者PID) 2.3.3. 占用内存最多的进程或线程 top -m 10 当前占用最高内存的10个进程 3. 维测dumpsys meminfo https://blog.csdn.net/weixin_43886680/article/details/121017741 dumpsys meminfo内存分析解读(收集整合） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/":{"url":"Andriod/","title":"Andriod","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/关键流程/":{"url":"Andriod/关键流程/","title":"关键流程","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/关键流程/InitSystem.html":{"url":"Andriod/关键流程/InitSystem.html","title":"Init System","keywords":"","body":"1. 目录2. 系统启动流程（纵向主线）2.1. 0层图2.2. 各个层的简介2.2.1. Loader层：2.2.2. Linux内核层2.2.3. 硬件抽象层 (HAL)2.2.4. Android Runtime & 系统库2.2.5. Framework层2.2.6. App层2.2.7. 墙 Syscall2.2.8. 墙JNI2.2.9. 进程关系2.3. 各个进程简介2.4. -------流程start，基于0层-------2.5. 内核加载2.6. 0号进程fork出init进程2.7. 安卓init进程 所做三件事2.8. init进程之 ------解析init.rc文件2.8.1. init进程解析init.rc文件，拉起各种进程2.8.2. 各个进程被拉起的时序2.9. serviceManager启动流程2.10. zygote进程启动native main2.10.1. runtime的启动runtime.start2.10.2. 虚拟机的启动startVm(&mJavaVM, &env)2.10.3. startReg(env) 注册JNI函数2.11. ZygoteInit.java main 世界2.11.1. 加载资源preload()2.11.2. forkSystemServer2.11.3. ZygoteInit.runSelectLoop2.12. SystemServer进程启动2.12.1. 向下分析核心代码mSystemServiceManager.startService2.12.2. publishBinderService 向Native注册Ibinder（核心）2.12.3. AMS new后，由AMS注册一堆进程相关服务2.13. -------流程end，基于0层------2.14. 基于0层，补充次要linux进程：2.15. 几大重要进程之间的通信2.16. 参考链接：2.17. 疑问2.18. 面试题:2.18.1. 孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote？2.18.2. 既然Zygote必要，linux系统为啥就没有 Zygote？2.18.3. Zygote的IPC通信机制为什么不采用binder？如果采用binder的话会有什么问题么？2.19. 参考3. linux启动过程-----详解3.1. TODO：如何手动把init进程拉起来？（源码角度、系统运行时文件角度） 系统启动流程（纵向主线） 0层图 各个层的简介 Loader层： Linux内核层 硬件抽象层 (HAL) Android Runtime & 系统库 Framework层 App层 墙 Syscall 墙JNI 进程关系 各个进程简介 -------流程start，基于0层------- 内核加载 0号进程fork出init进程 安卓init进程 所做三件事 init进程之 ------解析init.rc文件 init进程解析init.rc文件，拉起各种进程 各个进程被拉起的时序 serviceManager启动流程 zygote进程启动native main runtime的启动runtime.start 虚拟机的启动startVm(&mJavaVM, &env) startReg(env) 注册JNI函数 ZygoteInit.java main 世界 加载资源preload() forkSystemServer ZygoteInit.runSelectLoop SystemServer进程启动 向下分析核心代码mSystemServiceManager.startService publishBinderService 向Native注册Ibinder（核心） AMS new后，由AMS注册一堆进程相关服务 -------流程end，基于0层------ 基于0层，补充次要linux进程： 几大重要进程之间的通信 参考链接： 疑问 面试题: 孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote？ 既然Zygote必要，linux系统为啥就没有 Zygote？ Zygote的IPC通信机制为什么不采用binder？如果采用binder的话会有什么问题么？ 参考 linux启动过程-----详解 TODO：如何手动把init进程拉起来？（源码角度、系统运行时文件角度） 1. 目录 2. 系统启动流程（纵向主线） 主线：开机 ----> 桌面（launcher + systemUI） 2.1. 0层图 图：startApp.eddx 总结： 化简：init进程与zygote是一样的，一个拉起cpp的服务进程，一个孵化Java的进程 ---> zygote可删 化简之合理性：整张图，目标就是启动native和java的服务 ​ 自然：先启动native服务，之后java ​ 自然： 启动native众多服务之前，自然要先启动serverManager来管理 ---> ~~serverManager可删 ​ 自然：启动java 服务之前，java-native的自然有语言墙、搭建好梯子jni ----> ~~Runtime 自然，可删 ​ 自然：zygote存在合理性：只是为了 fork java服务进程而存在的 ---> ~~zygote可以删掉 总之： 1、启动自下而上；调用，自上而下（最终内核驱动，自然） 2、只需要记：整张图，目标就是启动native和java的服务。其他的都可以删了（是合理性下的必然）。 盘古开天辟地、女娲造人、女人生孩子模型： 人（类图），事（流程图）： 盘古，pid=0 内核进程： 自然的： 天地未开，宇宙混沌如鸡蛋（即kernel）一片----》 即当时只有kernel，自然 目标：开天辟地 流程： ​ （0）触发点：TODO ​ （1） 盘古 处于混沌中，即 pid=0 内核进程在内核中，自然 ​ （2） 盘古开天辟地： 辟地-------- pid=0 内核进程， 加载驱动，这是设备运行的基础（即地），自然 ​ 开天-------pid=0 内核进程，孵化了第一个 用户空间 进程init(pid=1) 女娲 ，自然 宇宙混沌：kernel 自然，里面有盘古 天与地之间，人间：用户空间 造人的 女娲： 自然：init进程 pid=1。。。。。。为啥叫init进程？ 第一个来到天地间的，来 创造人的（init的），自然 目标：造人 流程： ​ （0）触发点：女娲是被盘古叫来 创世的，自然。 女娲呆在 院子里（native） 创造人 ​ （1）根据天书，因为女娲目标是造人，那么先有管理者。首先 创建了一个管理天地的 玉皇大帝： init进程 解析 init.rc，首先创建了1 ServiceManager ​ （2）根据天书，因为目标是造人，所以先创建了人的眼睛（显示服务进程surfaceFlinger）、创建人的耳朵（Media Server） ​ （3）根据天书，因为目标是造人，最后在院子里（native）捏了一个 女人（zygote native进程） init.rc: 天书：如何创世的天书 玉皇大帝： ServiceManager， 自然的： 管理天地一切(java和native两个世界的所有服务)，比如2 世间一切视觉的显示（显示服务进程），比如3 一切声音（媒体服务进程），眼（显示）、耳（声音）、鼻、舌、身（触觉：inputManagerService）、意； 自然 女人：zygote native进程 天然的： 女人，天生就是 生孩子的（孵化java进程的），自然 目标： 生一个完整的家庭 流程： ​ （1） 触发点：女娲在院子里造出了女人 ​ （2）女人想要从院内跑到院外，自然： 院内的女人 要搬梯子 ：zygote native进程 安卓的Runtime（包括jvm、注册jni） ​ （3）女人通过梯子 翻墙。自然：zygote native进程 通过 反射 调用了 zygoteInit.java的main函数 ​ （4）翻墙到了院外，便是院外的女人： zygote运行在java环境中了 ​ （5）院外有大量的自然资源，自然。女人 先弄了一些 花草树叶 给自己穿衣：加载类、加载资源color、库so到jvm ​ （6）弄好了自己，拿出来自己一个肋骨，变成了自己的丈夫： SystemSever。。。注意：只有生 丈夫，是女人自己主动触发的；而其他孩子，都是别人让的 ​ （7）有了丈夫，怎么与丈夫之间联系呢？ 女人买了个 对讲机 ：起了一个socket 服务，一直循环，等待丈夫的消息 ​ 注意：不得不：女人只听丈夫的，自然： 女人只通过socket与丈夫交流 ​ 自然： 只有丈夫能让女人生孩子。孩子则不能直接让，需要告诉父亲，让妈妈生个弟弟，父亲再让女人生。 ​ 丈夫： SystemSever ​ 自然，他的作用是，给儿子们(APP)，提供服务： SystemSever给APP 提供核心服务 目标：丈夫有了，可是还没有孩子，生一个家庭对外的 接口人 流程： （1）触发点：女人 “生”了丈夫 （2）丈夫告诉女人，要生一个 家庭对外的 接口人，看客户有啥需求： 即AMS 让 zygote 创建 launcher进程 家庭对外的 接口人 ：launcher进程 ​ 根据 客户需要什么样的孩子，就让女人去生 院子里：native 院子外：java 墙：cpp与java的语言隔离 墙上的梯子： 安卓的Runtime、jni、jvm 一句话总结， 盘古开天辟地、女娲造人、女人生孩子模型： 记忆三个目标，忘记其他所有。 补充： 2、3、4，为啥是这个顺序？：自然女娲先 捏眼耳鼻舌身意，最后才捏了一个完整的人（此时Zygote就是可以调用surfaceFlinger等的） TODO: 上面模型的 文字描述，也是写文章的思路（即文字版的 类图和时序图）。待详细完善 TODO: 上面是通过联想模型记忆，如果 通过 不得不 来记忆呢？ 2.2. 各个层的简介 2.2.1. Loader层： Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在ROM里的预设代码开始执行，然后加载引导程序到RAM； Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。 2.2.2. Linux内核层 Android平台的基础是Linux内核，比如ART虚拟机最终调用底层Linux内核来执行功能，自然 启动Kernel的swapper进程(pid=0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载 驱动（Display、Camera、Binder）等相关工作，自然； 启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。----》TODO: 不懂 2.2.3. 硬件抽象层 (HAL) 硬件抽象层 (HAL) 提供标准接口，HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一组接口，比如WIFI/蓝牙模块，当框架API请求访问设备硬件时，Android系统将为该硬件加载相应的库模块。 2.2.4. Android Runtime & 系统库 每个应用都在其自己的进程中运行，都有自己的虚拟机实例。ART通过执行DEX文件可在设备运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式文件，经过优化，使用内存很少。ART主要功能包括：预先(AOT)和即时(JIT)编译，优化的垃圾回收(GC)，以及调试相关的支持。 这里的Native系统库主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，记忆：init进程是所有用户进程的鼻祖。 init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程； init进程还启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务 init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。 2.2.5. Framework层 Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含： 加载ZygoteInit类，注册Zygote Socket服务端套接字 加载虚拟机 提前加载类preloadClasses 提前加载资源preloadResouces System Server进程，是由Zygote进程fork而来，System Server是Zygote孵化的第一个进程，System Server负责启动和管理整个Java framework，包含ActivityManager，WindowManager，PackageManager，PowerManager等服务。 Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。 2.2.6. App层 Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App； Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。 所有的App进程都是由Zygote进程fork生成的。 2.2.7. 墙 Syscall Native与Kernel之间有一层系统调用(SysCall)层，见Linux系统调用(Syscall)原理; ​ Q：为什么要有Syscall墙？（等价问题：为什么要有内核空间和用户空间？） ​ A：它确实就是一道墙，目的也是墙的作用： ​ -保护硬件资源不会被随便访问，从而保证内核稳定性 （等价的表述：让用户态程序能受限访问硬件设备，比如申请系统资源，操作设备读写，创建新进程等。用户空间发生请求，内核空间负责执行，这些接口便是用户空间和内核空间共同识别的桥梁，这里提到两个字“受限”，是由于为了保证内核稳定性，而不能让用户空间程序随意更改系统，必须是内核对外开放的且满足权限的程序才能调用相应接口-----http://gityuan.com/2016/05/21/syscall/） 一些认知： 1、native代码也是用户态 2、APP、系统服务都是用户态 3、APP 打开文件 ----> JVM ----> native ---> Syscall ---> 内核 ---> 驱动 ​ 以上流程，不涉及系统服务 关于线程： -Syscall墙 隔离的是代码，不是线程。是同一个线程。（即：线程的用户态和内核态指的是同一个线程上下文中不同的代码执行。用户态是应用程序的代码，而内核态是内核代码、设备驱动代码等运行在线程的上下文中。例如，中断和系统调用会将执行权交给内核态代码。 ） 具体的 Syscall 的实现，见《linux》 2.2.8. 墙JNI Java层与Native(C/C++)层之间的纽带JNI，见Android JNI原理分析。 2.2.9. 进程关系 // ps -ef 显示用户空间进程 UID PID PPID C STIME TTY TIME CMD root 1 0 0 13:30:36 ? 00:00:02 init // 一号进程，父进程PPID 0号 ............... root 16 2 0 13:30:36 ? 00:00:04 [rcuc/1] ............... root 623 1 0 13:30:39 ? 00:00:09 zygote64 //Zygote 进程 root 624 1 0 13:30:39 ? 00:00:07 zygote ............... system 8951 623 0 14:10:30 ? 00:00:00 com.android.settings // 应用进程在 Zygote 进程 之后 u0_a81 9022 623 0 14:10:31 ? 00:00:00 com.android.dialer u0_a37 12510 623 0 13:41:05 ? 00:00:01 android.process.acore ps 显示进程号: init是1号进程（自然，其父进程PPID = 0号进程） 自然，0号进程属于 内核态，所以ps没有显示 Linux整个进程树形成：TODO Zygote 进程: 所有java进程(系统+APP都) 孵化机。自然，皇妃 Init 的可执行文件: x 可执行 ---》 对于cpp/java编译出来的，且可执行------> 自然，一定含main函数 2.3. 各个进程简介 2.4. -------流程start，基于0层------- 2.5. 内核加载 linux内核启动（再具体：），包括驱动加载，例如Binder驱动 2.6. 0号进程fork出init进程 开天辟地，第一个进程 0号进程（swapper），内核进程 驱动加载的流程 孵化出init进程 ----》用户空间的始祖进程（非内核进程，自然） 2.7. 安卓init进程 所做三件事 init 进程启动，主要做了以下三件事： 1’、目录相关: 创建（mkdir）和挂载（mount）启动所需的文件目录； 2、服务属性？？？？：初始化和启动属性服务（property service） 3、解析.rc文件，并按条件启动： 解析 init.rc 配置文件并启动 Zygote 进程 参考： https://blog.csdn.net/xingyu19911016/article/details/127451545 2.8. init进程之 ------解析init.rc文件 2.8.1. init进程解析init.rc文件，拉起各种进程 三角度： 1、从进程角度：基于0层图，init进程由0号进程孵化而来 自然 2、从文件角度：根目录下init文件执行 3、从源码角度： //system/core/init/init.cpp static void LoadBootScripts() { .......... if (bootscript.empty()) { parser.ParseConfig(\"/init.rc\"); // 解析init.rc if (!parser.ParseConfig(\"/system/etc/init\")) { late_import_paths.emplace_back(\"/system/etc/init\"); } if (!parser.ParseConfig(\"/product/etc/init\")) { late_import_paths.emplace_back(\"/product/etc/init\"); } if (!parser.ParseConfig(\"/product_services/etc/init\")) { late_import_paths.emplace_back(\"/product_services/etc/init\"); } if (!parser.ParseConfig(\"/odm/etc/init\")) { late_import_paths.emplace_back(\"/odm/etc/init\"); } if (!parser.ParseConfig(\"/vendor/etc/init\")) { late_import_paths.emplace_back(\"/vendor/etc/init\"); } init.rc 命令文件 : import /init.environ.rc // 给linux系统，设置了各种环境变量 import /init.usb.rc import /init.${ro.hardware}.rc import /vendor/etc/init/hw/init.${ro.hardware}.rc import /init.usb.configfs.rc import /init.${ro.zygote}.rc //import start zygote //【】启动zygote进程 start servicemanager //【】启动servicemanager // init.zygote64_32.rc // 【】定义了服务:zygote service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote //【1】 /system/bin/app_process64 // 【2】 --zygote // 【3】 --start-system-server 启动 SystemServer class main priority -20 user root // /说明以用户root身份运行，自然 group root readproc reserved_disk socket zygote stream 660 root system //【】 //socket关键字表示这个zygote进程需要一个名称为\"zygote\"的socket资源，这样，系统启动后，我们就可以在/dev/socket目录下看到有一个名为zygote的文件。这里定义的socket的类型为unix domain socket，它是用来作本地进程间通信用的 socket usap_pool_primary stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media // 当zygote重启时,则会重启media ---> 背后的机制是啥，如何保证的？ onrestart restart netd onrestart restart wificond writepid /dev/cpuset/foreground/tasks // 同理 servicemanager // frameworks/native/cmds/servicemanager/servicemanager.rc service servicemanager /system/bin/servicemanager 具体如何启动？ TODO: 即 命令如何执行，如何生成新进程？ 由【1】可见，zygote进程 运行的可执行文件是 app_process64（原来名字就叫 app process 见 attach)） 【2】 对应代码： if (zygote) { runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); 补充rc文件知识：TODO https://wenku.baidu.com/view/2955b4df740bf78a6529647d27284b73f24236c7.html?_wkts_=1670062987073&bdQuery=%E5%AE%89%E5%8D%93rc%E6%96%87%E4%BB%B6+%E6%A0%BC%E5%BC%8F android代码.rc文件结构解析 https://www.jb51.net/article/208558.htm Android ServiceManager的启动和工作原理 2.8.2. 各个进程被拉起的时序 记忆，大致顺序如下： ServiceManager是在各种Binder服务之前起来。自然，非常合理，因为要管理 Zygote是非常靠后的，自然，因为先native，最后进入java世界 验证： 可以通过进程pid得到验证 代码层面的验证：https://blog.csdn.net/u013463707/article/details/100926522?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-100926522-blog-116968113.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-100926522-blog-116968113.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1 1) early-init a) wait_for_coldboot_done b) property_init c) keychord_int d) console_init e) set_init_properties 2) init 3) late-init 4) early-fs 5) fs 6) post-fs f) property_service_init g) signal_init h) check_startup 7) early-boot 8) boot 9) service TODO: serviceManager启动流程、surfaceFling流程 2.9. serviceManager启动流程 2.10. zygote进程启动native main 三角度： 进程角度：zygote进程 ：java进程的始祖进程，自然 可执行文件角度： /system/bin/app_process64 ，自然，因为又叫 所以，源码角度：frameworks/base/cmds/app_process/app_main.cpp 三w： when： what： how： //frameworks/base/cmds/app_process/app_main.cpp //zygote进程入口 int main(int argc, char* const argv[]){ //zygote 是由init进程fork而来，init.rc文件中为zygote进程设置的启动参数如下 //argc = 4 //argv = [-Xzygote, /system/bin, --zygote, --start-system-server] AppRuntime runtime(argv[0]); //【1】 创建AndroidRuntime对象，没有启动 if (zygote) { runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);//【2】runtime启动 } else if (className) { runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); } else { fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); } } 【1】 创建AndroidRuntime对象，无他 【2】runtime启动，runtime包括哪些东西呢，见下 : （1）Dalvik虚拟机启动 （2）利用虚拟器，启动java的ZygoteInit 和 RuntimeInit 功能视角：TODO Zygote进程包含两个主要模块： 1. Socket服务端，该Socket服务端用于接收启动新的Dalvik进程命令。 2. Framework共享类及共享资源，当Zygote进程启动后，会装载一些共享类和资源，共享类是在preload-classes文件中定义的，共享资源是在preload-resources文件中定义。因为其他Dalvik进程是由Zygote进程孵化出来的，因此只要Zygote装载好了这些类和资源后，新的Dalvik进程就不需要在装载这些类和资源了，它们共享Zygote进程的资源和类。 原文链接：https://blog.csdn.net/yangwen123/article/details/17258023 2.10.1. runtime的启动runtime.start 三角度： 进程角度：zygote native进程中。不得不的，因为都是为java程序做准备工作的 可执行文件角度： /system/lib64/libandroid_runtime.so 所以，源码角度：frameworks/base/core/jni/AndroidRuntime.cpp //frameworks/base/core/jni/AndroidRuntime.cpp void AndroidRuntime::start(const char* className, const Vector& options, bool zygote) { JNIEnv* env; if (startVm(&mJavaVM, &env, zygote) != 0) { //【1】启动Dalvik Virtual Machine，拿到返回值mJavaVM和env return; } if (startReg(env) FindClass(\"java/lang/String\"); assert(stringClass != NULL); strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); //创建字符串classNameStr //对于zygote进程： classNameStr = new String(\"com.android.internal.os.ZygoteInit\") //对于启动应用进程：classNameStr = new String(\"com.android.internal.os.RuntimeInit\") classNameStr = env->NewStringUTF(className); env->SetObjectArrayElement(strArray, 0, classNameStr); ............ char* slashClassName = toSlashClassName(className != NULL ? className : \"\"); jclass startClass = env->FindClass(slashClassName); if (startClass == NULL) { ............ } else { //找到ZygoteInit类的静态main方法的jMethodID jmethodID startMeth = env->GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); } else { env->CallStaticVoidMethod(startClass, startMeth, strArray);//【3】通过虚拟机调用java的 ZygoteInit的main方法，zygote进程就进入了java世界 } } //.......【4】........ } 【2】非常自然，只有在虚拟机启动完后，才能注册jni函数（native函数） 注意：【3】zygote主线程，贯通native与java世界。自然，在java侧没有结束（正常情况下，不会结束），不会走【4】 -记忆：AndroidRuntime::start()中完成：即RunTime做了啥？四个任务 ①　startVm(&mJavaVM, &env) 启动虚拟机 。自然，必须第一个，java-native之间的墙 ②　onVmCreated(env) 虚拟机启动后的初始化 ③　startReg(env) 注册JNI函数。 自然，基于墙，架起梯子 ④　env->CallStaticVoidMethod(startClass, startMeth, strArray) 调用ZygoteInit类的main函数开创java世界。自然，架起梯子，翻过native，进入java世界大门 TODO： 所以RunTime就是指的虚拟机这些嘛？ 2.10.2. 虚拟机的启动startVm(&mJavaVM, &env) 见四任务 ，第一个任务 int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote) { JavaVMInitArgs initArgs; ............各种参数的解析与初始化................ /* * Initialize the VM. * * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread. * If this call succeeds, the VM is ready, and we can start issuing * JNI calls. */ if (JNI_CreateJavaVM(pJavaVM, pEnv, &initArgs) 【1】拿到env后（自然，native可以反射调用java方法），标志着javaVM已经初始化完毕了 JNI_CreateJavaVM 是c的函数，具体做了啥？ TODO 2.10.3. startReg(env) 注册JNI函数 见四任务 ，第三个任务 向虚拟机注册 jni函数(后面让java侧调用) 三角度： 进程角度：zygote native进程 。自然，因为要搭建 墙上的梯子 可执行文件角度： /system/lib64/libandroid_runtime.so 所以，源码角度：frameworks/base/core/jni/AndroidRuntime.cpp 三w： when：在虚拟机起来之后。自然，墙都没有，怎么搭建墙上的梯子？ what： how：不知道底层机制 int AndroidRuntime::startReg(JNIEnv* env) { /* * This hook causes all future threads created in this process to be * attached to the JavaVM. (This needs to go away in favor of JNI * Attach calls.) */ androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) PopLocalFrame(NULL); return -1; } env->PopLocalFrame(NULL); return 0; } // gRegJNI封装了各种注册函数,近两百个成员函数 static const RegJNIRec gRegJNI[] = { REG_JNI(register_com_android_internal_os_RuntimeInit), // 展开见下 REG_JNI(register_com_android_internal_os_ZygoteInit_nativeZygoteInit), REG_JNI(register_android_os_SystemClock), REG_JNI(register_android_util_EventLog), REG_JNI(register_android_util_Log), REG_JNI(register_android_util_MemoryIntArray), REG_JNI(register_android_util_PathParser), REG_JNI(register_android_util_StatsLog), REG_JNI(register_android_util_StatsLogInternal), REG_JNI(register_android_app_admin_SecurityLog), REG_JNI(register_android_content_AssetManager), REG_JNI(register_android_content_StringBlock), REG_JNI(register_android_content_XmlBlock), REG_JNI(register_android_content_res_ApkAssets), REG_JNI(register_android_text_AndroidCharacter), REG_JNI(register_android_text_Hyphenator), REG_JNI(register_android_view_InputDevice), REG_JNI(register_android_os_Binder), // REG_JNI(register_android_os_Parcel), // ................. 本质上，Oracle提供的注册API是：记忆： jniRegisterNativeMethods(env, java的类名，映射关系 数组) int register_com_android_internal_os_RuntimeInit(JNIEnv* env) { const JNINativeMethod methods[] = { //【1】 自然，映射关系为：java函数名string + java函数参数签名 ------》 native函数名 { \"nativeFinishInit\", \"()V\", (void*) com_android_internal_os_RuntimeInit_nativeFinishInit }, { \"nativeSetExitWithoutCleanup\", \"(Z)V\", (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup }, }; return jniRegisterNativeMethods(env, \"com/android/internal/os/RuntimeInit\", methods, NELEM(methods)); } 那么，jniRegisterNativeMethods 机制原理是什么呢？TODO: 2.11. ZygoteInit.java main 世界 见四任务 ，第四个任务 三角度： 进程角度：zygote main进程 。自然，已经翻过墙，进入java世界 可执行文件角度： framework.jar(见/frameworks/base/Android.bp ) 所以，源码角度：/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 三w： when：在虚拟机起来之后。自然，墙都没有，怎么搭建墙上的梯子？ what： how：jni调的 public static void main(String argv[]) { // 【】参数argv，从信息流角度: rc文件里的参数 ，传给 native（TODO:native用来标志启动java zygote,d），之后native又传给java侧（用来标志启动system-server） try { boolean startSystemServer = false; String zygoteSocketName = \"zygote\"; String abiList = null; boolean enableLazyPreload = false; for (int i = 1; i 2.11.1. 加载资源preload() static void preload(TimingsTraceLog bootTimingsTraceLog) { preloadClasses(); //【1】预加载类资源到jvm里，比如：view、actvity、Service等7600个类 存于文件\"/system/etc/preloaded-classes\" preloadResources(); //【2】预加载资源，包含drawable和color资源 nativePreloadAppProcessHALs(); maybePreloadGraphicsDriver(); //【3】预加载\"android\",\"compiler_rt\",\"jnigraphics\"这3个共享库（通过System.loadLibrary()方法） preloadSharedLibraries(); preloadTextResources(); WebViewFactory.prepareWebViewInZygote(); } 【1】 类加载，最终采用反射机制 java的Class.forName()方法来加载。自然，必然是反射，因为给定的是字符串 类预加载的原因：所有APP进程共用一份类资源（注意，不是对象，还没实例化！） 理解，本质：类、普通的图片jpg资源、xml 本质并无差别** ---> 都是没有实例化的资源 去重思想: 提取重复的。放到 Zygote 进程里 ------》 注意：此时的jvm属于 Zygote进程，所以资源也在 Zygote进程。 zygote进程内加载了preload()方法中的所有资源，当需要fork新进程时，采用copy on write技术，如下： 参考： https://github.com/huanzhiyazi/articles/issues/25 ​ https://blog.51cto.com/u_15375308/5216330 深入理解 Android 内核设计思想（二）内存管理 copy on write 原则：所有的子进程与父进程默认都共享所有资源，父进程 fork 一个子进程之后，子进程只需要生成共享资源的引用即可。只有当子进程需要对某个资源进行写入时，才需要拷贝一份原资源，从而保证资源的独立性。 ----> 自然，好处是： 安全性上：保证共享资源的访问安全（每个java进程都加载资源也可以实现） 1、时间上：只有一个进程加载资源（无需每个java进程都去加载系统资源，加载流程很消耗时间） 2、空间上：只有一个进程内存持有资源。 推论：TODO: 验证 1、VM实例每个进程参数不一样，所以涉及修改，会copy一个VM实例 2、其他资源，尤其类资源，很可能就一份。 来自：https://blog.csdn.net/m0_37999066/article/details/127271879 TODO: Class.forName() 加载类资源到jvm 原理 从资源加载的角度，理解设计zygote的必要性(合理性)：主要需要一个共享资源的祖先 （去重思想的推论，时间上去重、空间上去重） 2.11.2. forkSystemServer 非常自然，加载完共用资源，然后启动 java进程。 // ZygoteInit.java private static boolean startSystemServer(String abiList, String socketName) { ... pid = Zygote.forkSystemServer( //【1】 透传 parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); ... if (pid == 0) { if (hasSecondZygote(abiList)) { waitForSecondaryZygote(socketName); } handleSystemServerProcess(parsedArgs); //进入system_server进程 } return true; } 【1】 处， //Zygote.java int pid = nativeForkSystemServer( // 走native uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities); 所以，更本质的，还是native去fork的 TODO: native侧： pid = fork() //最终系统调用 2.11.3. ZygoteInit.runSelectLoop 自然，创建完systemServer之后，Zygote线程进入Looper。随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。 TODO: Zygote采用高效的I/O多路复用机制，保证在没有客户端连接请求或数据处理时休眠，否则响应客户端的请求。 private static void runSelectLoop(String abiList) throws MethodAndArgsCaller { ArrayList fds = new ArrayList(); ArrayList peers = new ArrayList(); //sServerSocket是socket通信中的服务端，即zygote进程 fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) { StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i = 0; --i) { //采用I/O多路复用机制，当客户端发出 连接请求或者数据处理请求时，则执行continue if ((pollFds[i].revents & POLLIN) == 0) { continue; } if (i == 0) { //创建客户端连接 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); } else { //处理客户端数据事务 boolean done = peers.get(i).runOnce(); if (done) { peers.remove(i); fds.remove(i); } } } } } 参考:http://gityuan.com/2016/02/01/android-booting/ 【1】 TODO: https://www.cnblogs.com/laosiji888/articles/5524067.html http://gityuan.com/2019/01/06/linux-epoll/ 源码解读epoll内核机制 http://gityuan.com/2019/01/05/linux-poll-select/ 源码解读poll/select内核机制 本质：socket服务端。 TODO: 总结安卓通信socket 2.12. SystemServer进程启动 参考： http://gityuan.com/2016/02/14/android-system-server/ https://www.jianshu.com/p/9912a556734f Android开机流程启动的系统服务以及功能介绍列表 问题：SystemServer如何被创建，如何执行的main？主要做了啥？ main流程，总共启动90多个系统服务：自然，太多了，需要一个管理类mSystemServiceManager SystemServer.java 房间中 // Start services. try { //cg: https://www.jianshu.com/p/9912a556734f startBootstrapServices(); // cg: Bootstrap 启动引导服务: AMS, PMS, powerMS, Lights, startCoreServices(); // cg: CoreService: BatteryService, webview startOtherServices(); // cg: Other: InputMS, CameraService, // 具体启动核心代码 ActivityTaskManagerService atm = mSystemServiceManager.startService( // cg: ATMS ActivityTaskManagerService.Lifecycle.class).getService(); mActivityManagerService = ActivityManagerService.Lifecycle.startService( // cg: AMS（注意AMS这里没有注册，在setSystemProcess中注册的） mSystemServiceManager, atm); mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); // cg：PowerManagerService mSystemServiceManager.startService(\"com.google.android.clockwork.sidekick.SidekickService\"); //cg：直接通过 类名 反射 AMS和ATMS通过内部类 Lifecycle（SystemService） 传参给 SystemServiceManager PMS 传的是本身 PowerManagerService（SystemService） ----> 本质上， 1、两者是一样的，因为 Lifecycle是内部类，即等同于外部类。 Lifecycle抽出了 生命周期相关的方法（onStart），感觉更集中 2、既然一样，为啥要有不同写法？ -不得不： AMS 涉及到 与APP通信，所以要继承 stub。也要继承 SystemService 。 ----> 涉及到多继承，所以，只能取一个。 EX1：AMS extends stub， 内部类Lifecycle extends SystemService, EX2，也可以反过来：PowerManagerService extends SystemService，其内部类继承 stub Q: 设计上为什么要有SystemService？ A: 目的：让所有被管理者继承，传给manager，统一管理 --------》 或者说：SystemService 是被管理接口 ，是所有被管理者 被管理部分的抽象 2.12.1. 向下分析核心代码mSystemServiceManager.startService 核心代码： // SystemServiceManager.java Constructor constructor = serviceClass.getConstructor(Context.class); //cg: reflect, serviceClass 用反射来统一new AMS、PMS等 service = constructor.newInstance(mContext); // Register it. ---->自然，管理，自然要向SystemServiceManager注册，java侧？？？？ mServices.add(service); 为啥一定要用反射呢？ TODO 可能原因： 1、有90个服务，依赖太多，规避依赖那么多服务类，所以统一用反射？ 2、代码结构上更简洁 -------------- 统一，类似于各种控件的反射创建： 否则得各种new A1()； new A2() 疑问： AMS、ATMS启动了，但是启动线程是在哪里可以看出来的？-----------> 见《binder线程池》 2.12.2. publishBinderService 向Native注册Ibinder（核心） 注册： // ActivityTaskManagerService.java publishBinderService(Context.ACTIVITY_TASK_SERVICE, mService); //cg: used by APP process,saved to serviceManger LocalServices.addService(ActivityTaskManagerInternal.class, mInternal);//cg: used by systemServer -ATMS 向native注册, 即是向 APP 公布出去publishBinderService ServiceManager的本质： 维护了一个列表，存储 “服务名” 与 binder驱动 疑问： 非Binder形式的service不用注册了？ 疑问： 与 registerService(Context.ACTIVITY_TASK_SERVICE, ActivityTaskManager.class, 差别？ ----> 后者是应用侧的，前者系统侧 2.12.3. AMS new后，由AMS注册一堆进程相关服务 // SystemServer.java mActivityManagerService.setSystemProcess(); //cg: register service AMS管理各个应用进程，所以由其注册的相关服务有(自然，与进程相关的服务)： public void setSystemProcess() { try { ServiceManager.addService(Context.ACTIVITY_SERVICE, this, /* allowIsolated= */ true, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);// cg: register AMS(this)， AMS 本身 ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); // cg: ProcessStats of APP, APP进程信息 ServiceManager.addService(\"meminfo\", new MemBinder(this), /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_HIGH); // cg: register meminfo(of App) service ServiceManager.addService(\"gfxinfo\", new GraphicsBinder(this)); ServiceManager.addService(\"dbinfo\", new DbBinder(this)); if (MONITOR_CPU_USAGE) { ServiceManager.addService(\"cpuinfo\", new CpuBinder(this), /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL); } ServiceManager.addService(\"permission\", new PermissionController(this)); // cg: register permission权限 ServiceManager.addService(\"processinfo\", new ProcessInfoService(this)); // cg: register ProcessInfo(of APP) service ........ synchronized (this) { ProcessRecord app = mProcessList.newProcessRecordLocked(info, info.processName, false, 0, new HostingRecord(\"system\")); ........ mProcessList.updateLruProcessLocked(app, false, null); // cg: add ProcessRecord updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_NONE); } 2.13. -------流程end，基于0层------ 2.14. 基于0层，补充次要linux进程： 参考：https://blog.csdn.net/yjzl1911/article/details/5613569 2.15. 几大重要进程之间的通信 -------> Todo：重新画 servicemanager 管理Binder的 2.16. 参考链接： http://gityuan.com/android/ https://blog.csdn.net/yangwen123/article/details/17258023 Zygote进程启动过程源代码分析 http://gityuan.com/2016/02/13/android-zygote/ 2.17. 疑问 https://blog.csdn.net/yangwen123/article/details/17258023 上面serviceManager画法是对的。管理java和native ----> 本质都是native做的 这个图画得挺好，为什么？ https://blog.csdn.net/wcsbhwy/article/details/105965932 Zygote如何fork一个进程 疑问：所有独立进程，都是靠 死循环loop() + epoll唤醒而存活。见上面图 - 那么线程呢？比如WMS与AMS？ 2.18. 面试题: 2.18.1. 孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote？ 等价问题： zygote设计的必要性在哪里？ ------> 问题的本质：Zygote的存在合理性(0层图需要考虑的) 效率角度： 应用在启动的时候需要做很多准备工作，包括启动虚拟机，加载各类系统资源等等，这些都是非常耗时的，如果能在zygote里就给这些必要的初始化工作做好，子进程在fork的时候就能直接共享，那么这样的话效率就会非常高。这个就是zygote存在的价值，这一点呢SystemServer是替代不了的，主要是因为SystemServer里跑了一堆系统服务，这些是不能继承到应用进程的。 内存角度： -应用进程在启动的时候，内存空间除了必要的资源外，最好是干干净净的，不要继承一堆乱七八糟的东西。所以呢，不如给SystemServer和应用进程里都要用到的资源抽出来单独放在一个进程里，也就是这的zygote进程，然后zygote进程再分别孵化出SystemServer进程和应用进程。孵化出来之后，SystemServer进程和应用进程就可以各干各的事了。 原文链接：https://blog.csdn.net/m0_37999066/article/details/127271879 设计模式角度： 抽象类：zygote作为应用进程的抽象祖先（共享很多共同资源，不用重新加载比如类） TODO： 能不能先起几个空进程？ ---------------> 性能优化，真的就这么做了 2.18.2. 既然Zygote必要，linux系统为啥就没有 Zygote？ Zygote的本质功能就是linux的fork linux系统为啥就没有 Zygote？-------------> 因为linux，不需要 启动虚拟机，加载各类系统资源 2.18.3. Zygote的IPC通信机制为什么不采用binder？如果采用binder的话会有什么问题么？ 原文链接：https://blog.csdn.net/m0_37999066/article/details/127271879 高频考点 2.19. 参考 https://blog.csdn.net/hzwailll/article/details/85339714 ActivityThread的理解和APP的启动过程 3. linux启动过程-----详解 参考： https://blog.csdn.net/weixin_43976122/article/details/128961694 参考： https://blog.csdn.net/whatday/article/details/100759678 3.1. TODO：如何手动把init进程拉起来？（源码角度、系统运行时文件角度） ---------> 1、研究deploy 2、问张、jueyu https://serverfault.com/questions/462821/how-do-i-run-a-debian-init-d-script-manually-not-at-boot How do I run a Debian init.d script manually, not at boot? https://blog.csdn.net/mostone/article/details/99659822 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/关键流程/startAPP.html":{"url":"Andriod/关键流程/startAPP.html","title":"Start APP","keywords":"","body":"1. 目录2. APP启动流程（纵向主线）2.1. 0层模型2.2. ----具体代码流程分析，所有围绕最终目标叙述-----2.3. 创建ActivityRecord/解析启动参数阶段2.4. 处理ActivityStack 阶段 -------总脉络2.5. 补充问题【1】：旧的Activity先要pause2.6. 补充问题【2】：AMS 判断 所要启动的Activity对应的进程 是否存在2.6.1. AMS 通知 Zygote进程2.7. ZygoteServer 接受消息后，fork流程（关键流程1）2.7.1. 总之：2.7.2. 次要补充：linux fork() 函数2.7.3. ActivityThread的 main函数起来2.8. APP进程起来后，attach过程（关键流程2）2.8.1. 补充：APP侧 handleBindApplication2.9. ActivityB 真正启动流程 realStart2.9.1. 补充：生命周期同步到APP侧2.9.2. 补充：APP 侧执行 生命周期同步transaction 的执行execute(关键数据结构)2.10. 启动ActivityA的Activity stop阶段2.11. 补充：render线程的创建2.12. TODO:2.13. 面试问题：2.13.1. 为什么APP不能直接启动进程？2.13.2. 为什么使用socket而不使用binder？（网易二面）3. 从trace角度----应用冷启动 目录 APP启动流程（纵向主线） 0层模型 ----具体代码流程分析，所有围绕最终目标叙述----- 创建ActivityRecord/解析启动参数阶段 处理ActivityStack 阶段 -------总脉络 补充问题【1】：旧的Activity先要pause 补充问题【2】：AMS 判断 所要启动的Activity对应的进程 是否存在 AMS 通知 Zygote进程 ZygoteServer 接受消息后，fork流程（关键流程1） 总之： 次要补充：linux fork() 函数 ActivityThread的 main函数起来 APP进程起来后，attach过程（关键流程2） 补充：APP侧 handleBindApplication ActivityB 真正启动流程 realStart 补充：生命周期同步到APP侧 补充：APP 侧执行 生命周期同步transaction 的执行execute(关键数据结构) 启动ActivityA的Activity stop阶段 补充：render线程的创建 TODO: 面试问题： 为什么APP不能直接启动进程？ 为什么使用socket而不使用binder？（网易二面） 从trace角度----应用冷启动 1. 目录 2. APP启动流程（纵向主线） 桌面 ---> APP 2.1. 0层模型 （图： https://blog.csdn.net/hzwailll/article/details/85339714） 图：startApp.eddx APP启动流程，总之： 1、皇子继位模型 2、整个模型的目的：fork 新进程。搭建两条桥梁（6和8） -生活化模型：皇子继位模型 记忆： 皇帝想要皇子继承皇位 -----> 通知太监总管 -----> 让皇妃 ----> 生皇子 人物： 皇帝，控制生死：Launcher进程，其他APP进程的生死 控制者 太监总管，传递皇帝旨意、管理宫里所有人:皇妃，生子: fork出新的app进程 皇子，成长成为一个人: APP创建页面等等 龙袍：activity 继位：龙袍处于民众面前（activity前台位置） 民众：手机使用者 联系方式ApplicationThreadProxy，本质是Binder 显然，基于生活模型，不得不的一些东西: 1、皇帝、总管、皇妃在建国时(系统启动时) 才有的 -----> 自然 2、皇帝和皇子都可以传唤 太监总管: 所以都持有 总管的引用 ActivityManagerProxy -----> 自然 ​ 反过来，总管也能联系 皇帝 和皇子：通过 联系方式Binder -----> 自然 3、皇子生下来之后，继承皇位事宜：启动自己的驴拉磨Looper、长了自己的脸Acitivity -----> 自然 4、总管 管理所有皇家联系方式Binder，从而总管 可以找到 任何皇室成员 -----> 自然 5、皇帝和皇子，本质是一个东西：APP进程。所以，和AMS 的两条桥梁是一样的 ---> 自然 6、为啥皇妃与外界的联系都是socket？ 7、化简桥梁1和2：自然，皇帝和皇子，与AMS联系是一样的：1与6无差异，2与8无差异 整个流程： 皇帝 想要 皇子APP1继承皇位， 皇帝通知 太监总管来安排（AMS）。自然，startActivity 太监总管通知老皇帝准备退位（launcher的黄袍Acitivity到paused状态） -----> 自然 （2） 太监总管 找对应的皇子 ，如果找到，自然是新皇子继承皇位（皇子activity到前台），直接scheduleLaunchActivity，没有socket和fork。所有流程结束 -----> 自然 ​ 如果没找到，太监总管安排皇妃Zygote来生皇子 -----> 自然 （3）皇妃生皇子，皇子诞生（Zygote fork出新进程APP1进程） （4）皇子生下来后，第一件事情是：开始生长：生长了自己的骨架(驴拉磨Looper)，但是此时龙袍肯定还没做， 没那么着急 （5）皇子生下来后，第二件事情是：向总管注册联系方式ApplicationThread，从而总管可以联系他 （6）总管知道皇子已经诞生。所以，总管通过 联系方式Binder 通知皇子 计划安排（ shedule）新皇子继位 shedulelaunchActivity （7）对于皇子这边，就处理继承皇位的一些事宜handleLaunchActivity：制作自己的龙袍Acitivity.onCreate(在这个流程里，可以自定义各种各样龙袍，豪装还是简装都可以) （8）龙袍Acitivity，到了前台，被民众看见，就继承皇位完毕。整个流程结束 -----> 自然 （9）新皇帝完成了登基的所有事情，就通知总管，让老皇帝不要再哔哔了Stop -----> 自然 疑问点： 为啥 总管 通知皇妃 通过socket ？？？？产子也是 Activity启动： 同进程启动(ActivityA 启动 ActivityB) 进程间启动(launcher启动 ActivityB)：涉及到新进程的启动fork 2.2. ----具体代码流程分析，所有围绕最终目标叙述----- -最终目标是 锚，挂满了所有逻辑 最终目标：真正的启动ActivityB 2.3. 创建ActivityRecord/解析启动参数阶段 围绕最终目标(真正的启动ActivityB), 所以为其创建 目标 ActivityRecord，并找到对应的 ActivityStack（自然，交给其去处理） 注：Mainactivty.startActivity(Intent) 是APP使用的入口（熟悉的入口） 原来ATMS就是AMS一部分, 在意识里不要分开（不要区分两者，ATMS管理Activity，这里自然是ATMS） ATMS是管理Activity的，其中 ActivityStartController 管理启动功能start（而且是很多Activity的） ---》 自然 对应关系： ATMS:管理 所有Activity的所有功能 ---> ActivityStartController 管理所有Activity启动功能start ---> ActivityStarter对应一个Activity的start 该阶段核心类： ActivityStarter ---> 自然，因为其负责启动流程 关键函数： 目标 ActivityRecord创建： ActivityStarter.startActivity() 为待启动的Activity创建 ActivityRecord() 源 ActivityRecord的寻找：sourceRecord = mRootActivityContainer.isInAnyStack(IBinder token); 通过token找到 TODO: 目标 ActivityRecord 对应的 ActivityStack ，即targetStack？？？？ TODO: 按道理此时会有很多 栈管理。比如resumeFocusedStacksTopActivities过程。代码级分析 栈管理 TODO: 图中，启动黑白屏流程 ----》 APP启动流程优化课程 TODO: mIntent的流转流程 2.4. 处理ActivityStack 阶段 -------总脉络 围绕最终目标(真正的启动ActivityB), 所以为其创建 目标 ActivityRecord，----》 自然交给 AMS 著名的栈管理 由ActivityStack 管理和启动 ActivityB 该阶段核心类： ActivityStack ---》 管理 activity栈的 关键函数： 记忆，总之：两个问题 1、实际上 resume函数进来两次，为啥呢？ 因为第一次进来，发现问题 【1】： 老的Activity还在可交互，先pause一把 第二次进来，其实也发现问题 【2】：新的process还不存在 但第三次的时候，并没有从resume进，而是直接到了 14 realStartartActivity 2、上述图画的不是调用关系，只是时间上的 3、实际上涉及到很多线程（图中只体现了一个） 证明： 目标：真正的启动ActivityB //第一次resume： 关注触发点 和 终止点 Breakpoint reached at com.android.server.wm.ActivityStack.resumeTopActivityInnerLocked(ActivityStack.java:2625) // 终止点: 启动新的过程中，发现问题 【1】：发现旧的还在，旧的先要pause呀 ---》 所以，跑去pause at com.android.server.wm.ActivityStack.resumeTopActivityUncheckedLocked(ActivityStack.java:2575) at com.android.server.wm.RootActivityContainer.resumeFocusedStacksTopActivities(RootActivityContainer.java:1158) at com.android.server.wm.ActivityStarter.startActivityUnchecked(ActivityStarter.java:1728) at com.android.server.wm.ActivityStarter.startActivity(ActivityStarter.java:1394) at com.android.server.wm.ActivityStarter.startActivity(ActivityStarter.java:933) at com.android.server.wm.ActivityStarter.startActivity(ActivityStarter.java:583) at com.android.server.wm.ActivityStarter.startActivityMayWait(ActivityStarter.java:1288) at com.android.server.wm.ActivityStarter.execute(ActivityStarter.java:514) at com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1058) at com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1032) at com.android.server.wm.ActivityTaskManagerService.startActivity(ActivityTaskManagerService.java:1009) // 触发点： laucher或其他应用StartActvity at android.app.IActivityTaskManager$Stub.onTransact(IActivityTaskManager.java:1486) at android.os.Binder.execTransactInternal(Binder.java:1021) at android.os.Binder.execTransact(Binder.java:994) sub Thread name is Binder:8184_2, 17, 2021-10-09 13:27:27:016 //第二次 resume： Breakpoint reached at com.android.server.wm.ActivityStack.resumeTopActivityInnerLocked(ActivityStack.java:2625) at com.android.server.wm.ActivityStack.resumeTopActivityUncheckedLocked(ActivityStack.java:2575)// 【2】终止点: 又发现问题了，新的进程都没有呢----》跑去创建process at com.android.server.wm.RootActivityContainer.resumeFocusedStacksTopActivities(RootActivityContainer.java:1158) at com.android.server.wm.ActivityStack.completePauseLocked(ActivityStack.java:1839) at com.android.server.wm.ActivityStack.activityPausedLocked(ActivityStack.java:1766) // 触发点： 前一个activityPaused at com.android.server.wm.ActivityStack$ActivityStackHandler.handleMessage(ActivityStack.java:451) at android.os.Handler.dispatchMessage(Handler.java:107) at android.os.Looper.loop(Looper.java:214) at android.os.HandlerThread.run(HandlerThread.java:67) at com.android.server.ServiceThread.run(ServiceThread.java:44) sub Thread name is android.display, 22, 2021-10-09 13:27:29:041 // display线程 //新的process创建后，attachApplication Breakpoint reached at com.android.server.wm.ActivityStackSupervisor.realStartActivityLocked(ActivityStackSupervisor.java:708)// 【3】最终真正StartActivity的地方！！！！！！！！ at com.android.server.wm.RootActivityContainer.attachApplication(RootActivityContainer.java:783) at com.android.server.wm.ActivityTaskManagerService$LocalService.attachApplication(ActivityTaskManagerService.java:6869) at com.android.server.am.ActivityManagerService.attachApplicationLocked(ActivityManagerService.java:5103) at com.android.server.am.ActivityManagerService.attachApplication(ActivityManagerService.java:5180)// 触发点：新的process创建后，attachApplication at android.app.IActivityManager$Stub.onTransact(IActivityManager.java:2003) at com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:2741) at android.os.Binder.execTransactInternal(Binder.java:1021) at android.os.Binder.execTransact(Binder.java:994) sub Thread name is Binder:8184_13, 228, 2021-10-09 13:27:36:361 2.5. 补充问题【1】：旧的Activity先要pause TODO 简略 触发点：startActivty之前，先pause老的 结果：puased之后，再继续走resume新的 2.6. 补充问题【2】：AMS 判断 所要启动的Activity对应的进程 是否存在 自然：启动ActivityB，发现的问题 逻辑： 如果存在，直接启动。即0层架构图中的 7和8 如果不存在，则 通知 zygote进程去fork一个新的APP进程 调用栈： Binder线程： startSpecificActivityLocked:961, ActivityStackSupervisor (com.android.server.wm) // 栈管理判断 resumeTopActivityInnerLocked:3037, ActivityStack (com.android.server.wm) resumeTopActivityUncheckedLocked:2575, ActivityStack (com.android.server.wm) resumeFocusedStacksTopActivities:1158, RootActivityContainer (com.android.server.wm) // 核心？？？ completePauseLocked:1839, ActivityStack (com.android.server.wm) activityPausedLocked:1766, ActivityStack (com.android.server.wm) activityPaused:1699, ActivityTaskManagerService (com.android.server.wm) //【1】 onTransact:1981, IActivityTaskManager$Stub (android.app) execTransactInternal:1021, Binder (android.os) execTransact:994, Binder (android.os) 可以看出：1、必须要等老皇帝paused，才会 resumeTopActivity ，自然 2、 resumeTopActivity发现没有，才fork新进程的，自然 对应代码： void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) { // Is this activity's application already running? .......... if (wpc != null && wpc.hasThread()) { // cg: if APP process is created, start APP Activity directly try { realStartActivityLocked(r, wpc, andResume, checkConfig); return; } .......... } try { .......... // Post message to start process to avoid possible deadlock of calling into AMS with the // ATMS lock held. final Message msg = PooledLambda.obtainMessage( // cg: if APP process is not created,create it. ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName, r.info.applicationInfo, knownToBeDead, \"activity\", r.intent.getComponent()); mService.mH.sendMessage(msg); .......... } 注意： AMS侧： 功能划分： 1、ATMS拿到paused消息，通知 栈管理ActivityStackSupervisor判断 有没进程：相当于ATMS----> ActivityStackSupervisor 2、栈管理把 判断结果，返回给ATMS和 AMS，AMS让 ProcessList去处理 : ActivityStackSupervisor ----> ATMS ----> AMS ----> ProcessList TODO: 从数据结构/代码架构角度，如何保证 功能上，AMS统领全局？？？？？？？？？ 2.6.1. AMS 通知 Zygote进程 触发点： 已经判断没有进程 记忆： 基于0层框架 ，~AMS ----> zygote进程阶段 目的：通知zygote fork一个App进程，即startProcess，自然 途径：通过socket 通信（流） 自然: 之前会 封装一系列参数 以构建socket消息， startViaZygote 为什么ATMS,最终要调用要回到ams, 最终要处理，但atms没有processList 2.7. ZygoteServer 接受消息后，fork流程（关键流程1） 2.7.1. 总之： ZygoteServer是一个socket服务器，在runSelectLoop轮询消息(死循环)，自然是必然的 （TODO: 轮询的epoll机制） 1、轮询到消息后，fork出 APP process (自然，fork需要参数，这个参数来自于socket的对端，解析出来的) 2、在 APP process中，先关闭Server Socket， 自然，因为用不到 ​ 初始化 RuntimeInit ​ 启动binder驱动（利用AndroidRuntime）？ 启动线程池 ​ 反射调用ActivityThread的 main函数，从而主线程起来 RuntimeInit.commonInit(); //cg: init Runtime. Two APPs have different runtime. ZygoteInit.nativeZygoteInit(); // cg: init Binder/Binder ThreadPool return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader); // cg: invotes ActivtyThread's main method by reflecting 代码： //ZygoteConnection.java //cg: nativeForkAndSpecialize a process for APP. Return 0 and 1 pid = Zygote.forkAndSpecialize(......); try { if (pid == 0) { // cg: in child process. APP process // in child zygoteServer.closeServerSocket(); // cg: Only zygote process needs socket server ...... return handleChildProc(parsedArgs, descriptors, childPipeFd, //cg: 反射获取 parsedArgs.mStartChildZygote); } else { // cg: zygote process // In the parent. A pid 启动binder驱动、 启动线程池： TODO // ProcessState.cpp mDriverFD(open_driver(driver)); // app_main.cpp proc->startThreadPool(); 对于fork出来的APP进程： 2.7.2. 次要补充：linux fork() 函数 nativeForkAndSpecialize具体如何fork的 -----》zygote视频 结论： 1、返回次数：一般说法为：fork函数 一定会返回两次。 但其实就是一次，子进程的返回，返回在子进程；父进程的返回，返回在父进程，自然 原因：在调用fork的时候，完全复制出另一个process（包括其属性都一样） 自然，原来进程 和 fork出的进程，都走在执行fork函数，所以会有两处返回点 -----》 TODO: 深入理解linux fork过程 ----》TODO: 返回pid=0子进程。那么,何时pid变的不为0? 2、关于返回值：fork返回值0，返回的是孩子进程 ；返回值 > 0, 说明是Zygote进程返回；返回值-1，fork失败 3、，在fork节点前的变量，在fork之后，被copy到两个进程里，独立运行，互不影响。 https://blog.csdn.net/m0_51242270/article/details/128086849?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-3-128086849-blog-126355841.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-3-128086849-blog-126355841.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=6 int main() { std::cout pid为进程号 注意：新fork出的进程，与zygote进程完全一样（除了一些） 2.7.3. ActivityThread的 main函数起来 （锚点）基于0层模型，主要做的事情： 1、创建了主线程的 驴拉磨Looper，并让死循环跑起来 2、向AMS 注册 ActivityThread的Binder 即IApplicationThread: attachApplication 2.8. APP进程起来后，attach过程（关键流程2） 一句话： 从APP角度, APP向AMS attach ActivityThread的Binder 即IApplicationThread 从AMS角度, AMS侧 bind Application AMS.attachApplicationLocked() 具体做了哪些事情呢？ 基于逻辑，推断： 1、AMS将新生儿的姓名、appInfo等同步给APP（此时新生儿白纸一张，和zygote一样）调用了APP.bindApplication ： AMS侧：thread.bindApplication(processName, appInfo, providers.........) ----> 基于刚搭建的桥梁AMS-->APP APP侧： 见 补充APP侧handleBindApplication章节 2、必然注册ApplicationThread给了AMS，存储在AMS的PorcessRecord，最终存在mLruProcesses 中----》自然，桥梁ApplicationThread的流转过程 3、必然执行Activity启动流程， 见下realStart ----》自然，最终目的 // AMS.Java private final boolean attachApplicationLocked(IApplicationThread thread, int pid, int callingUid, long startSeq) { // Find the application record that is being attached... either via // the pid if we are running in multiple processes, or just pull the // next app record if we are emulating process with anonymous threads. ProcessRecord app; long startTime = SystemClock.uptimeMillis(); long bindApplicationTimeMillis; if (pid != MY_PID && pid >= 0) { synchronized (mPidsSelfLocked) { app = mPidsSelfLocked.get(pid); // cg: inited in handleProcessStartedLocked method. } 。。。。。。。 } } ............ try { AppDeathRecipient adr = new AppDeathRecipient( app, pid, thread); thread.asBinder().linkToDeath(adr, 0); app.deathRecipient = adr; // cg: App Death Listner 死亡监听. http://t.zoukankan.com/xiayexingkong-p-6762569.html } app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ; app.setCurrentSchedulingGroup(app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT); app.forcingToImportant = null; updateProcessForegroundLocked(app, false, 0, false); app.hasShownUi = false; app.setDebugging(false); app.cached = false; app.killedByAm = false; app.killed = false; thread.bindApplication(processName, appInfo, providers.........) // cg: 关键流程！！！！将大量APP信息 同步给APP（此时APP还和zygote进程一模一样呢，），比如进程名，appInfo try { ........ app.makeActive(thread, mProcessStats); // cg: IApplicationThread of APP is bound to ProcessRecord. 这也就是后面AMS能调用 APP进程的原因 mProcessList.updateLruProcessLocked(app, false, null); //cg: Finally processRecord is added to mLruProcesses 最终存在mLruProcesses里 ........ } ........ } 2.8.1. 补充：APP侧 handleBindApplication 参考：https://blog.csdn.net/chupu2979/article/details/100616862 https://blog.csdn.net/innost/article/details/47254381 一句话总结handleBindApplication： handleBindApplication主要工作是初始化APP（APP由zygote进程fork而来，在hanldeBindApplication之前，这个APP进程和zygote没什么区别。只有调用完handleBindApplication之后，这个APP进程才是APP, 比如该进程有了对应的名字，Aplication对象被创建等）。 具体： private void handleBindApplication(AppBindDatadata) { mBoundApplication = data; mConfiguration = new Configuration(data.config); mCompatConfiguration = new Configuration(data.config); //初始化性能统计对象 mProfiler = new Profiler(); mProfiler.profileFile = data.initProfileFile; mProfiler.profileFd = data.initProfileFd; mProfiler.autoStopProfiler = data.initAutoStopProfiler; //设置进程名。从此，之前那个默默无名的进程终于有了自己的名字 Process.setArgV0(data.processName); android.ddm.DdmHandleAppName.setAppName(data.processName); if(data.persistent) { //对于persistent的进程，在低内存设备上，不允许其使用硬件加速显示 Display display = WindowManagerImpl.getDefault().getDefaultDisplay(); //当内存大于512MB，或者屏幕尺寸大于1024*600，可以使用硬件加速 if(!ActivityManager.isHighEndGfx(display)) HardwareRenderer.disable(false); } //启动性能统计 if(mProfiler.profileFd != null) mProfiler.startProfiling(); //如果目标SDK版本小于12，则设置AsyncTask使用pool executor，否则使用 //serializedexecutor。这些executor涉及Java Concurrent类，对此不熟悉的读者 //请自行学习和研究。 if(data.appInfo.targetSdkVersion 9) StrictMode.enableDeathOnNetwork(); //如果没有设置屏幕密度，则为Bitmap设置默认的屏幕密度 if((data.appInfo.flags &ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT); if(data.debugMode != IApplicationThread.DEBUG_OFF){ ......//调试模式相关处理 } IBinder b= ServiceManager.getService(Context.CONNECTIVITY_SERVICE); IConnectivityManager service = IConnectivityManager.Stub.asInterface(b); try { //设置Http代理信息 ProxyPropertiesproxyProperties = service.getProxy(); Proxy.setHttpProxySystemProperty(proxyProperties); } catch(RemoteException e) {} if(data.instrumentationName != null){ //在正常情况下，此条件不满足 } else { //创建Instrumentation对象，在正常情况都再这个条件下执行 mInstrumentation = new Instrumentation(); } //如果Package中声明了FLAG_LARGE_HEAP，则可跳过虚拟机的内存限制，放心使用内存 if((data.appInfo.flags&ApplicationInfo.FLAG_LARGE_HEAP) != 0) dalvik.system.VMRuntime.getRuntime().clearGrowthLimit(); //创建一个Application，data.info为LoadedApk类型，在其内部会通过Java反射机制 //创建一个在该APK AndroidManifest.xml中声明的Application对象 Applicationapp = data.info.makeApplication( data.restrictedBackupMode, null); //mInitialApplication保存该进程中第一个创建的Application mInitialApplication = app; //安装本Package中携带的ContentProvider if(!data.restrictedBackupMode){ List providers = data.providers; if(providers != null) { //installContentProviders我们已经分析过了 installContentProviders(app, providers); mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000); } } //调用Application的onCreate函数，做一些初始工作 mInstrumentation.callApplicationOnCreate(app); } 其中最重要的有： · 创建一个Application对象，该对象是本进程中运行的第一个Application。 · 如果该Application有ContentProvider，则应安装它们。 2.9. ActivityB 真正启动流程 realStart 途径：基于刚搭建的桥梁AMS-->APP 触发点（我来自哪里）： 见总脉络： ActivityManagerService.attachApplication 核心类（我是谁）： 栈管理 是 控制着启动，自然是 ActivityStackSupervisor 具体（做什么） ActivityStackSupervisor 创建生命周期封装类Transaction，交给 生命周期管理类，去同步给APP 2.9.1. 补充：生命周期同步到APP侧 不得不： 1、生命周期由AMS控制，通过事件ClientTranction 同步到APP 2、自然通过ActivityTread 跨进程 同步 3、binder线程过来，所以，会存在handler 转到主线程执行 -----》 自然，图中 Handler 舍弃 自然： 1、第一次，自然直接同步了resume过来。（自然APP端，先要create、start） 见： 2.9.2. 补充：APP 侧执行 生命周期同步transaction 的执行execute(关键数据结构) 核心函数： TransactionExecutor.execute(transaction); TransactionExecutor 执行器 触发流程： 自然是，realStart流程 触发了 ams的生命周期同步 ActivityThread 相关函数： handleLaunchActivity ---> performLaunchActivity ---> 【1】 创建Activity，并 attach() 创建window-----> onCreate （这里填充具体view） 【2】 handleStartActivity ---> performStartActivity -----> onStart handleResumeActivity ---> performResumeActivity -----> onResume 不得不： 1、【1】 ActivityThread.performLaunchActivity 目标是 创建activity、window、view树 ----> 自然，【1】不得不 2、在 Activity.attach() 中新建window（自然，并绑定windowManagerImpl） 3、onCreate中，APP开发者setContentView() 过程：为 开发者view 添加 最顶级view------DecorView，真正的viewTree TODO: 加强模型： 小的知识点： onCreate和onResume是AMS 同步来的 onStart是 APP侧执行器 自己算的（中间的生命周期状态都要执行cylceToPath） TODO: final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback);//cg: new window mWindow.setWindowControllerCallback(this); mWindow.setCallback(this);//cg: Activity之所以可以得到事件等消息的来源：Callback: dispatchKeyEvent、onWindowFocusChanged、onWindowAttributesChanged 关于handleResumeActivity流程----》 TODO: 新起章节 //ActivityThread.java public void handleResumeActivity(){ final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);//cg: onResume wm.addView(decor, l); //cg: keyProcess.显示： 调用 WindowManagerImpl 将decorview 添加到window系统中 Looper.myQueue().addIdleHandler(new Idler()); //cg: key process. Idler事件，关闭ActivityA 【Idler事件】 } 所以，先调用的 onResume之后，再显示的 -------》 但对于开发者，这两个先后顺序不重要，因为：都是在一个消息处理流程里，中间不可能断，都会一起执行完 2.10. 启动ActivityA的Activity stop阶段 最后一步，老皇帝行将就木stop 触发点：新皇帝完成了登基的所有事情，就通知总管，让老皇帝不要再哔哔了Stop： ActivityB 完成了所有生命周期的 同步（onCreate、onStart、onResume）。 在handleResumeActivity 最后一刻，通知ATMS，关闭ActivityA （生命周期的同步~）。见【Idler事件】 TODO: Idler事件 什么时候执行呢？当 Looper里没有可执行的消息了 ------》 这就解释了，停止ActivityA 是有空闲时，才做的 2.11. 补充：render线程的创建 时机：handleLaunchActivity // ActivityThread.java public Activity handleLaunchActivity(ActivityClientRecord r, ............. if (!ThreadedRenderer.sRendererDisabled && (r.activityInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) { // 硬件加速 HardwareRenderer.preload(); // 【1】启动render线程 Start render thread and initialize EGL or Vulkan. } WindowManagerGlobal.initialize(); ............. } 2.12. TODO: ApplicationThread是binder线程池一个线程 AMS也是嘛？ 2.13. 面试问题： 1、setContentView 2.13.1. 为什么APP不能直接启动进程？ 1、安全性角度：如果那样就见鬼了，APP自己是应用进程，开辟进程是非常危险的操作，必须由专人做专门的事。 2、性能角度（时间上、空间上）：都由Zygote进fork，可以 共享（write时复制），比APP自己加载资源，要快的多、内存开销小（如果是共享，基本上没开销） 2.13.2. 为什么使用socket而不使用binder？（网易二面） android中AMS通知Zygote去fork进程流程，为什么使用socket而不使用binder？ 参考： https://blog.csdn.net/cpcpcp123/article/details/127990882 https://blog.csdn.net/rzleilei/article/details/125770598 原因一： 1. 先后时序问题： 基于 启动系统的0层图， 如果用Zygote进程使用binder被通信 ------> 自然，在 Zygote进程 在加载过程中，需要注册服务给ServiceManager（但此时有可能ServiceManager没有初始化好） 简言之： 问题在于 不能保证ServiceManger先初始化好（因为两个进程是并行的） 补充： 图中1、2、3、4只是开始创建的时序。不是创建好的时序！！！！ 拓展问题： 等ServiceManager完全初始化好再去注册不就好了吗？ ----》 这个等，两种处理： （1）、完全初始化好，通知 -----> 这个通知也垮了进程，设计冗余 （2）、延时10ms ----> 垃圾做法 2、Linux多线程的fork存在问题 背景： Linux中，fork进程其实并不是完美的fork，linux设计之初只考虑到了主线程的fork，也就是说如果主进程中存在子线程，那么fork进程中，其子线程的锁状态，挂起状态等等都是不可恢复的，只有主进程的才可以恢复。 TODO: 所以Zygote进程，只有主线程？？？？ binder线程状态 在fork过程中存在问题： binder作为典型的CS模式，其在Server是通过线程来实现的，Server等待请求状态时，必然是处于一种挂起的状态。所以如果使用binder机制，zygote进程fork子进程后，子进程的binder的Server永远处于一种挂起不可恢复的状态，这样的设计无疑是非常差的。 3、内存问题： 进程的fork，各种内存对象自然也会被拷贝（是拷贝一个和原进程一摸一样的进程）。 --------> 如果用socket，占内存，-------> 所以 关闭socket（fork两次返回时，判断是子线程时） --------> 如果用binder，占内存 -------> 无法释放，binder成对存在？成对释放？所以需要释放AMS端的client binder Binder的特殊性在于其是成对存在的，其分为Client端对象和Server端对象。假设我们使用binder，那么因为APP端的binder是拷贝自Zygote进程的，所以如果要释放掉APP的Server端binder引用对象，就必须释放掉AMS中的Client端binder对象，那这样就会导致AMS失去binder从而无法正常向Zygote发送消息。 总之： 以上问题都是不致命的，所以，可以强行用binder 3. 从trace角度----应用冷启动 1、 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/其他核心服务/":{"url":"Andriod/其他核心服务/","title":"其他核心服务","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/其他核心服务/1_InputMethod.html":{"url":"Andriod/其他核心服务/1_InputMethod.html","title":"1 Input Method","keywords":"","body":"1. 目录2. 输入法2.1. 普通输入法需要支持的功能------功能角度2.2. 从systrace角度分析输入法3. 多屏互斥输入法4. 多屏同时输入------多屏多会话输入法4.1. 目前现状：4.2. 如何开启4.3. 参考：4.4. 其他一些TODO5. 多屏同时输入-------多屏输入法6. 输入法的前提----焦点6.1. 单个display6.2. 多个display -------焦点窗口6.2.1. 单屏焦点6.2.2. 多屏焦点6.3. 焦点0层7. 预研7.1. 引用分析7.1.1. 引用分析之InputMethodManagerInternal7.1.2. 引用分析之INPUT_METHOD_SERVICE7.2. 参考：multi7.3. 修改8. 硬件键盘与输入法软键盘8.1. 硬件键盘的事件流程8.2. 硬件键盘插入与软件盘之间的关系9. 一些琐碎的补充9.1. 关于setting信息的来源9.1.1. mSettings.getCurrentUserId()9.1.2. methodMap.put(imi.getId(), imi)来源 ------queryInputMethodServicesInternal9.1.3. 指定的输入法是怎么从设置来的？9.2. 输入法的启动时机---------窗口切换(的touch)10. Settings信息详解10.1. 关于setDisplayImePolicy最终生效的文件10.2. Settings中值的监听----ContentObserver11. 关于信息12. 抛开输入法不谈，有哪些深刻的点？12.1. 输入与焦点13. 次要13.1. android 强制打开和关闭输入法 TODO:13.2. 分布式输入法13.2.1. 分布式输入法流程14. 疑问 TODO15. 快速维测 输入法 普通输入法需要支持的功能------功能角度 从systrace角度分析输入法 多屏互斥输入法 多屏同时输入------多屏多会话输入法 目前现状： 如何开启 参考： 其他一些TODO 多屏同时输入-------多屏输入法 输入法的前提----焦点 单个display 多个display -------焦点窗口 单屏焦点 多屏焦点 焦点0层 预研 引用分析 引用分析之InputMethodManagerInternal 引用分析之INPUT_METHOD_SERVICE 参考：multi 修改 硬件键盘与输入法软键盘 硬件键盘的事件流程 硬件键盘插入与软件盘之间的关系 一些琐碎的补充 关于setting信息的来源 mSettings.getCurrentUserId() methodMap.put(imi.getId(), imi)来源 ------queryInputMethodServicesInternal 指定的输入法是怎么从设置来的？ 输入法的启动时机---------窗口切换(的touch) Settings信息详解 关于setDisplayImePolicy最终生效的文件 Settings中值的监听----ContentObserver 关于信息 抛开输入法不谈，有哪些深刻的点？ 输入与焦点 次要 android 强制打开和关闭输入法 TODO: 分布式输入法 分布式输入法流程 疑问 TODO 快速维测 1. 目录 2. 输入法 见AndriodSystem_Others google文档： https://source.android.google.cn/devices/tech/display/multi_display/ime-support?authuser=0&hl=zh-cn 输入法自己隐藏自己：需要向管理者请求（-------> 相当自然，自己的死不是自己能决定的） IMS.requestHideSelf ----> IMMS.hideMySoftInput ----> IMS.hideSoftInput() 注意：IMS ----> IMMS不是通过sessioncallback（TODO） 2.1. 普通输入法需要支持的功能------功能角度 也是验证角度 基础： 支持显示与隐藏功能： （1）输入对象侧控制输入法显示与隐藏IMM-->IMMS-->IMS。显示由框架层决定，隐藏由APP侧调框架层接口 （2）输入法面板自己主动隐藏。IMS--->IMMS--->IMS 支持向输入对象提交/删除文本内容。commitText() 操作：输入法可以向编辑框输入、删除 支持从输入对象获得光标信息 。 操作：手指在编辑框中移动光标，再进行输入，输入文字位置符合预期，则证明输入法获得了正确的光标位置；光标选中一段文字，删除 支持提交功能按键事件给输入对象。比如：百度搜索框下，点击输入法ENTER键，自动搜索 高阶： 支持根据系统语言类型配置键盘模式（出口国外，必须？） 支持向输入对象提交/删除富文本内容 支持输入法根据编辑框类型，自动选择不同输入法面板。 比如：姓名框是中文拼音键盘面板；数字框是数字键盘面板；密码框是安全键盘面板，还有语音键盘面板，手写键盘面板等等 输入法的全屏模式 支持setting中增加输入法设置入口：输入设置、手写设置、隐私设置等等 支持硬件键盘输入 2.2. 从systrace角度分析输入法 TODO: 3. 多屏互斥输入法 多屏非同时输入： https://blog.csdn.net/liaosongmao1/article/details/136151836 多屏模式输入法可以正确切换屏幕展示原理剖析 用户侧： 互斥 自然，多display 共用和一个焦点 ----------> TODO: 代码层面的实现 4. 多屏同时输入------多屏多会话输入法 4.1. 目前现状： Android 9 及以前： 系统中一次最多只有一个窗口具有焦点 Android 10~12：MultiClientInputMethodManagerService （见：https://source.android.google.cn/devices/tech/display/multi_display/ime-support?authuser=0&hl=zh-cn） google解释了为什么无法通过现有的IMS，做到多会话： Android 13： MultiClientInputMethodManagerService被删除：https://android.googlesource.com/platform/frameworks/base/+/34091a5066f3 4.2. 如何开启 1、框架要支持： （1）多屏 焦点： 将 config_perDisplayFocusEnabled 设置为 true （frameworks/base/core/res/res/values/config.xml） ​ 产物：framework-res.apk （2）非默认屏幕显示输入法： WMS.setDispalyImePolicy(2, 0) 2---- displayId 0-----WindowManger.DISPLAY_IME_POLICY_LOCAL //作用：输入法显示在本地，非默认屏 等价于？： DisplayWindowSettings#shouldShowImeLocked() DisplayWindowSettings#setShouldShowImeLocked() ​ 2、应用侧 编译MultiClientInputMethod.apk ------> 多会话的安卓demo 见：https://source.android.google.cn/devices/tech/display/multi_display/ime-support?authuser=0&hl=zh-cn#non-default //enable: $ make -j MultiClientInputMethod $ adb install -r $OUT/system/priv-app/MultiClientInputMethod/MultiClientInputMethod.apk $ adb root $ adb shell setprop persist.debug.multi_client_ime \\ com.example.android.multiclientinputmethod/.MultiClientInputMethod -----> TODO:这行是做什么的？？？ $ adb reboot //disable: # Disable multi-client IME again adb root adb shell \"setprop persist.debug.multi_client_ime ''\" //【】 adb reboot 核心功能实现： MultiClientInputMethodManagerService ------------> 支持每屏幕焦点是启用此功能的前提（自然，输入法是以窗口焦点为基础的） ​ 自然，需要将 config_perDisplayFocusEnabled 设置为 true 4.3. 参考： 《multi-client-ime.md》 https://source.android.google.cn/devices/tech/display/multi_display/ime-support?authuser=0&hl=zh-cn#non-default 4.4. 其他一些TODO 规则：键盘（硬件或软件）的输入只能进入最顶层的 activity（最近启动的应用） ---->否则隐藏 5. 多屏同时输入-------多屏输入法 见《》 TODO 6. 输入法的前提----焦点 焦点、焦点窗口、每屏焦点 6.1. 单个display 焦点 是window级别。在window之间切换 6.2. 多个display -------焦点窗口 6.2.1. 单屏焦点 焦点 是display级别，先看是哪个mTopFocusedDisplayId （关键词------------dump window） ​ 哪个window？（关键词mCurrentFocus=------------dump window） 即 1、 set： perDisplayFocusEnabled xml中配置false ​ 2、get： WindowManagerService#mPerDisplayFocusEnabled dump中如何判定？点击左右屏幕 只有一个focusDisplay，只有一个mCurrentFocus window （ANR的除外，也focus了） 现象： 1、分别点击左右框，输入法会切换 --------> 自然， 因为焦点只有一个（只能是一个diaplay的一个window） 2、如果设置了在非默认屏弹输入法（setPolicy），则输入法会在两边切换 -------->自然， 因为焦点只有一个 6.2.2. 多屏焦点 即 1、 set： perDisplayFocusEnabled xml中配置false ​ 2、判定get： WindowManagerService#mPerDisplayFocusEnabled值 aosp有问题, 只能切换一次屏幕： 此时，topFocusDisplayId只有一个，但是focuswindow有两个,dump: 6.3. 焦点0层 https://source.android.google.cn/docs/core/display/multi_display/displays?authuser=0&hl=zh-cn#focus 7. 预研 7.1. 引用分析 难点：IMMS的对外依赖 IMMS的依赖： ActivityManager ----> 忽略 ActivityManagerInternal ----> 忽略 mIPackageManager ----> 唯一，可以忽略 PackageManager ----> 唯一，可以忽略 PackageManagerInternal ----> 唯一，可以忽略 ResolveInfo ----> 忽略 ServiceInfo ----> 忽略 AudioManagerInternal mAudioManagerInternal ----> 忽略 KeyguardManager mKeyguardManager ----> 忽略 StatusBarManagerService mStatusBa ----> 忽略 InputManagerInternal ------>忽略 InputMethodService ------>忽略，都是引用常量 InputMethodSettings mSettings; -----> 这个依赖比较深，设置方面的 + userId userId = ActivityManager.getService().getCurrentUser().id; ----->有疑问：如果是双开，那么IMMS获取的是啥？ updateCurrentProfileIds UserManager mUserManager; -----> 使用了UserId，需注意 UserManagerInternal mUserManagerInternal ----> 使用了UserId，需注意 WindowManagerInternal mWindowManagerInternal; ----> WMS真正的内部类，很多调用点！！！！！！ ​ mWindowManagerInternal.getDisplayImePolicy(displayId); ​ mWindowManagerInternal.isUidAllowedOnDisplay(cs.selfReportedDisplayId, cs.uid)------> 不用管 ​ mWindowManagerInternal.removeWindowToken ----> 不用管，windowToken来标志 ​ mWindowManagerInternal.getTopFocusedDisplayId() -----> 这个接口很有问题 -------------------> IMMS.setImeWindowStatus需要修改： 1、该接口标注废弃了 2、topFocusedDisplayId 没有阻碍关键路径 IWindowManager mIWindowManager; -----> 这个是wms，只有两处调用，似乎OK mIWindowManager.addWindowToken(mCurToken, LayoutParams.TYPE_INPUT_METHOD, mCurTokenDisplayId, null / options /); transferTouchFocusToImeWindow ---> 特殊场景，忽略 这个方法仅在需要手动控制焦点转移时使用，一般情况下Android系统会自动处理焦点的转移。此方法通常在特殊的UI交互场景或自定义的文本输入组件中使用。 //IMS这里需要改 mImm = (InputMethodManager)getSystemService(INPUT_METHOD_SERVICE); mIWindowManager = IWindowManager.Stub.asInterface( ServiceManager.getService(Context.WINDOW_SERVICE)); 7.1.1. 引用分析之InputMethodManagerInternal 注意： LocalServices.addService(InputMethodManagerInternal.class, -------> muti框架基本上都没有实现！影响是？？？ InputMethodManagerInternal还是有很多地方引用的 我们自己新增的service2是不是也可以不实现？？？？ //muti框架实现的，仅仅 userIdToInputMethodInfoMapper.getAsList(userId); getEnabledInputMethodListAsUser 1、RecentsAnimationController最近任务（任务概览）动画的控制和协调。系统级的任务切换动画 ​ inputMethodManagerInternal.hideCurrentInputMethod( ​ InputMethodManagerInternal.get().updateImeWindowStatus( -------> 似乎有些影响 2、 Notifier.java ​ mInputMethodManagerInternal.setInteractive(interactive); 3、AutofillManagerServiceImpl.java ----> AutofillInlineSuggestionsRequestSession.java 内联？ ​ onCreateInlineSuggestionsRequest 4、RemoteInlineSuggestionViewConnector.java remote view相关，把输入事件传给输入法 ​ onTransferTouchFocusToImeWindow() 5、PhoneWindowManager.java SHORT_PRESS_POWER_CLOSE_IME_OR_GO_HOME：当用户在任何界面（包括应用程序、设置等）中短按电源按钮时, 隐藏输入法或者进入桌面 ------> 现在手机都没有这个现象 mInputMethodManagerInternal.hideCurrentInputMethod( 6、TranslationManagerServiceImpl.java 处理多语言翻译任务和提供相关 ​ getEnabledInputMethodListAsUser(mUserId) : 获取输入法列表信息，最终在setting里获取的 ---------> 总之，以上不是太重要，所以，multi框架忽略了 所以，新增的service2，不要注册InputMethodManagerInternal.class了！！！！，让主services去实现吧 7.1.2. 引用分析之INPUT_METHOD_SERVICE context.getSystemService(Context.INPUT_METHOD_SERVICE) Activity ----> context 要修改这么多context？ ---------> 最终统一追溯到SystemServiceRegistry.getSystemService ？？？ 7.2. 参考：multi final boolean perDisplayFocusEnabled = mContext.getResources().getBoolean( com.android.internal.R.bool.config_perDisplayFocusEnabled); 7.3. 修改 public void onStart() { publishBinderService(Context.INPUT_METHOD_SERVICE, mService, false // \"input_method2\" } ​ ----> 也可以参考multi的 8. 硬件键盘与输入法软键盘 8.1. 硬件键盘的事件流程 待验证： 1、软件盘能弹出的时候： 我记得是先分发给焦点窗口对应的view里了（keyEvent），然后再传给输入法的（输入法拿到keyEvent，相当于输入了） 2、软键盘设置不能弹出时： 似乎直接输入到view的？？？？？？ 8.2. 硬件键盘插入与软件盘之间的关系 能否显示软键盘， 设置入口1： 设置入口2： 注意： 搜狗输入法并没有受到系统这个限制--------> 如何做到的？ com.android.inputmethod.latin/.LatinIME --------> 受限 com.baidu.input/.ImeService --------> 受限 com.sohu.inputmethod.sogou/.SogouIME --------> 不受限 9. 一些琐碎的补充 9.1. 关于setting信息的来源 如何知道用户设置的默认的输入法是哪一个？ 9.1.1. mSettings.getCurrentUserId() 初始化InputMethodManagerService时，获取的是 可能存在多个用户同时登录系统的情况。在这种情况下，getCurrentUser()方法返回的是当前正在前台运行的用户的用户ID 修正： WindowManager wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE); Display[] displays = wm.getDisplays(); if (displays.length > 1) { Display secondDisplay = displays[1]; int userId = secondDisplay.getFocusedWindow().getUserId(); // ... } -疑问: 按道理，之前imms2的 userId 是有问题的。 1、用了user0的输入法配置 ？似乎没有呀 ........难道后面复写掉了？ 2、IMMS校验userID，没有校验嘛？ 9.1.2. methodMap.put(imi.getId(), imi)来源 ------queryInputMethodServicesInternal final InputMethodInfo imi = new InputMethodInfo(context, ri, additionalSubtypeMap.get(imeId)); 指定userId下所有包）：找到有 SERVICE_INTERFACE 或 SERVICE_META_DATA标志的 SERVICE_INTERFACE：表示服务的Intent过滤器中包含的Action。在查询服务信息时，可以通过指定该常量值来获取具有指定Action的服务信息。例如，在查询所有输入法服务信息时，可以使用InputMethod.SERVICE_INTERFACE作为查询条件。 SERVICE_META_DATA：表示服务的元数据。在查询服务信息时，可以通过指定该常量值来获取具有指定元数据的服务信息。例如，在查询所有输入法服务信息时，可以使用PackageManager.GET_META_DATA作为查询条件，以获取输入法服务的元数据。 比如：下面输入法应用都有 3929e0d79086:~/workingSpace/aosp_android1000_r28$ grep \"android.view.InputMethod\" -rl ./ /development/samples/SoftKeyboard/AndroidManifest.xml ./development/samples/browseable/CommitContentSampleIME/AndroidManifest.xml ./packages/apps/Car/tests/RotaryIME/AndroidManifest.xml ./packages/apps/Car/LatinIME/AndroidManifest.xml ./packages/inputmethods/LeanbackIME/AndroidManifest.xml ./packages/inputmethods/LatinIME/java/AndroidManifest.xml 9.1.3. 指定的输入法是怎么从设置来的？ //startInputUncheckedLocked InputMethodInfo info = mMethodMap.get(mCurMethodId);//关键 mCurMethodId是指定要展示的输入法 mCurIntent = new Intent(InputMethod.SERVICE_INTERFACE); ​ ​ String id = mSettings.getSelectedInputMethod(); //另外两个 setInputMethodWithSubtypeIdLocked switchToInputMethod ​ ​ 默认输入是如何决定的？ xml是硬盘里输入法 mCurMethodId是IMMS帧的输入法 ims是最后呈现的输入法 9.2. 输入法的启动时机---------窗口切换(的touch) -易错点：输入法的启动与输入框没有任何关系！！！！ 验证： C:\\Users\\Administrator>adb shell am force-stop com.sohu.inputmethod.sogou // 1、杀掉输入法 C:\\Users\\Administrator>adb shell dumpsys activity services | findstr ServiceRecord | findstr sogo // 2、查看没有了 C:\\Users\\Administrator>adb shell dumpsys activity services | findstr ServiceRecord | findstr sogo // 3、touch旧窗口，仍然没有 C:\\Users\\Administrator>adb shell dumpsys activity services | findstr ServiceRecord | findstr sogo // 4、切换窗口，比如回到桌面 * ServiceRecord{531b869 u0 com.sohu.inputmethod.sogou/.SogouIME} 10. Settings信息详解 https://blog.csdn.net/dongxianfei/article/details/120436477 https://blog.csdn.net/qq_37580586/article/details/122327215 https://blog.csdn.net/xiaowang_lj/article/details/125077473?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-125077473-blog-122327215.235^v38^pc_relevant_anti_t3&spm=1001.2101.3001.4242.1&utm_relevant_index=3 ----> 详解 Global：所有的偏好设置对系统的所有用户公开，第三方APP有读没有写的权限； System：包含各种各样的用户偏好系统设置，第三方APP有读没有写的权限； Secure：安全性的用户偏好系统设置，第三方APP有读没有写的权限。 默认值的加载 ： ​ overlay文件位于device/google/atv/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml 关于 设置属性： setprop persist.sys.binary_xml false 重启 设置后： -------> 但是 settings_secure.xml 仍然是二进制的 https://blog.csdn.net/wenzhi20102321/article/details/130646878 Android13 xml配置文件乱码问题解决 10.1. 关于setDisplayImePolicy最终生效的文件 注：setDisplayImePolicy与settings无关，但是原理一样 WMS.setDisplayImePolicy DisplayWindowSettings.setDisplayImePolicy SettingsProvider.updateOverrideSettings( mOverrideSettings.updateSettingsEntry(info, overrides) DisplayWindowSettingsProvider.writeSettings，其中，文件路径vendorFile = new File(Environment.getVendorDirectory(),VENDOR_DISPLAY_SETTINGS_FILE_PATH); XmlSerializer -----> 写入/vendor/etc/display_settings.xml getImePolicyLocked时： @DisplayImePolicy int getImePolicyLocked(DisplayContent dc) { if (dc.getDisplayId() == Display.DEFAULT_DISPLAY) { //【】 Default display should show IME. return DISPLAY_IME_POLICY_LOCAL; } final DisplayInfo displayInfo = dc.getDisplayInfo(); final SettingsProvider.SettingsEntry settings = mSettingsProvider.getSettings(displayInfo); return settings.mImePolicy != null ? settings.mImePolicy : DISPLAY_IME_POLICY_FALLBACK_DISPLAY; } -显示ime的规则： 1、主屏，默认0（在本屏幕显示ime） 2、其次，获取 /vendor/etc/display_settings.xml 配置里的数据 3、再其次，默认在主屏显示ime 10.2. Settings中值的监听----ContentObserver 以输入法的settingObserver为例 11. 关于信息 磁盘里的信息 内存里的信息 cpu执行 物理态信息 执行态信息 ---------->TODO: 如何搜索，以下每一个阶段，都可以搜索？如何搜索？ 代码态、编译态、手机中jar、运行态 手机磁盘静态、运行态 12. 抛开输入法不谈，有哪些深刻的点？ 12.1. 输入与焦点 抛开代码不谈：键盘（无论软硬）是个工具，对目标进行输入 ---------> 必然有个绑定关系，这里就是焦点的概念 进一步，抛开键盘不谈： 输入 与 输入对象之间如何对应？ --------> 焦点 总之： 1、任何输入（键盘、鼠标、软键盘）必然依赖于焦点：焦点的本质是绑定关系 2、触摸下为什么安卓没有焦点？因为绑定太明确了，坐标在view范围内 TODO: 理解焦点的机制（获焦、走焦）：焦点的概念是为了获取输入（无论键盘、输入法、手指、鼠标。。。。） 抛开输入不谈，焦点的本质： 是解决多对一问题。方法：1、单例模型 2、焦点模型 （锁也是焦点模型） 13. 次要 13.1. android 强制打开和关闭输入法 TODO: --------------> 这里似乎可以强制打开 TODO: 但是没有尝试成功 https://blog.csdn.net/u012720262/article/details/50118095 InputMethodManager inputMethodManager = (InputMethodManager)context.getSystemService(Context.INPUT_METHOD_SERVICE); // 接受软键盘输入的编辑文本或其它视图 inputMethodManager.showSoftInput(etContent,InputMethodManager.SHOW_FORCED); 13.2. 分布式输入法 见AndriodSystem_Others 13.2.1. 分布式输入法流程 见AndriodSystem_Others 14. 疑问 TODO 输入法窗口，应该是永远没法 获取 窗口焦点的（只能触摸，不能被输入） ------> 代码的证明 computeImeDisplayIdForTarget 计算display TODO：一个悬浮的输入法窗口位置呢？ -------> 谁决定的？ 15. 快速维测 //查看所有服务 adb shell dumpsys activity services | findstr ServiceRecord // 查看有没有sogou输入法 adb shell dumpsys activity services | findstr ServiceRecord | findstr sogo console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/其他核心服务/multi-client-ime.html":{"url":"Andriod/其他核心服务/multi-client-ime.html","title":"Multi Client Ime","keywords":"","body":"1. 目录2. Multi Client Input Method Editors2.1. History of Multi Client Input Method Editors (Multi Client IMEs)2.2. How to test2.3. How to develop multi-client IMEs2.4. Versioning2.5. Implementation note2.5.1. Unsupported features2.5.2. Security 目录 Multi Client Input Method Editors History of Multi Client Input Method Editors (Multi Client IMEs) How to test How to develop multi-client IMEs Versioning Implementation note Unsupported features Security Root permission is required to enable MCIMMS on non-supported devices Multi-client IME must be pre-installed Integer handle vs IBinder token 1. 目录 Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 2. Multi Client Input Method Editors 2.1. History of Multi Client Input Method Editors (Multi Client IMEs) An advanced multi-display support is requested for certain Android form-factors so that user(s) can type text on each display at the same time without losing software keyboard focus in other displays (hereafter called \"multi-client scenario\"). This is not possible in Android IMEs built on top of InputMethodService class. The assumption that a single IME client can be focused at the same time was made before Android IME APIs were introduced in Android 1.5 and many public APIs in InputMethodService have already relied heavily on that assumption (hereafter called \"single-client scenario\"). Updating InputMethodService class to support multi-client scenario is, however, quite challenging because: doing so would introduce an unacceptable amount of complexity into InputMethodService, which is already hard to maintain, IME developers still need to update their implementation to be able to support parallel requests from multiple focused IME client, which may require non-trivial redesign in their side (e.g. input decoder, typing history database, ...), and actual use cases for multi IME clients are expected to be evolved rapidly hence the new protocol is not yet stable and not yet ready to be exposed as public APIs. Thus the first decision we made was that to support such special multi-display environments a new type of IME (hereafter called \"multi-client IME\") needs to be designed and implemented rather than reusing InputMethodService public class. On top of this decision, following decisions were also made: Multi-client IME V1 will be built on top of private APIs. This means: Multi-client IME must be pre-installed into the system. They cannot be distributed via application store since protocol compatibility is not guaranteed across devices and releases. The system should trust multi-client IME to some extent. System integrators are responsible for making sure that the pre-installed multi-client IME works as expected. Unlike InputMethodService, multiple multi-client IMEs cannot be enabled. The system pre-installs only one multi-client IME. Punt some special features of Android IMEs (e.g. fullscreen mode, InputMethodSubtype, ...) from V1 goal unless someone actually requests those features for multi-client IME scenario. Introduce MultiClientInputMethodManagerService (MCIMMS) for multi-client IME scenario and use it instead of InputMethodManagerService (IMMS) when a certain runtime flag is enabled at the device boot time. This means: basically no risk for single-client scenario, the feature can be easily deprecated, and it forces us to rewrite IME system server, which is expected to be a good chance to reconsider what Android IME protocol should look like. Most of form-factors such as Phones and TVs continue to use IMMS and support at most one focused IME client even under multi-display environment. 2.2. How to test For multi-client IME to properly work, an internal boolean resource com.android.internal.R.bool.config_perDisplayFocusEnabled needs to be true. Since this value cannot be overridden at the run time, you may need to rebuild the system image to enable per-display focus mode. As for multi-client IME mode itself, you can enable multi-client IME mode just by setting a valid component name that supports multi-client IME protocol to the system property persist.debug.multi_client_ime, as long as android.os.Build.IS_DEBUGGABLE returns true and you can have root access. Reboot is required for this to take effect. # Build and install a sample multi-client IME make -j MultiClientInputMethod adb install -r $OUT/system/priv-app/MultiClientInputMethod/MultiClientInputMethod.apk # Enable multi-client IME for the side-loaded sample multi-client IME adb root adb shell setprop persist.debug.multi_client_ime com.example.android.multiclientinputmethod/.MultiClientInputMethod adb reboot To disable multi-client IME on non-supported devices again, just clear persist.debug.multi_client_ime as follows. Reboot is still required for this to take effect. # Disable multi-client IME again adb root adb shell \"setprop persist.debug.multi_client_ime ''\" adb reboot 2.3. How to develop multi-client IMEs There is a sample multi-client IME in development/samples/MultiClientInputMethod/. 2.4. Versioning Neither forward nor backward compatibility is guaranteed in multi-client IME APIs. The system integrator is responsible for making sure that both the system and pre-installed multi-client IME are compatible with each other every time the system image is updated. 2.5. Implementation note `` 2.5.1. Unsupported features VR IME VrManager#setVrInputMethod() system API is not supported. InputMethodSubtype Following APIs are not supported InputMethodManager#getEnabledInputMethodSubtypeList() ----> adb shell ime list失效的原因（multi-client输入法下） InputMethodManager#getCurrentInputMethodSubtype() InputMethodManager#setCurrentInputMethodSubtype() InputMethodManager#getShortcutInputMethodsAndSubtypes() InputMethodManager#setAdditionalInputMethodSubtypes() InputMethodManager#getLastInputMethodSubtype() Settings.Secure#SELECTED_INPUT_METHOD_SUBTYPE IME switching Following APIs are not supported InputMethodManager#showInputMethodPicker() InputMethodManager#showInputMethodAndSubtypeEnabler() InputMethodManager#setInputMethod() InputMethodManager#setInputMethodAndSubtype() InputMethodManager#switchToLastInputMethod() InputMethodManager#switchToNextInputMethod() InputMethodManager#shouldOfferSwitchingToNextInputMethod() Settings.Secure#DEFAULT_INPUT_METHOD Settings.Secure#ENABLED_INPUT_METHODS Direct-boot aware multi-client IME Device manufacturer can work around this by integrating in-app keyboard into the initial unlock screen. Full-screen mode Following API always returns false. InputMethodManager#isFullscreenMode() Custom inset For instance, floating IME cannot be implemented right now. Custom touchable region (InputMethodService.Insets#touchableRegion) Image Insertion API InputConnection#commitContent() API is silently ignored. adb shell dumpsys does not include any log from MCIMMS yet. 2.5.2. Security Root permission is required to enable MCIMMS on non-supported devices In order to override persist.debug.multi_client_ime device property, an explicit root permission is needed. Multi-client IME must be pre-installed Multi-client IME must be pre-installed since it is considered as part of the system component. This is verified by checking ApplicationInfo.FLAG_SYSTEM bit. This security check can be bypassed when Build.IS_DEBUGGABLE is true so that IME developers can easily side-load their APKs during development phase. public final class MultiClientInputMethodManagerService { ... @Nullable private static InputMethodInfo queryInputMethod(Context context, @UserIdInt int userId, @Nullable ComponentName componentName) { ... if (! && (si.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) { Slog.e(TAG, imeId + \" must be pre-installed when Build.IS_DEBUGGABLE is false\"); return null; } services/core/java/com/android/server/inputmethod/MultiClientInputMethodManagerService.java Integer handle vs IBinder token Sometimes MCIMMS needs to issue certain types of identifiers to the multi-client IME so that the IME can later specify to which entity or resource it intends to access. A good example is the IME client identifier. Multi-client IME definitely need to be able to specify which IME client to be interacted with for certain operations. The problem is that MCIMMS cannot simply pass IInputMethodClient to the multi-client IME as an ID because it would allow the IME to make IPC calls to the IME client. For this kind of situations, we usually use Binder object just as a non-spoofable token. For instance, IMMS creates another 'Binder' token then pass it to the IME, instead of directly passing 'IWindow' Binder token. public class InputMethodManagerService extends IInputMethodManager.Stub implements ServiceConnection, Handler.Callback { ... @GuardedBy(\"mMethodMap\") private final WeakHashMap mImeTargetWindowMap = new WeakHashMap<>(); ... @GuardedBy(\"mMethodMap\") @NonNull InputBindResult attachNewInputLocked(@StartInputReason int startInputReason, boolean initial) { ... final Binder startInputToken = new Binder(); final StartInputInfo info = new StartInputInfo(mCurToken, mCurId, startInputReason, !initial, mCurFocusedWindow, mCurAttribute, mCurFocusedWindowSoftInputMode, mCurSeq); mImeTargetWindowMap.put(startInputToken, mCurFocusedWindow); ... } ... @BinderThread private void reportStartInput(IBinder token, IBinder startInputToken) { if (!calledWithValidToken(token)) { return; } synchronized (mMethodMap) { final IBinder targetWindow = mImeTargetWindowMap.get(startInputToken); if (targetWindow != null && mLastImeTargetWindow != targetWindow) { mWindowManagerInternal.updateInputMethodTargetWindow(token, targetWindow); } mLastImeTargetWindow = targetWindow; } } services/core/java/com/android/server/inputmethod/InputMethodManagerService.java However, in MCIMMS, for certain cases we decided to use a simple integer token, which can be spoofable and can be messed up if integer overflow happens. This is because: It does not make much sense to worry about malicious multi-client IMEs, because it is guaranteed to be a pre-installed system component. Integer token is expected to be a more lightweight that Binder token. For that use case, integer overflow is unrealistic. Strict user separation is still enforced. Multi-client IMEs are still not allowed to interact with other users' resources by any means. Currently the following IDs are implemented as integer tokens: Client ID Window Handle Note that each IME client has its own Window Handle mapping table. Window Handle is valid only within the associated IME client. console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/其他核心服务/无障碍_.html":{"url":"Andriod/其他核心服务/无障碍_.html","title":"无障碍_","keywords":"","body":"1. 无障碍流程1.1. 总体静态框架1.2. 流程：1.2.1. 无障碍相关流程和原理1.2.2. 高级-----自定义view的无障碍1.2.3. 无障碍优化CheckList2. 从信息流看无障碍--------AccessibilityNodeInfo3. 其他理解3.1. 只接收的事件类型eventTypes4. H5的无障碍适配5. TODO: 总体静态框架 流程： 无障碍相关流程和原理 发出AccessibilityEvent 总问题： 创建AccessibilityNodeInfo 高级-----自定义view的无障碍 Y侧所做的 无障碍优化CheckList 从信息流看无障碍--------AccessibilityNodeInfo 其他理解 只接收的事件类型eventTypes H5的无障碍适配 TODO: 1. 无障碍流程 1.1. 总体静态框架 类图： 无障碍相关的类： A侧左滑流程 下滑操作无障碍流程TouchExplorerTouchExplorerAccessibilityManagerAccessibilityManagerAccessibilityManagerServiceAccessibilityManagerServiceAccessibilityInputFilterAccessibilityInputFilterEventStreamTransformationEventStreamTransformationAbstractAccessibilityServiceConnectionAbstractAccessibilityServiceConnectionIAccessibilityServiceClient接口IAccessibilityServiceClient接口TalkBackServiceTalkBackServiceAccessibilityInteractionControllerAccessibilityInteractionControllerAccessibilityInteractionConnection接口AccessibilityInteractionConnection接口ViewRootImplViewRootImplViewViewsystem_process进程system_process进程system_process进程AMS侧===》AS侧的接口as进程app进程onMotionEvent左滑过程：第一轮，ACTION_DOWN第二轮，ACTION_MOVE；第三轮，ACTION_MOVE。。。。。最后一轮，ACTION_UPhandleMotionEventStateTouchExploringsendAccessibilityEventsendAccessibilityEvent第一轮，TYPE_TOUCH_INTERACTION_START，后面全是该事件====》最终talkBack拿到了第二轮，TYPE_GESTURE_DETECTION_START，手势检测开始====》最终talkBack拿到了最后一轮，TYPE_GESTURE_DETECTION_END，手势检测结束====》最终talkBack拿到了TYPE_TOUCH_INTERACTION_END====》最终talkBack拿到了sendAccessibilityEvent(AccessibilityEvent, int userId)mainHandler.sendMessage(AccessibilityManagerService::sendAccessibilityEventToInputFilter,)TYPE_TOUCH_INTERACTION_STARTmainHandler在AMS中new出来，流转到AccessibilityServiceConnection和AbstractAccessibilityServiceConnectionmMainHandler.handleMessage(TYPE_TOUCH_INTERACTION_START)sendAccessibilityEventToInputFilter(AccessibilityEvent)notifyAccessibilityEvent(AccessibilityEvent)onAccessibilityEvent(AccessibilityEvent)super.onAccessibilityEvent(event)onAccessibilityEvent(event)这里是空的，啥也没做mainHandler通知执行notifyAccessibilityEventInternal(AccessibilityEvent)onAccessibilityEvent(event, serviceWantsEvent)onAccessibilityEvent(AccessibilityEvent event)第一轮，TYPE_TOUCH_INTERACTION_START，最终talkBack拿到了第二轮，TYPE_GESTURE_DETECTION_START，最终talkBack拿到了，第三轮。。。最后一轮，TYPE_GESTURE_DETECTION_END，最终talkBack拿到了TYPE_TOUCH_INTERACTION_END 最终talkBack拿到了app进程;ViewRootImpl内部类AMS===>APP侧的接口onGestureCompleted(int gestureId)TYPE_TOUCH_INTERACTION_END时候，收到手势动作GESTURE_SWIPE_RIGHT右滑onGesture(int gestureId)onGesture(gestureId)onGesture(gestureId)performAction(AccessibilityNodeInfoCompat node, int action,,EventId )哪个node，是有talkback决定的action为64，即ACTION_ACCESSIBILITY_FOCUS获焦！！！EventId：GESTURE_SWIPE_RIGHT，右滑performAccessibilityActionperformAccessibilityActionperformAccessibilityActionClientThread(long accessibilityNodeId, int action,整个performAction是从AMS侧调过来的！！！！AMS如何决定的？？Action具体是什么？？handleMessage(MSG_PERFORM_ACCESSIBILITY_ACTIONperformAccessibilityActionUiThread(message)View target = findViewByAccessibilityId(accessibilityViewId).performAccessibilityAction(action, arguments)View.performAccessibilityActionInternal(action, arguments) case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:View：case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:View：requestAccessibilityFocus sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);View：sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);发送无障碍事件？？？？？发送到哪里了？？？AS侧？setAccessibilityFocus(this, null)drawAccessibilityFocusedDrawableIfNeeded(Canvas canvas)画绿框 1.2. 流程： 1.2.1. 无障碍相关流程和原理 https://myslide.cn/slides/2795# 发出AccessibilityEvent 总问题： 1、sendEvent的始点是view ！！！》哪个view发的？？？ AccessibilityEvent包含哪些信息？？ Hover事件的分发流程？？？？ 发出AccessibilityEvent 用户点击 是否无障碍 模式？ 分发Hover事件给 View 构造 AccessibilityEvent 把NodeInfo对应的id 放到无障碍事件里 请求ViewRootImpl发 出无障碍事件 AccessibilityManager 将无障碍事件传送给 TalkBack 创建AccessibilityNodeInfo TalkBack收到无障碍 事件 取出事件中的id 根据id到 ViewRootImpl中找对 应的view View调用创建 NodeInfo的方法 是否自定义 AccessibilityNo deProvider 否是 根据View初始化 NodeInfo 自定义NodeInfo的创 建及初始化 把NodeInfo返回 Talkback 1.2.2. 高级-----自定义view的无障碍 当一个自定义View中包含多种UI元素时，无障碍模式下并不能区分包含的多种UI元素，而只为自定义View添加一个大无障碍焦点。如图： https://www.sohu.com/a/109190540_468731 Y侧所做的 就是利用上述的两个delegate，塞给A的view，相当于自定义虚拟view！！！ 1.2.3. 无障碍优化CheckList 1. 从手Q开发谈Android无障碍化实现原理 及优化 alberthe 何金源 2016年9月 2. ABOUT ME 何金源 毕业于华南理工大学 手机QQ 基础Android开发组 目前负责 Android手Q无障碍化 多人聊天 基础资料卡 3. 目录 无障碍相关流程和原理 自定义View无障碍化 无障碍优化CheckList 4. 无障碍化（Accessibility） • 无障碍化，是指针对听障、视障、肢障的用户所增加辅劣 项目，可以方便社会上此类有需要的人士有机会成功使用 我们的应用。 • 操作方式： 选择（Hover）：单击 开启（Click）：双击 滚劢：双指往上、下、左、右 选择上戒下一个项目：单指往上、下、左、右 快速回到主画面：单指上滑+左滑 返回键：单指下滑+左滑 最近画面键：单指左滑+上滑 通知栏：单指右滑+下滑 5. 无障碍焦点 • 可覆盖在任意View上 • 在屏幕上用绿色方框标明 • TalkBack根据用户交互来分配 • 表示当前活跃的元素 6. 目录 无障碍相关流程和原理 自定义View无障碍化 无障碍优化CheckList 7. Android系统的无障碍 QQ System TalkBack Google 讯飞 用户 8. 无障碍相关类 QQ System TalkBack AccessibilityManager View AccessibilityService AccessibilityDelegate AccessibilityNodeInfo AccessibilityNodeProvider 9. 发出AccessibilityEvent 用户点击 是否无障碍 模式？ 分发Hover事件给 View 构造 AccessibilityEvent 把NodeInfo对应的id 放到无障碍事件里 请求ViewRootImpl发 出无障碍事件 AccessibilityManager 将无障碍事件传送给 TalkBack 10. 创建AccessibilityNodeInfo TalkBack收到无障碍 事件 取出事件中的id 根据id到 ViewRootImpl中找对 应的view View调用创建 NodeInfo的方法 是否自定义 AccessibilityNo deProvider 否是 根据View初始化 NodeInfo 自定义NodeInfo的创 建及初始化 把NodeInfo返回 Talkback 11. View获取Focus TalkBack拿到 NodeInfo 根据无障碍事件中的 type来处理 执行NodeInfo中的 performAction方法 找到ViewRootImpl执 行Action 找到下一个需要获取 无障碍焦点的ViewB ViewB请求获取无障 碍焦点 找到上一个拥有无障 碍焦点的ViewA 释放ViewA的无障碍 焦点 结束 12. 绘制无障碍焦点 ViewRootImpl调用 draw方法绘制 是否无障碍 模式？ 是 找到当前focused的 View 算出View在屏幕的大 小 绘制无障碍焦点 13. 无障碍系统原理总结 • UI界面元素发生变化时（比如View被点击，View的焦点切换等）， 发出AccessibilityEvent • AccessibilityService接收这些AccessibilityEvent后，根据 AccessibiltyEvent里的accessibilityId来获取AccessibilityNodeInfo • AccessibilityNodeInfo由View来创建，戒者由 AccessibilityNodeProvider来创建 • AccessibilityService根据AccessibilityNodeInfo的信息提供无障碍 服务 • AccessibilityService通过AccessibilityNodeInfo来告知UI元素作出 处理 14. 目录 无障碍相关流程和原理 自定义View无障碍化 无障碍优化CheckList 15. 一般情况下的无障碍化 按钮添加 contentdescription ListView的Item 会变化的元素 16. 困难场景 17. 解决方案思考 自定义NodeInfo? TalkBack收到无障碍 事件 取出事件中的id 根据id到 ViewRootImpl中找对 应的view View调用创建 NodeInfo的方法 是否自定义 AccessibilityNo deProvider 否是 根据View初始化 NodeInfo 自定义NodeInfo的创 建及初始化 把NodeInfo返回 Talkback 18. 自定义虚拟节点 • 自定义AccessibilityNodeProvider 19. 自定义虚拟节点 • 创建根AccessibilityNodeInfo 20. 自定义虚拟节点 • 创建子AccessibilityNodeInfo 添加Action 设置子节点的边框 设置状态等 21. 自定义虚拟节点 • 实现performAction方法 创建好根节点和子节点后，AccessibilityNodeProvider会被系统调 用performAction，来执行指定的无障碍操作（Action），根据 virtualViewId判断由根节点还是子节点来执行。 22. 自定义虚拟节点 • 分发HoverEvent到子节点，发出Hover无障碍事件 23. 更好的办法？ AccessibilityNodeProvider 24. 认识ExploreByTouchHelper • 简化虚拟节点层次结构的实现 只要实现五个抽象方法 • 隐藏AccessibilityNodeProvider的实现 • 完善控制Hover事件、无障碍事件 • 兼容性好 25. 实现ExploreByTouchHelper • 委托处理无障碍 • 标记虚拟节点ID • 丰富无障碍信息 • 提供用户交互支持 26. 委托ExploreByTouchHelper 27. 实现ExploreByTouchHelper • 委托处理无障碍 • 标记虚拟节点ID • 丰富无障碍信息 • 提供用户交互支持 28. 无障碍节点id • 界面上的元素使用无障碍节点id标记 • 无障碍节点id需要满足： - id是一个接一个的 - id是稳定的 - id非负整数 29. 标记界面元素的无障碍节点id 30. 实现ExploreByTouchHelper • 委托处理无障碍 • 标记虚拟节点ID • 丰富无障碍信息 • 提供用户交互支持 31. 填充无障碍节点的属性 32. 实现ExploreByTouchHelper • 委托处理无障碍 • 标记虚拟节点ID • 丰富无障碍信息 • 提供用户交互支持 33. 提供用户交互支持 34. 实现ExploreByTouchHelper • 委托处理无障碍 • 标记虚拟节点ID • 丰富无障碍信息 • 提供用户交互支持 35. 目录 无障碍相关流程和原理 自定义View无障碍化 无障碍优化CheckList 36. 无障碍优化CheckList • setContentDescription • Focusable • Custom View • 可变元素 37. 无障碍化需持之以恒 1. 细节决定成败 感悟 2. 无障碍要迭代 《Android无障碍宝典》 http://geek.csdn.net/news/detail/93269 38. 谢谢 2. 从信息流看无障碍--------AccessibilityNodeInfo AccessibilityNodeInfo包含的主要信息： windowId -------------- 无障碍windowId mSourceNodeId ------------AccessibilityNodeInfo的Id，等价于界面上一个元素 view的属性mAccessibilityViewId 标志着 view的id： // view.java mAccessibilityViewId = sNextAccessibilityViewId++; ​ 创建位置：在APP进程（自然） 3. 其他理解 AccessibilityService运行在后台,并且能够收到由系统发出的一些事件(AccessibilityEvent,这些事件表示用户界面一系列的状态变化),比如焦点改变,输入内容变化,按钮被点击了等等,该种服务能够请求获取当前活动窗口并查找其中的内容.换言之,界面中产生的任何变化都会产生一个时间,并由系统通知给AccessibilityService.这就像监视器监视着界面的一举一动,一旦界面发生变化,立刻发出警报. 参考： android 无障碍多点点击 无障碍模拟点击 https://blog.51cto.com/u_12897/7388266 3.1. 只接收的事件类型eventTypes 方法一：属性配置 android:accessibilityEventTypes：这个属性设置服务只接收的事件类型 ---------> 优化 android:accessibilityFeedbackType：服务支持的反馈类型，FEEDBACK_AUDIBLE（可听），FEEDBACK_BRAILLE（盲文），FEEDBACK_GENERIC（普通），FEEDBACK_HAPTIC（触觉），FEEDBACK_SPOKEN（口语），FEEDBACK_VISUAL（可视），FEEDBACK_ALL_MASK（全部） 参考： android 无障碍多点点击 无障碍模拟点击 https://blog.51cto.com/u_12897/7388266 方法二：通过setServiceInfo setServiceInfo(AccessibilityServiceInfo info) 是 Android 中 AccessibilityService 类的一个方法，它用于设置服务的信息，其中参数 info 是一个 AccessibilityServiceInfo 对象，包含了有关 AccessibilityService 的各种配置和属性。 以下是这个方法的作用和一些常见的配置项： 设置服务的基本信息： AccessibilityServiceInfo 对象包含了一些基本的信息，如服务的名称、描述等。通过这个方法，你可以为你的无障碍服务设置这些基本信息。 配置支持的事件类型： AccessibilityServiceInfo 中有一个 eventTypes 属性，表示服务感兴趣的事件类型。通过设置 AccessibilityServiceInfo 的 eventTypes，你可以确定服务会在哪些事件发生时被激活。 配置支持的包名： packageNames 属性用于指定服务要支持的应用包名。通过设置 AccessibilityServiceInfo 中的 packageNames，你可以限制服务在哪些应用中激活。 配置反馈类型： feedbackType 属性表示服务提供的反馈类型，如语音、振动等。通过设置 AccessibilityServiceInfo 中的 feedbackType，你可以确定服务提供的反馈类型。 配置能否接收通知事件： notificationTimeout 属性表示服务接收通知事件的超时时间。通过设置 AccessibilityServiceInfo 中的 notificationTimeout，你可以配置服务是否能够接收通知事件。 这个方法的调用通常在你的 AccessibilityService 的 onServiceConnected() 方法中进行，当服务被绑定时调用。例如： @Override protected void onServiceConnected() { super.onServiceConnected(); AccessibilityServiceInfo info = new AccessibilityServiceInfo(); // 配置 AccessibilityServiceInfo 对象 setServiceInfo(info); } 通过调用 setServiceInfo 方法，你可以为你的无障碍服务提供相关的配置信息，以便系统能够正确地使用和管理你的服务。 4. H5的无障碍适配 https://blog.csdn.net/LuckyWinty/article/details/132309940 TODO: 按道理：H5的无障碍适配 与 webview没有什么区别 5. TODO: 无障碍mWindowId哪里来？ createAccessibilityNodeInfoInternal 做了两件事情： 1、AccessibilityNodeInfo.obtain(this) 为view绑定 NodeInfo 2、onInitializeAccessibilityNodeInfoInternal //（1）给NodeInfo填充具体的view信息 info.setImportantForAccessibility(isImportantForAccessibility()); info.setPackageName(mContext.getPackageName()); info.setClassName(getAccessibilityClassName()); info.setContentDescription(getContentDescription()); info.setEnabled(isEnabled()); info.setClickable(isClickable()); info.setFocusable(isFocusable()); info.setScreenReaderFocusable(isScreenReaderFocusable()); info.setFocused(isFocused()); info.setAccessibilityFocused(isAccessibilityFocused()); info.setSelected(isSelected()); info.setLongClickable(isLongClickable()); info.setContextClickable(isContextClickable()); info.setLiveRegion(getAccessibilityLiveRegion()); //（2）填充NodeInfo中mParentNodeId ​ AccessibilityNodeInfo.obtain(view);------> 为view创建AccessibilityNodeInfo accessibilityNodeInfo.setSource(view); // 绑定 新生成的 nodeInfo 以及 对应的view -----> 如何绑定？ （1）把view的 无障碍mWindowId给了 nodeInfo （2）该view作为该AccessibilityNodeInfo的root（虽然该view不是view树的root） （3）mAccessibilityViewId + 根ROOT ------> 作为NodeInfo唯一标识mSourceNodeId console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/0_AndriodSystem.html":{"url":"Andriod/0_AndriodSystem.html","title":"0 Andriod System","keywords":"","body":"1. 目录2. 官方文档3. 对系统的理解与疑问4. 0层4.1. 静态0层4.2. 动态0层 ---> 以进程的视角4.3. 知识点0层4.4. 进程0层-------进程树5. 源码地图：即分层，细化5.1. framework基础框架，0层5.2. 其中，WMS 1层6. 系统启动流程（纵向主线）7. APP启动流程（纵向主线）8. window8.1. 0层8.2. setAttributes流程：8.3. vSync - surface -window-view 0层：8.4. 参考的博客资料：9. 无障碍10. 应用程序消息处理机制分析11. 稳定性专题11.1. ANR12. 内存泄漏专题13. 内存抖动专题14. 安卓资源：14.1. 见config需求分析14.2. 资源目录结构14.2.1. symbols.xml 系统私有资源14.2.2. public.xml公共资源14.2.3. attrs.xml14.2.4. 以attr为例子：14.2.5. style15. ViewOverlay16. 安卓面试题目16.1. Activity生命周期？16.2. Activity的启动过程16.3. Broadcast注册方式与区别16.3.1. HttpClient、HttpUrlConnection16.3.2. java虚拟机和Dalvik虚拟机的区别16.3.3. 进程保活（不死进程）16.3.4. 讲解一下Context16.3.5. 理解Activity,View,Window三者关系16.3.6. 四种LaunchMode及其使用场景17. 安卓基础知识17.1. aidl17.1.1. aidl的理解17.1.2. Android中Parcelable接口：17.1.3. 状态保存分析，待合并17.1.4. 关于Binder17.2. 关于线程的理解：17.2.1. 什么是线程？17.2.2. 什么是主线程？17.2.3. 安卓主线程是一个死循环18. 输入法19. 安卓逆向20. 计算机基础20.1. 操作系统之进程管理21. 性能专题21.1. 其他22. 面试22.1. 项目相关问题：22.1.1. 开发22.1.2. 软件经理22.2. 面试技术问题22.2.1. 帧数据的流转22.2.2. 需要补充的知识点：22.3. 一些好的点22.4. 问面试官的问题22.5. 谈薪资23. 参考文章24. Android开发常用网站24.1. Android 相关25. 格式25.1. 使用逻辑：25.2. 标记25.3. 隐藏26. 书籍 官方文档 对系统的理解与疑问 0层 静态0层 动态0层 ---> 以进程的视角 知识点0层 进程0层-------进程树 源码地图：即分层，细化 framework基础框架，0层 其中，WMS 1层 系统启动流程（纵向主线） APP启动流程（纵向主线） window 0层 setAttributes流程： vSync - surface -window-view 0层： 参考的博客资料： 无障碍 应用程序消息处理机制分析 稳定性专题 ANR 内存泄漏专题 内存抖动专题 安卓资源： 见config需求分析 资源目录结构 symbols.xml 系统私有资源 public.xml公共资源 attrs.xml 以attr为例子： style ViewOverlay 安卓面试题目 Activity生命周期？ Activity的启动过程 Broadcast注册方式与区别 HttpClient、HttpUrlConnection java虚拟机和Dalvik虚拟机的区别 进程保活（不死进程） 讲解一下Context 理解Activity,View,Window三者关系 四种LaunchMode及其使用场景 View的绘制流程 View，ViewGroup事件分发 保存Activity状态 Android中的几种动画 Android中跨进程通讯的几种方式 AIDL理解 Handler的原理 Binder机制原理 热修复的原理 Android内存泄露及管理 Fragment、Activity通信的方式 Android UI适配 app优化 图片优化 HybridApp WebView和JS交互 JAVA GC原理 27、ANR 安卓基础知识 aidl aidl的理解 Android中Parcelable接口： 何时使用？使用例子 parcel #1 parcel.writeString 如何转的？？？ 复杂化：Book类里面有其它对象 Parcelable与Intent或者Bundle 与Serializable对比，优劣势？ 状态保存分析，待合并 关于Binder 关于线程的理解： 什么是线程？ 什么是主线程？ 安卓主线程是一个死循环 输入法 安卓逆向 计算机基础 操作系统之进程管理 性能专题 其他 面试 项目相关问题： 开发 软件经理 所做的事情 遇到需求交不了，你是怎么解决的： 遇到很多领域都没完成的 对某一个项目中遇到的问题，举一反三 面试技术问题 帧数据的流转 需要补充的知识点： 一些好的点 问面试官的问题 谈薪资 参考文章 Android开发常用网站 Android 相关 格式 使用逻辑： 标记 隐藏 书籍 1. 目录 2. 官方文档 1、https://source.android.com/docs/core?hl=zh-cn - 两个相似网站 https://source.android.com/docs/core?hl=zh-cn ---------> 英文网站（的中文翻译） https://source.android.google.cn/docs/core?hl=zh-cn ------> 废除！！！！！！！这个本身就是中文网站，信息不是最新的！！！！！ 官方文档是最快搭建知识框架的方式！！！ 重要的事只有一件，同样重要的文档只有一个-------官方文档 从哪些角度理解安卓？以上 2、Android 开发者 https://developer.android.com/guide?hl=zh-cn 3、Google git 查找提交记录 https://android.googlesource.com/platform/frameworks 3. 对系统的理解与疑问 系统是status在时间上的流淌，即status(t)-----> 以帧来理解系统 那么多status，抓主status（次要status为主要服务） 如何理解dump？即一帧status 规定： 1、每一个status都要只要adb 设置的的方法，和get的方法 ，比如 perDisplayFocusEnabled设置是xml，获取是 WindowManagerService#mPerDisplayFocusEnabled debug可以看 2、永远不相信任何一个set（只有经历get之后，才能确定） 疑问： 那么多进程与线程，如何做到协调？ -------> 一定是有大的结构协调（小协调依附于大协调）: 房子是框架与框架协调决定的，而不是砖与砖之间协调决定的 ​ 抛开代码不谈，事物的本质？ TODO： 大的结构指的是啥？ 模块之间如何协调？（同进程的） 如何协调硬件资源？ 安卓是一个大的Binder应用 APP-----系统服务 4. 0层 https://mp.weixin.qq.com/s/saps9pV-HEAon4majH1-aQ 注：所有的知识，必须脱离纸面、脱离文字！！！！！！！！ 4.1. 静态0层 Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而连通整个系统。 4.2. 动态0层 ---> 以进程的视角 系统启动架构图： 见 《系统启动流程》 4.3. 知识点0层 注意点： RunTime 和 异常原理 4.4. 进程0层-------进程树 Android 10 进程 删减版 ?(0)-+-init(1)-+-ATFWD-daemon(3416)-+-{ATFWD-daemon}(3433) | | `-{ATFWD-daemon}(3434) | |-adbd(3690)-+-busybox(4212) | | |-{UsbFfs-monitor}(3692) | | |-{UsbFfs-worker}(3693) | | |-{shell svc 4212}(4213) | | `-{usb ffs open}(3691) | |-adsprpcd(826)-+-{adsprpcd}(849) | | `-{adsprpcd}(850) | |-allocator@1.0-s(651) | |-allocator@2.0-s(521)-+-{HwBinder:521_1}(532) | | `-{HwBinder:521_2}(1842) | |-apexd(604)-+-{Binder:604_1}(608) | | `-{Binder:604_2}(609) | |-ashmemd(684) | |-atrace@1.0-serv(511) | |-audio@2.0-servi(654)-+-{Binder:654_1}(690) | | |-{Binder:654_2}(758) | | |-{HwBinder:654_1}(760) | | |-{HwBinder:654_2}(764) | | |-{HwBinder:654_2}(1035) | | |-{HwBinder:654_3}(1109) | | |-{HwBinder:654_4}(2208) | | |-{audio@2.0-serv}(1001) | | `-{writer}(3444) | |-audioserver(685)-+-{ApmAudio}(902) | | |-{ApmOutput}(903) | | |-{AudioOut_15}(1043) | | |-{AudioOut_1D}(1045) | | |-{AudioOut_25}(1051) | | |-{AudioOut_2D}(1053) | | |-{AudioOut_D}(1038) | | |-{Binder:685_1}(920) | | |-{Binder:685_2}(922) | | |-{Binder:685_3}(1321) | | |-{Binder:685_4}(1461) | | |-{Binder:685_5}(1589) | | |-{FastMixer}(1037) | | |-{FastMixer}(1042) | | |-{FastMixer}(1050) | | |-{FastMixer}(1052) | | |-{HwBinder:685_1}(885) | | |-{HwBinder:685_2}(907) | | |-{TimeCheckThrea}(1317) | | `-{soundTrigger c}(1207) | |-bluetooth@1.0-s(655)-+-{POSIX timer 0}(2003) | | |-{POSIX timer 1}(2035) | | |-{POSIX timer 2}(2105) | | |-{POSIX timer 3}(2112) | | |-{POSIX timer 4}(2113) | | |-{POSIX timer 5}(2150) | | `-{bluetooth@1.0-}(2104) | |-boot@1.0-servic(512) | |-cameraserver(804)-+-{Binder:804_1}(1206) | | |-{Binder:804_2}(1453) | | |-{Binder:804_3}(1586) | | |-{Binder:804_4}(2522) | | |-{HwBinder:804_1}(900) | | |-{HwBinder:804_2}(906) | | `-{HwBinder:804_3}(1178) | |-cas@1.1-service(658)---{HwBinder:658_1}(677) | |-drm@1.0-service(660)---{HwBinder:660_1}(678) | |-drm@1.1-service(661)---{HwBinder:661_1}(682) | |-drmserver(805)---{Binder:805_1}(838) | |-fingerprint@2.1(844)---{fingerprint@2.}(985) | |-gatekeeper@1.0-(662) | |-gatekeeperd(837) | |-init(471) | |-init(472) | |-keymaster@3.0-s(513) | |-keystore(812)---{HwBinder:812_1}(845) | |-light@2.0-servi(665) | |-lmkd(689) | |-loc_launcher(857)-+-lowi-server(1210)-+-{lowi-server}(1213) | | | |-{lowi-server}(1214) | | | |-{lowi-server}(1215) | | | |-{lowi-server}(1216) | | | |-{lowi-server}(2062) | | | |-{lowi-server}(2063) | | | |-{lowi-server}(2066) | | | `-{lowi-server}(3620) | | |-slim_daemon(1211)-+-{HwBinder:1211_}(1223) | | | |-{Loc_hal_worker}(1219) | | | |-{Loc_hal_worker}(1221) | | | |-{Loc_hal_worker}(1226) | | | |-{Loc_hal_worker}(1233) | | | `-{NDK}(1218) | | |-xtra-daemon(1212)-+-{LocTimerMsgTas}(1228) | | | |-{LocTimerPollTa}(1227) | | | |-{pcid-loc-api}(1217) | | | |-{pcid-loc-api}(1222) | | | |-{pcid-loc-api}(1225) | | | `-{pcid-loc-api}(1232) | | `-{loc_launcher}(872) | |-logd(482)-+-{logd.auditd}(507) | | |-{logd.control}(493) | | |-{logd.daemon}(487) | | |-{logd.klogd}(506) | | |-{logd.writer}(492) | | `-{logd}(491) | |-main(641)-+-.localtransport(3001)-+-{ADB-JDWP Conne}(3010) | | | |-{Binder:3001_1}(3015) | | | |-{Binder:3001_2}(3016) | | | |-{Binder:3001_3}(3022) | | | |-{FinalizerDaemo}(3013) | | | |-{FinalizerWatch}(3014) | | | |-{HeapTaskDaemon}(3011) | | | |-{Jit thread poo}(3004) | | | |-{Profile Saver}(3032) | | | |-{ReferenceQueue}(3012) | | | |-{Signal Catcher}(3009) | | | `-{queued-work-lo}(3061) | | |-ackageinstaller(3199)-+-{ADB-JDWP Conne}(3217) | | | |-{Binder:3199_1}(3222) | | | |-{Binder:3199_2}(3225) | | | |-{Binder:3199_3}(3227) | | | |-{FinalizerDaemo}(3220) | | | |-{FinalizerWatch}(3221) | | | |-{HeapTaskDaemon}(3218) | | | |-{Jit thread poo}(3210) | | | |-{Profile Saver}(3233) | | | |-{ReferenceQueue}(3219) | | | `-{Signal Catcher}(3215) | | | |-{Binder:2469_1}(2489) | | | |-{Binder:2469_2}(2495) | | | |-{FinalizerDaemo}(2487) | | | |-{FinalizerWatch}(2488) | | | |-{HeapTaskDaemon}(2485) | | | |-{Jit thread poo}(2477) | | | |-{Profile Saver}(2561) | | | |-{ReferenceQueue}(2486) | | | |-{Signal Catcher}(2482) | | | `-{queued-work-lo}(2614) | | |-d.process.media(2546)-+-{ADB-JDWP Conne}(2580) | | | |-{Binder:2546_1}(2589) | | | |-{Binder:2546_2}(2594) | | | |-{Binder:2546_3}(2600) | | | |-{FinalizerDaemo}(2583) | | | |-{FinalizerWatch}(2584) | | | |-{HeapTaskDaemon}(2581) | | | |-{Jit thread poo}(2568) | | | |-{Profile Saver}(2649) | | | |-{ReferenceQueue}(2582) | | | |-{Signal Catcher}(2573) | | | |-{android.bg}(2933) | | | |-{queued-work-lo}(2694) | | | `-{sAsyncHandlerT}(2683) | | |-droid.launcher3(1975)-+-{ADB-JDWP Conne}(2005) | | | |-{Binder:1975_1}(2012) | | | |-{Binder:1975_2}(2029) | | | |-{Binder:1975_3}(2034) | | | |-{Binder:1975_4}(2742) | | | |-{FinalizerDaemo}(2008) | | | |-{FinalizerWatch}(2009) | | | |-{GrallocUploadT}(2732) | | | |-{HeapTaskDaemon}(2006) | | | |-{Jit thread poo}(1995) | | | |-{Profile Saver}(2048) | | | |-{ReferenceQueue}(2007) | | | |-{RenderThread}(2574) | | | |-{Signal Catcher}(2001) | | | |-{TaskThumbnailI}(2521) | | | |-{UiThreadHelper}(2053) | | | |-{android.bg}(2051) | | | |-{hwuiTask0}(3498) | | | |-{hwuiTask1}(3499) | | | |-{launcher-loade}(2655) | | | |-{magnifier pixe}(2688) | | | |-{pool-1-thread-}(3530) | | | |-{pool-2-thread-}(2491) | | | |-{pool-2-thread-}(2672) | | | `-{queued-work-lo}(2508) | | |-droid.messaging(3120)-+-{ADB-JDWP Conne}(3135) | | | |-{AsyncTask #4}(3168) | | | |-{Binder:3120_1}(3140) | | | |-{Binder:3120_2}(3143) | | | |-{Binder:3120_3}(3276) | | | |-{FinalizerDaemo}(3138) | | | |-{FinalizerWatch}(3139) | | | |-{HeapTaskDaemon}(3136) | | | |-{Jit thread poo}(3126) | | | |-{Profile Saver}(3151) | | | |-{ReferenceQueue}(3137) | | | |-{Signal Catcher}(3134) | | | `-{queued-work-lo}(3163) | | | `-{Signal Catcher}(1647) | | |-lcomm.telephony(3386)-+-{ADB-JDWP Conne}(3399) | | | |-{Binder:3386_1}(3405) | | | |-{Binder:3386_2}(3406) | | | |-{Binder:3386_3}(3408) | | | |-{CTSA Inject Th}(3424) | | | |-{FinalizerDaemo}(3402) | | | |-{FinalizerWatch}(3403) | | | |-{HeapTaskDaemon}(3400) | | | |-{HwBinder:3386_}(3425) | | | |-{Jit thread poo}(3393) | | | |-{Profile Saver}(3414) | | | |-{ReferenceQueue}(3401) | | | |-{Signal Catcher}(3398) | | | |-{Thread-2}(3423) | | | `-{queued-work-lo}(3426) | | |-m.android.email(3033)-+-{ADB-JDWP Conne}(3047) | | | |-{AsyncTask #11}(3110) | | | |-{Binder:3033_1}(3053) | | | |-{Binder:3033_2}(3062) | | | |-{Binder:3033_3}(3066) | | | |-{Binder:3033_4}(3879) | | | |-{EmailNotificat}(3156) | | | |-{FinalizerDaemo}(3050) | | | |-{FinalizerWatch}(3051) | | | |-{HeapTaskDaemon}(3048) | | | |-{Jit thread poo}(3039) | | | |-{Profile Saver}(3071) | | | |-{ReferenceQueue}(3049) | | | |-{Signal Catcher}(3044) | | | `-{queued-work-lo}(3084) | | |-ndroid.keychain(3622)-+-{ADB-JDWP Conne}(3634) | | | |-{Binder:3622_1}(3639) | | | |-{Binder:3622_2}(3640) | | | |-{Binder:3622_3}(3645) | | | |-{Binder:3622_4}(3650) | | | |-{FinalizerDaemo}(3637) | | | |-{FinalizerWatch}(3638) | | | |-{HeapTaskDaemon}(3635) | | | |-{Jit thread poo}(3628) | | | |-{ReferenceQueue}(3636) | | | |-{Runtime worker}(3629) | | | |-{Runtime worker}(3630) | | | |-{Runtime worker}(3631) | | | |-{Runtime worker}(3632) | | | |-{Signal Catcher}(3633) | | | `-{queued-work-lo}(3651) | | |-ndroid.settings(3316)-+-{ADB-JDWP Conne}(3329) | | | |-{AsyncTask #2}(3543) | | | |-{Binder:3316_1}(3334) | | | |-{Binder:3316_2}(3335) | | | |-{Binder:3316_3}(3337) | | | |-{Binder:3316_4}(3878) | | | |-{ConnectivityTh}(3532) | | | |-{FinalizerDaemo}(3332) | | | |-{FinalizerWatch}(3333) | | | |-{HeapTaskDaemon}(3330) | | | |-{Jit thread poo}(3323) | | | |-{Profile Saver}(3340) | | | |-{ReferenceQueue}(3331) | | | |-{RenderThread}(3527) | | | |-{SettingsIntell}(3531) | | | |-{Signal Catcher}(3328) | | | |-{pool-3-thread-}(3544) | | | `-{queued-work-lo}(3585) | | |-ndroid.systemui(1429)-+-{ADB-JDWP Conne}(1446) | | | |-{AsyncTask #3}(2078) | | | |-{AudioTrack}(3385) | | | |-{Binder:1429_1}(1452) | | | |-{Binder:1429_2}(1454) | | | |-{Binder:1429_3}(1475) | | | |-{Binder:1429_4}(1479) | | | |-{Binder:1429_5}(2210) | | | |-{Binder:1429_6}(2213) | | | |-{Binder:1429_7}(2225) | | | |-{CCodecWatchdog}(2092) | | | |-{ConnectivityTh}(2070) | | | |-{FinalizerDaemo}(1449) | | | |-{FinalizerWatch}(1451) | | | |-{FlashlightCont}(2181) | | | |-{GrallocUploadT}(3509) | | | |-{HeapTaskDaemon}(1447) | | | |-{HwBinder:1429_}(2094) | | | |-{ImageWallpaper}(1741) | | | |-{Jit thread poo}(1436) | | | |-{Keyboard}(2209) | | | |-{NDK MediaCodec}(2093) | | | |-{Profile Saver}(1485) | | | |-{ReferenceQueue}(1448) | | | |-{RenderThread}(2061) | | | |-{ScreenDecorati}(2212) | | | |-{Signal Catcher}(1443) | | | |-{SoundPoolThrea}(1934) | | | |-{SoundPool}(1933) | | | |-{SysUiBg}(1916) | | | |-{Thread-2}(2349) | | | |-{TimeTick}(2086) | | | |-{VolumeDialogCo}(1959) | | | |-{WifiTracker{2e}(2072) | | | |-{async_sensor}(2067) | | | |-{hwuiTask0}(2347) | | | |-{hwuiTask1}(2348) | | | |-{pool-2-thread-}(1815) | | | |-{pool-3-thread-}(2239) | | | |-{pool-4-thread-}(2249) | | | |-{pool-6-thread-}(2248) | | | |-{queued-work-lo}(2056) | | | `-{recents.fg}(2211) | | |-putmethod.latin(1858)-+-{ADB-JDWP Conne}(1892) | | | |-{AsyncTask #1}(2044) | | | |-{Binder:1858_1}(1899) | | | |-{Binder:1858_2}(1904) | | | |-{Binder:1858_3}(1908) | | | |-{Binder:1858_4}(2050) | | | |-{Binder:1858_5}(3591) | | | |-{ExecutorUtils}(2047) | | | |-{FinalizerDaemo}(1897) | | | |-{FinalizerWatch}(1898) | | | |-{HeapTaskDaemon}(1895) | | | |-{InputLogicHand}(2431) | | | |-{Jit thread poo}(1884) | | | |-{Profile Saver}(1938) | | | |-{ReferenceQueue}(1896) | | | `-{Signal Catcher}(1889) | | |-system_server(926)-+-{ADB-JDWP Conne}(945) | | | |-{AccountManager}(1249) | | | |-{ActivityManage}(974) | | | |-{ActivityManage}(975) | | | |-{ActivityManage}(976) | | | |-{AdbDebuggingMa}(2355) | | | |-{AlarmManager}(1251) | | | |-{AsyncQueryWork}(2852) | | | |-{AsyncTask #2}(2246) | | | |-{AudioDeviceBro}(1320) | | | |-{AudioPortEvent}(1718) | | | |-{AudioService}(1319) | | | |-{AudioTrack}(3523) | | | |-{BatteryStats_w}(1008) | | | |-{Binder:926_1}(952) | | | |-{Binder:926_2}(953) | | | |-{Binder:926_3}(1289) | | | |-{Binder:926_4}(1298) | | | |-{Binder:926_5}(1323) | | | |-{Binder:926_6}(1468) | | | |-{Binder:926_7}(1805) | | | |-{Binder:926_8}(1814) | | | |-{Binder:926_9}(1957) | | | |-{Binder:926_A}(1968) | | | |-{Binder:926_B}(1974) | | | |-{Binder:926_C}(3268) | | | |-{Binder:926_D}(3695) | | | |-{BluetoothRoute}(1702) | | | |-{CCodecWatchdog}(2114) | | | |-{CallAudioModeS}(1744) | | | |-{CameraService_}(1355) | | | |-{ClientModeImpl}(1274) | | | |-{ConnectionSvrF}(1745) | | | |-{ConnectivitySe}(1299) | | | |-{ConnectivityTh}(1341) | | | |-{CpuTracker}(1004) | | | |-{DeviceStorageM}(1313) | | | |-{EmergencyAffor}(1487) | | | |-{EthernetServic}(1373) | | | |-{FileObserver}(1003) | | | |-{FinalizerDaemo}(948) | | | |-{FinalizerWatch}(949) | | | |-{GraphicsStats-}(1347) | | | |-{HealthServiceR}(1245) | | | |-{HeapTaskDaemon}(946) | | | |-{HwBinder:926_1}(1007) | | | |-{HwBinder:926_2}(1255) | | | |-{HwBinder:926_3}(1256) | | | |-{HwBinder:926_4}(1257) | | | |-{HwBinder:926_5}(1259) | | | |-{InputDispatche}(1260) | | | |-{InputReader}(1261) | | | |-{Jit thread poo}(938) | | | |-{LazyTaskWriter}(2429) | | | |-{NDK MediaCodec}(2121) | | | |-{NetworkPolicy}(1270) | | | |-{NetworkStatsOb}(1480) | | | |-{NetworkStats}(1269) | | | |-{NetworkTimeUpd}(1520) | | | |-{NetworkWatchli}(1262) | | | |-{NsdService}(1305) | | | |-{OomAdjuster}(977) | | | |-{OsuServerHandl}(1388) | | | |-{PackageInstall}(1201) | | | |-{PackageManager}(1012) | | | |-{PackageManager}(1013) | | | |-{PhotonicModula}(1378) | | | |-{PowerManagerSe}(1006) | | | |-{RedirectListen}(1368) | | | |-{ReferenceQueue}(947) | | | |-{RenderThread}(3694) | | | |-{RollbackManage}(1246) | | | |-{RollbackPackag}(1247) | | | |-{Runtime worker}(939) | | | |-{Runtime worker}(940) | | | |-{Runtime worker}(941) | | | |-{Runtime worker}(942) | | | |-{SensorEventAck}(1208) | | | |-{SensorService}(1209) | | | |-{SettingsProvid}(1250) | | | |-{Signal Catcher}(943) | | | |-{SliceManagerSe}(1354) | | | |-{SoundPoolThrea}(1464) | | | |-{SoundPool}(1463) | | | |-{StatsCompanion}(1356) | | | |-{StorageManager}(1267) | | | |-{SyncHandler-0}(1366) | | | |-{SyncManager}(1396) | | | |-{TaskSnapshotPe}(1377) | | | |-{Thread-4}(1459) | | | |-{UEventObserver}(1254) | | | |-{UsbService hos}(1425) | | | |-{WifiP2pService}(1275) | | | |-{WifiScanningSe}(1295) | | | |-{WifiService}(1273) | | | |-{android.anim.l}(969) | | | |-{android.anim}(968) | | | |-{android.bg}(973) | | | |-{android.displa}(967) | | | |-{android.fg}(964) | | | |-{android.io}(966) | | | |-{android.ui}(965) | | | |-{backup-0}(2434) | | | |-{backup}(1343) | | | |-{batterystats-w}(980) | | | |-{hidl_ssvc_poll}(1258) | | | |-{mDnsConnector}(1307) | | | |-{notification-s}(1308) | | | |-{onProviders.EC}(1311) | | | |-{pool-3-thread-}(1346) | | | |-{queued-work-lo}(1977) | | | |-{ranker}(1309) | | | |-{roid.pacmanage}(1301) | | | |-{tworkPolicy.ui}(1271) | | | |-{uteStateMachin}(1734) | | | |-{watchdog}(970) | | | `-{wifiRttService}(1370) | | |-{FinalizerDaemo}(3625) | | |-{FinalizerWatch}(3626) | | |-{HeapTaskDaemon}(3623) | | |-{Jit thread poo}(3627) | | `-{ReferenceQueue}(3624) | |-main(642)-+-webview_zygote(1819)-+-{FinalizerDaemo}(1836) | | | |-{FinalizerWatch}(1837) | | | |-{HeapTaskDaemon}(1834) | | | |-{Jit thread poo}(1838) | | | `-{ReferenceQueue}(1835) | | |-{FinalizerDaemo}(1822) | | |-{FinalizerWatch}(1823) | | |-{HeapTaskDaemon}(1820) | | |-{Jit thread poo}(1824) | | `-{ReferenceQueue}(1821) | |-mediadrmserver(813)---{Binder:813_1}(830) | |-mediaextractor(815)-+-{Binder:815_1}(915) | | |-{Binder:815_2}(2139) | | `-{Binder:815_3}(2145) | |-mediametrics(819)---{Binder:819_1}(878) | |-mediaserver(820)-+-{Binder:820_1}(933) | | |-{Binder:820_2}(1949) | | |-{Binder:820_3}(1950) | | |-{Binder:820_4}(2763) | | `-{HwBinder:820_1}(1489) | |-mediaswcodec(836)-+-{HwBinder:836_1}(917) | | |-{HwBinder:836_1}(2017) | | |-{HwBinder:836_2}(2079) | | |-{HwBinder:836_3}(2081) | | |-{HwBinder:836_4}(2082) | | |-{HwBinder:836_5}(2084) | | |-{HwBinder:836_6}(2088) | | |-{HwBinder:836_7}(2101) | | `-{HwBinder:836_7}(2115) | |-surfaceflinger(515)-+-{Binder:515_1}(540) | | |-{Binder:515_2}(541) | | |-{Binder:515_3}(657) | | |-{Binder:515_4}(1009) | | |-{Binder:515_5}(3576) | | |-{DispSync}(542) | | |-{HwBinder:515_1}(578) | | |-{app}(544) | | |-{sf}(545) | | |-{surfaceflinger}(543) | | |-{surfaceflinger}(546) | | `-{surfaceflinger}(547) | |-tombstoned(840) | |-traced(791)---{traced}(808) | |-traced_probes(793)---{traced_probes}(809) | |-ueventd(473) | |-update_engine(841) | |-usb@1.1-service(673)---{usb@1.1-servic}(1338) | |-vibrator@1.0-se(674) | |-vndservicemanag(485) | |-vr@1.0-service(675) | |-wifi@1.0-servic(676)-+-{wifi@1.0-servi}(2065) | | `-{wifi@1.0-servi}(2069) | |-wificond(824) | `-wpa_supplicant(1590) `-kthreadd(2)-+-9-0022(291) |-ufs_clk_ungatin(273) |-ufs_pm_qos_0(272) |-usb_bam_wq(375) |-usbnet(280) |-vsync_retire_wo(162) |-watchdog/0(13) |-watchdog/1(14) |-watchdog/2(20) |-watchdog/3(26) |-wcnss_smd_trans(39) |-wlan_logging_th(1839) `-writeback(73) 5. 源码地图：即分层，细化 5.1. framework基础框架，0层 见 AndriodSystem_Others 5.2. 其中，WMS 1层 见 AndriodSystem_Others 6. 系统启动流程（纵向主线） 见《InitSystem.md》 7. APP启动流程（纵向主线） 见《startAPP.md》 8. window 8.1. 0层 注意：这里并没有statusBar的window （G:\\working_pan\\doc_my\\Draw\\Activity_window_dialog.eddx） 1、每个window结构都如此，dialog亦如此 2、activity的本质是 context 3、dialog本质是 window。。。new的时候需要传入context，即activity，必须依赖activity 1、Z的dialog包了A的window ，A的window里又塞了A的surfaceview（Z画图的地方） ------》2、给window里再塞一块view，置于surfaceview之上。Z dialog有两块surface了 -------》todo： 第二块surface和canvas啥关系？ 如果说为啥surface换了，canvas没换？地址 todo：status bar 属于哪个widow，哪个进程 SurfaceView有自己的窗口 。所以，如果一个Activity有一个SurfaceView，它将有多个窗口。 关于dialog： TODO： dialog里面的window也是phoneWindow ！！！！自己new出来的 final Window w = new PhoneWindow(mContext); PhoneWindow持有WindowManagerImpl（即是WindowManager） 8.2. setAttributes流程： dialog -》被塞到了Window(PhoneWindow)里，mWindowAttributes记录，-》PhoneWindow.dispatchWindowAttributesChanged() 注意：linearLayout，没有包statusBar ----> (1) linearLayout包含的是statusBar和navigationBar的背景, 因为 statusBar本身透明，需要下一层的window显示颜色？？？（TODO: 为什么要这样设计？？） （2）statusBar和navigationBar在另一个window上（TODO: 一个还是两个？？？） ----》对于dialog类型的呢？？？ Dialog： （https://ericchows.github.io/Android-Window-Mechanism/） 带你彻底理解 Window 和 WindowManager Surface是一个对象，用于保存与屏幕合成的像素。 每个窗口（对话框，全屏活动，状态栏）都有自己的绘图表面surface。（todo：如果没有view，surface还能显示嘛？Z dialog证明不能？） Window Manager creates a Surface for each window and gives it to the application for drawing. Todo：验证。 应用指的具体是啥，哪个类 wm哪个进程？ Surface Flinger会以正确的Z顺序将这些窗口渲染到最终显示 关于view： 1、A View is an interactive UI element inside of a window. 交互用的 2、A window has a single view hierarchy attached to it, which provides all of the behavior of the window. 独一的view体系 下面有四个window，对应四个surface ----》有几个canvas？？？？ TODO: surface、canvas 画图往这个上画————》最终怎么呈现的？ 谁创建的surface？（window粒度的）最终用作什么了？ 8.3. vSync - surface -window-view 0层： 见 AndriodSystem_Others 8.4. 参考的博客资料： https://ericchows.github.io/Android-Window-Mechanism/ --->优 9. 无障碍 见 《无障碍.md》 10. 应用程序消息处理机制分析 ---》（Looper、Handler）分析 总结：Android应用程序是通过消息来驱动的 系统为每一个应用程序维护一个消息队列，应用程序的主线程不断地从这个消息队例中获取消息（Looper），然后对这些消息进行处理（Handler），这样就实现了通过消息来驱动应用程序的执行--------》总结：消息驱动程序！！！！ 当ActivityManagerService需要与应用程序进行交互时，如加载Activity和Service、处理广播等，会通过Binder进程间通信机制来知（TODO:）会应用程序，应用程序接收到这个请求时，它不是马上就处理这个请求，而是将这个请求封装成一个消息，然后把这个消息放在应用程序的消息队列中去，然后再通过消息循环来处理这个消息。 ------->总结：1、AMS通过Binder请求应用程序 2、应用程序（TODO:具体哪个）自己发消息，然后自己处理 为什么要有这样的机制？？？好处: 消息的发送方只要把消息发送到应用程序的消息队列中去就行了，它可以马上返回去处理别的事情，而不需要等待消息的接收方去处理完这个消息才返回，这样就可以提高系统的并发性。实质上，这就是一种异步处理机制。（TODO:一个线程还是两个？要是一个，怎么异步的） 例子： 程序启动过程中（（TODO:）），要启动的应用程序称为Activity，它的默认Activity是MainActivity: Launcher来负责启动的，而Launcher又是通过ActivityManagerService来启动的，当ActivityManagerService为这个即将要启的应用程序准备好新的进程后，便通过一个Binder进程间通信过程来通知这个新的进程来加载MainActivity，如下图所示： 11. 稳定性专题 11.1. ANR 《什么是ANR_如何避免ANR.md》 《ANR问题的产生机制.pdf》 12. 内存泄漏专题 参考： https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650238704&idx=1&sn=ad334840afdc2d9bdb8215e9f942e54e&chksm=88639f9fbf1416898edfc3615a7ea25f6798e3bb6f3089ca720e18b92ce67328c623561cf35e&scene=27 好文 内存泄漏全解析 郭霖;) 2017-02-28 08:00 原因： 1、对于cpp：内存泄漏就是new出来的对象没有 delete -------》 例子：阎王 让你出生，忘记 让你死了 2、对于 java ：就是 new 出来的 Object 放在 Heap 上无法被GC回收 无法GC的原因：长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用 ----》 例子：父子之间 同生共死 ，明显不合理 补充：目前java 常见GC，是可达性分析（还有计数引用） ​ 注意： 对于java，一般关心比较消耗内存的类，比如Activity; 不占内存的类，发生泄漏，其实没太大关系 疑问： cpp会产生类似于java那种嘛？A：不会，cpp对象的销毁由程序员自己去delete。 如果存在 父子之间 同生共死，那么就是 程序员自己delete 时机出了问题。 例子：见Handler导致的内存泄漏 规定： 在 Android 开发中，为了防止内存溢出，在处理一些占用内存大并且生命周期较长的对象的时候，可以尽量地使用 软引用 和 弱引用 技术。 13. 内存抖动专题 见设计模式---复用原则 14. 安卓资源： 14.1. 见config需求分析 14.2. 资源目录结构 14.2.1. symbols.xml 系统私有资源 （不对app公开) 14.2.2. public.xml公共资源 （可以在app中访问） 注意：公共资源在xml里给定了id值。但。。没有 public.xml的作用：1、显示对外了 2、给配了唯一的id ---》TODO:public为什么要配固定ID？？？ https://blog.csdn.net/joby1981/article/details/16809869 AOSP添加资源的方法： 如果要添加的资源是私有的，则加上 （不需要id），如果是公共的则先找到最后一个type为 drawable 的 public 项，4.2.2系统中最后一项为，然后添加一句 ，即id为最后一个的id+1（为了避免 id 冲突） 原文链接：https://blog.csdn.net/ganzhijie/article/details/38489957 14.2.3. attrs.xml -->基于类， 定义了其属性 1、定义了类的有哪些xml配置属性：--->导致IDE编辑时xml联想 比如：view类，有属性id、padding.......... Theme类 再比如：include类以及ViewGroup类： 2、TODO：attrs.xml 与public.xml什么关系？？？ 14.2.4. 以attr为例子： java中引用：android.R.attr.absListViewStyle 结论：attrs.xml ： ​ （2） 注意：format即类型，比如reference、boolean、dimension、integer、color。。。。。。。 format=\"reference\"是指这个类型是引用类型：引用某一资源id！！！ 1. //reference：参考另一资源ID。 （1）属性定义： （2）属性使用： //这里引用资源Id!!!!!! 3. boolean：布尔值。 （1）属性定义： （2）属性使用： ​ （2） 《-------到底对应什么资源？？？ todo: 14.2.5. style -style是可以继承的，并且子类可以修改父类的属性值 4行是继承 12行是修改 ----》这一点非常好：结论：资源本身对开发者也是public的！！！！ -----》所以，我理解，开发者是能够改变系统默认获焦效果（灰色）的！！！！！！！！！！ 自定义主题： G:\\working_pan\\Demo\\BarrierFree_demo\\app\\src\\main\\res\\values\\styles.xml // 这里自定义 @color/colorPrimary @color/colorPrimaryDark @color/colorAccent // 注意:这里必须用android: 才能覆盖--->跳转的地方不一样 @drawable/my_item_background false true 15. ViewOverlay ViewOverlay中的view或者drawable不会响应任何触摸事件 ----》本质：ViewOverlay是另一个抽象层（只显示，不响应） ---》用途：动画 16. 安卓面试题目 16.1. Activity生命周期？ onCreate() -> onStart() -> onResume() -> onPause() -> onStop() -> onDetroy() 16.2. Activity的启动过程 注意：（不要回答生命周期） app启动的过程有两种情况，第一种是从桌面launcher上点击相应的应用图标，第二种是在activity中通过调用startActivity来启动一个新的activity。 我们创建一个新的项目，默认的根activity都是MainActivity，而所有的activity都是保存在堆栈中的，我们启动一个新的activity就会放在上一个activity上面，而我们从桌面点击应用图标的时候，由于launcher本身也是一个应用，当我们点击图标的时候，系统就会调用startActivitySately(),一般情况下，我们所启动的activity的相关信息都会保存在intent中，比如action，category等等。我们在安装这个应用的时候，系统也会启动一个PackaManagerService的管理服务，这个管理服务会对AndroidManifest.xml文件进行解析，从而得到应用程序中的相关信息，比如service，activity，Broadcast等等，然后获得相关组件的信息。当我们点击应用图标的时候，就会调用startActivitySately()方法，而这个方法内部则是调用startActivty(),而startActivity()方法最终还是会调用startActivityForResult()这个方法。而在startActivityForResult()这个方法。因为startActivityForResult()方法是有返回结果的，所以系统就直接给一个-1，就表示不需要结果返回了。而startActivityForResult()这个方法实际是通过Instrumentation类中的execStartActivity()方法来启动activity，Instrumentation这个类主要作用就是监控程序和系统之间的交互。而在这个execStartActivity()方法中会获取ActivityManagerService的代理对象，通过这个代理对象进行启动activity。启动会就会调用一个checkStartActivityResult()方法，如果说没有在配置清单中配置有这个组件，就会在这个方法中抛出异常了。当然最后是调用的是Application.scheduleLaunchActivity()进行启动activity，而这个方法中通过获取得到一个ActivityClientRecord对象，而这个ActivityClientRecord通过handler来进行消息的发送，系统内部会将每一个activity组件使用ActivityClientRecord对象来进行描述，而ActivityClientRecord对象中保存有一个LoaderApk对象，通过这个对象调用handleLaunchActivity来启动activity组件，而页面的生命周期方法也就是在这个方法中进行调用。 16.3. Broadcast注册方式与区别 此处延伸：什么情况下用动态注册 Broadcast广播，注册方式主要有两种. 第一种是静态注册，也可成为常驻型广播，这种广播需要在Androidmanifest.xml中进行注册，这中方式注册的广播，不受页面生命周期的影响，即使退出了页面，也可以收到广播这种广播一般用于想开机自启动啊等等，由于这种注册的方式的广播是常驻型广播，所以会占用CPU的资源。 第二种是动态注册，而动态注册的话，是在代码中注册的，这种注册方式也叫非常驻型广播，收到生命周期的影响，退出页面后，就不会收到广播，我们通常运用在更新UI方面。这种注册方式优先级较高。最后需要解绑，否会会内存泄露 广播是分为有序广播和无序广播。 16.3.1. HttpClient、HttpUrlConnection 两者区别： 此处延伸：Volley里用的哪种请求方式（2.3前HttpClient，2.3后HttpUrlConnection） 首先HttpClient和HttpUrlConnection 这两种方式都支持Https协议，都是以流的形式进行上传或者下载数据，也可以说是以流的形式进行数据的传输，还有ipv6,以及连接池等功能。HttpClient这个拥有非常多的API，所以如果想要进行扩展的话，并且不破坏它的兼容性的话，很难进行扩展，也就是这个原因，Google在Android6.0的时候，直接就弃用了这个HttpClient. 而HttpUrlConnection相对来说就是比较轻量级了，API比较少，容易扩展，并且能够满足Android大部分的数据传输。比较经典的一个框架volley，在2.3版本以前都是使用HttpClient,在2.3以后就使用了HttpUrlConnection。 16.3.2. java虚拟机和Dalvik虚拟机的区别 Java虚拟机： 1、java虚拟机基于栈。 基于栈的机器必须使用指令来载入和操作栈上数据，所需指令更多更多。 2、java虚拟机运行的是java字节码。（java类会被编译成一个或多个字节码.class文件） Dalvik虚拟机： 1、dalvik虚拟机是基于寄存器的 2、Dalvik运行的是自定义的.dex字节码格式。（java类被编译成.class文件后，会通过一个dx工具将所有的.class文件转换成一个.dex文件，然后dalvik虚拟机会从其中读取指令和数据 3、常量池已被修改为只使用32位的索引，以 简化解释器。 4、一个应用，一个虚拟机实例，一个进程（所有android应用的线程都是对应一个linux线程，都运行在自己的沙盒中，不同的应用在不同的进程中运行。每个android dalvik应用程序都被赋予了一个独立的linux PID(app_*)） 16.3.3. 进程保活（不死进程） 此处延伸：进程的优先级是什么 当前业界的Android进程保活手段主要分为 黑、白、灰 三种，其大致的实现思路如下： 黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒） 白色保活：启动前台Service 灰色保活：利用系统的漏洞启动前台Service 黑色保活 所谓黑色保活，就是利用不同的app进程使用广播来进行相互唤醒。举个3个比较常见的场景： 场景1：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app 场景2：接入第三方SDK也会唤醒相应的app进程，如微信sdk会唤醒微信，支付宝sdk会唤醒支付宝。由此发散开去，就会直接触发了下面的 场景3 场景3：假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。（只是拿阿里打个比方，其实BAT系都差不多） 白色保活 白色保活手段非常简单，就是调用系统api启动一个前台的Service进程，这样会在系统的通知栏生成一个Notification，用来让用户知道有这样一个app在运行着，哪怕当前的app退到了后台。如下方的LBE和QQ音乐这样： 灰色保活 灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的Service进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个Notification，看起来就如同运行着一个后台Service进程一样。这样做带来的好处就是，用户无法察觉到你运行着一个前台进程（因为看不到Notification）,但你的进程优先级又是高于普通后台进程的。那么如何利用系统的漏洞呢，大致的实现思路和代码如下： 思路一：API 思路二：API >= 18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理 熟悉Android系统的童鞋都知道，系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app。这套杀进程回收内存的机制就叫 Low Memory Killer ，它是基于Linux内核的 OOM Killer（Out-Of-Memory killer）机制诞生。 进程的重要性，划分5级： 前台进程 (Foreground process) 可见进程 (Visible process) 服务进程 (Service process) 后台进程 (Background process) 空进程 (Empty process) 了解完 Low Memory Killer，再科普一下oom_adj。什么是oom_adj？它是linux内核分配给每个系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收。对于oom_adj的作用，你只需要记住以下几点即可： 进程的oom_adj越大，表示此进程优先级越低，越容易被杀回收；越小，表示进程优先级越高，越不容易被杀回收 普通app进程的oom_adj>=0,系统进程的oom_adj才可能 有些手机厂商把这些知名的app放入了自己的白名单中，保证了进程不死来提高用户体验（如微信、QQ、陌陌都在小米的白名单中）。如果从白名单中移除，他们终究还是和普通app一样躲避不了被杀的命运，为了尽量避免被杀，还是老老实实去做好优化工作吧。 所以，进程保活的根本方案终究还是回到了性能优化上，进程永生不死终究是个彻头彻尾的伪命题！ 16.3.4. 讲解一下Context Context是一个抽象基类。在翻译为上下文，也可以理解为环境，是提供一些程序的运行环境基础信息。Context下有两个子类，ContextWrapper是上下文功能的封装类，而ContextImpl则是上下文功能的实现类。而ContextWrapper又有三个直接的子类， ContextThemeWrapper、Service和Application。其中，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity，所以Activity和Service以及Application的Context是不一样的，只有Activity需要主题，Service不需要主题。Context一共有三种类型，分别是Application、Activity和Service。这三个类虽然分别各种承担着不同的作用，但它们都属于Context的一种，而它们具体Context的功能则是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。 getApplicationContext()和getApplication()方法得到的对象都是同一个application对象，只是对象的类型不一样。 Context数量 = Activity数量 + Service数量 + 1 （1为Application） 16.3.5. 理解Activity,View,Window三者关系 这个问题真的很不好回答。所以这里先来个算是比较恰当的比喻来形容下它们的关系吧。Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）LayoutInflater像剪刀，Xml配置像窗花图纸。 1：Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。 2：这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。 3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等 4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。 16.3.6. 四种LaunchMode及其使用场景 此处延伸：栈(First In Last Out)与队列(First In First Out)的区别 栈与队列的区别： 队列先进先出，栈先进后出 \\2. 对插入和删除操作的\"限定\"。 栈是限定只能在表的一端进行插入和删除操作的线性表。 队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。 \\3. 遍历数据速度不同 standard 模式 这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。 singleTop 模式 如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。 singleTask 模式 如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance 模式 在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。 View的绘制流程 自定义控件： 1、组合控件。这种自定义控件不需要我们自己绘制，而是使用原生控件组合成的新控件。如标题栏。 2、继承原有的控件。这种自定义控件在原生控件提供的方法外，可以自己添加一些方法。如制作圆角，圆形图片。 3、完全自定义控件：这个View上所展现的内容全部都是我们自己绘制出来的。比如说制作水波纹进度条。 View的绘制流程：OnMeasure()——>OnLayout()——>OnDraw() 第一步：OnMeasure()：测量视图大小。从顶层父View到子View递归调用measure方法，measure方法又回调OnMeasure。 第二步：OnLayout()：确定View位置，进行页面布局。从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。 第三步：OnDraw()：绘制视图。ViewRoot创建一个Canvas对象，然后调用OnDraw()。六个步骤：①、绘制视图的背景；②、保存画布的图层（Layer）；③、绘制View的内容；④、绘制View子视图，如果没有就不用； ⑤、还原图层（Layer）；⑥、绘制滚动条。 View，ViewGroup事件分发 \\1. Touch事件分发中只有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、onTouchEvent两个相关事件。其中ViewGroup又继承于View。 2.ViewGroup和View组成了一个树状结构，根节点为Activity内部包含的一个ViwGroup。 3.触摸事件由Action_Down、Action_Move、Aciton_UP组成，其中一次完整的触摸事件中，Down和Up都只有一个，Move有若干个，可以为0个。 4.当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。 5.当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。 6.当ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况下，触发Acitivity的onTouchEvent方法。 7.onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。 保存Activity状态 onSaveInstanceState(Bundle)会在activity转入后台状态之前被调用，也就是onStop()方法之前，onPause方法之后被调用； Android中的几种动画 帧动画：指通过指定每一帧的图片和播放时间，有序的进行播放而形成动画效果，比如想听的律动条。 补间动画：指通过指定View的初始状态、变化时间、方式，通过一系列的算法去进行图形变换，从而形成动画效果，主要有Alpha、Scale、Translate、Rotate四种效果。注意：只是在视图层实现了动画效果，并没有真正改变View的属性，比如滑动列表，改变标题栏的透明度。 属性动画：在Android3.0的时候才支持，通过不断的改变View的属性，不断的重绘而形成动画效果。相比于视图动画，View的属性是真正改变了。比如view的旋转，放大，缩小。 Android中跨进程通讯的几种方式 Android 跨进程通信，像intent，contentProvider,广播，service都可以跨进程通信。 intent：这种跨进程方式并不是访问内存的形式，它需要传递一个uri,比如说打电话。 contentProvider：这种形式，是使用数据共享的形式进行数据共享。 service：远程服务，aidl 广播 AIDL理解 此处延伸：简述Binder AIDL: 每一个进程都有自己的Dalvik VM实例，都有自己的一块独立的内存，都在自己的内存上存储自己的数据，执行着自己的操作，都在自己的那片狭小的空间里过完自己的一生。而aidl就类似与两个进程之间的桥梁，使得两个进程之间可以进行数据的传输，跨进程通信有多种选择，比如 BroadcastReceiver , Messenger 等，但是 BroadcastReceiver 占用的系统资源比较多，如果是频繁的跨进程通信的话显然是不可取的；Messenger 进行跨进程通信时请求队列是同步进行的，无法并发执行。 Binde机制简单理解: 在Android系统的Binder机制中，是有Client,Service,ServiceManager,Binder驱动程序组成的，其中Client，service，Service Manager运行在用户空间，Binder驱动程序是运行在内核空间的。而Binder就是把这4种组件粘合在一块的粘合剂，其中核心的组件就是Binder驱动程序，Service Manager提供辅助管理的功能，而Client和Service正是在Binder驱动程序和Service Manager提供的基础设施上实现C/S 之间的通信。其中Binder驱动程序提供设备文件/dev/binder与用户控件进行交互， Client、Service，Service Manager通过open和ioctl文件操作相应的方法与Binder驱动程序进行通信。而Client和Service之间的进程间通信是通过Binder驱动程序间接实现的。而Binder Manager是一个守护进程，用来管理Service，并向Client提供查询Service接口的能力。 Handler的原理 Android中主线程是不能进行耗时操作的，子线程是不能进行更新UI的。所以就有了handler，它的作用就是实现线程之间的通信。 handler整个流程中，主要有四个对象，handler，Message,MessageQueue,Looper。当应用创建的时候，就会在主线程中创建handler对象， 我们通过要传送的消息保存到Message中，handler通过调用sendMessage方法将Message发送到MessageQueue中，Looper对象就会不断的调用loop()方法 不断的从MessageQueue中取出Message交给handler进行处理。从而实现线程之间的通信。 Binder机制原理 在Android系统的Binder机制中，是有Client,Service,ServiceManager,Binder驱动程序组成的，其中Client，service，Service Manager运行在用户空间，Binder驱动程序是运行在内核空间的。而Binder就是把这4种组件粘合在一块的粘合剂，其中核心的组件就是Binder驱动程序，Service Manager提供辅助管理的功能，而Client和Service正是在Binder驱动程序和Service Manager提供的基础设施上实现C/S 之间的通信。其中Binder驱动程序提供设备文件/dev/binder与用户控件进行交互，Client、Service，Service Manager通过open和ioctl文件操作相应的方法与Binder驱动程序进行通信。而Client和Service之间的进程间通信是通过Binder驱动程序间接实现的。而Binder Manager是一个守护进程，用来管理Service，并向Client提供查询Service接口的能力。 热修复的原理 我们知道Java虚拟机 —— JVM 是加载类的class文件的，而Android虚拟机——Dalvik/ART VM 是加载类的dex文件， 而他们加载类的时候都需要ClassLoader,ClassLoader有一个子类BaseDexClassLoader，而BaseDexClassLoader下有一个 数组——DexPathList，是用来存放dex文件，当BaseDexClassLoader通过调用findClass方法时，实际上就是遍历数组， 找到相应的dex文件，找到，则直接将它return。而热修复的解决方法就是将新的dex添加到该集合中，并且是在旧的dex的前面， 所以就会优先被取出来并且return返回。 Android内存泄露及管理 （1）内存溢出（OOM）和内存泄露（对象无法被回收）的区别。 （2）引起内存泄露的原因 (3) 内存泄露检测工具 ------>LeakCanary 内存溢出 out of memory：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。内存溢出通俗的讲就是内存不够用。 内存泄露 memory leak：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光 内存泄露原因： 一、Handler 引起的内存泄漏。 解决：将Handler声明为静态内部类，就不会持有外部类SecondActivity的引用，其生命周期就和外部类无关， 如果Handler里面需要context的话，可以通过弱引用方式引用外部类 二、单例模式引起的内存泄漏。 解决：Context是ApplicationContext，由于ApplicationContext的生命周期是和app一致的，不会导致内存泄漏 三、非静态内部类创建静态实例引起的内存泄漏。 解决：把内部类修改为静态的就可以避免内存泄漏了 四、非静态匿名内部类引起的内存泄漏。 解决：将匿名内部类设置为静态的。 五、注册/反注册未成对使用引起的内存泄漏。 注册广播接受器、EventBus等，记得解绑。 六、资源对象没有关闭引起的内存泄漏。 在这些资源不使用的时候，记得调用相应的类似close（）、destroy（）、recycler（）、release（）等方法释放。 七、集合对象没有及时清理引起的内存泄漏。 通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用。 Fragment、Activity通信的方式 1.直接在一个Fragment中调用另外一个Fragment中的方法 2.使用接口回调 3.使用广播 4.Fragment直接调用Activity中的public方法 Android UI适配 字体使用sp,使用dp，多使用match_parent，wrap_content，weight 图片资源，不同图片的的分辨率，放在相应的文件夹下可使用百分比代替。 app优化 app优化:(工具：Hierarchy Viewer 分析布局 工具：TraceView 测试分析耗时的) App启动优化 布局优化 响应优化 内存优化 电池使用优化 网络优化 App启动优化(针对冷启动) App启动的方式有三种： 冷启动：App没有启动过或App进程被killed, 系统中不存在该App进程, 此时启动App即为冷启动。 热启动：热启动意味着你的App进程只是处于后台, 系统只是将其从后台带到前台, 展示给用户。 介于冷启动和热启动之间, 一般来说在以下两种情况下发生: (1)用户back退出了App, 然后又启动. App进程可能还在运行, 但是activity需要重建。 (2)用户退出App后, 系统可能由于内存原因将App杀死, 进程和activity都需要重启, 但是可以在onCreate中将被动杀死锁保存的状态(saved instance state)恢复。 优化： Application的onCreate（特别是第三方SDK初始化），首屏Activity的渲染都不要进行耗时操作，如果有，就可以放到子线程或者IntentService中 布局优化 尽量不要过于复杂的嵌套。可以使用，， 响应优化 Android系统每隔16ms会发出VSYNC信号重绘我们的界面(Activity)。 页面卡顿的原因： (1)过于复杂的布局. (2)UI线程的复杂运算 (3)频繁的GC,导致频繁GC有两个原因:1、内存抖动, 即大量的对象被创建又在短时间内马上被释放.2、瞬间产生大量的对象会严重占用内存区域。 内存优化：参考内存泄露和内存溢出部分 电池使用优化(使用工具：Batterystats & bugreport) (1)优化网络请求 (2)定位中使用GPS, 请记得及时关闭 网络优化(网络连接对用户的影响:流量,电量,用户等待)可在Android studio下方logcat旁边那个工具Network Monitor检测 API设计：App与Server之间的API设计要考虑网络请求的频次, 资源的状态等. 以便App可以以较少的请求来完成业务需求和界面的展示. Gzip压缩：使用Gzip来压缩request和response, 减少传输数据量, 从而减少流量消耗. 图片的Size：可以在获取图片时告知服务器需要的图片的宽高, 以便服务器给出合适的图片, 避免浪费. 网络缓存：适当的缓存, 既可以让我们的应用看起来更快, 也能避免一些不必要的流量消耗. 图片优化 (1)对图片本身进行操作。尽量不要使用setImageBitmap、setImageResource、BitmapFactory.decodeResource来设置一张大图，因为这些方法在完成decode后， 最终都是通过java层的createBitmap来完成的，需要消耗更多内存. (2)图片进行缩放的比例，SDK中建议其值是2的指数值,值越大会导致图片不清晰。 (3)不用的图片记得调用图片的recycle()方法 HybridApp WebView和JS交互 Android与JS通过WebView互相调用方法，实际上是： Android去调用JS的代码 通过WebView的loadUrl(),使用该方法比较简洁，方便。但是效率比较低，获取返回值比较困难。 通过WebView的evaluateJavascript(),该方法效率高，但是4.4以上的版本才支持，4.4以下版本不支持。所以建议两者混合使用。 JS去调用Android的代码 通过WebView的addJavascriptInterface（）进行对象映射 ，该方法使用简单，仅将Android对象和JS对象映射即可，但是存在比较大的漏洞。 漏洞产生原因是：当JS拿到Android这个对象后，就可以调用这个Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而进行任意代码执行。 解决方式： (1)Google 在Android 4.2 版本中规定对被调用的函数以 @JavascriptInterface进行注解从而避免漏洞攻击。 (2)在Android 4.2版本之前采用拦截prompt（）进行漏洞修复。 通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url 。这种方式的优点：不存在方式1的漏洞；缺点：JS获取Android方法的返回值复杂。(ios主要用的是这个方式) (1)Android通过 WebViewClient 的回调方法shouldOverrideUrlLoading ()拦截 url (2)解析该 url 的协议 (3)如果检测到是预先约定好的协议，就调用相应方法 通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息 这种方式的优点：不存在方式1的漏洞；缺点：JS获取Android方法的返回值复杂。 JAVA GC原理 垃圾收集算法的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象 ，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。垃圾收集算法的选择和垃圾收集系统参数的合理调节直接影响着系统性能。 27、ANR ANR全名Application Not Responding, 也就是\"应用无响应\". 当操作在一段时间内系统无法处理时, 系统层面会弹出上图那样的ANR对话框. 产生原因： (1)5s内无法响应用户输入事件(例如键盘输入, 触摸屏幕等). (2)BroadcastReceiver在10s内无法结束 (3)Service 20s内无法结束（低概率） 解决方式： (1)不要在主线程中做耗时的操作，而应放在子线程中来实现。如onCreate()和onResume()里尽可能少的去做创建操作。 (2)应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。 (3)避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。 (4)service是运行在主线程的，所以在service中做耗时操作，必须要放在子线程中。 17. 安卓基础知识 17.1. aidl 17.1.1. aidl的理解 见AndriodSystem_Others 17.1.2. Android中Parcelable接口： 记忆，实现了某个接口，即拥有某种能力！！！！！！----》实现了Parcelable接口，就有了打包的能力 何时使用？使用例子 是一种序列化（反）手段：其本质：将对象转换为二进制流 -----》为什么要转？： 为了传输，网络传输或者保存到本地 》TODO：不转不能完成这些？？？？怎么证明？？？ 应用场景：进程间通信IPC、网络传输、保存到本地、Activity之间？？。。。。。。TODO：补充并验证 //Book类的序列化 public class Book implements Parcelable { private String name; private int id; private String classify; protected Book(Parcel in) { name = in.readString(); classify = in.readString(); id = in.readInt(); } public Book(String classify, String name, int id) { this.name = name; this.id = id; this.classify = classify; } /** * （2）CREATOR负责反序列化过程：从Parcel中新建对象 */ public static final Creator CREATOR = new Creator() { @Override public Book createFromParcel(Parcel in) { return new Book(in); } @Override public Book[] newArray(int size) { return new Book[size]; } }; @Override public int describeContents() { return 0; } /** * （1）序列化过程 * * @param dest * @param flags */ @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(name); dest.writeString(classify); dest.writeInt(id); } @Override public String toString() { return \"name : \" + name + \"\\\"\" + \"id : \" + id + \"\\\"\" + \"classify\" + classify; } } ---》那么拥有序列化能力的book如何使用？？？？ parcel https://www.cnblogs.com/ldq2016/p/8469334.html （1）parcel读写能力： Parcel parcel= Parcel.obtain(); //写入，即是write parcel.writeString(\"111111\"); //#1 parcel.marshall(); //#2 (1)序列化过程--》没有这一步，后面read为null (2)这一步返回byte parcel.setDataPosition(0); // #3 在将数据写入之后，需要将指针手动指向到最初的位置 //#4 read String s = parcel.readString(); 为什么没有#2 #3, 步骤#4 read出来的是null？？？？？？ 《-------必须回答#123做了啥，4又具体做了啥？？ #1 parcel.writeString (2)parcel的复制 如何转的？？？ 具体的序列化原理：Parcelable的序列化需要借助Parcel 最后对Parcelable的序列化做一个总结： Parcelable的序列化需要借助Parcel。 Parcel通过JNI把序列化数据写入到进程的共享内存中，或从进程共享内存中读数据。 Parcel推荐使用Parcel.obtain()方法获取可用实例。 与Serializable相比，Parcelable避免了大量反射操作，在效率上有很大提升。 Parcelable仅仅是IPC的高效实现方案，其他场景慎用。 复杂化：Book类里面有其它对象 Parcelable与Intent或者Bundle 与Serializable对比，优劣势？ Parcelable属于安卓，Serializable是java的 Parcelable比Serializable快十倍--------》证明？？？？？ 本质原因在于：Serializable保存了整个类------》消耗极大 Parcelable只是保存了数据结构的值， 没有保存数据结构，而数据结构仍然在开发者手中（恢复时用！！！） Serializable具有可继承性，Parcelable虽然也具有，但是仍然需要完善实现，因为CREATOR是静态的。 17.1.3. 状态保存分析，待合并 序列化： (1)ActivityThread 去做的 (2)场景：activityStopped时机 （3）序列化最终去向：内存(证据：parcel底层是内存操作函数)，native侧的二进制。。。并非文件？（文件场景：开机重启后仍然能够恢复） java序列化是外部存储器，效率低（证据：？？？？） （4）序列化的场景比状态保存的场景少！！！！！！！！（activity切换时，前activity保存） （5）反序列化场景比序列化场景还要少？？？？ writeToParcel:13053, TextView$SavedState (android.widget) writeParcelable:1801, Parcel (android.os) writeValue:1707, Parcel (android.os) writeSparseArray:1085, Parcel (android.os) writeValue:1732, Parcel (android.os) writeArrayMapInternal:928, Parcel (android.os) writeToParcelInner:1584, BaseBundle (android.os) writeToParcel:1253, Bundle (android.os) writeBundle:997, Parcel (android.os) writeValue:1698, Parcel (android.os) writeArrayMapInternal:928, Parcel (android.os) writeToParcelInner:1584, BaseBundle (android.os) writeToParcel:1253, Bundle (android.os) activityStopped:4505, IActivityTaskManager$Stub$Proxy (android.app) run:145, PendingTransactionActions$StopInfo (android.app.servertransaction) handleCallback:883, Handler (android.os) dispatchMessage:100, Handler (android.os) loop:214, Looper (android.os) main:7356, ActivityThread (android.app) invoke:-1, Method (java.lang.reflect) run:492, RuntimeInit$MethodAndArgsCaller (com.android.internal.os) main:930, ZygoteInit (com.android.internal.os) trace是万能的，但是弊端：必须建立在场景你能复现！！！！！（所有动态调试的弊端）。比如状态保存好复现，但是反序列化很难复现！！！！ nameili思路： 1、网页提示 已知存在native和java -----》找流程: 1、先save流程，下发空Bundle 66，填充 ----->注意：这个接口也开给开发者了！！！！！！ Activity.onSaveInstanceState(@NonNull Bundle outState) 2、旋转之后，onCreate----->注意：这个接口开给开发者了！！！！！！(但用处是啥) Activity.onCreate(Bundle savedInstanceState) Bundle 66 ------》怎么协调这个与Ability的关系呢？ 3、Activity.onRestoreInstanceState(@NonNull Bundle savedInstanceState) ----->注意：这个接口开给开发者了！！！！！！ ----》这个Bundle 66 ------>上述问题，可以把转换代码挪到元解决（目前问题，转换问题） 目前上述所有问题，都是Activity去对接的，责任主体是元？？？？ ------->两边SE定的是元透传给安卓AcitivityTread。现在有对外接口，数据开发者能拿到，所以，必须元去转数据！！！！！！！！！！！！！ 后期挪动，现在这个需求仍然这么做，不影响我们 元目前接口有问题 -------》最后没有问题，把恢复和反序列化分开！！！！！！！！ 安卓还有接口： public void onPostCreate(@Nullable Bundle savedInstanceState) * public class Activity extends ApplicationContext { * protected void onCreate(Bundle savedInstanceState); * * protected void onStart(); * * protected void onRestart(); * * protected void onResume(); * * protected void onPause(); * * protected void onStop(); * * protected void onDestroy(); * } ----------》总揽这个事情，给一个大反思： 为什么之前没想到是元去转？？？因为之前定的是透传！！！！！ 一度把他的对外接口给忘记了！！！！！！ 关于容器Bundle的由来： // ActivityThread.java ActivityClientRecord r = mActivities.get(tmp.token); ActivityThread里维护了所有activity的记录Record，Record持有记录activity状态的Bundle 最开始，Bundle是为null的----》问题：问题在于为什么每次取到的都是null？（即使你修改了这个值） // ActivityThread.java private void callActivityOnSaveInstanceState(ActivityClientRecord r) { r.state = new Bundle(); // 这里赋值的！！！（初始化时，默认mParcelledByNative = false），时机：在Save流程最开始的时候 r.state.setAllowFds(false); if (r.isPersistable()) { r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); } } 即使初始化时修改mParcelledByNative = true-----》也无用----》序列化开关不是这里。到底是哪里？？？？？？ 关于序列化： // （1）PendingTransactionActions.java ---》调用栈见上。具体触发的消息是啥？？ ActivityTaskManager.getService().activityStopped( mActivity.token, mState, mPersistentState, mDescription); //（2） ActivityTaskManagerService.java --->到系统进程 public final void activityStopped( // 存储在ActivityRecord里：Bundle icicle; // last saved activity state -------》（1）（2）之间跨进程传输，把state跨进程传给ActivityTaskManagerService系统进程了！！！！！！！（本质）所以这是状态保存需要序列化的本质原因（证据：确实可以看到先序列化，后跨了进程）！！！！！！！！！，这是序列化的地方！！！！！！！！！ 结论：（1）mParcelledByNative------》不是序列化的原因（TODO:那这个是干啥的？？？？） （2）不同于Book的跨进程序列化传输，这里系统进程拿到了二进制，没有再反序列化出对象（实际上，系统进程也不可能反序列化出对象，因为类是在App进程里。。。而之前Book demo，是两边都有要传输的类！！！！！，可以做到反序列化！！！！） 证明：ActivityRecord的Bundle持有的是native侧的指针 addCallback:75, ClientTransaction (android.app.servertransaction) transactionWithCallback:125, ClientLifecycleManager (com.android.server.wm) scheduleTransaction:83, ClientLifecycleManager (com.android.server.wm) scheduleTopResumedActivityChanged:724, ActivityRecord (com.android.server.wm) updateTopResumedActivityIfNeeded:2318, ActivityStackSupervisor (com.android.server.wm) setResumedActivity:2610, ActivityStack (com.android.server.wm) onActivityStateChanged:555, ActivityStack (com.android.server.wm) onActivityStateChanged:1870, TaskRecord (com.android.server.wm) setState:1869, ActivityRecord (com.android.server.wm) startPausingLocked:1686, ActivityStack (com.android.server.wm) resumeTopActivityInnerLocked:2748, ActivityStack (com.android.server.wm) resumeTopActivityUncheckedLocked:2575, ActivityStack (com.android.server.wm) resumeFocusedStacksTopActivities:1158, RootActivityContainer (com.android.server.wm) startActivityUnchecked:1728, ActivityStarter (com.android.server.wm) startActivity:1394, ActivityStarter (com.android.server.wm) startActivity:933, ActivityStarter (com.android.server.wm) startActivity:583, ActivityStarter (com.android.server.wm) startActivityMayWait:1288, ActivityStarter (com.android.server.wm) execute:514, ActivityStarter (com.android.server.wm) startActivityAsUser:1058, ActivityTaskManagerService (com.android.server.wm) startActivityAsUser:1032, ActivityTaskManagerService (com.android.server.wm) startActivity:1009, ActivityTaskManagerService (com.android.server.wm) onTransact:1486, IActivityTaskManager$Stub (android.app) execTransactInternal:1021, Binder (android.os) execTransact:994, Binder (android.os) -----------》首要任务：（1）classLoader （2） 制造crash 17.1.4. 关于Binder https://carsonho.blog.csdn.net/article/details/73560642?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control 17.2. 关于线程的理解： 17.2.1. 什么是线程？ 执行的控制流 被包含在进程（进程内存共享）中 17.2.2. 什么是主线程？ 注意： 对于java，主线程指的是启动main函数的线程 ----》TODO：java的进程号，与主线程号？？？？ 对于安卓，主线程即是UI线程 ----》为什么这么说？启动的main函数线程，1、即是ActivityTread的（即UI？？？？） 2、初始化了线程号，作为后续校验UI操作的线程号？？（TODO：代码） 17.2.3. 安卓主线程是一个死循环 （在Looper.loop()里取消息时死循环）： （0）机制： App本身就运行在一个Looper里，以消息驱动。代码证明：？？？？ （1）可能会休眠!!!!!!!!!!？？？？ （2）既然是死循环，为什么没有ANR？ ANR是为安卓的四大组件设置的？？？？ 无非也就是是个线程，线程是有生命周期的，任务执行结束，或者在执行任务过程中抛了异常，线程就结束了。在 Android 中，正式由于 Looper 维护的这个死循环才能保证主线程不退出，至于为什么不会被卡死，这个说法本身就不成立，loop 方法一直循环处理任务，如果没有任务，进程会休眠。不是一直在循环。至于程序 anr，不是由于死循环，而是由于在 mainlooper 维护这个线程中，执行耗时任务，在规定时间内没有完成，才触发了 Android 系统的 anr 机制！这个跟这个死循环没有任何关系 （3）既然是死循环，又如何退出主线程？---->TODO：线程的生命周期 （4）UI线程的死循环，会进入休眠嘛？ 18. 输入法 见InputMethod 19. 安卓逆向 目的： 1、有时候，不能确定环境中的jar、apk是否含自己的修改(非常重要) ----------> 从手机环境中pull出来jar或者apk，反编译看代码 2、看别人的实现方式 工具一：jadx https://juejin.cn/post/7168086915445424136 范围： APK，AAR，JAR，DEX，AAB，ZIP -------> Java 类 APK，AAR，AAB，ZIP 中的资源 (根本原因：在于资源不可能混淆，系统要识别的) 工具二： apktool + dex2jar + jd-gui 组合： https://juejin.cn/post/7158107697907236878 难点：混淆 参考： https://juejin.cn/post/7168086915445424136 https://www.youtube.com/watch?v=aEEYM0QbnO4&list=PLwIrqQCQ5pQlBNwwf9afQNNUChwdYPVLr 视频教程 20. 计算机基础 20.1. 操作系统之进程管理 TODO: https://mp.weixin.qq.com/s/OCtpPLoBUyVBw2wUlEj1Kw 只有三种状态： 21. 性能专题 见AndriodSystem_Others 21.1. 其他 网络性能优化、APK 大小优化、App 耗电 https://www.androidperformance.com/ https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/ 极好的文章 22. 面试 安卓系统最新面试题 ------》问题永远是第一位重要的 https://blog.csdn.net/kai_zone/article/details/81117644 22.1. 项目相关问题： 华为IDP流程里，你担任什么角色？遇到需求交不了，你是怎么解决的 22.1.1. 开发 开发中遇到哪些问题，你是怎么解决的 22.1.2. 软件经理 软件经理，项目管理方面能力 ：需求管理方面的能力 ----> 技术leader角色 华为的项目线和人力线是两条线：软件经理是项目线角色 所做的事情 组织开发交付，细化并规范化交付流程。定时推动项目进展。 和各个部门协商开发人员，以及开发周期。-----> 针对于要求时间过多的？1、让他们解释为什么要这么多时间，代码量评估多少、验证用例多少 2、对于模块开发，固定的，以往开发时间多少 3、技巧： 让他们都报多一些，越多越好，激化矛盾 ，然后拉各地主管，狠狠批斗 技巧：和硬件沟通时间，都会给软件预留一定时间 遇到需求交不了，你是怎么解决的： 1、首先确保不会有延期的情况出现。需求的开发过程中，先按功能模块划分待开发代码，评估工作量。按照各功能模块给出计划、以及联调时间计划、转测试时间等。设计桌面也有进度，让他们自己更新，所有人都能看到 对于重要的项目，每天会议跟踪计划，发日报周报进展 2、万一有延期的风险。比如，SE、MDE前期分析不到位等，通过每天会议及时发现风险，知会人力PL。 要根据风险点，到底是技术难题，还是验证量过大，让PL协调投入技术专家，还是其他普通开发。让他们手中不是那么急的任务优先级放低 7*24小时 3、等项目风险释放开发后，AAR回溯问题。回溯不针对人，而是针对问题，改进措施。完善checkList 遇到很多领域都没完成的 比如，排查问题、自验证版本。 ------> 发邮件通报前三。一直通报前三 对某一个项目中遇到的问题，举一反三 通知其他项目 说的很顺畅，流程很顺畅 22.2. 面试技术问题 22.2.1. 帧数据的流转 surface对应一个buffer，那么APP进程的Buffer，如何流转到 surfaceFlinger？ ----->TODO: 这实际上涉及到两个进程了！！！？ 用到了surfaceQueue？，类似于MesseageQueue 22.2.2. 需要补充的知识点： linux相关： 内存知识、pss、rss、uss kernel相关： 安卓相关： AMS、WMS、显示相关、PMS 22.3. 一些好的点 商泰面试答复： 您好，不好意思，这两天公司阳太多人了，一直在处理问题，上次面试的确和我们招聘的需求有点差距，对于上层关联的一些系统源码有阅读和自己的理解，个人的算法意识不错，Android系统框架层深入学习研究的经验可能会欠缺一些，所以还是比较抱歉了 ------> 个人的算法意识不错: 这个是由于，回答算法题之前先说了异常边界情况（优） ------> Android系统框架层深入学习研究的经验可能会欠缺一些： 应该值得是WMS、AMS那块 22.4. 问面试官的问题 1、让面试官介绍自己的业务 2、 看源码，如何更深刻的理解呢 22.5. 谈薪资 参考视频： 产品老曾 面试谈薪资，这个东西也变成套路了啊，就跟演电影一样，你就照着一个方式演一遍就可以了: HR:哎呀，我们家这个晋级大概就这个级别，然后在这个级别下我们已经聊了，可能按照这个薪酬的标准啊。我们大概给你的薪酬是这样，你看要不然你无法接了吧， 我：然后你就说我还挺喜欢你们公司对我的认可。然后呢我也相信你们帮我去争取过，但是呢确实因为原来的公司是这样，如果是只给我涨这么点的。吸引力可能没有那么大 HR: 未来未来还有奖金呢，是吧？我们还有福利，是不是啊？你就接了吧，这是一个话术，对吧？ 我：然后你就说我觉得你对我也挺好的，我们俩这个经历这么长时间我的面试过程，对吧？同学其实对我的支持和帮助这些。这样的话我才能拿到这个，最后能跟你们谈这个，但是呢因为现在呢还是有其他的一些公司在正在跟我接触， 而且有一些公司他们开的这个薪酬确实比你们这边给的我还是高比较多，当然了，我倒不是说只是说因为钱我就非要去他们那儿，是说我是觉得这个第一呢，这个能证明这个我自己在市场上的一个价值。第二个呢我也是因为很想去你们公司，所以我才跟你们聊这个事情。 我们俩反正比较直接坦白的讲。就是您这边也帮我挺多的，你就在帮帮我跟公司再争取争， HR: 然后这个hr同学就是说这个还是挺为难的，因为我们公司没有这个先例啊，这个一般就定完了以后，其实我也没有办法再去改变，如果你不接的话，你现在外面有一些公司在跟你接触吗？他们开多少呢？ 我：你就说啊，巴拉巴拉稍微高一点的。然后你说他们开的确实也比较有吸引力，但是我还是很想加入你们公司，因为我们我还挺喜欢跟你们交流的，就不要跟让他变成你的敌对去了啊，注意就是不要让他变成说你们在干嘛呢？不要说这些东西，你说你跟我是一边的。 一直在说这个东西啊，就是说还是希望你能尽力帮我争取一下来回拉扯，现在都是这样，你就照这个来就好了，反正大家都心知肚明，就是肯定要拉扯一两个，你知道这个东西我跟你讲一线的hr的，它确实权限比较小，所以呢如果你的那个薪酬你感觉不满意。 他最多最多能够在他自己权利范围内给你加10%，他看你薪酬的话，比如说假设你原来薪酬是1万多2万，然后他给你加个什么一两千，那就算是他的权限范围超过这个范围，比如说你说我要个30场数。50涨幅，这是一定要向上面的HR的那个老大去申报了， 而那个人在想的就是成本问题，成本性价比，业务那边是不是对你非常认可，那你就有机会，但是有机会你就要还是要跟他讲好话，然后让他愿意去帮你去做这个申请，因为他申请很艰难，他是要跟他老板打报告的 。你不要以为说反正你们就压我这，反正我无所谓，就你自己解决去，那你其实就没有帮别人提供一个理由来帮你加薪，你明白了这个东西以后你就要知道说你要给这个跟你聊天的这个圈儿一个合适的理由让他去。 是的，比如说你在外面有一些其他公司在竞争力这是一种，对吧，还有就是我其实对于我们公司做的这个事儿比较了解，我比较胜任，而且业务对我很认可，这也是一种就是这些东西都是可以给你加成你的性价比， 你注意啊，最终公司给不给你家选不选你这是性价比问题，所以他压薪资他一定会压，你一定会争取大家就拉手拉手就跟你在那个菜市场买菜一样的。这个青菜多少钱啊？青菜一块便宜点呗，哎呀，便宜不了，便宜不了，小本生意，便宜不便宜，我拿两把呢，你在送我点算。 哎呀，这个赔不了，就说那这样吧，你拿三把给我三块，然后我再给你两块算，好吧？哎呀。都是牢固主了，对不对？给我便宜点嘛，一般菜市场聊天就这样，大家都是惯例，所以你也按惯例来就行。 最后聊完就是有理有据，把这个圈拉在你自己这一边，请他去帮你去申请给他申请的理由，然后最后你跟他讲你说不申请的结果如何？注意这句话啊， 不管你帮我申请的结果如何，我都一定会感激你的， 他的感受就是说你其实比较认可他的工作 但是你不太认可公司的那个决定，我知道你很为难。我也知道是公司决定，你其实是愿意帮我加，但是公司不愿意我加，但是我还是给了你一些理由。让你帮我再争取一下，不管你争取的成功不成功，我都会感激你，我感激你，我也不一定来，听懂了吗？ 然后这个圈呢就明白了，他自己会酌情，如果你要求是第一，他可能就回去过来跟你说。他说我就申请了，好不容易再给你加个1000多，那接了吧，如果你还要求更高，你说我要加5000才行，他接受不了，他回去打报告，要不然我们跟业务聊一下吧，这个是不是他们非常喜欢这个东西， 然后呢因为现在这个新城已经超出我们的工资帽了，但是这个同学呢好像确实还不错，然后他在外面。有几家其他公司在挖他，他说那挖多少钱给他高个五六千，你说啊进队里面给这么高吗？那我们再看看其他候选人，哎，其他会员有些人没来，那这个东西好像还是确实还不错， 我们要不然这样我们给他加3000。他又没来好吧，他如果愿意，我就交了。不愿意那就算了，我们在面对的人，他们一般就这样聊完了，聊完了以后回来跟你聊，说那个我们好不容易争取了一下业务，那边呢跟我讲就是说有时候我们为了招一些比较不错的人， 我们还是稍微的可以再增加一点这个额度，但是这已经是最多了，如果你再不接的话，其实我们也没办法。大概就先加个3000左右，你看这个ok，那你自己决定吧，你要接就接，不接就算了，因为这个手摆的就是还是为什么不加5000，就是你的性价比还是不够。 所以很多时候你要把这个所谓的人家压价这个东西归因于我自己的说服人家的那个能力，或者面试的整个过程中表现的状态不够强，还有就是有些东西不在你的控制范围内，就是假设现在有很多候选人。都可以胜任这个岗位，然后背景不是背景设置，是吧？ 卷在一起了，你在这里你非要跟别人说我不行，我非要3%涨，不然你你随便，爱去哪去哪。所以你要对市场本身要有一个概念，我们讲压价这个事情，说你不要说因为你对我要求的那个钱不满意，就认为你是加价，而是说我尊重一下市场的一个基本情况好不好？ 这个怎么去谈的？艺术已经全给你了啊。那你就会发生什么我都告诉你了 23. 参考文章 https://blog.csdn.net/carson_ho/article/details/73560642 Carson带你学Android http://gityuan.com/2016/04/24/how-to-study-android/ https://jsonchao.github.io/ https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/#/%E4%BA%86%E8%A7%A3%E5%8D%A1%E9%A1%BF%E5%8E%9F%E7%90%86 性能方面的博主 24. Android开发常用网站 24.1. Android 相关 Android 开发官网：https://developer.android.google.cn/ Android源码在线查看：https://www.androidos.net.cn/sourcecode Android源码在线查看：http://androidxref.com/ Material Design：https://www.mdui.org/design/|https://material.io/components Material Design github：https://github.com/material-components Android 开发者动画：https://github.com/android/animation-samples Android 开发者ndk：https://github.com/android/ndk-samples OpenGL学习官网：https://learnopengl-cn.readthedocs.io/zh/latest/intro/ 官网镜像：https://developers.google.cn/android/images Kotlin:https://kotlinlang.org/api/latest/jvm/stdlib/ 鸿蒙系统源码：https://codechina.csdn.net/openharmony 鸿蒙开源系统入门：https://blog.csdn.net/qq_33487044/article/details/108560890 Flutter https://flutterchina.club/ springboot:https://github.com/liaozihong/SpringBoot-Learning 图标https://www.iconfont.cn/ protobuf:https://www.tizi365.com/archives/367.html https://www.jianshu.com/p/d4dfe258e796 https://developers.google.cn/protocol-buffers/docs/javatutorial SVG地图下载 https://www.amcharts.com/demos/ Gradle https://services.gradle.org/distributions/ 贝塞尔曲线在线 https://cubic-bezier.com/#.17,.67,.83,.67 25. 格式 # 自动刷入 -w双清 : 25.1. 使用逻辑： 跳转使用逻辑 25.2. 标记 IME switching Following APIs are not supported InputMethodManager#showInputMethodPicker() InputMethodManager#showInputMethodAndSubtypeEnabler() 25.3. 隐藏 26. 书籍 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/log框架.html":{"url":"Andriod/log框架.html","title":"log框架","keywords":"","body":"1. log框架 与 丢log处理2. LOG 实践2.1. system log2.1.1. ProtoLog动态log2.2. EventLog2.2.1. 参考2.3. kernel Log 驱动相关的log2.4. log环境规定2.5. 加log技巧2.6. view log维测技巧：2.7. AS 日志 过滤2.8. 日志问题之 丢日志2.9. 日志问题之 单条日志截断 LOG 实践 system log ProtoLog动态log EventLog 参考 kernel Log 驱动相关的log log环境规定 加log技巧 view log维测技巧： AS 日志 过滤 日志问题之 丢日志 日志问题之 单条日志截断 1. log框架 与 丢log处理 cmd： https://blog.csdn.net/Tecinno4/article/details/108471795 Android logcat log丢失 https://blog.csdn.net/kc58236582/article/details/51506896 android log丢失（一）使用logd丢失log原理 -是否有丢log判断： log中有 chatty 关键词 Android studio logcat log丢失： https://www.jianshu.com/p/ce2b246cfec4 Android studio logcat log丢失不全问题解决 TODO： 2. LOG 实践 2.1. system log 作用： 记录手机android上层app以及framework相关活动的log，比如你写的app打印的log，就在这里面 adb shell logcat -v 2.1.1. ProtoLog动态log Android ProtoLog动态开启相关wm logging源码分析补充 https://blog.csdn.net/liaosongmao1/article/details/130597983?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-130597983-blog-110820407.235^v38^pc_relevant_default_base3&spm=1001.2101.3001.4242.1&utm_relevant_index=3 2.2. EventLog 作用： 非常简洁明了地展现当前Activity各种状态 -----》 状态性日志，而不是流程性 ActivityManager、powerManager等相关的log adb shell logcat -b events adb shell logcat -b events | findstr \"am_ wm_\" // 同时过滤AMS与Wms ---------> 注意：普通的adb shell logcat 日志里没有 event log 涉及的源码类： EventLog.java, EventLogTags.java 2.2.1. 参考 http://gityuan.com/2016/05/15/event-log/ Android EventLog含义 ----> 详细 https://blog.csdn.net/junjle/article/details/87184120?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-87184120-blog-117734286.235^v38^pc_relevant_default_base3&spm=1001.2101.3001.4242.2&utm_relevant_index=4 2.3. kernel Log 驱动相关的log ctrl+alt+shift+i 2.4. log环境规定 规定： 1、永远不允许用AS抓log （日志过多，AS端日志会冲掉） 用 adb logcat -c && adb logcat -v time > logcat.txt 2、log buffer选择最大 -----> 否则，有可能丢日志 2.5. 加log技巧 1、log也要注意判断null，否则直接crash，浪费编译时间 ​ 加log，可能导致attach system_process挂了 ​ ------> 规定： ​ （1）每次加完，验证一下 ​ （2）加log要谨慎，判空要做好 2、log和调用栈一起使用 3、避免一行超长，notePad看不方便： // 换行 Log.d(TAG, \"child.mAttachInfo.mTmpInvalRect \" + child.mAttachInfo.mTmpInvalRect + \"\\\\n\" + \"child.getId(): \"+ child.getId() + \"\\\\n\" + \"child.getAccessibilityViewId(): \"+ child.getAccessibilityViewId() + \"\\\\n\" + \"child.getWindowId(): \"+ child.getWindowId()); 4、技巧之： 针对（关键指标，要非常显眼）、差异化对待： （1）比如关注某个接口的时间差 ----------> 如果打印频繁，不好一直做差 ​ 即用Error 打印出来差值（Error自带红色） （2）我们只对时间差高的关心，更进一步 差异化： if （差值 > 70ms ）{ log.e() } else { log.d() } 2.6. view log维测技巧： TODO： 特点：多而杂乱 方法一：以偏概全 ---------------打印含有文字的控件，然后基本知道所有控件的布局（对应关系） ​ -------------> 抓住一点，不及其余 方法二： 直观画图：-----> 也是有文字的才画 直观画图 // 将矩形的数组合并到大数组中 private char[][] mergeArrays(char[][] screen, char[][] rectangle) { int row = rectangle.length; int col = rectangle[0].length; for (int i = 0; i 2.7. AS 日志 过滤 https://blog.csdn.net/qq_38909786/article/details/134416770 日志 过滤 过滤包名加两个字段 package:org.sipdroid.sipua message:=alarm message:600 2.8. 日志问题之 丢日志 AS 或者 logcat发现有丢日志，根因： 日志缓冲区过小 方法一： 缓冲区，直接在配置中，改大：------------------> 防止日志丢失 P13_5G:/system # cat build.prop | grep logd persist.logd.size=8M adb pull /system/build.prop ---> 修改 特别注意： 不能修改 build.prop 的权限（方法：pull & push，不要直接vi修改） 方法二： 参考： https://blog.csdn.net/zhangxu1024/article/details/121374807 报错： logcat: Unexpected EOF! This means that either the device shut down, logd crashed, or this instance of logcat was unable to read log messages as quickly as they were being produced. If you have enabled significant logging, look into using the -G option to increase log buffer sizes. 最终生效： D:\\\\\\\\work\\\\\\\\test\\\\\\\\log>adb shell logcat -g main: ring buffer is 256 KiB (3 MiB consumed), max entry is 5120 B, max payload is 4068 B system: ring buffer is 256 KiB (251 KiB consumed), max entry is 5120 B, max payload is 4068 B crash: ring buffer is 256 KiB (15 KiB consumed), max entry is 5120 B, max payload is 4068 B kernel: ring buffer is 256 KiB (245 KiB consumed), max entry is 5120 B, max payload is 4068 B 修改： adb shell logcat -G 5M --------------------> 很多时候，方法一不生效！！！！！！！！！！！！ ---------------------> TODO: 找到持久化的文件，写成脚本。每次导入jar时执行 方法三：万能方法（验证ok）： 在logd处限制 -----------> 只允许打印E 及以上的日志（其他日志不打印，自然不会过频） setprop persist.log.tag E 参考： Android logcat log输出控制_persist.log.tag-CSDN博客 TODO： log框架： APP 通过UDP---------> logd服务 通过TCP-----------> logcat终端 打印，指的是logd打印；logcat只是取日志 2.9. 日志问题之 单条日志截断 方法一： https://blog.csdn.net/realDonaldTrump/article/details/128468204 Android单条日志太长导致被截断的问题分析和解决 方法二：多次输出 https://blog.csdn.net/chuyouyinghe/article/details/81699307 1 // Function to print equal segments of a string2 void printEqualSegments(const char* str, int length) {3 const int segmentLength = length / 2;4 char firstSegment[segmentLength + 1]; // +1 for null terminator5 char secondSegment[segmentLength + 1]; // +1 for null terminator6 7 // Copy first segment8 strncpy(firstSegment, str, segmentLength);9 firstSegment[segmentLength] = '\\\\0'; // Null terminate10 11 // Copy second segment12 strncpy(secondSegment, str + segmentLength, segmentLength);13 secondSegment[segmentLength] = '\\\\0'; // Null terminate14 15 // Print segments16 // printf(\"First Segment: %s\\\\n\", firstSegment);17 // printf(\"Second Segment: %s\\\\n\", secondSegment);18 ALOGI(\"ProgramCache::generateProgram: fs1:%s end\", firstSegment);19 ALOGI(\"ProgramCache::generateProgram: fs2:%s end\", secondSegment);20 } 日志跟很多相关： 系统侧打印(系统侧的配置能力) 日志服务 终端的接收能力（cmd、AS、cmd输出到文件） 好的方式：输出文件，相对靠谱 1 adb logcat -v time > 111.txt // cmd输出到文件 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/permissions.html":{"url":"Andriod/permissions.html","title":"Permissions","keywords":"","body":"1. 目录2. 问在前面（目的论）3. 安卓权限概念4. 哪些app属于system app？5. 权限的声明&使用&获取6. 环境中查看状态权限6.1. 以package 为base，查看一个包涉及的权限6.1.1. declared permissions ：自定义权限6.1.2. requested permissions ：请求权限6.1.3. install permissions ：安装权限6.1.4. runtime permissions ： 运行时权限6.2. 以权限为base，查哪些声明了，哪些使用了7. 参考：8. Selinux权限9. 应用获取su权限9.1. 方法一：修改代码9.1.1. 编译userdebug版本9.1.2. su命令源码中添加了uid检验，只允许shell/root用户进行调用　9.1.3. 修改su文件读写权限9.1.4. Zygote.DropCapabilitiesBoundingSet9.1.5. 修改内核代码9.1.6. SELinux安全模块 -----> 这里似乎不是必须的9.1.7. packages/modules/adb/Android.bp andriod12及以后9.1.8. 参考：9.2. 方法二：有源码----刷入Magisk获取root权限9.2.1. deploy linux 磁盘扩容9.2.2. 其他网站：9.3. 没有源码---刷入Magisk获取root权限9.4. AS 模拟器的su权限9.5. 方法三：借用能力---借有root权限进程的能力9.6. 方法三：回避su权限9.7. su权限的验证9.7.1. 参考10. linux文件权限以及 chmod11. 格式 目录 问在前面（目的论） 安卓权限概念 哪些app属于system app？ 权限的声明&使用&获取 环境中查看状态权限 以package 为base，查看一个包涉及的权限 declared permissions ：自定义权限 requested permissions ：请求权限 install permissions ：安装权限 runtime permissions ： 运行时权限 以权限为base，查哪些声明了，哪些使用了 参考： Selinux权限 应用获取su权限 方法一：修改代码 编译userdebug版本 su命令源码中添加了uid检验，只允许shell/root用户进行调用 修改su文件读写权限 Zygote.DropCapabilitiesBoundingSet 修改内核代码 SELinux安全模块 -----> 这里似乎不是必须的 packages/modules/adb/Android.bp andriod12及以后 参考： 方法二：有源码----刷入Magisk获取root权限 deploy linux 磁盘扩容 其他网站： 没有源码---刷入Magisk获取root权限 AS 模拟器的su权限 方法三：借用能力---借有root权限进程的能力 方法三：回避su权限 su权限的验证 参考 linux文件权限以及 chmod 格式 1. 目录 2. 问在前面（目的论） 权限： 其实，权限状态是必然的。比如，做饭这件事情， 1、你要有出门的权限（疫情就不行），去买菜 2、房间要满足厨房的通风要求 3、生火的权限 ..................... 权限的功能是啥？ ----》1、如何理解应用权限 与 INTERNAL_SYSTEM_WINDOW 啥关系？ 2、权限的本质是什么？ A申明了权限，B使用权限？ ​ 权限有哪些状态？（xml中申明？xml请求？用户同意？自定义？运行时？） -----> 软件必须弄懂状态 从信息角度： 限制来源于谁？限制于谁？ 3. 安卓权限概念 参考: https://blog.csdn.net/sinat_20059415/article/details/80370223 见下 TODO 4. 哪些app属于system app？ https://blog.csdn.net/Liu1314you/article/details/77368585 大体认识： privileged app（特权app） > System app > 状态判定标准： ​ ApplicationInfo.FLAG_SYSTEM` ​ ApplicationInfo.PRIVATE_FLAG_PRIVILEGED 5. 权限的声明&使用&获取 声明权限是指在AndroidManifest.xml中使用了， -----》 TODO: 不懂 使用权限是指在AndroidManifest.xml中使用了 获得权限（或赋予权限）是指真正的可以通过系统的权限检查，调用到权限保护的方法 App A中声明了权限PermissionA，App B中使用了权限PermissionA--------> B可以调用A？ 6. 环境中查看状态权限 注意， 1、其实，与运行时无关，因为PMS这些权限的状态，与运行时无关 ----> 安装包决定的 2、与应用是否打开也无关 6.1. 以package 为base，查看一个包涉及的权限 adb shell dumpsys package 以com.tencent.mm为例： adb shell dumpsys package com.tencent.mm 文件结构如下： 1、给出自定义的Permission 推论：与 declared permissions中的权限 应该一样 TODO 点击展示 Permissions: Permission [com.tencent.mm.WAID_PROVIDER_WRITE] (7bc450): sourcePackage=com.tencent.mm // sourcePackage是权限声明的地方 uid=10108 gids=null type=0 prot=signature perm=Permission{632649 com.tencent.mm.WAID_PROVIDER_WRITE} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.permission.EXT_OPEN_APPBRAND_LAUNCHER_UI] (dc0b46f): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{ee0d57c com.tencent.mm.permission.EXT_OPEN_APPBRAND_LAUNCHER_UI} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.matrix.strategynotify] (aede05): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{ef83e5a com.tencent.mm.matrix.strategynotify} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.permission.MM_MESSAGE] (64e288b): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{623cd68 com.tencent.mm.permission.MM_MESSAGE} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.plugin.permission.READ] (c445581): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{debe626 com.tencent.mm.plugin.permission.READ} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.wear.message] (4f4c267): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{21c5814 com.tencent.mm.wear.message} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.ext.permission.SPORT] (c5fc8bd): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=normal perm=Permission{3203eb2 com.tencent.mm.ext.permission.SPORT} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.ext.permission.WRITE] (7811e03): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature|privileged perm=Permission{270e180 com.tencent.mm.ext.permission.WRITE} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.backtrace.warmed_up] (7c533b9): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{ecf93fe com.tencent.mm.backtrace.warmed_up} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.permission.C2D_MESSAGE] (1ed975f): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{8c295ac com.tencent.mm.permission.C2D_MESSAGE} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.matrix.permission.PROCESS_SUPERVISOR] (37c5275): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{88cf20a com.tencent.mm.matrix.permission.PROCESS_SUPERVISOR} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.permission.EXT_OPEN_APPBRAND_MY_COLLECTIONS] (37e4a7b): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{d996098 com.tencent.mm.permission.EXT_OPEN_APPBRAND_MY_COLLECTIONS} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.manual.dump] (34ca0f1): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{c1024d6 com.tencent.mm.manual.dump} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.vfs.broadcast] (19d1357): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{80fee44 com.tencent.mm.vfs.broadcast} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.plugin.permission.WRITE] (5f95b2d): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{6c1b862 com.tencent.mm.plugin.permission.WRITE} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permission [com.tencent.mm.permission.MOVE_XLOG] (4758df3): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature|privileged perm=Permission{43faab0 com.tencent.mm.permission.MOVE_XLOG} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.ext.permission.READ] (93d7d29): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature|privileged perm=Permission{206f8ae com.tencent.mm.ext.permission.READ} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} 2、给出涉及的Permission 点击展示 Packages: Package [com.tencent.mm] (557bb4e): //下面针对于 com.tencent.mm userId=10108 // userId到底是啥？ pkg=Package{e030746 com.tencent.mm} codePath=/data/app/com.tencent.mm-FtxVmfhJnuP-P7oGWPgRrw== resourcePath=/data/app/com.tencent.mm-FtxVmfhJnuP-P7oGWPgRrw== legacyNativeLibraryDir=/data/app/com.tencent.mm-FtxVmfhJnuP-P7oGWPgRrw==/lib primaryCpuAbi=arm64-v8a // 包路径、资源路径、lib路径 secondaryCpuAbi=null versionCode=2400 minSdk=23 targetSdk=29 //需要的安卓sdk版本 versionName=8.0.38 splits=[base] apkSigningVersion=1 applicationInfo=ApplicationInfo{f07dea4 com.tencent.mm} flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA LARGE_HEAP ] // TODO: flags是啥 privateFlags=[ PRIVATE_FLAG_ACTIVITIES_RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION ALLOW_AUDIO_PLAYBACK_CAPTURE PRIVATE_FLAG_REQUEST_LEGACY_EXTERNAL_STORAGE HAS_DOMAIN_URLS PARTIALLY_DIRECT_BOOT_AWARE ] dataDir=/data/user/0/com.tencent.mm supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] usesOptionalLibraries: org.apache.http.legacy com.google.android.maps com.sec.android.app.multiwindow com.miui.easygo com.hihonor.easygo com.here.android androidx.window.extensions androidx.window.sidecar androidx.camera.extensions.impl com.huawei.easygo soterkeystore usesLibraryFiles: /system/framework/org.apache.http.legacy.jar timeStamp=2023-06-28 21:50:04 firstInstallTime=2023-06-28 21:50:28 lastUpdateTime=2023-06-28 21:50:28 installerPackageName=com.android.packageinstaller signatures=PackageSignatures{a4cc409 version:1, signatures:[962f5b7], past signatures:[]} //签名 installPermissionsFixed=true // 安装权限 -----> 如果装上了，一定为true？ pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA LARGE_HEAP ] declared permissions: // 【1】微信自定义的权限 com.tencent.mm.plugin.permission.WRITE: prot=signature, INSTALLED com.tencent.mm.plugin.permission.READ: prot=signature, INSTALLED com.tencent.mm.permission.MM_MESSAGE: prot=signature, INSTALLED com.tencent.mm.permission.MOVE_XLOG: prot=signature|privileged, INSTALLED com.tencent.mm.ext.permission.READ: prot=signature|privileged, INSTALLED com.tencent.mm.ext.permission.WRITE: prot=signature|privileged, INSTALLED com.tencent.mm.ext.permission.SPORT: prot=normal, INSTALLED com.tencent.mm.wear.message: prot=signature, INSTALLED com.tencent.mm.WAID_PROVIDER_WRITE: prot=signature, INSTALLED com.tencent.mm.permission.EXT_OPEN_APPBRAND_LAUNCHER_UI: prot=signature, INSTALLED com.tencent.mm.permission.EXT_OPEN_APPBRAND_MY_COLLECTIONS: prot=signature, INSTALLED com.tencent.mm.matrix.strategynotify: prot=signature, INSTALLED com.tencent.mm.vfs.broadcast: prot=signature, INSTALLED com.tencent.mm.manual.dump: prot=signature, INSTALLED com.tencent.mm.backtrace.warmed_up: prot=signature, INSTALLED com.tencent.mm.matrix.permission.PROCESS_SUPERVISOR: prot=signature, INSTALLED com.tencent.mm.permission.C2D_MESSAGE: prot=signature, INSTALLED requested permissions: // 【2】已经请求的权限。。。1、一定包含install permissions (对于已经安装了的pkg) 2、Todo: 一定都是用户授权了吗？ android.bluetooth.permissions.SHORTCUT_ACTION android.permission.CHANGE_WIFI_MULTICAST_STATE com.tencent.mm.plugin.permission.READ com.tencent.mm.plugin.permission.WRITE com.tencent.mm.permission.MM_MESSAGE com.huawei.authentication.HW_ACCESS_AUTH_SERVICE com.google.android.providers.gsf.permission.READ_GSERVICES android.permission.CHANGE_NETWORK_STATE android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_COARSE_LOCATION android.permission.ACCESS_FINE_LOCATION android.permission.CAMERA// 微信自然需要CAMERA权限 android.permission.GET_TASKS android.permission.INTERNET android.permission.MODIFY_AUDIO_SETTINGS android.permission.RECEIVE_BOOT_COMPLETED android.permission.RECORD_AUDIO android.permission.READ_CONTACTS android.permission.VIBRATE android.permission.WAKE_LOCK android.permission.WRITE_EXTERNAL_STORAGE: restricted=true com.android.launcher.permission.INSTALL_SHORTCUT com.android.launcher.permission.UNINSTALL_SHORTCUT com.android.launcher.permission.READ_SETTINGS com.tencent.mm.location.permission.SEND_VIEW android.permission.BLUETOOTH android.permission.BLUETOOTH_ADMIN android.permission.BROADCAST_STICKY android.permission.SYSTEM_ALERT_WINDOW android.permission.CHANGE_WIFI_STATE android.permission.GET_PACKAGE_SIZE android.permission.DOWNLOAD_WITHOUT_NOTIFICATION android.permission.NFC com.miui.easygo.permission.READ_PERMISSION com.huawei.android.launcher.permission.CHANGE_BADGE android.permission.WRITE_APP_BADGE cn.cyberidentity.certification.AUTH com.tencent.mm.ext.permission.READ com.tencent.mm.ext.permission.WRITE android.permission.ACTIVITY_RECOGNITION com.tencent.mm.wear.message android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS miui.permission.READ_STEPS android.permission.FOREGROUND_SERVICE android.permission.READ_EXTERNAL_STORAGE: restricted=true android.permission.ACCESS_WIFI_STATE com.open.gallery.smart.Read com.open.gallery.smart.Write com.open.gallery.smart.Provider android.permission.REQUEST_INSTALL_PACKAGES android.permission.USE_FULL_SCREEN_INTENT android.permission.USE_FINGERPRINT android.permission.USE_BIOMETRIC com.tencent.mm.WAID_PROVIDER_WRITE com.bbk.launcher2.permission.READ_SETTINGS com.android.vending.BILLING com.android.vending.CHECK_LICENSE com.tencent.mm.matrix.strategynotify android.permission.ACCESS_NOTIFICATION_POLICY com.tencent.mm.vfs.broadcast com.tencent.mm.manual.dump com.tencent.mm.backtrace.warmed_up com.tencent.mm.matrix.permission.PROCESS_SUPERVISOR com.huawei.easygo.permission.READ_PERMISSION com.oplus.permission.safe.FANTASYWINDOW com.google.android.finsky.permission.BIND_GET_INSTALL_REFERRER_SERVICE com.google.android.c2dm.permission.RECEIVE com.tencent.mm.permission.C2D_MESSAGE com.soter.permission.ACCESS_SOTER_KEYSTORE android.permission.USE_FACERECOGNITION install permissions: // 【3】安卓时，所必要的权限，安装上，必然用户授权 ranted=true android.permission.DOWNLOAD_WITHOUT_NOTIFICATION: granted=true android.permission.MODIFY_AUDIO_SETTINGS: granted=true android.permission.ACCESS_NOTIFICATION_POLICY: granted=true com.tencent.mm.WAID_PROVIDER_WRITE: granted=true com.tencent.mm.matrix.strategynotify: granted=true android.permission.NFC: granted=true android.permission.CHANGE_NETWORK_STATE: granted=true android.permission.FOREGROUND_SERVICE: granted=true android.permission.RECEIVE_BOOT_COMPLETED: granted=true com.tencent.mm.permission.MM_MESSAGE: granted=true com.android.launcher.permission.UNINSTALL_SHORTCUT: granted=true android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS: granted=true android.permission.BLUETOOTH: granted=true android.permission.CHANGE_WIFI_MULTICAST_STATE: granted=true android.permission.GET_TASKS: granted=true android.permission.INTERNET: granted=true android.permission.BLUETOOTH_ADMIN: granted=true android.permission.GET_PACKAGE_SIZE: granted=true com.tencent.mm.plugin.permission.READ: granted=true com.tencent.mm.wear.message: granted=true com.tencent.mm.ext.permission.WRITE: granted=true android.permission.USE_FULL_SCREEN_INTENT: granted=true android.permission.BROADCAST_STICKY: granted=true android.permission.CHANGE_WIFI_STATE: granted=true com.tencent.mm.backtrace.warmed_up: granted=true android.permission.ACCESS_NETWORK_STATE: granted=true com.tencent.mm.permission.C2D_MESSAGE: granted=true android.permission.USE_FINGERPRINT: granted=true com.tencent.mm.matrix.permission.PROCESS_SUPERVISOR: granted=true com.tencent.mm.manual.dump: granted=true com.tencent.mm.vfs.broadcast: granted=true com.tencent.mm.plugin.permission.WRITE: granted=true android.permission.VIBRATE: granted=true android.permission.ACCESS_WIFI_STATE: granted=true android.permission.USE_BIOMETRIC: granted=true com.android.launcher.permission.INSTALL_SHORTCUT: granted=true android.permission.WAKE_LOCK: granted=true com.tencent.mm.ext.permission.READ: granted=true User 0: ceDataInode=1106633 installed=true hidden=false suspended=false stopped=false notLaunched=false enabled=0 instant=false virtual=false gids=[3002, 3003, 3001] runtime permissions: // 【4】运行时的权限：运行时，才申请？？？？所以很多用户还没有授权granted=false android.permission.ACCESS_FINE_LOCATION: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] android.permission.READ_EXTERNAL_STORAGE: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED|RESTRICTION_INSTALLER_EXEMPT] android.permission.ACCESS_COARSE_LOCATION: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] android.permission.CAMERA: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] android.permission.WRITE_EXTERNAL_STORAGE: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED|RESTRICTION_INSTALLER_EXEMPT] android.permission.ACTIVITY_RECOGNITION: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] android.permission.RECORD_AUDIO: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] android.permission.READ_CONTACTS: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] disabledComponents: com.tencent.mm.plugin.nfc_open.ui.NfcWebViewUI enabledComponents: androidx.work.impl.background.systemjob.SystemJobService 结论: 见上 6.1.1. declared permissions ：自定义权限 作用： 与其他应用分享自己的资源和功能 比如：启动 myapp 的activity ----> 功能分享出去 代码： 1、分享侧自定义DEADLY_ACTIVITY权限： //AndroidManifest.xml ... 2、调用侧 TODO 在AndroidManifest.xml中使用了 ？？？ TODO: 和 在dump中怎么体现的？ TODO: protectionLevel、permissionGroup https://blog.csdn.net/hanhan1016/article/details/105864367 6.1.2. requested permissions ：请求权限 6.1.3. install permissions ：安装权限 6.1.4. runtime permissions ： 运行时权限 6.2. 以权限为base，查哪些声明了，哪些使用了 adb shell dumpsys package permission 结果： Permissions: Permission [android.permission.CALL_PHONE] (cb5d7a9): sourcePackage=android // 权限的申明者？？？？ uid=1000 gids=null type=0 prot=dangerous //保护级别 perm=Permission{6d8812e android.permission.CALL_PHONE} packageSetting=PackageSetting{bb25476 android/1000} Packages: //下面是涉及到这个权限的所有pkg Package [com.android.providers.telephony] (788ac20): // 权限的使用者 userId=1001 sharedUser=SharedUserSetting{91f34cf android.uid.phone/1001} pkg=Package{b7abe5c com.android.providers.telephony} codePath=/system/priv-app/TelephonyProvider versionCode=29 minSdk=29 targetSdk=29 versionName=10 splits=[base] apkSigningVersion=3 applicationInfo=ApplicationInfo{6b4565 com.android.providers.telephony} flags=[ SYSTEM HAS_CODE ALLOW_BACKUP KILL_AFTER_RESTORE RESTORE_ANY_VERSION ] privateFlags=[ PRIVATE_FLAG_ACTIVITIES_RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION ALLOW_AUDIO_PLAYBACK_CAPTURE BACKUP_IN_FOREGROUND DEFAULT_TO_DEVICE_PROTECTED_STORAGE DIRECT_BOOT_AWARE PRIVILEGED ] dataDir=/data/user_de/0/com.android.providers.telephony supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2020-11-13 02:05:45 firstInstallTime=2020-11-13 02:05:45 lastUpdateTime=2020-11-13 02:05:45 signatures=PackageSignatures{def823a version:3, signatures:[b4addb29], past signatures:[]} installPermissionsFixed=true pkgFlags=[ SYSTEM HAS_CODE ALLOW_BACKUP KILL_AFTER_RESTORE RESTORE_ANY_VERSION ] requested permissions: install permissions: User 0: ceDataInode=950283 installed=true hidden=false suspended=false stopped=false notLaunched=false enabled=0 instant=false virtual=false Package [com.android.dynsystem] (a6339d9): userId=1000 sharedUser=SharedUserSetting{b844eeb android.uid.system/1000} pkg=Package{c236448 com.android.dynsystem} codePath=/system/priv-app/DynamicSystemInstallationService versionCode=29 minSdk=29 targetSdk=29 versionName=10 splits=[base] apkSigningVersion=3 applicationInfo=ApplicationInfo{b4fd2e1 com.android.dynsystem} flags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ] privateFlags=[ PRIVATE_FLAG_ACTIVITIES_RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION ALLOW_AUDIO_PLAYBACK_CAPTURE PRIVILEGED ] dataDir=/data/user/0/com.android.dynsystem supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2020-11-13 02:14:46 firstInstallTime=2020-11-13 02:14:46 lastUpdateTime=2020-11-13 02:14:46 signatures=PackageSignatures{e438806 version:3, signatures:[b4addb29], past signatures:[]} installPermissionsFixed=true pkgFlags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ] requested permissions: install permissions: User 0: ceDataInode=950286 installed=true hidden=false suspended=false stopped=false notLaunched=false enabled=0 instant=false virtual=false Package [com.android.messaging] (656fd19): userId=10065 pkg=Package{e7d91de com.android.messaging} codePath=/system/app/messaging versionCode=10001040 minSdk=29 targetSdk=28 versionName=1.0.001 splits=[base] apkSigningVersion=3 applicationInfo=ApplicationInfo{d9cefbf com.android.messaging} flags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ] privateFlags=[ PRIVATE_FLAG_ACTIVITIES_RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION PRIVATE_FLAG_REQUEST_LEGACY_EXTERNAL_STORAGE ] dataDir=/data/user/0/com.android.messaging supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] usesLibraries: android.hidl.manager-V1.0-java android.hidl.base-V1.0-java usesLibraryFiles: /system/framework/android.hidl.manager-V1.0-java.jar /system/framework/android.hidl.base-V1.0-java.jar timeStamp=2020-11-13 02:14:42 firstInstallTime=2020-11-13 02:14:42 lastUpdateTime=2020-11-13 02:14:42 signatures=PackageSignatures{998768c version:3, signatures:[b4addb29], past signatures:[]} installPermissionsFixed=true pkgFlags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ] requested permissions: android.permission.CALL_PHONE install permissions: User 0: ceDataInode=950337 installed=true hidden=false suspended=false stopped=false notLaunched=false enabled=0 instant=false virtual=false gids=[3003] runtime permissions: android.permission.CALL_PHONE: granted=true, flags=[ // granted=true 证明该pkg已经获得了权限 GRANTED_BY_DEFAULT|USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] Package [com.android.dialer] (15fd569): userId=10085 pkg=Package{10a0bee com.android.dialer} codePath=/system/product/priv-app/Dialer versionCode=2900000 minSdk=29 targetSdk=28 versionName=23.0 splits=[base] apkSigningVersion=3 applicationInfo=ApplicationInfo{8fdc88f com.android.dialer} flags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] privateFlags=[ PRIVATE_FLAG_ACTIVITIES_RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION PRIVATE_FLAG_REQUEST_LEGACY_EXTERNAL_STORAGE PARTIALLY_DIRECT_BOOT_AWARE PRIVILEGED PRODUCT ] dataDir=/data/user/0/com.android.dialer supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] usesLibraries: android.hidl.manager-V1.0-java android.hidl.base-V1.0-java org.apache.http.legacy usesLibraryFiles: /system/framework/android.hidl.manager-V1.0-java.jar /system/framework/android.hidl.base-V1.0-java.jar /system/framework/org.apache.http.legacy.jar timeStamp=2020-11-13 02:16:32 firstInstallTime=2020-11-13 02:16:32 lastUpdateTime=2020-11-13 02:16:32 signatures=PackageSignatures{4c4271c version:3, signatures:[9542d9b9], past signatures:[]} installPermissionsFixed=true pkgFlags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] requested permissions: android.permission.CALL_PHONE install permissions: User 0: ceDataInode=950512 installed=true hidden=false suspended=false stopped=false notLaunched=false enabled=0 instant=false virtual=false gids=[3002, 3003, 3001] runtime permissions: android.permission.CALL_PHONE: granted=true, flags=[ GRANTED_BY_DEFAULT|USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] dialer！！！ 比如：android.permission.CALL_PHONE 权限，有了这个权限，可以调用打电话的APP(自然，它声明了) TODO: 这个查看结果，使用户设置之后的嘛？ 7. 参考： https://blog.csdn.net/Liu1314you/article/details/77368585 Android 权限的一些细节 https://developer.android.com/reference/android/Manifest.permission.html ------>完整版的权限表 https://www.jianshu.com/p/6c755ca6a3a3 https://blog.csdn.net/hanhan1016/article/details/105864367 Android权限 - 查看应用权限信息 https://www.cnblogs.com/andy-songwei/p/10638446.html Android安全之（一）权限篇 https://blog.csdn.net/li6151770/article/details/52782141 Android调用打电话(Call Phone) 8. Selinux权限 9. 应用获取su权限 9.1. 方法一：修改代码 验证ok的平台： RK3588s+Andriod11 MT8675+Andriod12 9.1.1. 编译userdebug版本 TODO：难道user版本不行？ 9.1.2. su命令源码中添加了uid检验，只允许shell/root用户进行调用　 注释掉uid校验： 9.1.3. 修改su文件读写权限 9.1.4. Zygote.DropCapabilitiesBoundingSet 作用：限制了 APP setuid功能 注释掉frameworks/base/core/jni/com_android_internal_os_Zygote.cpp 9.1.5. 修改内核代码 /security/commoncap.c 注释掉cap_prctl_drop函数中的代码，以防止它检查adbd进程是否有CAP_SETPCAP能力，以及是否传递了一个有效的能力参数。 9.1.6. SELinux安全模块 -----> 这里似乎不是必须的 1,2条都满足情况下也会被中断su 临时：adb shell setenforce 0 永久： 9.1.7. packages/modules/adb/Android.bp andriod12及以后 ​ 这个文件定义了adbd模块的编译选项和依赖项。需要添加-DALLOW_ADBD_ROOT=1到cflags中，以启用adbd进程的root模式，并添加remount到required中，以允许adbd进程重新挂载系统分区。这个文件好像是Android12以上出来的, adb换到这个目录了 原文链接：https://blog.csdn.net/SHH_1064994894/article/details/131966009 @@ -50,6 +50,7 @@ cc_defaults { \"-Wvla\", \"-DADB_HOST=1\", // overridden by adbd_defaults \"-DANDROID_BASE_UNIQUE_FD_DISABLE_IMPLICIT_CONVERSION=1\", + \"-DALLOW_ADBD_ROOT=1\", ], cpp_std: \"experimental\", @@ -111,8 +112,15 @@ cc_defaults { cc_defaults { name: \"adbd_defaults\", defaults: [\"adb_defaults\"], + cflags: [ + \"-UADB_HOST\", + \"-DADB_HOST=0\", + \"-UALLOW_ADBD_ROOT\", + \"-DALLOW_ADBD_ROOT=1\", + \"-DALLOW_ADBD_DISABLE_VERITY\", + \"-DALLOW_ADBD_NO_AUTH\", +], - cflags: [\"-UADB_HOST\", \"-DADB_HOST=0\"], } cc_defaults { @@ -605,7 +613,7 @@ cc_library { \"libcrypto\", \"liblog\", ], - + required: [ \"remount\",], target: { android: { srcs: [ 9.1.8. 参考： https://zhuanlan.zhihu.com/p/612380272 RK3588s Android 12 Framework修改记录（三）开放ROOT权限给上层应用 执行su命令 --------------------> 完全ok，特别注意commoncap.c需要修改 https://blog.csdn.net/chlbd/article/details/107065810?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-7-107065810-blog-122415926.235%5Ev38%5Epc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-7-107065810-blog-122415926.235%5Ev38%5Epc_relevant_sort_base1&utm_relevant_index=6 将Android10编译成真正的具有root权限的系统 https://blog.csdn.net/SHH_1064994894/article/details/131966009 Android13 Root实现和原理分析 9.2. 方法二：有源码----刷入Magisk获取root权限 https://zhuanlan.zhihu.com/p/651446082 aosp-刷入Magisk面具获取root权限 注：例子是安卓10 -------------> 已经验证ok 偶现： 刷了Magisk，无法remount系统分区，remount失败 关键步骤： 1、刷入面具制作的boot imgage adb reboot bootloader fastboot flash magisk_patched-27000_p2DRn.img 2、重启后，查看 Magisk本身是否有su权限 3、安装 busybox和 linuxdeploy。用 Magisk给两者赋予 su权限 4、inux Deploy安装debian 参考： （1） https://blog.csdn.net/qq_28817367/article/details/130394040 安卓安装Linux Deploy 基础安装&&自定义安装 （2）TODO： com 全部恢复，取消su权限： //还原boot： fastboot flash boot boot.img 总之，所有文件打包： E:\\softWare\\softWare\\Linux_ON_Andriod\\ 9.2.1. deploy linux 磁盘扩容 https://blog.csdn.net/weixin_73464466/article/details/126654730 linux deploy安装kali和磁盘扩容 -------------> 验证OK dd if=/dev/zero bs=1048576 count=1000 >> //storage/emulated/0/kali.img e2fsck -f /storage/emulated/0/kali.img resize2fs /storage/emulated/0/kali.img -----------------> 新增 1000M 上面的代码每输入一次磁盘空间就会增加1000M 9.2.2. 其他网站： https://magiskcn.com/ magisk中文网 9.3. 没有源码---刷入Magisk获取root权限 https://zhuanlan.zhihu.com/p/90965580 如何用magisk root 跑着android 13的pixel https://juejin.cn/post/7074400963750002718 Android 刷机与ROOT流程整理 https://magiskcn.com/ 小米手机安装面具教程（Xiaomi手机获取root权限） 9.4. AS 模拟器的su权限 模拟器不存在boot.img，也不存在fastboot模式 ----------- > 所以，比较特殊 核心： 9.5. 方法三：借用能力---借有root权限进程的能力 适用场景： 应用自己写的，有源码 应用把要做的事情，socket给到 参考： https://blog.csdn.net/hunter___/article/details/103867021 https://www.jianshu.com/p/dce099c7cf92 使用socket赋予app root权限 9.6. 方法三：回避su权限 适用场景： 某些情况，代码执行不是必须的（不需要实时性的） -------> 以手动进入sh 替代 代码执行 例子： deploy.apk --------> 手动执行 linuxdeploy 的shell 命令 9.7. su权限的验证 private void myTEST() { ProcessBuilder pb=new ProcessBuilder(\"/system/bin/sh\"); //java.lang.ProcessBuilder:Createsoperatingsystemprocesses. pb.directory(new java.io.File(\"/\"));//设置shell的当前目录。 try{ Process proc = Runtime.getRuntime().exec(\"su\"); //Process proc= pb.start(); //获取输入流，可以通过它获取SHELL的输出。 java.io.BufferedReader in=new java.io.BufferedReader(new java.io.InputStreamReader(proc.getInputStream())); // 返回error信息 java.io.BufferedReader err=new java.io.BufferedReader(new java.io.InputStreamReader(proc.getErrorStream())); //获取输出流，可以通过它向SHELL发送命令。 java.io.PrintWriter out=new java.io.PrintWriter(new java.io.BufferedWriter(new java.io.OutputStreamWriter(proc .getOutputStream())),true); out.println(\"pwd\"); // out.println(\"ls -la\"); out.println(\"su root\");//执行这一句时会弹出对话框（以下程序要求授予最高权限...），要求用户确认。切换root用户 out.println(\"cd /data/data\");//这个目录在系统中要求有root权限才可以访问的。 out.println(\"ls -la\");//这个命令如果能列出当前安装的APK的数据文件存放目录，就说明我们有了ROOT权限。 out.println(\"exit\"); //proc.waitFor(); String line; while((line=in.readLine())!=null){ System.out.println(line);//打印输出结果 Log.d(TAG, \"cg, out: \" + line); } while((line=err.readLine())!=null){ System.out.println(line);//打印错误输出结果 Log.d(TAG, \"cg, error: \" + line); } in.close(); out.close(); proc.destroy(); }catch(Exception e){ System.out.println(\"exception:\"+e); Log.d(TAG, \"cg, error: \" + e); } } 9.7.1. 参考 https://blog.csdn.net/m0_38036918/article/details/130346508 如何给Android Studio模拟器安装Magisk https://github.com/newbit1/rootAVD 10. linux文件权限以及 chmod 严重参考： 非常好的文章：https://blog.csdn.net/enderman19980125/article/details/110439456 Linux 的文件权限和 chmod 命令详解 11. 格式 点击展示 隐藏 / console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Andriod/模型.html":{"url":"Andriod/模型.html","title":"模型","keywords":"","body":"1. 目录2. 为什么模型是重要的？3. 模型的收集3.1. 安卓设计主线程改变UI的目的----------------避免加锁3.2. 锁模型 为什么模型是重要的？ 模型的收集 安卓设计主线程改变UI的目的----------------避免加锁 锁模型 1. 目录 2. 为什么模型是重要的？ 因为模型是结构性的： 稳定、本质 --------------> 看到结构需求，便可以想到对应解决的模型 3. 模型的收集 3.1. 安卓设计主线程改变UI的目的----------------避免加锁 3.2. 锁模型 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/":{"url":"coding/","title":"Coding","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_computorBase/":{"url":"coding/0_computorBase/","title":"0 Computor Base","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_computorBase/DesignPattern.html":{"url":"coding/0_computorBase/DesignPattern.html","title":"Design Pattern","keywords":"","body":"1. 目录2. 0层3. 面向对象设计的 目标：4. 总体目标：高内聚，低耦合5. 六大 设计基本原则：5.1. 单一职责原则SRP：5.2. 开放封闭原则OCP：5.3. 里氏替换原则LSP：5.4. 依赖倒置原则5.4.1. 安卓例子 drawable5.5. 接口隔离原则5.6. 迪米特法则5.6.1. 符合迪米特法则的设计模式 TODO：6. 设计模式6.1. 创建型模式6.1.1. 单例模式 TODO6.1.2. 简单工厂模式6.1.3. （普通）工厂模式6.1.4. 抽象工厂模式6.1.5. ------比较 简单、普通、抽象工厂模式-----6.1.6. 建造者模式（生成器模式）---重点6.1.7. 原型模式 TODO6.2. 结构型模式6.2.1. 代理模式6.2.2. 适配器模式6.2.3. 装饰器模式 TODO6.2.4. 组合模式6.2.5. 桥接模式6.2.6. 享元模式6.2.7. 外观（门面）模式 TODO6.3. 行为型模式6.3.1. 责任链模式6.3.2. 中介者模式6.3.3. 观察者模式 TODO6.3.4. 迭代器模式6.3.5. 状态模式6.3.6. 策略模式6.3.7. 模板方法模式TODO6.3.8. 例子：6.3.9. 命令模式 TODO6.3.10. 访问者模式 TODO6.3.11. 备忘录模式--->状态保存6.4. 其他设计模式6.4.1. 生产者-消费者模式7. =======其他设计思想==========8. 设计思想的大道9. 回调9.1. SetLinsterner与set(this)区别：9.2. 代码层面的设计---------cpp的callback与java的比较9.2.1. 相同点：9.2.2. 不同点：10. 分层设计思想11. 配置 与 框架 分离思想：12. 内外接口分开思想：13. 第一性原理之---------扩展性（弹性）14. 扩展性之-----------反射15. 背后的背后：思考设计模式的维度16. 软件总结17. 视频教程 & 参考链接18. uml18.1.1. 分两类：静态图、动态图18.1.2. 关系表达18.1.3. 类的表达18.1.4. 接口的表达 0层 面向对象设计的 目标： 总体目标：高内聚，低耦合 六大 设计基本原则： 单一职责原则SRP： 开放封闭原则OCP： 里氏替换原则LSP： 依赖倒置原则 安卓例子 drawable 接口隔离原则 迪米特法则 符合迪米特法则的设计模式 TODO： 设计模式 创建型模式 单例模式 TODO 懒汉式 饿汉式 双重检锁(推荐) 静态内部类实现单例模式(非常推荐) 安卓代码中的单例模式 何时会使用单例（场景）？ 参考： 单例模式的线程安全问题 -----单独讨论 简单工厂模式 与建造者模式的区别 采用反射机制，可以解决开闭原则？TODO java中的例子TODO 简单工厂问题/特征： 一个具体工厂，生产多个具体产品 （普通）工厂模式 jdk中的应用： 普通工厂问题/特征： 一个具体工厂，生产一个具体产品 安卓工厂模式的应用: 抽象工厂模式 安卓中的例子： TODO 普通工厂特征： 一个具体工厂，生产一个具体产品 ------比较 简单、普通、抽象工厂模式----- 建造者模式（生成器模式）---重点 关于builder的线程安全 TODO 与工厂模式的区别: 安卓建造模式的应用1：从JDK的StringBuilder 安卓建造模式的应用2：AlertDialog 原型模式 TODO 结构型模式 代理模式 安卓代码的例子 适配器模式 安卓代码的例子 装饰器模式 TODO 组合模式 桥接模式 代码中的列子 享元模式 安卓中的享元模式的例子： 享元模式之 安卓 msg 安卓检测工具：profiler检测内存抖动 外观（门面）模式 TODO 行为型模式 责任链模式 安卓代码中的 责任链模式： 中介者模式 安卓例子： TODO: 观察者模式 TODO 迭代器模式 java 的例子 状态模式 安卓例子 TODO 策略模式 与状态模式的不同： 安卓代码的例子 TODO 模板方法模式TODO 例子： 例子： 命令模式 TODO 访问者模式 TODO 备忘录模式--->状态保存 其他设计模式 生产者-消费者模式 代码例子： 面试问题： =======其他设计思想========== 设计思想的大道 回调 SetLinsterner与set(this)区别： 代码层面的设计---------cpp的callback与java的比较 相同点： 不同点： 分层设计思想 配置 与 框架 分离思想： 内外接口分开思想： 第一性原理之---------扩展性（弹性） 扩展性之-----------反射 背后的背后：思考设计模式的维度 软件总结 视频教程 & 参考链接 uml 分两类：静态图、动态图 关系表达 接口的实现： 两种表达 依赖关系： 关联： 聚合 组合 类的表达 接口的表达 1. 目录 2. 0层 参考： https://www.youtube.com/playlist?list=PLGmd9-PCMLhb16ZxeSy00qUsBazXgJyfM GoF（Gang of Four），中文名——四人组 注意： 很多原则核心都是抽取共同的！！！！ 抽象：面向对象的六大原则 ----> 具体应用：设计模式 关于分类，为啥设计模式是三类，记忆： 关于设计模式的三种类型，其实就是说的建筑： 建筑零部件（创建型模式）、链接节点（行为型模式）、最终结构（结构型模式）————》自然，必然如此，面向对象 3. 面向对象设计的 目标： 1、 可扩展性 ：容易添加新的功能 2、灵活性 ：修改一个接口，不影响另一个接口的功能 注意：整个设计模式/设计原则的出发点都是可扩展性，即日后方便修改 也就是说，如果 日后不需要演进（修改、新增、删减），那么就不需要 设计模式/设计原则了 时刻提醒自己，从演进的角度看代码 4. 总体目标：高内聚，低耦合 对象的要求！！！！！！ 5. 六大 设计基本原则： 由目标产生了具体的 原则： 记忆： 5.1. 单一职责原则SRP： 例子： CustomerChart既查找数据库，又显示图表displayChart() => 问题：当数据库发生变化时，需要修改find方法= 用的哪个数据库 ，本来跟图表是没有任何关系的！！！！！ 一句话 ：find不是图表的方法，图表只关心数据及数据的展示！！！！！！ 抽取出find方法 抽取后：---->职责更单一 5.2. 开放封闭原则OCP： 对扩展开放，对修改封闭 例子： 如果每 新增一种char， 需要修改manager和新chart两处的代码！！！！！------> 扩展时，修改了原有代码，违反了开闭原则 方法： 抽取displayer方法到基类，manager.display() 方法入参为基类！！！ uml图： 扩展遇到的问题：现在要增加一个PieChart，自然要修改 Manager(增加依赖) 解决问题的方法： 抽取display作为 基类： 上述uml的生活化模型： 墙里电线（manager）如果直接依赖于 各种电器（各种chart），一但新增或者删除，必然影响到墙里电线（manager与chart之间的依赖）。 解决办法： 在两者之间加上一个无限大的 插座（抽象接口 BaseChart）。 需要新增电器就直接插入就好，不需要改动任何东西。 这就是把依赖于 具体对象 改成依赖于接口的好处 新增一个类时，原来所有代码不需要动！！！ 开放封闭，一句话总结： 从uml角度：依赖于多个具体 ------》 变为 依赖于 多个具体的抽象基类（扩展时，基类就可不修改）。扩展没有修改的本质原因：依赖于抽象基类 从代码形式角度： 向上提取公因式（公因函数）----> 向上提取为抽象基类 这也就是，java代码有那么多抽象基类的原因。 TODO: 一个类的 不同函数中相同部分，也可以提取公因式 5.3. 里氏替换原则LSP： 好的参考： https://blog.csdn.net/Weixiaohuai/article/details/102510273 一句 总结： 里氏替换原则，子类可以替换父类，程序不会发生行为的变化 （自然，推论：满足里氏原则，子类之间也可以替换） 一句话，本质： 里氏替换原则 希望父子之间 只有复用，没有覆写（自然，覆写抽象方法除外） 从代码运行角度：希望运行的永远是父类的代码，这样，就不存在 子类互换风险。 基于本质，我们的做法是： 1、子类中可以增加自己特有的方法，不覆写 2、如果子类实在要覆写 就把要覆写的函数提出为抽象基类（基类抽象方法）（自然，原先父子公共方法也提取至抽象基类） 原先父子都继承这个抽象基类 -----> 即：父子关系 转变为 兄弟关系。。。。强行不覆写 从代码形式上来看： 就是将 覆写的方法，提取成为 抽象基类 -----> 提取公因式 成为抽象基类 （所以，java抽象基类多） 提取公因式角度：一句话总结开放封闭原则与里氏替换原则： 都是提取公因式，形成新的抽象基类 uml角度：EX1 子类一定要父类方法 参见： https://blog.csdn.net/Weixiaohuai/article/details/102510273 需要新增一个ClassA 的子类，而且 ClassB就是一定要有自己的compare，所以会覆写 -----》 提取公因式，孩子变兄弟 uml角度：EX2 子类一定不要父类方法（有时候就见到，子类覆写抛异常，不让调用的情况） 见：https://www.youtube.com/watch?v=DWkggQoxFeI&list=PLGmd9-PCMLhb16ZxeSy00qUsBazXgJyfM&index=6 需要新增一个玩具枪ToyGun 的子类，所以一定不要父类shoot杀人的功能 做法：提取公因式，没得提？？？？ 里氏替换原则的一些推论：https://blog.csdn.net/Weixiaohuai/article/details/102510273 尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承(也就是面向接口和抽象编程)。 5.4. 依赖倒置原则 官方表述： 本质：依赖于抽象 ----》 非常非常基础的原则 例子：一开始将代码写成 妈妈看书 一旦日后演进，妈妈看 报纸。所要做的操作： 1、新增 报纸类 2、修改妈妈对报纸的依赖 ------》 这个修改可以避免掉 通过依赖抽象： 这种设计，后面 新增 妈妈看杂志 。只需要新增杂志类 继承于IReader即可 5.4.1. 安卓例子 drawable 5.5. 接口隔离原则 官方表述： 关注点： 依赖最小的接口 例子：找美女和模特模型 找美女： 后面，找模特，自然不需要 上面 IPrettyGirl 这么复杂的接口 --------》 抽取 IPrettyGirl 中接口，分成两个接口（接口隔离） 记忆： 接口隔离原则即拆分接口 新增一个类，依赖接口的一部分方法。。。。这个时候，根据最小依赖原则，拆分接口 注意： 很多设计原则，都是最小化思想 5.6. 迪米特法则 英文： Law of Demeter 官方表述： 关注点： 即是最少 依赖 原则： 1、从某个类的角度来看，依赖其他类的个数最少。访问其他类的方法也尽量少。 生活化模型， 迪米特吃汉堡包模型： lucy 吃汉堡包，如果自己做，那么依赖 汉堡包，牛肉，vegetable，面包........... 从lucy的角度来看： 这个依赖的类 相当多，造成结构关系复杂 证明过程，自然：依照迪米特法则-------》 减少依赖类的个数 ----》 实际上就是减少Lucy的功能，不做汉堡包了（交给其他人做），自己专心吃 ​ -----》 只吃 总结： 1、剥离一部分功能出来（做），形成新的类。可以将原本的依赖个数减少 ​ 代价：新增了类 2、迪米特法则，可以看到也符合单一职责原则 3、如果没有要新增Lily，其实只有Lucy，多依赖没有太大关系 ---------从修改角度 4、生活中，也许Lucy要吃 汉堡包 必须自己做 ------》 但是这是代码，一定可以 抽象出其他人来做的 自然，优缺点： 优点 类间解耦, 弱耦合, 耦合降低, 复用率提高; 缺点 类间的耦合性太低, 会产生大量的中转或跳转类, 会导致系统的复杂性提高, 加大维护难度; 5.6.1. 符合迪米特法则的设计模式 TODO： 6. 设计模式 6.1. 创建型模式 6.1.1. 单例模式 TODO 英文：Singleton Pattern 官方表述： 一个类只有一个实例 自然，不得不， 1、外部各个地方私自构造 问题 --------> 将造方向私有化 2、有个静态方法，实例化 3、线程安全问题 ----->加锁 安卓中的例子： 在Android系统中，我们经常会通过Context获取系统级别的服务，如WindowsManagerService、ActivityManagerService等， 这些服务会在合适的时候以单例的形式注册在系统中，在我们需要的时候就通过Context的getSystemService(String name)获取。 ------> 所以 Context 相当于一个 大管家 优点（依附于 例子）： (1) 内存空间角度：由于单例模式在内存中只有一个实例，减少内存开支，特别是一个对象需要频繁地创建销毁时，而且创建或销毁时性能又无法优化,单例模式就非常明显了 (2) 内存时间角度：由于单例模式只生成一个实例，所以，减少系统的性能开销，当一个对象产生需要比较多的资源时，如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。 (3) 单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作 (4)代码角度： 单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。 ​ 使用对象的好处 缺点： (1) 单例模式没有抽象层，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。 (2) 单例类的职责过重，在一定程度上违背了“单一职责原则”。 (3) 滥用单例将带来一些负面问题，如：为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出； 又比如：在多个线程中操作单例类的成员时，但单例中并没有对该成员进行线程互斥处理。 （4）对于安卓，单例对象如果持有 Context，容易造成内存泄漏（） 懒汉式 饿汉式 双重检锁(推荐) 静态内部类实现单例模式(非常推荐) -对于java，非常推荐这种方式-------------利用了Jvm的线程互斥（很机智） 比如：qing的util 安卓代码中的单例模式 很多manager 只需要一个实例， 比如 1、安卓的 ResourcesManager // public static ResourcesManager getInstance() { synchronized (ResourcesManager.class) { if (sResourcesManager == null) { sResourcesManager = new ResourcesManager(); } return sResourcesManager; } } 2、注意：java侧的 serviceManager 不是 ----> 工具类 ​ native侧的 serviceManager 是单例！！ 何时会使用单例（场景）？ 结合例子体会： （1）调用点，形式上： 当调用点很多 且分散在 非常多个文件里 -------> 比如 context、manager 本质：谁都能随时随地找到大管家 （2） 参考： https://blog.csdn.net/qq_36639105/article/details/126745002 单例模式的线程安全问题 -----单独讨论 1、静态变量方法--------------------java保证（jvm保证）（静态局部变量在 C++ 中具有线程安全的保证） cpp保证（静态局部变量在 C++ 中具有线程安全的保证） ​ ---------> 本质上，利用的语言的线程安全性 最优： （1）本身是懒汉式（调用时，才创建，节省内存） （2）利用语言的线程安全性，没有显示的加锁 规定：只允许使用这种 参考：https://blog.csdn.net/zxf347085420/article/details/129528960 2、饿汉式: ---------> 也是线程安全的（因为单例对象被使用之前就已经创建好）。但是浪费内存 6.1.2. 简单工厂模式 简单工厂模式： 可以根据参数的不同（一个参数）返回不同的实例 专门创建一个类来创建其他类的实例 被创建的实例通常具有共同的父类 生活化模型： 具体工厂：手机工厂 具体产品：HW手机、苹果手机 简单工厂中的角色: 1、抽象产品类 2、产品子类 3、 工厂类 uml： // 抽象产品 abstract class Product{ public void use() { } } // 具体产品A class ProductA extends Product { public void use(){ System.out.println(\"使用了产品A\"); } } // 具体产品B class ProductB extends Product { public void use(){ System.out.println(\"使用了产品B\"); } } class Factory{ // 工厂 ​ public static Product createProduct(String type){ ​ if (type.equals(\"A\")){ ​ return new ProductA(); ​ }else if (type.equals(\"B\")) { ​ return new ProductB(); ​ } ​ return new ProductA(); ​ } } 优点，对比new的形式： （或者说要解决的问题：） 1、把对象的创建交给工厂，客户端不用关注 ---> 建造与使用分离，实现解耦 注意：与建造者模式的区别在于： 工厂模式，客户端只会指定某一个Product，比如 \"A\" ；而 建造者模式，会传入很多参数 缺点：（即是后面要改进的） 基于生活化模型，可见，站在工厂的角度，如果新增小米手机，要修改工厂的代码，违背了开闭原则 自然，工厂模式适用的一些场景(对比直接New): 1、对象的创建过程/实例化准备工作很复杂,需要初始化很多参数、查询数据库等。 ---------》 每次new的时候，创建会用很多行；工厂模式将 创建的复杂代码封装进工厂对象里 2、类本身有好多子类,这些类的创建过程在业务中容易发生改变,或者对类的调用容易发生改变。 从代码形式上，相比于new，其本质： 就是将new的复杂代码，封装 与建造者模式的区别 采用反射机制，可以解决开闭原则？TODO java中的例子TODO 简单工厂问题/特征： 一个具体工厂，生产多个具体产品 所以，新增产品时，违背开闭原则 6.1.3. （普通）工厂模式 英文： Factory pattern 基于简单工厂模式，为什么要有普通工厂模式？ 因为前文提到 前者违背了开闭原则。修改方法：将工厂内部的修改，用继承的方式下沉到子类里：-------》 （注意：这似乎是一个 通用规则：利用 继承方式体现差异化，同时满足开闭原则） 1、自然，下沉后，工厂变抽象工厂（客户依赖抽象的工厂） 2、自然，下沉后，实例化由 工厂子类完成。 从uml，本质： 抽象的工厂生产 抽象的产品；具体的工厂 生产对应的具体的 产品 ----》 记忆，本质： 抽象生产抽象，具体生产具体 客户端用 FactoryA 生产 ProductA 生活化模型： 抽象工厂：手机工厂 具体工厂：HW手机工厂、苹果手机工厂 具体产品：HW手机、苹果手机 基于生活化模型， 优点(比简单工厂模式): 1、符合开闭原则。即需要增加生产小米手机，只需要在新增一个小米手机具体工厂 缺点： 1、太过浪费，一个工厂只能生产一个产品，即 生产手机，就不能生产平板 从代码形式上，相比于 简单工厂，其本质： 一个具体工厂，生产一个具体产品 jdk中的应用： 抽象的工厂Collection生产 抽象的产品Iterator；具体的工厂ArrayList 生产对应的具体的 产品Itr public interface Collection extends Iterable { Iterator iterator(); // 抽象Collection生产抽象Iterator boolean add(E var1); boolean remove(Object var1); } 普通工厂问题/特征： 一个具体工厂，生产一个具体产品 矫枉过正，一个工厂只能生产一个产品 安卓工厂模式的应用: 有什参考： https://blog.csdn.net/weixin_35092037/article/details/117346981 抽象的Activity生产抽象的view。具体的MainActivity生产具体的ViewGroup。 ----》 工厂方法是onCreate 6.1.4. 抽象工厂模式 英文： Abstract Factory Pattern 要解决的问题： 普通工厂模式： 抽象生产抽象，具体生产具体 -------》 那还有什么问题呢？ 原因在于 具体的 FactoryA只能 生产 ProductA ​ 一个产品对应一个具体工厂是很浪费的。比如生产 手机和平板， 是可以在同一个具体工厂内完成（复用相同功能的代码） 优点，相比于普通工厂模式：参考https://www.cnblogs.com/it-deepinmind/p/13283562.html1、 相似的 一类产品族，可以放到一个具体工厂中生产 记忆： 即一个工厂，有多个流水线 缺点： 1、违背了开闭原则：新增产品，抽象工厂和具体工厂（即所有工厂类）都新增了 创建新产品的方法 注意： 如果一个具体工厂，生产的两个产品之间不相似（没有代码复用的可能），比如 生产手机和生产口罩 ----》 应该拆成两个工厂，即使用普通工厂模式 安卓中的例子： TODO 普通工厂特征： 一个具体工厂，生产一个具体产品 介于简单和普通之间，一个工厂能生产相似的一类产品 6.1.5. ------比较 简单、普通、抽象工厂模式----- 参考视频： https://www.bilibili.com/video/BV1524y1y79F/?spm_id_from=333.337.search-card.all.click 6.1.6. 建造者模式（生成器模式）---重点 参考链接： https://blog.csdn.net/nugongahou110/article/details/50395698 ---》 好文：一步一步解释了为啥用建造者模式 https://blog.csdn.net/u011814346/article/details/70312214?spm=1001.2101.3001.6650.15&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-15-70312214-blog-119713865.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-15-70312214-blog-119713865.pc_relevant_default&utm_relevant_index=18 要解决的问题，直接new的问题： 构造函数 把 表达 与 构造绑死了，造成表达不灵活 解释见下 一句话，记忆： 建造者模式解决的就是表达灵活性问题 英文： Builder Pattern 官方表述： 生活化模型： 建造一台电脑：装机人员Builder根据 用户 Client 需求进行沟通。装机人员将电脑的主机划分成各个部件：CPU（必选）、内存（必选）、硬盘（必选）、音响（可选）、鼠标（可选）、鼠标垫（可选） 根据用户的指定各种参数setXXX，装机人员 一把组建build电脑。（再找装机人换内存，不会鸟你了） 建构与表示分离： https://blog.csdn.net/langfeiyes/article/details/124142430 TODO 表示：即用户指定的 CPU（i7）、内存（DDR4 48g）、硬盘500G、音响一个、鼠标一个、鼠标垫不选 即set 构建：装机人员帮忙装机，组装成一台电脑，即build 分离：可见这是两个部分嗯，隔离了： 1、表示set多少个属性，与构建过程完全没有关系。 即： 这样使得同样的构建过程 可以 创建出不同的表现。 2、为什么要隔离？变与不变的相隔离，自然：隔离左边是 剧烈变化的，右边是稳定不变的 直接new 对象 的问题： 做不到 构建与表达 隔离： // https://blog.csdn.net/nugongahou110/article/details/50395698 public class Student { private final int stuId;//必须 private final String name;//必须 private final int age;//可选 private final int gender;//可选 private final int address;//可选 ...//还有很多可选属性 public Student(int stuId,String name){ //【1】 this(stuId,name,0,1,\"\"); } public Student(int stuId,String name,int age){ // 【2】 this(stuId,name,age,1,\"\"); } public Student(int stuId,String name,int age,int gender){ this(stuId,name,age,gender,\"\"); } public Student(int stuId,String name,int age,int gender,String address){ this.stuId = stuId; this.name = name; this.age = age; this.gender = gender; this.address = address; } } 所有的构造方法，都将 表达（参数）与 构造 绑定了，比如【1】要求表达一定有 stuId 和 name 所以new的构造方式问题在于： 表达不灵活了，都被构造函数的参数限定死了 为了表达的灵活性，表示出可选与必选： 【1】表达了必选的含义 【2】表达了age可选的含义，，，但是四个构造函数 远远不够， 应该需要 2的3次方个构造函数 ---》 太多了 这里也说明了：当参数不多的时候，可以用不同构造方法表达灵活性。---》 过多时，只能用builder 适用场景: 其建造的东西, 是由多个东西组合而成(显示上就是多个参数)-----》主要如何组合是由外界决定(工厂模式, 如何组合不是由外界决定?) UML: 代码特征： 建造者模式的格式如下: ·目标类的构造方法要求传入Builder对象 //【】 自然，目标类的构造函数应该是private， 不给外面用。 ·Builder建造者类位于目标类内部且用static描述 ·Builder建造者对象提供内置属性与各种set方法,注意set方法返回Builder对象本身 ·Builder建造者类提供build()方法实现目标类对象的创建 //【】 使用： // 在客户端代码中: new Builder().setA(\"a\") // partA .setB(\"b\") // partB .setC(\"c\") ....... .build() 1、通过把参数一个个set 给builder，然后统一一次 build。 2、Set方法 return this 从生活模型中(从代码可以看出)，build一把做的。 自然：之后再 set 是无效的（再找装机人换内存，不鸟你了。只有build才真正有效），只给了builder，保护了 “不可变对象”的密封性 基于生活化模型优缺点： https://blog.csdn.net/a734474820/article/details/128386628?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-128386628-blog-119713865.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-128386628-blog-119713865.pc_relevant_default&utm_relevant_index=5 优点： 1、良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节； 2、变与不变相隔离。变的部分，有很好的灵活性 2、易于拓展：增加新的具体创建者无需修改原有的内部代码，符合开闭原则。 缺点： 产生多余的Builder以及Director对象，消耗内存； 代码上的优点： 1、建造者模式很好的表达了可选与必选： Builder构造方法是必选。Set方法可选。 ---》 技巧 2、通过build可以很明确的告诉别人，我们的对象已经创建完毕。 代码形式的记忆： 从代码形式上看，先创建了一个内部student类（即builder）。再把这个内部对象赋值给student。---》 这也就解释了为啥setXXX方法有两套。 关于builder的线程安全 TODO https://blog.csdn.net/nugongahou110/article/details/50395698 先new 再校验参数 与工厂模式的区别: 相同点： 1、都是给客户端构造对象的 Builder 跟 Factory 是不是很像？？？ 工厂模式: 客户端代码中，只是指定了 生产哪种产品。大量的参数封装在工厂中？ 建造者模式: 客户端代码中设置了大量参数 建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程。 https://blog.csdn.net/qq_26460841/article/details/119713865 安卓建造模式的应用1：从JDK的StringBuilder 安卓建造模式的应用2：AlertDialog 详细代码： // 使用 AlertDialog.Builder builder = new AlertDialog.Builder(this).setIcon(R.mipmap.ic_launcher).setTitle(\"\") .setMessage(\"\").setPositiveButton(\"确定\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }).setNegativeButton(\"取消\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); builder.create().show(); 为什么用建造者模式呢？其实就是方便用户使用的时候，知道要传哪些参数，方便且正确。 6.1.7. 原型模式 TODO 6.2. 结构型模式 6.2.1. 代理模式 生活化模型： 张三躲到 寺庙里不想见人， 所有事情， 由其管家代理 通知 张三 目的(基于生活化模型)： 控制对对象的访问（站在被代理对象的角度）---》 自然，张三不想被打扰 补充：站在client来看，没啥意义。但对于被代理对象，很有意义，保护了被代理对象 UML: EX1: EX2: 上网代理 和装饰器的区别: 侧重点不同：一个是功能扩展。一个仅仅做一层代理 安卓代码的例子 安卓例子： 1、远程调用AIDL。反推代码： 2、网络服务（跨设备了） 6.2.2. 适配器模式 一句话理解: 适配器模式，就是转换，把不能直接用的数据，转换成能用的。 本质上，是一个不得不的东西 生活模型： 电源适配器。 我想要直流电给手机充电，但是 目前有的是交流电，所以需要一个 适配器，把交流转直流 可以这样表达： 直流电适配器(交流电) ----》 即是直流电 自然，适配器，必然实现输出直流电的接口（抽象接口） 为什么要这样做？不得不的理由是什么？ UML：涉及的角色： 适配器模式涉及了三个角色： ①Target(适配器接口)： ②Adaptee(被适配角色)： ③Adapter(具体适配器)： 实现方式： 即 拥有别人能力的方式，自然： 1、组合方式：Adapter(A_Structure) 即： 把被适配对象放到适配器里 2、继承方式：通过继承，拿到 被适配对象的能力 注意： 使用继承方式时，Adapter extends Adaptee implement Interface ​ -----》可见，Adapter是一个既A又Z的东西 推论：对于继承方式 A extends B ，我们认为 A就是B ​ 组合方式， A(B), B 成为A一个持有的对象 ----》 理解上，化简为：没有B，B的能力都给了A (有点儿向内部类) Z如果想要用Andriod的数据结构，不能直接用。做一个Adapter 转Z可以使用的数据结构 Adapter(A_Structure) 代码EX2： 视频教程：https://www.bilibili.com/video/BV1Hz411e7sA/?-Arouter=story&buvid=XYA50C4AE9D0FD435535889530C0CC38FFE8A&is_story_h5=false&mid=3rb72hWRTB8TwF8P3lhSvg%3D%3D&p=1&plat_id=163&share_from=ugc&share_medium=android&share_plat=android&share_session_id=b529db63-da75-4196-b81b-9ac27310644a&share_source=WEIXIN&share_tag=s_i&timestamp=1675149493&unique_k=jdoUprV&up_id=59546029 EX3：安卓例子 TODO!!!! https://blog.csdn.net/zenmela2011/article/details/124591585 TODO: 适配器模式与装饰器模式区别？ 安卓代码的例子 6.2.3. 装饰器模式 TODO 装饰器模式: 扩功能两种方式: 1、继承方式,在子类中扩展 2、关联方式,把原来的类嵌入到新的类里,比如,把机器人装进箱子,箱子里装上手和脚---》即装饰器模式 静态?动态?为啥更加灵活? 优缺点: 6.2.4. 组合模式 参考： https://www.jianshu.com/p/2ef80f857153 作用： 将类和对象组装成 一个较大的 结构（必定是树形结构） ----> 所以，组合模式，是一种组织的方式 生活化模型： 树进行光合作用 -----》 记忆：组合树 如何组织一棵树？即树干（容器） : 容纳树叶及叶子 整体是树干，局部也是树干 效果： 整体与局部具有同样功能 ------》 不得不：自然：整体和局部有相同的功能和接口 模型推论，自然： 1、树干的方法： 树干是容器，自然，有 管理子元素的方法，add和remove 树干需要向下传递工作，自然，有工作的 方法 2、自然，具体工作光合作用只能leaf 完成；树干 只是向下传递工作，最终传给子元素（子树干和叶子） ​ 自然，树干和叶子都继承 光合作用的接口 uml： 适用范围： 任何可以组织为 树结构的。EX1: 统计全国人数 EX2: 安卓中View 和 ViewGroup 是典型的组合模式 基于模型（创造知识）反推安卓代码： 1、反推1：如何组织一个界面所有控件呢？用树可以 自然 2、反推2：树 可以用 组合模式组织 自然 3、反推3：控件和控件容器用组合模式---> 控件容器 必然有addview，remove 自然 必然有哪些工作方法呢？TODO 符合六大原则哪些： 符合开闭原则？ 6.2.5. 桥接模式 参考： https://blog.csdn.net/qq_16240393/article/details/89304453?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-89304453-blog-103319743.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-89304453-blog-103319743.pc_relevant_aa&utm_relevant_index=1 《Android源码设计模式》之桥接模式 https://www.bilibili.com/video/BV1Pp4y167DG/?spm_id_from=333.337.search-card.all.click&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 五分钟学设计模式.21.桥接模式 https://www.bilibili.com/video/BV1vU4y117qL/?spm_id_from=333.337.search-card.all.click&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 桥接模式的要解决的问题，即使用场景： 多维度变化类，新增时，类暴涨问题。 比如：两个维度：种类 m*n -----》 如果要新增一种，则 文件、类爆炸式增长 例子：华为曲面屏手机类 ----》 明显是两个(三个)维度的类 维度一：水滴屏、挖孔屏、曲面屏 ----》 抽象为 屏幕形式 维度二：华为、小米、vivio ----》抽象为 手机品牌 ------》 类的个数：m*n，新增 oppo的手机，会新增三个类 其实，这个是自然的，因为生活中，就是如此： 华为水滴屏手机P30、华为曲面屏手机Mate30 将抽象与实现分离，使他们可以独立变化。 用组合关系，替代继承关系 疑问： 为什么叫桥接? 两个维度，为什么叫抽象和具体？ 精髓在于，独立开，单独演进；类的个数减少 手段：以组合方式替代继承关系 代码中的列子 6.2.6. 享元模式 字面记忆：原本是多个元素，现在共享一个元素 -------享元 英文： Flyweight Pattern 生活中模型： 共享单车----即享元 好处：减少了整个社会的资源开销（只有一辆车） 特征：原本应该是两个对象，现在一个对象，被重复使用了（自然，对象内部包裹的内容，是变化的） 特别 注意：享元隐含着的意思/前提条件：原本应该是两个对象 ----> 比如：妈妈使用家里的锅，我使用家里的锅。这个锅本身就应该是一个，家庭级别的。所以，不是享元模式 uml图： 三个角色的理解： 1、共享单车模型：车子：享元、 车的其userName：不可共享的 -----------> 两者共同 组成 client 所使用的车 享元工厂：美团 2、安卓msg msg 空的对象：享元 msg 内的各种属性值：不可共享的 -----------> 两者共同组成 msg 从信息的角度看，享元模式的 精髓： 更新对象里的数据，不更新对象本身 优点： 可以极大的减少创建对象的数量，使得相同或者相似对象在内存中只保留一份。 即1、可以大大节约内存资源和系统开销 2、对于快速频繁创建的对象，解决了内存抖动问题 享元模式的缺点： （1）为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。 （2）享元模式需要额外维护对象缓存池。 使用场景： 1、 2、短时间内频繁创建的对象 安卓中的享元模式的例子： java：字符串常量、线程池、 安卓：Messege、recycleView复用机制、手机相机预览图片(跟recyleView好像) ​ 对象池（parcel、Messege、） 享元模式之 安卓 msg 享元模式：对于快速频繁创建的对象，解决了内存抖动问题(即 Memory Churn 问题) 参考： https://blog.csdn.net/zenmela2011/article/details/125070508 现象： 频繁创建对象（内存迅速攀升）---> 达到一定临界程度，又会触发GC（内存使用迅速减小）---》之后又，，，，，， 即短时间内造成内存使用的迅速攀升于迅速衰减 例子： msg、binder、如果在view.onDraw里创建对象（每次重新绘制都会触发，16.7ms一次） 大循环里创建对象 原理： 短时间(抖动)内产生一批 使用一次的对象，会被分配内存，当数量达到一定的时候，垃圾内存会触发GC，------》 这一刻，就会骤减 内存抖动的危害： 总之，时间上，空间上 1、内存抖动伴随着频繁的GC，而GC有一个特性，就是STW(stop the world)，STW就会使程序（表现为界面卡顿）出现卡顿。(GC会占时间) ----》 根本原因：不能频繁的GC，GC 会占用时间2、导致OOM： 抖动太厉害的时候，此时如果新建一个大对象（比如5M）时，就会出现内存溢出OOM（内存碎片会造成无法提供连续的内存空间） -----》 根本原因：内存抖动会产生内存碎片 安卓 msg 复用具体代码： // Message.java void recycleUnchecked() { what = 0; arg1 = 0; arg2 = 0;// 数据置空 synchronized (sPoolSync) { if (sPoolSize 所以，msg存在两个 链表： 一个通过表示 queue 另一个sPool，是对象池 安卓检测工具：profiler检测内存抖动 可截取某段时间进行对象分析，查看哪些对象被频繁创建。---》 TODO: 实操一下 解决办法： 1、大循环引起的内存抖动，解决办法就是将对象创建放到循环外， 2、对于无法避免的创建对象情况，可采用对象池模型进行缓存，复用对象，需注意用完后要手动释放对象池中对象 3、其他： https://blog.csdn.net/m0_64420071/article/details/127303447?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-127303447-blog-125070508.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-127303447-blog-125070508.pc_relevant_recovery_v2&utm_relevant_index=10 6.2.7. 外观（门面）模式 TODO 6.3. 行为型模式 6.3.1. 责任链模式 生活化模型： 请假责任链：张三请假，根据请假不同的天数，不同人去审批 一句话记忆： 责任链，本质就是处理链 明显的特征： 1、有链条（责任链可能是一条直线，一个环链或者一个树结构的一部分。） 2、真正的处理者，只会是链条上的某一个 官方表述： 责任链模式是一种处理请求的模式。他让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链。然后让请求在链上传递 UML： 特征，有链条 next 注： 无论啥模式，都尽量依赖抽象 代码： 优点: 从请求者角度：将请求者和处理者分开（原来是依赖关系）请求者不需要知道处理者。处理者也不需要知道请求者全貌。 ----》 自然提高系统灵活性 新增一个处理器到链条中的代价是非常小的 缺点： 也比较明显，就是他会降低整个系统的性能，因为处理者可能最坏的情况可能处于链条的末尾 安卓代码中的 责任链模式： 参考： https://mp.weixin.qq.com/s/sSPFz3E5gncYiMMFtF_xlg 好文 从责任链模式看Android事件分发 事件分发中的责任链模式 (外层责任链) TODO : 指的是input 事件那一套 事件处理中的责任链模式（内层责任链）: Activity -> PhoneWindow -> DecorView -> ViewGroup -> …View （在view段，是沿着树形结构分发的） 安卓的高超优化： ------------- mFirstTouchTarget 责任链 背景： 上述讲的是一个事件分发 （树责任链），但是 真正的 事件是事件流：1个 ACTION_DOWN、n个 ACTION_MOVE、1个ACTION_UP 引入的问题： n+2 个事件，沿着 树分发，复杂度太高 解决办法：第一个ACTION_DOWN事件的分发，会找出一个 分发线路（即给 mFirstTouchTarget 赋值）。后面同一事件序列的ACTION_MOVE、ACTION_UP 都按照这个线路分发（【1】） 这个分发线路即图中 mFirstTouchTarget 单链表 （这本身就是责任链模式） 【1】这个逻辑，其实也是符合生活尝试的，比如 TODO 总之： 安卓事件分发机制： 是双责任链模式（树责任链 + 链表责任链），见图 从代码中总结： 1、责任链不一定是单链表 2、分发流程 天然适合责任链 6.3.2. 中介者模式 英文： mediator pattern 生活化模型： 飞机降落模型： 多架飞机 ------> 存在的问题， 每两个对象之间都存在联系 即 多对多的关系 中介者模式： 飞机角度： 通过一个中介对象 转化为 一对多 从中介角度： 是调度者 基于生活化模型，自然： 优点： 降低类的关系复杂度，将多对多转化成一对多，实现解耦。 自然 符合迪米特原则（最少知识原则） 缺点 中介者要做很多事，会变得庞大且难以维护。 官方表述： 中介者模式是一种行为设计模式，能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使他们通过一个中介对象进行合作 优缺点： uml： ConcreteMediator：具体的中介者角色 安卓例子： TODO: 6.3.3. 观察者模式 TODO 6.3.4. 迭代器模式 迭代器模式是一种行为设计模式,让你能在不暴露集合底层表现形式(列 表、栈和树等)的情况下遍历集合中所有的元素。 接化发 希望对集合类，有统一的迭代接口，方便人使用 for (String str : set) { } // 集合类（Set或list），是一个可迭代对象： 必然持有迭代器 public interface Iterable { Iterator iterator(); // 返回迭代器 } // 迭代器接口： public interface Iterator { boolean hasNext(); E next(); remove(); } uml： 可迭代 持有 迭代器 理解：迭代器的本质就是遍历元素 不同的迭代器 遍历算法不同，比如：深度优先遍历和宽度优先遍历 java 的例子 集合类 set List Collection实现了 Iterable 接口 如何使用迭代器 public class RunoobTest { public static void main(String[] args) { ArrayList sites = new ArrayList(); sites.add(\"Google\"); sites.add(\"Runoob\"); sites.add(\"Taobao\"); sites.add(\"Weibo\"); for (String i : sites) { // 背后使用了迭代器 System.out.println(i); } } } 6.3.5. 状态模式 生活化模型： 不同状态下做的工作不一样。比如： 高兴 ---》 工作认真。 被人打了心情难过 ---》 不工作 饿着肚子---》无精打采的工作 本质： 封装转化，即状态 到 行为的转化 UML： 优缺点： 优点，（相比于不用状态模式）： ①将繁琐的状态判断转换成结构清晰的状态类族，在避免代码膨胀的同时也保证了可扩展性和可维护性。 ②体现了开闭原则和单一职责原则，每个状态都是一个子类，要增加状态只需增加子类，要修改状态只需修改一个子类即可。 ③符合迪米特法则。 缺点：会增加系统类和对象的个数。 ---》 似乎是一个通用的法则：通过增加类来减小系统的复杂度。 代码 从代码形式角度，本质：参考：https://blog.csdn.net/zenmela2011/article/details/126508765 把if else用多态继承的方式来实现。 与策略模式的不同点： 见策略模式。 安卓例子 TODO 6.3.6. 策略模式 生活化模型： 上班模型：针对于去公司这一件事情，封装算法，客户端不关心算法实现细节 开车去（算法1：取车、停车、开车的路线，红绿灯、停车地点） 坐公交车（算法2：查找公交线路，公交站点。走路去公交站点，下公交） 骑车（算法3：） 走路（算法4：） 记忆： 达到同一目的 的不同策略。 官方表述： 注意，1、可以相互替换（自然，~因为各个策略都干了相同一件事情，去公司） 2、好处，算法可以独立于客户端而变化。（优点：如果没有封装，客户端是要 实现具体算法的，则耦合） 优点， 相对于没有封装算法的做法： 见上 缺点： UML： 与状态模式的不同： uml两者一模一样 不同点： 1、关注点不同： 状态模式的关注点：关注点在于转化，状态到行为的转换。不同状态下不同行为。一个状态下，可能有不同的行为。 ​ -----》 例子：今天状态是不开心，转化为行为：不想学习，不想吃饭，不想工作，只想睡觉 策略模式的关注点： 关注点在于封装一组算法，将每一种算法都封装到具有具体类中 ​ -----》 例子：打游戏。我是自己玩儿还是找朋友玩儿？还是找陪玩儿 2、目标不同： 策略模式的行为是可相互替换的（因为不同策略都干成了同一件事情）----》 即不同策略，目标相同。 状态模式 的不同行为，基本上不是干同一件事情 ----》 不同状态，行为不同，目标也不同。 安卓代码的例子 TODO jdk中例子： 代码： 6.3.7. 模板方法模式TODO 生活化模型, 读书模型： 幼儿园、小学、中学、大学… ------> 抽象 每个人的经历都是特别的… ------> 具体 UML: 参考： https://blog.csdn.net/weixin_39578432/article/details/118553952 例子： 6.3.8. 例子： 安卓的Actvity的生命周期： onCreate onStart onResume onPause onStop onDestroy -----》 操控了Activity 的一生 6.3.9. 命令模式 TODO 6.3.10. 访问者模式 TODO 6.3.11. 备忘录模式--->状态保存 6.4. 其他设计模式 非 GOF提出的23种设计模式 6.4.1. 生产者-消费者模式 英文： producer-consumer 生活化模型： 机场工作人员（生产者线程）-----机场传送带（缓存队列） --取行李的乘客（消费者线程） 行李（数据，比如msg） 由生活化模型，该设计模式需要满足以下三点要求： （1）自然，生产者生产数据到缓冲区中，消费者从缓冲区中取数据。 （2）自然，如果缓冲区已经满了，则生产者线程阻塞；---》安卓如何做的？ （3）自然，如果缓冲区为空，那么消费者线程阻塞。---》安卓epoll 生活化模型，自然优点： 1、数据的传递是解耦的 2、支持并发 ------ 多个工作人员同时 往 传动带投递行李 3、支持忙闲不均 代码例子： EX1: ui线程产生绘制数据 ---> render线程去消费 EX2: input？？ EX3: 安卓Handler 参考： https://carsonho.blog.csdn.net/article/details/121468054?spm=1001.2014.3001.5502 https://blog.csdn.net/haigand/article/details/90551070 https://zhuanlan.zhihu.com/p/73442055 经典并发同步模式：生产者-消费者设计模式 面试问题： 单生产者和单消费者共同操作同一个消息队列需要加锁吗 https://www.cnblogs.com/codingmengmeng/p/14420573.html 答案：不需要 7. =======其他设计思想========== 好代码设计原则：－－－－＞举例子，所有代码的设计原则，给出总结 1、模块分层合理，类职责清晰，代码可读性强，注释规范 2、模块具有过载流控能力，支持非法输入校验和外部输入防御性拷贝，可靠性强；-----＞状态保存机制，在AZ转换地方，做了大小校验 3、所有参数采用动态配置项，可扩展性强； 4、消息处理过程中，减少不必要的内存复制与对象实例化操作，支持系统高并发； 8. 设计思想的大道 设计之代码尽量模糊：因为模糊，所以扩展性强（新增接口，新增代码量小） 模糊例子： 依赖于抽象接口 序列化成byte，各个流程都认识 目标：扩展性强 -----------> 手段：代码模糊 9. 回调 9.1. SetLinsterner与set(this)区别： 都是用于回调类似的操作 设计模式上，一般希望单项依赖。 好处：层级关系明确 linsterner与this区别： linsterner比较固定，大部分时候实现接口，固定不变。。。。这样，this其他部分改动，不影响B的开发 9.2. 代码层面的设计---------cpp的callback与java的比较 9.2.1. 相同点： 理解：callback只是 调用方向（与代码无关，不是类，只是表达方向） 9.2.2. 不同点： cpp有函数类型 ------> 用函数类型不同 来区分 （包装）参数类型的不同 java没有 函数类型 ------> 用类的类型不同，来区分 （包装）参数类型的不同 回调传回不同的参数类型： 1、cpp实现： int getPriorityByName(const std::string& serviceName, std::function callback) //【1】 int getServiceName(const unit32_t& procId, std::function ca11back); //【2】 java实现上述效果: java实现上述效果: public interface StringCallback { void onStringCallback(String result); // 【】不同的类来约束，不同参数 } public interface IntCallback { void onIntCallback(int result); } public class CallbackHandler { public void registerStringCallback(StringCallback callback) { // 处理回调 callback.onStringCallback(\"String result\"); } public void registerIntCallback(IntCallback callback) { // 处理回调 callback.onIntCallback(123); } } public class Main { public static void main(String[] args) { CallbackHandler handler = new CallbackHandler(); // 使用StringCallback handler.registerStringCallback(new StringCallback() { @Override public void onStringCallback(String result) { System.out.println(\"String callback result: \" + result); } }); // 使用IntCallback handler.registerIntCallback(new IntCallback() { @Override public void onIntCallback(int result) { System.out.println(\"Int callback result: \" + result); } }); } } cpp优点：很显然，cpp简洁许多 根本原因： cpp函数类型表达的强大： （1）编译约束角度： 系统侧 约束 接口调用者填充 （2）函数即类，即类型 -------> 不同的function类型，以区分不同的返回值类型，比如int值返回，string值返回 注：所以，函数（类）可以返回多个，不同的参数 -----------------> 总之，一句话: cpp有函数类型 ------> 用函数类型不同 来区分 （包装）参数类型的不同 java没有 函数类型 ------> 用类的类型不同，来区分 （包装）参数类型的不同 /【1】次要的补充： int getPriorityByName ----------> 直接返回的Int不是跨进程的 callback返回的 int result 才是跨进程的 10. 分层设计思想 见《0层结构---一次Binder通信》 11. 配置 与 框架 分离思想： 1、框架 强制约束 配置 2、配置可以放置的位置 （1） 差异封装在哪里（即如何区分）：-----------配置封装在哪里 将差异封装在类中（用不同类来区分不同）： triangle、rectangle ​ -------> 对于c语言来说，封装在map（map每一行代表一个类： string、函数指针等不同） 将差异封装在函数中（用不同函数区分不同）。switch case （2） 框架侧 强制约束 配置侧： 比如：生命周期的强制约束----------大的AMS循环，强制约束 配置侧的onCreate() ​ 继承 强制约束 各个子类（配置侧） 实现抽象方法 ​ 接口的入参的抽象（框架侧） 强制约束 调用者（配置侧） 必须实现抽象参数。比如 TODO： EM的 ​ coding时，原则： 尽一切可能将配置放到一起，不要零散在代码各个地方！！！！！！！ 框架追求通用化（后续无需改代码），配置追求聚集化 最理想状况：代码全是框架机制，配置全在xml、txt等配置文件里!!!!!!!!! 12. 内外接口分开思想： 例子： 安卓系统服务的设计 // wms mIWindowManager = IWindowManager.Stub.asInterface( // 外部接口 ServiceManager.getService(Context.WINDOW_SERVICE)); mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class); //内部接口 ---> 形式化统一 TODO ！！！！！！！！： 这样确实很好。但是具体、精确的好，在哪里 13. 第一性原理之---------扩展性（弹性） 扩展性的标准： 每新增一个接口（类）的适配工作量 14. 扩展性之-----------反射 -反射，可以实现的功能（或者 为啥要用反射）： （1）从编译角度，可以避开编译约束: 私有，不可见 （2）从代码角度, 可以实现 统一，大量简化代码量（一行代码，可以new 出各种类）-------> 语言，架构层面 （3） 从功能角度：同（1） (4) 从代码 扩展性、弹性角度： 反射有着非常好的弹性。比如，新增一个MyView，xml解析器创建view的代码，不需要改动一行 安卓源码中反射的场景： XML ------> 类： new view() byte --------> 类： 反序列化创建 parcelable，使用到的Creator 参考：android对象序列化Parcelable浅析 - xerrard - 博客园 (cnblogs.com) https://www.cnblogs.com/xerrard/p/5144386.html ---------------> 总之: （1）都是从二进制 到 类的过程 （2）一般都是很多个类-----> 反射，大量简化代码量！！！！！！ 必然： 既然安卓都可以从xml和byte可以反射出安卓对象 ----------> 必然也可以: (1)来源于Z的数据，反射成安卓对象 (2)来源于Linux二进制数据，反射成安卓对象 如何做？---------> 既A又Z，既A又L，节省链路的长度 但问题： 安卓对象和Linux对象数据不对等？ 办法： 没有关系。部分序列化与部分反序列化。 15. 背后的背后：思考设计模式的维度 生活化模型、一句话理解、uml（涉及的角色）、为什么要这样做？不得不的理由是什么？、解决什么问题、应用场景、应用范围 有缺点（和....对比的优点），比如：对于new的形式： 设计模式，一定是站在某一个类的角度考虑的问题。站在哪个对象角度去看（比如代理模式，站在client来看，没啥意义。但对于被代理对象，很有意义，保护了被代理对象） 安卓例子、如何用设计模式反推安卓代码(创造知识) 和。。。设计模式的区别 明显的特征（如何从代码中识别何种设计模式？） 16. 软件总结 1、不让开发者用的接口，但是又对外了， 最好是抛异常---->这样开发者能感知到 Log.error不容易感知到 17. 视频教程 & 参考链接 https://www.bilibili.com/video/BV1PJ411y7iL/?p=7&spm_id_from=333.880.my_history.page.click 骆诗琪 https://www.bilibili.com/video/BV1hK4y1L7zV/?spm_id_from=333.788&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 子烁爱学习 18. uml 18.1.1. 分两类：静态图、动态图 静态图： 动态图： 状态机 18.1.2. 关系表达 接口的实现： 两种表达 依赖关系： 使用关系《用到了 use a！！！！ 代码中的临时变量、入参、import 尽量不要相互依赖 关联： ​ 记忆之 锚：具体分为两种：有+同生同死、有+非 。。。。 有或者包含（has a 或 contains a） 即代码中的成员变量 关联关系可以继续分为： 聚合 ----->记忆：关联符号尾端， 空心 has a 整体与部分关系 组合 ---->关联符号尾端，实心 contains a 同生同死 18.1.3. 类的表达 18.1.4. 接口的表达 尽量用label形式？？？ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_computorBase/HowToReadCode.html":{"url":"coding/0_computorBase/HowToReadCode.html","title":"How To Read Code","keywords":"","body":"1. 目录2. 写在前面3. 待整理TODO:4. 理解代码架构4.1. 功能是架构的终极目的4.2. 代码就是一片很多岔路口的森林4.3. 为什么我记不住代码？4.4. 多画0层图、1层图4.4.1. 画结构图技巧：4.5. 0层之纵向运行时0层4.6. 0层之子系统间关系图4.7. 0层之模型图/结构图4.8. 0层时序图4.9. 1层之核心类图+作用4.10. N层之核心类继承关系4.11. N层之模型图拆解（注释）4.12. N层之基础设施4.13. N层之使用4.14. TODO:其他4.15. 自然法则：4.16. 给出0层设计、一层设计、二层设计4.17. 更深的理解来源于本质的实现4.18. 用面向对象的语言去描述事情！4.19. 为什么我不能从代码中抽象出xu的图？4.20. 一些经验：4.20.1. 覆写的作用，4.20.2. 类的本质：4.20.3. 实现了某个接口，即拥有某种能力4.20.4. 工具类4.21. 知全局而做局部4.22. 代码框架的收集4.23. 如何阅读别人的代码4.24. 如何搜索代码？5. 文章TODO: 链到你的文章结构里5.1. gitYUan5.2. 罗升阳5.3. wangyin5.3.1. Talk is not cheap5.4. xu5.5. 以信息流的方式理解代码结构：：5.6. AS 中引入其他盘的java代码作为source5.7. 解bug体会、查找：5.7.1. 看问题，都要正向看+反向看5.7.2. 如何识别一个对象，唯一化？5.7.3. 对于快速变化的问题5.8. 永远不要用模糊性词语，5.9. 思考问题，一定要闭上眼睛5.10. 答案永远在代码之外5.11. 代码脑中简化技巧5.11.1. 0层综述5.11.2. 记忆之房间：5.11.3. 简化之 猜测实现5.11.4. 化简之框架：逻辑上舍弃已知框架5.11.5. 化简之 大概就是、大部分情况就是5.11.6. 化简之包裹5.11.7. 化简之内部类（次要类）：5.11.8. 化简之内部类2（解决java单继承问题）：5.11.9. 化简之同胞类5.11.10. 函数化简之 信息流5.11.11. 函数化简之 return5.11.12. 化简之透传（可大量化简）5.11.13. 化简之合理性（围绕目标的）5.11.14. 化简之目标5.11.15. 化简之if else5.11.16. 化简之名词5.11.17. 化简之类比5.11.18. 化简之 减少逻辑调用链5.11.19. 如何识别模块的主类：5.11.20. 如何识别类的主方法:5.11.21. 化简之解耦思想5.11.22. 化简之设计模式5.11.23. 化简之 功能逻辑 驱动 函数记忆5.11.24. 化简之按功能点拆解（写技术文章方法）5.11.25. 化简之 按照变量抽离5.11.26. 化简之大流程5.11.27. 化简之小函数5.11.28. 化简之函数调用栈Tree5.11.29. 化简之忽略 handler5.11.30. 化简工具 之BookMarks5.11.31. 化简之持有5.11.32. 化简之new bing5.11.33. 化简之 设置的值5.11.34. 跳转化简之AIDL5.11.35. 化简之 不断提取公因式5.11.36. 化简之 删减之特殊情况5.12. 秒解技巧5.13. 常见代码框架5.13.1. TODO: 为什么框架是这个样子？何时要用这个框架？5.13.2. 解决JAVA不能多继承问题5.14. 方法集key (清单)5.14.1. 仅限于代码的方法 list5.14.2. 生活5.14.3. 文章\\文字6. 阅读代码，跳转大总结7. 如何理解魔鬼数字（魔鬼矩阵）8. 格式 写在前面 待整理TODO: 理解代码架构 功能是架构的终极目的 代码就是一片很多岔路口的森林 为什么我记不住代码？ 多画0层图、1层图 画结构图技巧： 0层之纵向运行时0层 0层之子系统间关系图 0层之模型图/结构图 0层时序图 1层之核心类图+作用 N层之核心类继承关系 N层之模型图拆解（注释） N层之基础设施 N层之使用 TODO:其他 自然法则： 给出0层设计、一层设计、二层设计 更深的理解来源于本质的实现 用面向对象的语言去描述事情！ 为什么我不能从代码中抽象出xu的图？ 一些经验： 覆写的作用， 类的本质： 实现了某个接口，即拥有某种能力 工具类 知全局而做局部 代码框架的收集 如何阅读别人的代码 如何搜索代码？ 文章TODO: 链到你的文章结构里 gitYUan 罗升阳 wangyin Talk is not cheap xu 以信息流的方式理解代码结构：： AS 中引入其他盘的java代码作为source 解bug体会、查找： 看问题，都要正向看+反向看 如何识别一个对象，唯一化？ 对于快速变化的问题 永远不要用模糊性词语， 思考问题，一定要闭上眼睛 答案永远在代码之外 代码脑中简化技巧 0层综述 记忆之房间： 简化之 猜测实现 化简之框架：逻辑上舍弃已知框架 化简之 大概就是、大部分情况就是 化简之包裹 化简之内部类（次要类）： 化简之内部类2（解决java单继承问题）： 化简之同胞类 函数化简之 信息流 函数化简之 return 化简之透传（可大量化简） 化简之合理性（围绕目标的） 化简之目标 化简之if else 化简之名词 化简之类比 化简之 减少逻辑调用链 如何识别模块的主类： 如何识别类的主方法: 化简之解耦思想 化简之设计模式 化简之 功能逻辑 驱动 函数记忆 化简之按功能点拆解（写技术文章方法） 化简之 按照变量抽离 化简之大流程 化简之小函数 化简之函数调用栈Tree 化简之忽略 handler 化简工具 之BookMarks 化简之持有 化简之new bing 化简之 设置的值 跳转化简之AIDL 化简之 不断提取公因式 化简之 删减之特殊情况 秒解技巧 常见代码框架 TODO: 为什么框架是这个样子？何时要用这个框架？ 解决JAVA不能多继承问题 方法集key (清单) 仅限于代码的方法 list 生活 文章\\文字 技术文章目录，要呈现代码架构 化简 阅读代码，跳转大总结 如何理解魔鬼数字（魔鬼矩阵） 格式 1. 目录 2. 写在前面 读代码，最核心的核心，在于： 1、识别架构 -------> 从代码中抽出模块。抽象出模块交互图 2、架构的背后 -------> 抛开代码，理解架构的背后，理解交互图的背后 3、了解背后的自然法则 --------> 走向生活 不要将自己限于，知道接口怎么使用，这种low的水平 规定：每一技术文章，必须有的点： 架构 ----> 架构背后的思想 ----> 自然法则，生活化 ----> 基于自然法则的扩展（走向具体） -生活，是理解抽象的 唯一手段 代码亦如是 代码的合理性，永远在代码之外 3. 待整理TODO: 面向对象精髓： 1、对象+关系 （全局视角） 2、入口与出口（个体视角） 代码的精髓：流（小蝌蚪的涌动） 时时刻刻把握住入口和出口！ + 时刻把握位置 + 时刻要有对象的思想（就是一个人！！！！！） 一个模块的入口和出口 一个类的入口和出口 同理，任何系统无非干两件事：输入和输出，接收到外部输入信号后经过操作系统处理后输出信息。 位置： 哪个线程、哪个模块、哪个层！！！！ 看代码，按照功能块来看。。。。比如一个类太大，森林太大=>功能块总是 相对独立的，我们看一个功能块就行。。比如森林里的一块池塘，比如人体的消化系统 识别了类的一个功能块，就ok了，心里不要慌 看代码一定要有层的概念。。。比对象概念高一级 其实有对象的地方，就有层 比如，应用和我们以及内核--------->就是层的概念 提升工程架构思维，软件工程思想都是相通的，境界会得到提升！！！！只要一个领域做到极致， 换新领域你也能做到极致。 好奇心比雄心走得更远：很多人对未来空有满腔的雄心壮志，往往不如对技术要有一份好奇心，一份探索欲，再加上一份执着的人。 思考，问题，好奇心 一个类的主要功能，接口 不要做很详细的笔记，很烂，因为很具体，你根本记不住 干事的进展，要记录下来。这样有叠加性，后期可以追溯。关键写在纸上，可以分析 常常问一下你能说出个123嘛？ 说出123，倒逼你了解细节，以输出倒逼理解 要重视你的话，称呼，反应了你对事物的理解： 比如Z无障碍，你可以把它称为Z无障碍服务（Z的adpter+A的无障碍服务） contentview粒度 systemui，空指针，会重启 lunyin surface是内存，是内存的数据结构，理解为像素 canvas是抽象的画布 client，sendEvent那条路，你没有说清楚 命令的多句并列执行 价值，问题有没有价值,xuji 差异化，改动，才能认识深刻 比如，改变颜色，看看。改动大小 通过问题，熟悉代码很快 冲突，问题，差异化都是好东西 冲突，问题，差异化，不要死磕，先一定思考+求助别人>最后反思成文 调用别人接口， 1、会不会耗时， 2、多线程调用 把握住入口和出口：1、理解代码。2、记忆。3、打log也是。 最好是唯一的入口和出口，任何bug都可以倒逼 出口和入口表现为： 模块的 类的，即public 如何提高调试的效率和精确度？技巧： 1、在log里设置起始标志，之前log的全删 2、所有view里的log，加地址+宽高>区分 对于应用，设置不同颜色 3、分层 分层， 代码，应用与底层，社会 为什么要分层？ 为啥做编写代码时，整一个空的接口？ 1、先搭架子 2、符合计算机思维，拆解问题 3、本质原因：人脑子有限，只能想清楚一个调用frame里的逻辑 注意：上一frame定义了getNextString ------>该接口功能必须定义清楚，下一frame实现起来才清楚 ------->规定：必须文字写上 4. 理解代码架构 4.1. 功能是架构的终极目的 -功能是架构的终极目的，证明了功能对应的实现，才算彻底理解（才能彻底不记忆） 证明！！！！证明！！！！！自然！！！！！自然！！！ 锚点 之 功能（文字性） 我们能轻易记住 功能（大功能、小功能），但是记不住 对应的 大函数、小函数 规定：代码大纲 & 调用栈，只能用作 字典 4.2. 代码就是一片很多岔路口的森林 又如人之间 我们如何认识森林，就如何理解代码 （0）如果有现成的地图----架构图（文档），先看地图 如何理解人物，就如何理解代码。类即是人！！！！ 如何认识一个新类？----->如何认识一个新人？？先看表象： （1）先看长的怎么样：对外接口-------->猜测做啥的，人物关系 对于陌生代码，先画地图，然后跟着地图分析具体过程 画地图---->调用栈+plantUml，可以无脑画 看log，第一步，一定是用空行分层 不要用人脑直接对抗机器 （2）看源码目录结构 为什么输出不了xuji的0层图？？？--->即静态的架构图？？？ 原因在于： 你只走了地图中的一条路，只熟悉了一条路。你看不到其他路是怎么样的 4.3. 为什么我记不住代码？ -------->如何记忆代码 永远不要记代码，因为你也永远无法记忆一片森林，记的是： ​ (1)自己的话！！！！！！！！，而非英文代码 ​ (2)记忆森林中关键路，关键路上的一些关键标志，比如凉亭：要记关键流程的 时序图。注意：记忆时序图，也只是记忆关键类的关键方法（最大限度的抽象，才能成为记忆之锚，理解之锚）。。。 （3）记忆流程按照块来记，模块指定了流程的方向，不得不 规定：一个流程，必须回答： 从进程角度看整个： ​ 进程树中的位置（谁启动，启动谁） ​ 运行态的进程交互、线程交互 核心类是啥，在哪个进程里？？？主要功能是啥？？？有哪些对外接口 =>不要记忆动态的流程！！！ ​ 动态的调用流程太长，你记不住的！！！！！------> 记忆每个类的功能，方向是自然的！！！不得不的！！！！ 做了啥（做事的直接时机是啥？间接时机？与主干哪个时机挂钩？---> 记忆之锚） 业务场景是啥（用户点击等） 入口在哪，交互点 该流程的启动时机 涉及哪几个进程----->即模块架构 模块之间的通信是怎样的？ 有哪些关键流程点 时机：何时新建的？初始化时机比较重要 变量的流转流程 是否是单例？--->为什么要用单例？ 不断去抽象，更高层、更高层、更高层（方向）！！！！！！！=>甚至0层！！更容易记忆 主干的生命周期是啥？（其实任何一个事物都是一个对象，都有生命周期）对象的生命周期，线程的生命周期，模块的生命周期 极度化简 反馈-----------网上搜面试题（相当于课后题） 4.4. 多画0层图、1层图 体会：如果要真正理解一个东西，一定要走向抽象、走向简单、甚至走向忘记。无论是知识、方法、习惯、、、、、、、、 包括画图本身，也是抽象过程：具体代码 ---> N层 ---> 2层 ---> 1层 ---> 0层 注意：没必要N层很熟悉了，再画0层；对于一个新项目，先画0层（根据接口），后期再修正 ​ 对于设计，一定是抽象走向具体：设计0层 ---> 设计1层 --->........具体代码 ​ 封装性，也体现了代码实现过程，抽象到具体：leetcode 在主要函数里，先加空实现函数A(), 之后再实现 记忆与理解的关键做好链接： 0层代码与0层图的链接（其实是映射） 1层代码与1层图的链接（其实是映射） 0层代码与1层代码的链接 0层图与1层图的链接： 链接方向： 实际物体—0层架构-1层架构（0层放大）-1层流程图 TODO: 反过来呢？是不是应该让实际依附0层架构呢？ -规定：0层架构图 一定尽量有方向（方向正确）：比如 事件的0层，上下一定要对！！ -规定： 0层纵向流程，（1）必须依赖于0层结构图 ​ （2）方向必须正确！ -------------------------> 技巧：依赖方向感，来减少记忆！！！！！ -规定：0层时序，必须有方向简化 -规定：研究完0层时序（纵向），必须横向看 -规定：借鉴土木画图的方法，1层架构图必须基于0层架构图，放大版（保证方向和形状不变）！！！！！否则，认为无效 4.4.1. 画结构图技巧： 1、 结构为主+重点信息方向 画图，重点在画方向，关键流程的方向，核心信息的流转方向！！！！大的箭头流动 为什么要这样子？因为信息流动的是要依靠结构流动的 举例子：Y侧graphic图 4.5. 0层之纵向运行时0层 对于多线程的流程，运行时0层，从进程、线程的角度去分析，更本质 ------> 线程结构 + 数据流转 才是 真正意义上的 0层架构，表达了运行时的0层 EX1: ------------------------> TODO: 图不好，方向不对，事件最好上下画 0层需要关注（需要回答的问题）：数据运行在哪个进程的线程 EX2: IMM-IMMS-IMS 之间关系 问题： 图中，以线还是 框 代表线程呢？ 如果以框，一定要在框里区别，这是IMS还是IMS线程！！！！！！ 4.6. 0层之子系统间关系图 0层之子系统间关系，即系统功能划分---->当前模块在整个系统中的位置，与其他的联系 例子1，xu view框架---0层 具体技巧：对于一个新项目，先画子系统间关系（根据接口），后期再修正 例子2： 4.7. 0层之模型图/结构图 我们记忆的是模型，而不是代码实现 面试讨论的也是模型 你要增长的核心能力，也是理解模型能力（更甚者，发展模型，建立模型的能力） 模型的本质就是数据结构(模型是更生活化的语言)： (1)、什么样的模型：一堆数据，如何组织起来 比如，flutter的三棵树 (2)模型承载了啥、主要作用是啥------>从层的角度来看 比如： (2)模型(数据结构)的建立过程 (3) 模型的维护过程 (4) 模型的生命周期 (5)基于模型，分析其他重要流程 问题在于：TODO: 对于现有代码，如何在代码里抽象出最核心的模型？ TODO: 每个子系统都有模型图吗？输入法有吗？ 程序的本质：信息沿着 结构图流动 结构图的缺陷：能展现正常运行态，但是展示不了，搭建结构的过程 补齐能力：0层时序 4.8. 0层时序图 一般时序不是0层。但是需要一个0层时序，串起来整个系统（至少多个子系统）。串起来所有模块，保证所有模块有条不紊。 方式一： A- uiTask- IOTask- GPU Task 方式二（推荐方式）：用思维导图方式 优点： 1、折叠起非1层------> 便是0层大的时序，不会陷入细节: 1层时序a ---> 2层时序a ---> 1层时序b 0层的几个绿色框---->记忆之锚，即使是不能折叠的情况下，也只关注0层的几个绿框关系，锚要牢记 2、展开情况下，又能看到0层与其他层的链接关系。在方式1做不到这一点，要么过于细致，要么只有0层，没有链接其他层 3、很好的契合了人脑的思维+记忆方式：frame + 链接。三个frame + 链接 4、方向性要比方式1好，易于记忆：信息的流动总是 先向右再向下 5、很好地链接了代码 6、折叠性解决了调用栈的复杂性 总之：思维导图画时序图核心在于，善于利用折叠，牢记0层的锚点顺序。 规定：（1）0层时序第一个子主题必须用中文描述，干了啥 （2）看0层时序时，必须想着0层架构图或实际图。。。让0层时序依附0层架构图或实际场景--》原因在于，时序图不适合用于记忆？ 4.9. 1层之核心类图+作用 例子，xu view框架---Native简图 4.10. N层之核心类继承关系 4.11. N层之模型图拆解（注释） 4.12. N层之基础设施 基础设施是桥梁，拿来用的，你知道怎么过桥就行; 但是 至少有一次要了解桥怎么搭建的 基础设施，比如：IPC桥梁、JNI桥梁、高低软注册桥梁 1、怎么过桥：(1)怎么写代码 (2)怎么快速索引代码，比如上述三个 2、桥怎么搭建：背后机制具体实现 4.13. N层之使用 从开发者或者新开发一个控件角度去看，如何使用一个已经有的框架：需要做哪些 比如，xu view框架---无障碍、事件和手势 4.14. TODO:其他 关于进程，区分在哪一张图里呢？？还是每一张图 如何了解一个类做了啥？接口+doc，看public API（包括.h） 如何了解一个模块做了啥？找两个模块之间的API （统一的interface，比如aidl、interface；非统一的，A调B的public函数）-----> 抽象：横向看调了哪些方法，不看某一方法实现细节 关于模型，关于自然法则，一定要找到物理模型（生活模型），这样才更好理解 4.15. 自然法则： 给出上述每一张图背后的自然法则： 为什么会是这样？背后的美学在哪里？必然性在哪里？生活(哲学)原理在哪里？ 有没有不好的地方？违背自然法则的地方？ 设计模式----------无模式，不代码 像解答 证明题一样，证明代码为什么是这样写的 4.16. 给出0层设计、一层设计、二层设计 规定:任意一个项目，至少给出0层设计、一层设计！！！！ 按照提交人，看代码---->剥离出特定功能 记忆：主要类图（静）和主要时序图（动）------>相辅相成 时刻把类想象成一个人 一个人，有哪些东西 一个人，可以有哪些能力 其实，任何事情都是？ 有没有深刻理解，一定要看有没有回答很多问题，尤其是本质的一些问题！！！！！！！！以问题驱动理解 那么，如何提一些常见性问题、以后后续的本质问题？ 避免模糊性词语，会欺骗你 比如安卓画的>就把所有细节掩盖过去了，欺骗了你自己 安卓进程还是z进程？ 安卓的类？还是z的类？ 安卓的哪个进程？ 具体怎么画的？哪个类负责的？ 画在哪个surfaceview上？ 怎么画的？ 如果是在A的view上，怎么处理与Z的surface view关系？遮挡 4.17. 更深的理解来源于本质的实现 比如bep一致性；再比如 进程的理解：进程实体、 ------>所以，深入理解计算机系统非常重要！！！！ 需要了解到什么程度？具体技巧：理解了一个功能的实现机制，并能画出实现机制的模型图。。。比如： 4.18. 用面向对象的语言去描述事情！ 永远不要说，A类调了B类的 onTouchEvent(MotionEvent event)接口！！！！！！！ 而是： （1）A将事件（MotionEvent）让B处理了（onTouchEvent） （2）或：A分发事件给B，让B去处理 -------->可见，整个代码体系，从来都没有代码，只是背后的对象本质 4.19. 为什么我不能从代码中抽象出xu的图？ ---->如何从代码中提炼主要类图和主要时序图？-->即如何寻找主干？ 寻找代码主干的方法： （0）你无法在森林里找到主路的，除非你有地图： 找他人，网上要地图：设计文档，流程图 但是有一点你要保证： 别人告诉了你路的大致方向后，只有你自己走一遍路，路才是你的！！！！！否则记忆别人说的，不可靠！！！！！ 什么叫走一遍：沿着log，回答上面问题 （1）初步用ea自动生成类图，找出主要类（以及主要调用方向） 一群人干了几件事情 （2）运行起来，打调用栈及log------->无法识别主干 技巧：网上下载的项目，如何运行起来？？？？？很多报错 尤其是版本对不上。。。。。代码和sdk和手机版本对 ----->比较好的方法是：注释掉！！！ 因为版本错位的代码都非主干代码！！！ 比如编译时报错： 错误：找不到符号 类XXX 位置：程序包 com.xxx.xxx 3、为什么我听不懂别人说话？ 大致方向： 阅读代码有两种模式: top-down和bottom- upo Top-down模式,就是先设定一个use case, 比如说打开一个文件。然后静态跟着代码看, 或者用debugger跟着看。每次出现函数识m 的时候,把函数的执行层次纪录下来。大 下: func1( ) ​ func2( ​ func3( 具体方法： 优先级：断点调试----->调用栈----->log----->走读（静态） 如何看发消息的log？？？ 因为有很多同类的消息，一条消息会调整个流程 >多条消息会造成log错综复杂 方法： 1、先挑一条典型的消息，串好整个流程 2、再广度：看一组消息是怎样的，有哪些（用过滤器） 4.20. 一些经验： 4.20.1. 覆写的作用， （1）完善子类功能，比如TextView覆写view方法，完善自己特有的，然后调用super方法 （2）恶意阻断，屏蔽父类方法：子类将父类方法重写，直接return出去。那么开发者调用这个方法永远失效！！！！！ （3）把调用流程和参数拦截到子类里 4.20.2. 类的本质： 即对外功能的总和，即一切方法的总和（是方法的抽象） 推论：通过对外API来认识一个新的类（横向看所有类） 一对多，一定是模型，尝尝是一定要画图的 4.20.3. 实现了某个接口，即拥有某种能力 ！！！！！！---->实现了Parcelable接口，就有了打包的能力 接口的另一个作用：协议 --->我实现了某个接口，你便可以用这个接口实现类 4.20.4. 工具类 工具类都是静态方法 比如：Utils 安卓的Process.java /** * Tools for managing OS processes. */ public class Process { .......... } 4.21. 知全局而做局部 ------>如果你没有全局的视野，做局部毫无意义！！！！！！（因为你理解不深刻，做了也是很快忘记！！！！！） 4.22. 代码框架的收集 4.23. 如何阅读别人的代码 https://www.yinwang.org/blog-cn/2020/02/05/how-to-read-code -----wangyin 比起阅读代码，我更喜欢别人给我讲解他们的代码，用简单的语言或者图形来解释他们的思想。有了思想，我自然知道如何把它变成代码，而且是优雅的代码。很多人的代码我不会去看，但如果他们给我讲，我是可以接受的。 如果有同事请我帮他改进代码，我不会拿起代码埋头就看，因为我知道看代码往往是事倍功半，甚至完全没用。我会让他们先在白板上给我解释那些代码是什么意思。我的同事们都发现，把我讲明白是需要费一番工夫的。因为我的要求非常高，只要有一点不明白，我就会让他们重新讲。还得画图，我会让他们反复改进画出来的图，直到我能一眼看明白为止。如果图形是 3D 的，我会让他们给我压缩成 2D 的，理解了之后再推广到 3D。我无法理解复杂的，高维度的概念，他们必须把它给我变得很简单。 很多人都不知道，有一天我用不到一百行 Scheme 代码就写出了一个「深度学习框架」，它其实是一个小的编程语言。虽然没有性能可言，没有 GPU 加速，功能也不完善，但它抓住了 PyTorch 等大型框架的本质——用这个语言写出来的函数能自动求导。这种洞察力才是最关键的东西，只要抓住了关键，细节都可以在需要的时候琢磨出来。几十行代码反复琢磨，往往能帮助你看透上百万行的项目里隐藏的秘密。 很多人以为看大型项目可以提升自己，而没有看到大型项目不过是几十行核心代码的扩展，很多部分是低水平重复。几十行平庸甚至晦涩的代码，重复一万次，就成了几十万行。看那些低水平重复的部分，是得不到什么提升的。造就我今天的编程能力和洞察力的，不是几百万行的大型项目，而是小到几行，几十行之短的练习。不要小看了这些短小的代码，它们就是编程最精髓的东西。反反复复琢磨这些短小的代码，不断改进和提炼里面的结构，磨砺自己的思维。逐渐的，你的认识水平就超越了这些几百万行，让人头痛的项目。 注：目的性要明确 ----> 比如了解view显示，那么事件的流程就不要考虑 解耦思想 4.24. 如何搜索代码？ 1、赋值点： 核心：搜 \"不得不\" ​ 对于基本数据类型 A a; ---------> 赋值点搜 “a = ” ​ 容器 ArrayMap mMethodMap -------> 搜 \"ap.put(\" ​ 因为 容器可以传引用，搜 mMethodMap，很可能搜不到 2、 5. 文章TODO: 链到你的文章结构里 5.1. gitYUan https://mp.weixin.qq.com/s/saps9pV-HEAon4majH1-aQ Android系统之博大精深，包括Linux内核、Native、虚拟机、Framework，通过系统调用连通内核与用户空间，通过JNI打通用户空间的Java层和Native层，通过Binder、Socket、Handler等打通跨进程、跨线程的信息交换。 只有真正阅读并理解系统核心架构的设计，解决问题和设计方案才能做到心中无剑胜有剑，才能做到知其然知其所以然。当修炼到此，恭喜你对系统有了更高一个层次的理解，正如太极剑法，忘记了所有招式，也就练成了太极剑法。 再回过头去看看那些API，看到的将不再是一行行代码、一个个接口的调用，而是各种信息的传递与交互工作，而是背后成千上万个小蝌蚪的动态执行流。记得《侠客行>里面的龙木二岛主终其一生也无法参透太玄经，石破天却短短数日练成绝世神功，究其根源是龙木二岛主以静态视角去解读太玄经，而石破天把墙壁的图案想象成无数游动的蝌蚪，最终成就绝世神功。一言以蔽之，程序代码是死的，系统运转是活的，要以动态视角去理解系统架构。 我们看代码时，要抱着的一个目的就是弄懂它的骨架和脉络，细节无需记忆。毕竟对于一个系统来说，它是有很多细节的，我们无法在短时间把它们都完全吃透。但是主要我们掌握了它的骨架和脉络，以后无论是要了解它的什么细节，都可以很轻轻地找到相关的源文件，并且可以很容易进入主题。 似懂非懂的感觉，实际上就是不懂！ 理念总结： ​ 1. 从代码中找答案——Read The Fucking Source Code。 ​ 2. 以不变应万变——坚持看一个版本的代码直至理清它的骨架和脉络。细节无需记忆 对于优秀的开源项目来说，不去读一下它的源代码，简直就是暴殄天物啊。读代码有什么好处呢？太多了，除了可以学到别人的优秀代码、架构之外，最重要的是，我们能从中找到答案，从而可以解决自己项目上的燃眉之急。 拿Android系统来说，你在至少得懂点Linux内核基础吧！ 5.2. 罗升阳 对Linux内核有大概的了解之后，就开始学习Android应用开发，因为我觉这是学习Android系统的切入点：知道怎么用一个东西之后，才能更好地知道它是怎么实现的。 -------->所以，测试demo以及测试demo比源码实现重要！！！！ ---->要经常写demo = 输出比输入重要！！！！ 我一直相信潜意识这种东西：只要你相信你能解决一个问题，并且坚持住不放弃，潜意识就会帮助你去加工和组织各种信息。因此，自信很重要，它是一种软实力：有自信不一定能成功，但是没有自信就很难成功。 淡定。淡定是一种人生态度，它能使人不功利，不浮躁，从容地面对得与失，找到一条更合适自己长远发展的路。往往梦想都是一个比较长期的东西，不是短期内就能看到效益的。 5.3. wangyin 5.3.1. Talk is not cheap https://www.yinwang.org/blog-cn/2019/09/11/talk-is-not-cheap 5.4. xu CHEN: https://www.jianshu.com/p/37370c1d17fc 这个文章很好。但是又长又臭,过一两年后可能就忘记了。作为技术专 家, 到底记得的是啥? 如果要记得这么多知识点,又该怎么化简做减法呢? 越能做减法,cover的知识树越大。我是这样理解的 XU: 看软件先看架构、再看关键流程,它们是软件的骨架,支撑起组件和无数实现细节。这个帖子介绍了关键流程、细节满满,你可以跳过细节看大纲, 然后尝试去解释每个启动步骤的合理性。解释通了就算初步理解了, 至于流程的 细节不用看,看了不用也记不住的。 大纲 cache 在脑子里,有需要知道怎么去查, 就够了 CHEN: 解释每个步骤的合理性。这是一个不错的想法。如果解释的很合乎自然, 就不用记忆力, 靠逻辑、靠自然 理念总结，只有一个关注点就是骨架自然性： 1、骨架： 架构图、关键流程图 肉：组件、具体代码实现细节 无论什么时候(新项目第一次看，还是老项目复习知识点)，都是 关注骨架、忽略细节。不看代码，更不记忆！ 看帖子，也要跳过细节 2、对于骨架，也不记忆！！！ （1）尝试去解释每个步骤的合理性，如果解释的很合乎自然, 就不用记忆力, 靠逻辑、靠自然 （2）编故事，生活化模型去理解，在生活模型中找不得不！ 3、不能有复杂的图，复杂的图，只能当做字典 自然，代码是最大的字典 5.5. 以信息流的方式理解代码结构：： 信息流 ---->是代码的本质 1、类是一个信息流-->类信息流的流向，决定了类的持有关系 2、方法也是一个信息流 ----->决定了方法的调用关系 方法信息流查看ide：alt + F7 ，调用关系 3、变量是信息流 --->决定变量的信息传递流向 变量信息流：双击选中 --->会给你信息流 （计算机的本质） --->x信息最终给到了touchBounds ​ --->在此之前x信息被getScrollx改写了 利用信息流的例子： 1、问题：view.setTranslationX(float translationX) ---->(1)这个接口会造成view显示变化了，那么touch时的热区变化了嘛？ ----> (2)如果没变化，那么又是如何做到的？？ ​ ---->（1)可以通过event的x,y来断定 下面分析（2）： 信息流思维：translationX 信息只流向了类mRenderNode，没有停留在view里 ------>所以最后要用，只能由mRenderNode流出 ------->方法1：查看mRenderNode方法调用点 ------->方法2：用trace暴力，看调到RenderNode哪个方法 ------>方法3：反向，不得不 ---->从event入手，event的x,y需要translationX 信息 ----->跟踪event的x, y ，必然会找到拿到translationX的地方 只抓一点，不及其余！！！！！！！比如这里的位置，只看event的位置！！！！ ------>虽然调用栈很深、方法很多、方法体很长 ------->但是某一问题，关心的量只有一个，死盯着一个量，只跟踪一个量的信息流！！！！！！！ ----->这样就容易很多 这里，追踪MotionEvent ev的,x与y，便可以跟踪到方法： 5.6. AS 中引入其他盘的java代码作为source 1、进步:云帆引入方法，可以将其他盘代码引入As工程源码作为source 基于进步的拓展:那么可以做的事情就非常多了，比如将Z侧计算云代码引入source断点调试，依赖源码 再拓展: 打通ndk调试（A侧和Z侧），以同样方法引入cpp 5.7. 解bug体会、查找： 5.7.1. 看问题，都要正向看+反向看 每前进任何一步，都要正向看+反向看，然后再下一步（方法便可以指数增长） ----》 基于这一进步，我们可以做很多事情 。 以bug为例子: 正向: 不断找crash来源 反向: 对比正确的例子，寻找差异点 主动制造冲突: 修改某一个量，比如，增加颜色，改变view大小（as可以临时）、view相同大小获取其父亲 找到任何一个差异点后，1，都可以尝试用as去修正（反向） 2，追踪差异点来源（正向） 例子：无障碍下手表应用commonDialog无法触摸获得焦点 ------>反向可以对比的元素：无障碍+非、手表+手机、Dialog+ ability、无法触摸焦点+可以触摸焦点 手表的Dialog window没有liearlayout ------>1、正向 断点加在构造函数里 2、反向： 结果，有swipelayout 正向:何时生成 （反向:在冲突点修改值，看能否正常） 反向，与其他手表应用对比？ 改好，改差 这个不行，对比其他 正向:把这个改好 反向:把其他改差 多个因素对比，比如手表手机，dialog和ability 非代码区别:describtion，打印父子关系 代码中区别:hash 一心只为提高自己，偏离这个即使有利益，放弃 xuji 反面看事物=>提问题，去怀疑 如何理解深刻？>要问的尖锐深刻+回答得清晰 跳出代码看问题 过年的影响0:消费 投资和个人一样，本质都是价值 如果你想要变得聪明，你必须不停地追问的问题是“为什么，为什么，为什么” 严格分析——使用科学方法和有效的检查清单能够最大限度地减少错误和疏忽 耐心——克制人类天生爱行动的偏好 “复利是世界第八大奇迹”（爱因斯坦），不到必要的时候，别去打断它 5.7.2. 如何识别一个对象，唯一化？ 在log中---->内存地址 非log中---->直观：增加颜色，改变view大小（as可以临时）、view相同大小获取其父亲 断点调试中--->比如在xml里，给一个控件一个ID 5.7.3. 对于快速变化的问题 ---->一大利器就是：放慢！！！！ 放慢例子1：快速变化的代码---->log 放慢例子2：快速变化的代码---->断点调试 放慢例子3：对于动态快速变化的显示现象 ------->手机拍视频 + virtualbud一帧帧放慢 放慢例子4：基于1和3 ---->现象的时间序列 与 log的时间序列 一一对应了！！！！！ 基于3，可以做： 现象的时间序列----->如果足够细，可以预测每个现象变化的时刻点（无法精准）（从而预测每段现象的时间段！！！！） 例子： 问题描述：commonDialog在销毁的时候很快闪了一下（就像闪屏一样） 规定 ，记忆：永远不要用模糊性词语，欺骗人，更欺骗自己！！！ --->要求精准描述，才发现自己的问题，根本答不上来，什么叫闪了一下？？？？？？完全是忽悠人的词！！！！！ ----->快速变化，必须用拍视频放慢----->从而才有精准描述：Dialog先消失（1、销毁时刻点），然后隔了50ms后，又出现了（2、再次显现时刻点）又隔了10ms，又消失（3、又消失时刻点） 比起正常流程，多了2和3时刻 TODO：上面的例子，已经分析到了各个现象时间 + log是正常的 ---->可我为什么没有想到这时就可以断定一部有问题？？？？ 逻辑链条断了？？？ 5.8. 永远不要用模糊性词语， 欺骗人，更欺骗自己----->时刻要有感性词(模糊词) + 理性语句 感性词用于理解与记忆《------->理性语句，用于精确描述，翻译感性词 规定： 任何时候，都要有 感性+理性 ------------>尤其感性词，绝不允许感性词单独存在！！！ ​ 感性词 容易骗自己。。。。。。。理性语句又不够抽象，不能记忆 例子1: 数学：极限、无线逼近 《--------->ε，无论正整数N为多少，都存在某个n>N，使得|xn-a|≥ε 语言 例子2: 计算机：dialog闪一下 《----------->隐藏后，50ms又显示，又过了10ms隐藏了 5.9. 思考问题，一定要闭上眼睛 1、换脑子 2、 留在脑子里的是本质 3、 眼睛传入的信息，会障碍人 记忆与理解，也要闭上眼睛。。想图像（避免注意力停留在文字上） 5.10. 答案永远在代码之外 1、一个线程可以有几个Looper？可以有几个Handler？ 从模型角度： Looper.looper() 是驱动整个线程运行的 拉磨驴----> 自然，只有一个 ​ Handler是对外接口，send.msg和处理msg，自然，可以有多个 从代码角度：Looper.prepare()创建Looper之前，会判断当前线程的Looper是不是存在，存在会抛异常 --------> 所以，问题的深层次答案，只能从模型中得出（代码只能给出浅显的答案） 5.11. 代码脑中简化技巧 5.11.1. 0层综述 解决混乱的方法就是，化简。----》找出主次 上面画图、0层都是化简 化简有多简单，决定领悟有多深刻。 化简有多简单，决定能hold得住多大代码量 规定： 看源码，第一件事情，就是超级化简、之后大化简（超级化简弄懂后）、化简（大化简弄懂后）、不化简 -----> 大流程遵守上述、小流程遵守上述、函数级（行数多的）也要遵守上述 为啥要化简？1层剖析： 1、纵向：点击代码跳转过多，脑子内存不够用！！！！！！！堆栈溢出 ----》自然，另一种方法：增加脑子内存，截图 2、横向：脑子里的类过多，脑子内存不够用 ----》自然，另一种方法：增加脑子内存，截图 3、横向关联：一个函数里，四五百行，if else 嵌套过深刻, 造成逻辑过于复杂 -----》 挑选重要的if else 分支，那如何挑选重要的呢？ 5.11.2. 记忆之房间： 例子： //SystemServer.java // 具体启动核心代码 ActivityTaskManagerService atm = mSystemServiceManager.startService( // cg: ATMS ActivityTaskManagerService.Lifecycle.class).getService(); mActivityManagerService = ActivityManagerService.Lifecycle.startService( // cg: AMS mSystemServiceManager, atm); SystemServer.java 房间中, 有两个人 mSystemServiceManager和Lifecycle 5.11.3. 简化之 猜测实现 能猜测实现-------> 这样不用浪费时间看海量代码了 角度： 1、从测试用例的用法（用户角度）-------> 猜测实现 2、通过接口、使用，猜测内部实现 3、demo 4、使用例子 5.11.4. 化简之框架：逻辑上舍弃已知框架 总结框架，桥梁 ---------> 见 《代码框架的收集》 ---------> 已知框架，桥梁，作为化简工具。 高低软架构----》 如何索引，如何添加新接口 5.11.5. 化简之 大概就是、大部分情况就是 即，把握主要： //viewGroup.java protected int getChildDrawingOrder(int childCount, int drawingPosition) { return drawingPosition; } 该方法，只有少数子类复写了，所以认为，大部分情况，返回值就是输入值 ---> 忽略掉小量 5.11.6. 化简之包裹 简化之包裹（主次之包裹），那么内核是。。。为什么包裹，要一层皮 5.11.7. 化简之内部类（次要类）： 内部类是次要结构，可以被简化掉 逻辑上，内部类是外部类的一部分，调用内部类，就认为是调用外部类。 比如： // 具体启动核心代码 ActivityTaskManagerService atm = mSystemServiceManager.startService( // cg：ActivityTaskManagerService ActivityTaskManagerService.Lifecycle.class).getService(); mActivityManagerService = ActivityManagerService.Lifecycle.startService( mSystemServiceManager, atm); mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); // cg：PowerManagerService AMS和ATMS通过 Lifecycle（SystemService） 传参给 SystemServiceManager PMS 传的是本身 PowerManagerService（SystemService） ----》 本质上，两者是一样的，因为 Lifecycle是内部类，即等同于外部类。 Lifecycle抽出了 生命周期相关的方法（onStart），感觉更集中 5.11.8. 化简之内部类2（解决java单继承问题）： java只能单继承，如何在功能上实现多继承呢？ 5.11.9. 化简之同胞类 内部类在逻辑上，可以认为是一个类 功能相同的同包类 可以认为都是一个核心类（核心类拆出来的：比如：ATMS、栈管理、生命周期同步器.........等等，脑子中都认为是AMS，见小了逻辑链 自然，持有关系，如果功能相近，认为是一个类 ------> 减小逻辑链 5.11.10. 函数化简之 信息流 图： 1、目标应该是非常明确的 2、起始点应该也是非常明确的 ------------->3、（绿色）连接 起始点 和 目标点 就是 0层纵向主干 （化简1） 4、如何阅读 纵向主干？ 找到起始点 和 目标点确定要跟踪的主要信息，比如Inputconnection， 只阅读 含有 Inputconnection 的代码！！！！！！ ------> （化简2: 函数的主要阅读方法） status_t Parcel::writeAligned(T val) { // val信息流 COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE_UNSAFE(sizeof(T)) == sizeof(T)); if ((mDataPos+sizeof(val)) (mData+mDataPos) = val; // val这里必然是核心主干 return finishWrite(sizeof(val)); } status_t err = growData(sizeof(val)); if (err == NO_ERROR) goto restart_write; return err; } 5、两个节点间，是一个层，一个功能。可以只读一部分层（化简3） 其他： 所有的节点if都是一个分支 如何找函数中核心代码？ 思想：高亮重要入参，重要入参流淌的代码就是重要代码。 因为核心代码就两三行，这样看代码就省事多了 例子： 比如InputMethodManager.startInputInner() 方法，总共两百行 -------》 softInputMode表征IMS的一个重要参数 -------》 核心必然是mService.startInputOrWindowGainedFocus() 一个推论？两个核心函数之间，变量是怎么演变的？？ 优点（使用场景）： 快速找到主要调用栈 缺点：忽略的太多，比如if条件等 5.11.11. 函数化简之 return 可以找到绝对的主干，而且是从上至下找（优）： （调用栈是从下往上） EX1: //ActivityStarter.java private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) { int result = START_CANCELED; final ActivityStack startedActivityStack; try { mService.mWindowManager.deferSurfaceLayout(); result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, // 【1】cg: startFlags, doResume, options, inTask, outActivity, restrictedBgActivity); } finally { ........... return result; //【2】 } 从return点的result，跟踪result，找到赋值点，就是主干 补充： return err 分支可以必然次要，可以不读 5.11.12. 化简之透传（可大量化简） 透传的，逻辑上直接可以忽略掉 因为核心代码只有一两行，那么：90%的代码都是透传，都可以从逻辑上删掉 记忆与关注点： 非透传的核心代码 + 核心代码的外面一层层洋葱皮（判空、其他分支） -规定。技巧：透传函数不能注释齐功能，只能注释 // 透传 只有扎到根，才是非透传代码 EX1: 比如 startSystemServer、forkSystemServer 都是透传，只能注明 // 透传 5.11.13. 化简之合理性（围绕目标的） 适用范围： 这一条，适合理解、记忆软件的整体架构 延拓，记忆、理解任何流程性的东西都合适 ----> 天生适合记忆0层 纵向流程 步骤： 目标（目的）功能是啥？这个对于软件来说，一般是明确的 关注目标， 给出存在合理性、时序合理性 -----》 便可以删除了，仅仅留下目标 这个合理性，本质上 是路径（实现手段），便是代码流程 EX1: 炒菜 流程：不需要记忆去买菜（买菜之前还去拿钱、拿钱后还对比了与网上菜贵还是便宜）、买酱油、砍价、回来的路上还买了锅 炒菜还查了教程、洗菜、切菜、炒菜五分钟、然后加水............. -----》所以，炒菜流程远比软件流程复杂的多 你是如何记炒菜的，你就应该如何记忆代码流程： 1、我没有记忆流程，一点也没有 2、提到炒菜，我的第一印象（目标）就是 菜在锅里炒 3、其他的都是 合理性推出来的 （这是人的天性，只是面对代码，迷失了本性） EX2: 图：startApp.eddx 总结： 化简：init进程与zygote是一样的，一个拉起cpp的服务进程，一个孵化Java的进程 ---> zygote可删 化简之合理性：整张图，目标就是启动native和java的服务 ​ 自然：先启动native服务，之后java ​ 自然： 启动native众多服务之前，自然要先启动serverManager来管理 ---> ~~serverManager可删 ​ 自然：启动java 服务之前，自然要 树立起java-native的墙jvm、搭建好梯子jni ----> ~~Runtime 自然，可删 ​ 自然：zygote只是为了 fork java服务进程而存在的 ---> ~~zygote可以删掉 总之： 1、启动自下而上；调用，自上而下（最终内核驱动，自然） 2、只需要记：整张图，目标就是启动native和java的服务。其他的都可以删了（是合理性下的必然）。 5.11.14. 化简之目标 永远不要按照调用栈 或者 时间顺序 去理解，尤其是记忆代码流程 而是 先想着核心点（一行代码、一个功能结果），反推其他辅助流程（这才是真正的理解，不得不在里面） ------》这和 合理性 是一个思想 比如：视频11 activity启动流程 ---》 重新看 5.11.15. 化简之if else 一般情况下，if else下是两个对等的分支，只要看一个就可以！！！ 5.11.16. 化简之名词 IMM是InputMethodManager化简。不要小看名词化简：方便搜索；且方便记忆 5.11.17. 化简之类比 核心：理解与记忆时，找寻已有的东西类比 。书写时，亦如此 禁止用Y的类名，为啥，因为类名这种情况下不重要了，没必要用两套。基于A来记忆Y的。 Y_IMS 5.11.18. 化简之 减少逻辑调用链 如何减少? 1、多个函数调用,只关注一行代码 (基本上是底层函数的) 2、回看最外层函数,一行代码逻辑挂到最外层函数 3、关注点:入口---关键函数,链接 规定：强制删减 ? 5.11.19. 如何识别模块的主类： 5.11.20. 如何识别类的主方法: 即这个类的主要职责： 1、横向看看对外函数: h文件/public 接口(无法区分主次要) 2、索引属性, 属性做了哪些事情?------>牵强,属性太多,用处太多 3、看被谁持有。在持有的类中,索引改属性,看属性生命周期图谱中,怎么用的这个类 上层类主要流程怎么用这个类 4、类之间明显存在一对多的情况 规定:画类图,只允许添加关键属性、关键方法 但:如何识别一个类的关键属性,关键方法呢------>用于画图, 用于理解和记忆 1、次要属性之透传: 横向索引属性, 只有透传------>排除掉（这也是逻辑化简的方法） 2、主要方法:一个属性创建地方, 最终传递到的地方(该类的主要属性) 5.11.21. 化简之解耦思想 解耦方法的应用场景: 1、对于不理解的东西, 先记忆为框架能力, 后面再弄懂。 2、对于复杂的耦合问题（AB相互影响），假装一部分是正确的、 已经验证过了的框架, 先记忆。等其他的弄明白了,再来理解框架原理。 举例子：看代码的时候，遇到AIDL架构，链接直接用 AIDL.stub，先忽略背后的架构 -解耦 延拓: frame+ 链接-的记忆, 所以，记忆本身就是解耦 ​ 0层 ----> 1层局部放大, 本身就是解耦。 举例子：土木结构的放大、代码结构 0层-1层的放大 解耦的根本思想就是把两个相关联的问题，强行拆解成不相关的，一一击破; 解耦的具体办法，1、就是先假定（假定没有关系，假定是正确的） 2、解耦的最后，一定要回到这个假定上来，考虑这个假定的正确性 举例子：力学中很常见，比如10N的力推动一个 三角结构：A和B之间一定是相互影响的（力和位移） ----------> 解耦具体办法：先假设AB没有关系，A有一个位移；B有一个位移 后面再考虑关系： A的位移 = -B的位移 5.11.22. 化简之设计模式 很多代码为啥这样写，就是设计模式规定死了的 5.11.23. 化简之 功能逻辑 驱动 函数记忆 记忆也如此： 以功能，驱动函数（不能反过来） -注意力一定在功能上，不是在函数和类上。 比如： Activity起来之后（window也准备好了），那么如何与view绑定 -----》setContentView 不是去记忆 setContentView，反推绑定关系 写文章也是如此。。。。各个章节标题永远都是 功能点，而不是 setContentView这种函数 比如： Activity绑定viewTree，setContentView 5.11.24. 化简之按功能点拆解（写技术文章方法） 按功能点去拆解，小功能点单独列一节 -------》 原因：1、 因为一个功能点的内部，在逻辑上天然 链接的 ​ 2、防止小功能点，阻碍主要流程的 思考、书写、画图 例： handler机制，主要功能： 至于：次要功能 when、epollwait详细在另外章节里讲、在另外的图里画！！！！！ TODO： 看代码、思考也是如此；；；；说话更是如此 5.11.25. 化简之 按照变量抽离 按照变量来抽离 按照变量抽离------变量代表功能点，实际上是按照功能抽离 5.11.26. 化简之大流程 起点----目标反推法： 1、其他函数都是次要的，都理解为透传 ---->逻辑上 删除所有 调用链 2、同函数下，其他代码都是 为 核心代码服务的(逻辑上可以推断出来，不得不的) --->可以删除 ----> 逻辑上删除 -规定： 1、直接保留核心代码，删除其他所有 ---》 逻辑上、记忆上、画图上 2、以 核心代码替代 最外层函数 来记忆 ​ 写技术文章时，以核心代码 替代 最外层函数 作为 标题 原因：最外层函数 太空，而且做了很多件事情 突出核心的话，其他的可以逻辑推导 -总结，起点----目标反推法： 1、一个大流程，永远只有一行代码是核心代码 ------》目标 ​ 用文字描述，永远不超过十个字 2、其他代码都逻辑上删除。要用的时候反推，基于起点与目标 TODO: 一些推论： 按照时间线记忆， 流程性东西，害死人！！！！ 方法优点： 1、记忆量就一行，十几个字 2、以始为终：一切自然。否则是看不懂代码的 3、说到一个大流程，脑子第一时刻就知道这个流程主要做了啥。不会陷入细节 4、记忆长久 例子： 我以 runSelectLoop作为章节标题，因为 runSelectLoop是fork最外层函数 ------》很有问题，长时间只记得looper，不知道looper里面做了啥 但是突出核心 fork就不一样 ----》记得fork，逻辑上必然以后死循环Looper读取消息， 必然有fork之前，参数解析 必然有fork之后，基础建设 runtime和binder驱动 最后的目的，也是逻辑上必然： 反射主线程的main函数 5.11.27. 化简之小函数 也用 起点----目标反推法 5.11.28. 化简之函数调用栈Tree 我们可以画全量调用栈图：比如图形的 ----》 当做字典 但是记忆与理解： 1、记忆关键大流程，作为锚点（一定要足够大，足够关键）2、基于锚点，记忆其他关键函数（即核心代码） 3、逻辑上删除所有其他函数调用 ----> 总结，以上是对调用栈Tree的化简 5.11.29. 化简之忽略 handler 知道 跨线程，忽略 handler 转换 尤其是Binder线程的转换 5.11.30. 化简工具 之BookMarks （1）保存一份固定不变的源码，不更新 （2）重要的纵向流程中，关键分支、核心函数，用BookMarks标记 -------> 作为记忆的锚点、也是快速查询的锚点、经常复习的锚点 补充： breakpoint和BookMarks的点不一样： 前者尽量在边界处、最底层------> 方便得到完整得调用栈 后者 在关键函数和关键分支处 -----> 锚点处 BookMarks 好处在于 锚的好处： 1、快速查找 2、利用它支撑起整个框架 5.11.31. 化简之持有 持有一个类，可以认为是一个类的扩展 前提： 两个类的名字很相似（因为还持有其他） 比如： AppWindowToken 持有 IApplicationToken token 所以 AppWindowToken 扩展了 IApplicationToken 5.11.32. 化简之new bing 让chatGpt给你： 1、先给出模块框架 2、再给出主要功能点 3、指出沿着功能点的关键函数 4、函数每一行代码的解释 5.11.33. 化简之 设置的值 C语言的阅读： 设置（挂表）与运行 共同点： 1、找一个变量（指针）来源，会有栈 ----》 需要记忆 这是经常用的，脑子内存不够用了？有啥办法呢----》 截图屏幕、txt作为缓冲 2、信息流 5.11.34. 跳转化简之AIDL 方法一： 全局搜II........... IInputMethodPrivilegedOperations ops = mOps.getAndWarnIfNull() 要找下游跨进程的调用（即定义处）: 搜IInputMethodPrivilegedOperations： extends IInputMethodPrivilegedOperations.Stub 方法二： 搜：II接口.Stub 比如： IAccessibilityServiceClient.Stub ---------> Stub是连接点 上游：IAccessibilityServiceClientWrapper extends IAccessibilityServiceClient.Stub 下游：mServiceInterface = IAccessibilityServiceClient.Stub.asInterface(service); 5.11.35. 化简之 不断提取公因式 使用场景： 记笔记、记忆 你的关注点，决定了你hold能力： 开机自启设置：systemctl enable service_name 禁止开机自启设置：systemctl disable service_name --------------> 关注点： systemctl enable 超级化简（提取公因子------只关注差异点） 设置： 开机自启：systemctl enable service_name 禁止disable 5.11.36. 化简之 删减之特殊情况 删减之特殊情况(只要是概率不大的，都认为是特殊情况，即使重要) 5.12. 秒解技巧 5.13. 常见代码框架 5.13.1. TODO: 为什么框架是这个样子？何时要用这个框架？ 很多时候，看完代码，即使理解了其调用的结构，也不明白其中框架 -------》不明白为什么框架是这个样子？ 如何解决这一类问题呢？ -即：回答不出来，不得不！！！！ 5.13.2. 解决JAVA不能多继承问题 java语言只能单继承，如何支持多继承呢? 方法：通过内部类 继承另一个 。因为：内部类，等同于外部类。 例子: AMS与其内部类lifecycle extends SystemServer 实际上，希望AMS extends SystemServer , 但是 AMS 涉及到 与APP通信，所以也要继承 stub -不得不： AMS 涉及到 与APP通信，所以要继承 stub。也要继承 SystemService 。 ----> 涉及到多继承，所以，只能取一个。 EX1：AMS extends stub， 内部类Lifecycle extends SystemService, EX2，也可以反过来：PowerManagerService extends SystemService，其内部类继承 stub 5.14. 方法集key (清单) --—>常看、内化 1、正反角度 2、信息流（本质） 跳转 3、不得不 （最次：很可能）---->然后拦截 4、动态调试万能方法：trace，搜索所有类((已知类的时候) + 所有方法 5、简化demo--->唯一性 6、放慢 ：放到最慢看 --->放到次慢看 --->放到快看 7、方法： 对比、差 好的与不好的 8、动态断点调试方法： 修改-----夸张、弄坏、抛异常、激化矛盾。 9、log方法：绑定 10、方法：步步推进 11、断点调试：动态一般方法 ---->很容易走岔，得一行行调试 纲要性的东西，每天看 迁移： 在不同的事物上，迁移推广相同的机制。与比喻类似，但比喻是已知存在的两个物体，迁移是一个OK，另一个待迁移。。。。。。比如：嗑瓜子理论，迁移到学习上 13、本质 14、自然法则 技巧：规定，对于技巧集、本质集，剥离出原文，经常单独复习 自信（说话感觉离两米） 精力十足。管理 假装。1、以假装是主管，以主管的视角看问题，说话，解决问题 2、模仿技术达人所做的事情。所呈现出的总结 知识立体化。多个角度 代码技巧： 对于经常要看 + 稳定不变的源码，可以在代码中注释关键分支和核心函数。比如aosp源码。为什么要这样做？ 1、因为你要看千百遍的aosp，下一次看，一定要站在前一次的肩膀上。否则浪费大量精力！！！！！！ 2、代码最垃圾的地方就是 没有重点，通过注释标记重点、核心代码、关键分支 框架，桥0梁 化简 观察角度： 触发点（是一个锚点）------从调用栈能获得 观察角度： 0层结构、核心结构（对应关键函数） 观察角度：任何一个系统（系统、模块、类、函数、测试用例、老化......生物系统、地球.......），都是可以从 I/O角度分析，即一个系统的输入与输出分析 规定：为了体现主次：对主要调用栈， 标注： cheduleTransaction(clientTransaction);// main process 比喻 5w法 洞察力（观察人、观察事务，观察知识） 分层思想。。。精髓在于：隔层之间，不能有交集。分层看待，结构分层 搭积木思想。。。。。积木架构图+木块原理图（更重要） 帧+链接。。。链接，一定要以逻辑为链接。如果以记忆为链接，很容易忘，而且很难记忆 依附与链接：窗口级的。。。 闭眼睛 读大师的事迹、文章 解耦思想：先假装。。回头考虑假装的东西 过河弃筏思想 思想上，已经过河，就要弃筏（负担） 例子：架构是桥梁，过了河，就要放弃？？？？ 记忆方法之 扫词（单词、知识点、题目）--- > 对于大量知识点的方法 记忆方法之：逻辑链、不得不 一句话总结（最强简化）。1、锚点：一句话是 无招 ，一切演化的锚点 2、检验标准：真传一句话 所以，你要是不能总结到一句话。那么你没有真正理解 化简一切（减法）: 通过链接一切，做到极致化简 大方向 延拓、推广 优秀实践 心置一处，身置一处 写文字性东西，给出关键词。比如：技巧层面，理解层面，功能层面，本质： 从.....角度，例子 ​ ​ 穿针引线，串起来 层 提纲文章：如何写复杂技术文章？ ----> 用一整篇文章，来做提纲，说明引用关系： http://gityuan.com/2015/10/31/binder-prepare/ 背后是啥：干任何事情，看到任何事情，都想一下背后是啥 图解一切（理解之后的事情，便于记忆+整体结构的理解） 降低难度---否则会痛苦。例子：技术博客看不懂，看视频 看评论区 按功能拆解 可复制：模板可复制、搭建环境流程可复制、知识点可复制 ---> 任何能力，做到可复制，尤其容易复制 ​ 可复制之应用：免安装版本 (就是 安装后copy的版本) 免安装版本，好处在于：----> 基于可复制、可迁移思想 1、持久化-----独立于系统（即使系统重装） 2、最关键的是设置，可以持久化。优点： 不同电脑无需重新配置 规定： 1、免安装版本库 需要及时更新。对本地做了设置，要及时更新到 免安装版本库里 2、对于 安装复杂 或 配置复杂 的软件，规定必须 同步到免安装库里 规定： 有些软件如果做不到免安装，但是设置复杂 ----> 尽量把设置导出来，做持久化 学习上建立正反馈机制：成瘾的根本原因是：有一套反馈机制在里面。。。。例子，写技术文章，写到所有知识点，都是不得不的逻辑链接（不存在记忆链接时）-----> 好文章；是一个大奖励；超越了所有人；幻想 化简之精力管理： 最简单的，才是最有效的(也才是最节省精力的) 方法之闭眼： https://www.campzhe.com/archives/1440 我闭上眼睛，目的是为了看 给出关注点 清单：避免犯错的利器。例子：方法集、交付checkList、购物清单 笔记：1、给大脑减压的工具 2、达到可复制的目的 -----> 大脑永远留给用来思考与理解，记忆不应该是大脑做的事情！！！！！！在思考的过程中，人的大脑其实一边维持记忆，一边进行分析，两面开战。而笔记，能够释放掉大脑记忆所占用的精力，专注思考。我看见，优秀的思考者，往往善于使用笔记本、白纸和白板。摘自： https://www.campzhe.com/archives/551 结构化：思考更全面&表达更清晰。EX： 树状图 及时激励： 比如 思想世界中，工具的个数 兴奋点：又得到了一个思想工具 commit方法：任何事情，过了一个阶段要commit，像git一样。人生也是如此，基于上一个commit，做下一个 ------》 如果两个阶段之间没有传承，那你肯定走不深 合理性要求(设计合理性、存在合理性)：对于代码架构： 解释每个步骤的合理性，如果解释的很合乎自然, 就不用记忆力, 靠逻辑、靠自然 生活化模型 ----> 任何知识点都可以，大利器 时间利用方法：并行化。但是要警惕，不能切换太多，消耗精力。主要思考（学习、工作） 与 耗时无需操作过程（下载、docker 加载jar等）并行化 夜间运行：人要多休息，计算机不要休息 主次应用之主要路径：考虑软件性能要在主要（高频）路径上。不是关键路径上 学习要非常重视纵向：1、入门可以沿着一条线先熟悉 2、能串起来很多知识点！！！（否则，知识是零散的） 旋涡中心 + 链接 要多角度： 比如回答问题：1、从模型角度（本质） 2、从代码角度 眼睛是障碍、文字也是：文字障碍事物表面、眼睛障碍事物本质 ----------> 规定：看了文字(尤其核心知识点)，就眼睛，在脑袋里想 。目的: 消灭文字！ 理解、行文工具：出发---目标----不得不 对于传递，文字是竹筏 对于进步，文字是障碍 问题、知识点，睡醒前想、洗澡想、吃饭想 -----> 为什么要这样做？ 对境生迷 ，所以只能离开境 这一点有个问题，违背了活在当下 洗脑：每天反复给自己洗脑。我爱代码架构，我爱原理。我爱控场的感觉 数学是一种修身养性的方式-------柳智宇。。。。。。代码也应如是（虽然差很多） 大脑最害怕的就是凌乱。比如：1、有多处记忆点，记忆点之间没有任何联系（办法：链接和锚点） 2、介绍AMS的内容，分散到不同的技术文章里 （解决办法：一个专门文章AMS，然后引用）3、 0层（模型、记忆的锚点）---》1层（具体业务场景、面试要回答一层内容，比如Activity切换时生命周期）----》 N层，技术细节 ---》代码 ---》相关面试问题（衡量标准、反馈） 给出观察主干的固定角度。 ----》1、观察枝叶。越来越乱 2、对一类事物有固定角度，那么 对新事物分析，就完善了。比如，一个新的设计模式 角度： 核心类做了什么（属性+方法） ，更重要的是，核心模块做了什么（模块的接口） 技巧： 认识 记忆核心类的主要功能的方法： 把核心类的 主要功能 归结到其属性，记忆其属性（与周边的关系） ----》反推类的功能，自然无需记忆 例子： TODO: 认识核心类可以吗？ 5.14.1. 仅限于代码的方法 list 代码分析的三角度：1、运行态（内存） 2、文件系统（编译后在真机中的结果、可执行文件） 3、源码 进程视角、模块视角 不要使用无意义的名词、术语：比如0号进程，鬼知道0号进程干啥的，名字至少要体现本质，就像给小孩纸起名字一样，要有所寓意 技术文章的引用：为了链接更聚焦，规定： 不同技术文章之间的引用，只能引用总结部分。 5.14.2. 生活 走路在练功、吃饭也在练功 走路在当下（冥想）、吃饭也在当下（冥想） 5.14.3. 文章\\文字 -无提示，不写字：任何文字、文章，必须要加 提示词 EX: 技术文章目录，要呈现代码架构 不能让文章目录，破坏 代码架构 比如： window、WMS是一个级别的东西 ​ view只是window的一部分 填充，所以： 1、不能和window、WMS一个目录级别 2、如果想要 详细写view, 当前文章插桩。链接另一篇view文章 ​ --------> 跟搭积木一模一样：（1）不要破坏整体结构 （2）要详细了解的，另起一个视角 化简 不仅代码需要化简才能记忆，生活需要化简 文章需要化简。小到一句话也要化简，规定，技术文字写法： 规定：主要动作五六个字说完。（其他内容，加括号补充说明） 注意： 这个技巧，很像英语语言 6. 阅读代码，跳转大总结 1、跳转之 信息流 -------> 缺点：流程很长 ​ 包括：调用栈 2、跳转之 结构体约束 ----------->快速跳转 ​ 包括：类、抽象类---子类、接口与实现、overide函数跳转 3、跳转之 最近使用的文件（Ctrl + E）------> 非常快速 4、跳转之 书签（Ctrl + B） ------> 非常快速，对于知道会反复看的 5、跳转之 搜索文件名 -------> 文件名相对比较少（相比于函数），模糊记忆很容易匹配到 6、跳转之 词典 ： 经常画一些N层图，源码解读，当做词典，只用于查询 7、source insight极大优点：实时展示调用栈 tree 7. 如何理解魔鬼数字（魔鬼矩阵） 把整数值，破坏成非整数 0.6 ----------> 这样特征明显，可以观察了！！！ .d = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 1, 0, 1}, 8. 格式 规定，记忆：永远不要用模糊性词语，欺骗人，更欺骗自己！！！ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_computorBase/HowWritecode.html":{"url":"coding/0_computorBase/HowWritecode.html","title":"How Writecode","keywords":"","body":"1. 目录2. 一些原则2.1. 0层：一点点思想2.2. 1层（一点点思想）2.2.1. 代码一点点增加（然后验证）2.2.2. git commit一点点2.2.3. 写代码第一步：一个干净的环境2.2.4. 能编译OK，极大程度意味着可以运行2.2.5. 修改bug，尽量限制范围2.2.6. 做好备份2.2.7. 做好jar的备份2.2.8. 技巧：在debug断点中写代码2.2.9. 技巧：动态开关的利用(手动开关)2.2.10. 避免空指针是写代码的第一要义2.2.11. 准则1：怀疑一切使用的量2.2.12. 准则2：他人用过的不用校验2.2.13. 准则2：他人待用的暂时不用校验2.2.14. 准则3：构造方法中传过来，且用过，且不会置为null ----> 不用校验2.2.15. 准则4：利用空实现来替代判定空2.3. 如何下上升代码？2.4. 利用chatgpt写代码2.5. 识别 频繁路径+关键路径2.6. 从源码中积累素材 ------> 学会捡金子2.7. 最小化原则 之 传参：2.8. 想复用已有函数的部分功能：3. 测试维度4. 代码技巧： 目录 一些原则 0层：一点点思想 1层（一点点思想） 代码一点点增加（然后验证） git commit一点点 写代码第一步：一个干净的环境 能编译OK，极大程度意味着可以运行 修改bug，尽量限制范围 做好备份 做好jar的备份 技巧：在debug断点中写代码 技巧：动态开关的利用(手动开关) 避免空指针是写代码的第一要义 准则1：怀疑一切使用的量 准则2：他人用过的不用校验 准则2：他人待用的暂时不用校验 准则3：构造方法中传过来，且用过，且不会置为null ----> 不用校验 准则4：利用空实现来替代判定空 如何下上升代码？ 利用chatgpt写代码 识别 频繁路径+关键路径 从源码中积累素材 ------> 学会捡金子 最小化原则 之 传参： 想复用已有函数的部分功能： 测试维度 代码技巧： 1. 目录 2. 一些原则 2.1. 0层：一点点思想 为什么会这样？因为代码的易错性造成的，一个符号都就会造成大问题 ---------> 对于易错的东西，最好的办法，就是一点点 2.2. 1层（一点点思想） 2.2.1. 代码一点点增加（然后验证） 极限：每次只增加一行，验证一行........ 例子： 写反射的时候，很容易出错 2.2.2. git commit一点点 每验证好一个小功能，前进一小步，commit一次，且分开 -规定：基于commit维度： 1、保存代码 2、保存jar，保证commit级别可以回退 3、每笔commit，都要验证基本功能OK： ​ （1）attach system_server进程，不会挂 ​ （2）业务基本功能OK 目标： 每一笔commit，做到哪些功能要很清晰 要可快速回退 2.2.3. 写代码第一步：一个干净的环境 一个可以断点的环境 2.2.4. 能编译OK，极大程度意味着可以运行 为什么呢？因为编译是协议 ，协议即通顺，即运行 2.2.5. 修改bug，尽量限制范围 if (严格条件) { //修改 } 条件尽量严格，限制不影响其他场景 2.2.6. 做好备份 最忌讳的是重复劳动，所以代码备份 ,方式： 一小步一个commit、 一大步提一个链接 2.2.7. 做好jar的备份 1、每次刷完机，做一下jar的备份 2、每次一个比较完整功能的commit，做一次jar的备份 -------> 可能需要回退 2.2.8. 技巧：在debug断点中写代码 这是极优的，因为相当于，在运行时写代码 不是在代码态写代码，也不是编译态写代码，而是直接运行态 优点： 1、立刻给出运行结果-----> 验证代码的正确性 2、省去了编译的时间 3、此时 （1）虚浮窗可以跳转 AS代码 （2）AS代码如正常情况一样，可以跳转，back导航.......................... ​ ----------------> 总之，多了一个运行态窗口，其他不变 4、见 《动态开关的利用》 规定： 只允许在运行态写代码 2.2.9. 技巧：动态开关的利用(手动开关) 修改的代码，用动态开关 static boolean isSwitchOn = false; if (isSwitchOn) { //新增代码 } ----------> 为啥要这样做？ 1、如果新增代码，验证后是一个无用的代码 ----> 重启便可以恢复新增代码之前，减少了再次编译的时间 2、手动开启更好: 新增代码有可能导致开不了机。所以，还是运行后，手动开启更好 2.2.10. 避免空指针是写代码的第一要义 -加log(定位问题) 也是写代码，也要特别注意 空指针 否则： 1、log会将程序崩溃 2、有时候，崩溃在子线程，还没有报错 ----> 根本看不出来，难以定位 3、debug时 attach一些进程，直接vm挂掉 如何避免空指针？ 2.2.11. 准则1：怀疑一切使用的量 1、对一切量进行校验 2、除了下面的准则里的，百分百确认的 2.2.12. 准则2：他人用过的不用校验 比如， mContext使用过了，在图中2处，便不需要校验，可直接使用 2.2.13. 准则2：他人待用的暂时不用校验 比如， mContext使用过了，在图1处可以直接使用 -------> 前提： 其他人没校验使用沒有问题 （一般来说可以） 2.2.14. 准则3：构造方法中传过来，且用过，且不会置为null ----> 不用校验 除了以上，其他的都要校验 2.2.15. 准则4：利用空实现来替代判定空 例子：安卓中 public abstract class InputMethodManagerInternal { } 获取 -------InputMethodManagerInternal协议-------实现 因为InputMethodManagerInternal是协议，我们不能保证我们获取到的非null 何时会这样做？ 结合例子体会： （1）当调用点很多 且分散在 非常多个文件里 (TODO: 疑问：很多对外接口都能做到，为什么没这样做呢？) -------> 单例（见《设计模式之单例》） （2）我们保证不了返回值不为null ------> 那么意味着大量的调用点，都要判空 --------> 避免这种情况：为null时，返回空实现 public static InputMethodManagerInternal get() { final InputMethodManagerInternal instance = LocalServices.getService(InputMethodManagerInternal.class); return instance != null ? instance : NOP; } 背后思想： 1、以空实现替代 判空 2、 好处是什么？真的有好处嘛？ 好处： 给其他文件用的接口（尤其大量被调用的），最好不要返回null 2.3. 如何下上升代码？ 原则： 开发时上升代码。。。。设计时下沉代码。。。。 目的： 上升代码到APP，在APP里编译 -------> 优点： 高效、无风险（framwork写错代码，起不了机器） 具体操作: 1、继承 方式： LIntent extends Intent ​ override 来把流程拦截到APP里，然后在APP内部写代码 2、组合（持有父类）----代码稍微麻烦一些 override 来把流程拦截到APP里，然后在APP内部写代码 3、通过编译SDK，把要写的类传递给APP TODO：具体怎么做？ -------------------> 从这一点来看，APP与框架，并没有任何区别 public Lparcel() { mParcel = Parcel.obtain(); } 3、TODO: 强制继承，万能：修改sdk？？？ 2.4. 利用chatgpt写代码 让它写，它知道哪些接口可以使用，你不知道 2.5. 识别 频繁路径+关键路径 规定： 1、初步写代码必须每个函数加log ----> 以识别频繁路径 2、频繁路径+关键路径，不允许加代码： 3、频繁路径加代码，需要进行性能验证 方法一：缓存机制 方法二： 2.6. 从源码中积累素材 ------> 学会捡金子 2.7. 最小化原则 之 传参： prepareblur(struct weston_output *output, struct weston_blurFilter* blurFilter) { struct gl_output_state *go = get_output_state(output); // 没有用到output里其他 参数，直接用传 gl_output_state *go 2.8. 想复用已有函数的部分功能： 1、复用即相同部分 2、差异部分： （1）函数内部 用if else分支隔离 （2）最保险的做法：复制代码，新增函数(不会影响老的流程) （ 如果用 if 或者 else ，改动较大时） -----------> 总之一句话， 到底谁来承载差异（if else，函数，还是类） ​ 剩余复用 修改代码之 纯数学等价替换-----------与业务无关 3. 测试维度 1、多个demo验证（尽量不同类型） 2、top ：查看cpu占用 3、查看编译告警warning，会有提示 4、完成功能后，注意 所有类的销毁逻辑！！！！！（没有被 功能测试 测到！！！） 内存是否释放 5、内存泄漏排查 6、多个屏幕 对外接口： 参数校验 接口说明：取值范围 多线程校验 并发数量校验 4. 代码技巧： 子类修改父类的属性值，关于修改点：可以插到父类任意一行代码位置上！！！！ 利用复写的截断流程思想 比如想要在1648行就修改userId： 父类新增一个接口modifyUsrid(), 空实现；子类具体实现去修改 -----------> 好处： 1、父不会对子产生依赖 2、实现任意点插入 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_computorBase/linux.html":{"url":"coding/0_computorBase/linux.html","title":"Linux","keywords":"","body":"1. 目录2. 操作系统工作方式（从一次调用来看）------纵向0层：3. 模块之间的关系（联系）：4. 模块之间的独立性（割裂）5. linux kernel 功能划分图-----静态6. 中断6.1. Linux的中断机制6.2. 中断工作流程6.3. linux中中断你的工作流程6.3.1. 代码结构6.3.2. 中断的代码实现7. 补充： 常见的系统调用sys_call8. 参考： 操作系统工作方式（从一次调用来看）------纵向0层： 模块之间的关系（联系）： 模块之间的独立性（割裂） linux kernel 功能划分图-----静态 中断 Linux的中断机制 中断工作流程 linux中中断你的工作流程 代码结构 中断的代码实现 补充： 常见的系统调用sys_call 参考： 1. 目录 2. 操作系统工作方式（从一次调用来看）------纵向0层： 一次调用，从上到下: 底层：硬件 操作系统的工作方式: 1.把操作系统从用户态 切换到 内核态 (用户应用程序 到 内核的流程) 2.实现操作系统的系统调用(操作系统服务层) 3.应用操作系统提供的底层函数,进行功能实现 ​ 3.1 操作系统的驱动结构 4.推出后从内核态切换到用户态 3. 模块之间的关系（联系）： 高速缓存 其实就是一块内存。。。计算机写文件时，先存储在高速缓存里，最后一把写入硬件磁盘 4. 模块之间的独立性（割裂） 独立性： 注意区分：管理层与实现层 提供接口的，不实现；实现的，不提供接口 为什么要这样做呢？ 易于维护和升级？？？？ https://www.bilibili.com/video/BV1tQ4y1d7mo?t=3147.4 高版本和低版本内核之间的区别： 1、内核驱动的管理模式并没有巨大的改变。一段时间3个阶段的跳段： 零散型 分层型 设备树 ​ 多的只是内核驱动的种类 2、进程的管理方式并没有巨大的改变 进程的调度算法发生了改变 ------> 总之，就是没有大的改变 技巧： 不变的看老版本 -------- 主 ​ 变化的，看新版本 -------- 次 5. linux kernel 功能划分图-----静态 Linux内核是linux操作系统的核心部分，它实现了操作系统的五大功能模块： 进程管理 内存管理 文件系统 设备控制 网络 CD ------光盘 6. 中断 目的：为啥要有中断？ ​ 1、硬件的中断响应 ----》 内核驱动的中断 ​ 2、系统调用的函数响应（sys_call） ----》 系统调用 ​ 3、自定义中断 ----》 软件的软中断模式 ​ 4、信号中断(kill-signalnum) ----》 进程间通信（有助于了解信号的使用、创建等） ​ 5、系统的异常和错误 ----》 系统的异常获取；了解系统异常的作用 后面的章节，围绕着这五个目的 6.1. Linux的中断机制 分类，自然： 硬件中断：比如：电脑主机的8259A类似的硬件中断控制芯片发出的中断、ARM中断控制器发出的中断 软件中断：异常：第一类：CPU 自行保留的中断 -------》 TODO: 不懂 ​ 系统调用异常 6.2. 中断工作流程 任意系统中断都有： ----------------保存------------------------- 做CPU工作模式的转化 进行寄存器的拷贝与压栈 -----> TODO: 这个目的是啥？ 设置中断异常向量表 保存正常运行的函数返回值 ------------------执行-------------------------- 跳转到对应的中断服务函数上运行 ------------------恢复------------------------- 进行模式的复原以及寄存器的复原 跳转回正常工作的函数地址继续运行 （对应video： https://www.bilibili.com/video/BV1tQ4y1d7mo?t=1252.7&p=2） -------------> 总之， 字面上来看： 中断就是 中断CPU，做其他事情（运行中断服务函数） 6.3. linux中中断你的工作流程 ---------------保存(中断前)------------------------- 1、将所有的寄存器值入栈 -----》 上面的保存 寄存器比如： 8086中的 SS EFLAGS ESP CS EIP（错误码） ARM中的（r0-r15） 2、将异常码入栈（中断号） 3、将当前的函数返回值进行入栈(为了在中断执行后能够找到在哪中断的, 能够复原) ------------------执行(中断)-------------------------- 4、调用对应的中断服务函数 ------------------恢复(中断后)------------------------- 5、出栈函数返回值 6、返回所有入栈的寄存器值 6.3.1. 代码结构 重要代码结构： 保存过程（123），恢复过程（56） 调用？ 中断的执行过程（4） 硬件中断的处理过程 asm.s traps.c 软件及系统调用的处理过程 system_call.s fork.c signal.c exit.c sys.c 结论： 软中断和硬中断，完全两条路 系统调用 同 软中断 6.3.2. 中断的代码实现 以 asm.s ---》 traps.c为例： 7. 补充： 常见的系统调用sys_call 常见的系统调用 ： open、mmap、ioctl、dose mmap()： 磁盘文件（驱动文件？） 映射到 物理内存 例子：进程建立binder线程池时 // 为/dev/binder文件 映射固定大小的物理内存 mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); // 即打开的 /dev/binder文件 维测之-------查看进程中，各个二进制文件mmap的地址段： P13_5G:/ # ps -ef | grep servicemanager system 328 1 0 14:19:52 ? 00:01:37 servicemanager 2|P13_5G:/ # cat /proc/328/maps 6197007000-619700d000 r--p 00000000 fc:02 1640 /system/bin/servicemanager 619700d000-6197014000 r-xp 00006000 fc:02 1640 /system/bin/servicemanager 6197014000-6197016000 r--p 0000d000 fc:02 1640 /system/bin/servicemanager 6197016000-6197017000 rw-p 0000e000 fc:02 1640 /system/bin/servicemanager 744f1b2000-744f2b0000 r--p 00000000 00:23 4 /dev/binderfs/binder 744f2b0000-744f2b3000 r--p 00000000 fc:02 3825 /system/lib64/libnetd_client.so 参考： https://blog.csdn.net/hcgeng/article/details/134563659 8. 参考： https://www.bilibili.com/video/BV1tQ4y1d7mo?t=1252.7&p=2 https://blog.csdn.net/u014571143/article/details/129660010 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_computorBase/linux文件系统.html":{"url":"coding/0_computorBase/linux文件系统.html","title":"linux文件系统","keywords":"","body":"1. 文件系统角度1. 文件系统角度 结论：安卓所有的native程序 1、都是独立的二进制文件，比如 /system/bin/servicemanager /system/bin/servicemanager /system/bin/surfaceflinger /system/bin/app_process64 ------》 systemServer 系统进程 2、都在 /system/bin/ 目录下 3、独立进程 运行（的 二进制文件） linux中常见的文件系统有三类：基于磁盘的文件系统；基于内存的文件系统；网络文件系统， 结论： ls -la 看到的，部分是在内存，部分在磁盘 ---------> 主要看Filesystem 的类型 tmpfs, 临时文件系统 ------> 存储于RAM，虚拟文件系统 proc ------> 存储于RAM，虚拟文件系统 ：进程相关 参考： https://zhuanlan.zhihu.com/p/619966043?utm_id=0&eqid=fd4dda010004ae4c000000046459f99b sysfs P13_5G:/ $ df -a Filesystem 1K-blocks Used Available Use% Mounted on tmpfs 2292348 3408 2288940 1% /dev devpts 0 0 0 0% /dev/pts proc 0 0 0 0% /proc sysfs 0 0 0 0% /sys selinuxfs 0 0 0 0% /sys/fs/selinux tmpfs 2292348 36 2292312 1% /mnt /dev/block/vda13 29584 172 28376 1% /metadata /dev/block/dm-2 1480328 1475848 0 100% / /dev/block/dm-4 1832960 251460 1581500 14% /mnt/scratch overlay 1832960 251460 1581500 14% /system overlay 1832960 251460 1581500 14% /vendor overlay 1832960 251460 1581500 14% /product tmpfs 2292348 0 2292348 0% /apex tmpfs 2292348 264 2292084 1% /linkerconfig tmpfs 2292348 36 2292312 1% /mnt/installer tmpfs 2292348 36 2292312 1% /mnt/androidwritable overlay 1832960 251460 1581500 14% /apex/com.android.adbd overlay 1832960 251460 1581500 14% /apex/com.android.permission overlay 1832960 251460 1581500 14% /apex/com.android.runtime overlay 1832960 251460 1581500 14% /apex/com.android.ipsec overlay 1832960 251460 1581500 14% /apex/com.android.mediaprovider overlay 1832960 251460 1581500 14% /apex/com.android.vndk.v30 overlay 1832960 251460 1581500 14% /apex/com.android.art overlay 1832960 251460 1581500 14% /apex/com.android.tethering overlay 1832960 251460 1581500 14% /apex/com.android.wifi overlay 1832960 251460 1581500 14% /apex/com.android.sdkext overlay 1832960 251460 1581500 14% /apex/com.android.conscrypt overlay 1832960 251460 1581500 14% /apex/com.android.extservices overlay 1832960 251460 1581500 14% /apex/com.android.neuralnetworks overlay 1832960 251460 1581500 14% /apex/com.android.media overlay 1832960 251460 1581500 14% /apex/com.android.os.statsd overlay 1832960 251460 1581500 14% /apex/com.android.resolv overlay 1832960 251460 1581500 14% /apex/com.android.media.swcodec overlay 1832960 251460 1581500 14% /apex/com.android.tzdata overlay 1832960 251460 1581500 14% /apex/com.android.cellbroadcast overlay 1832960 251460 1581500 14% /apex/com.android.i18n none 0 0 0 0% /dev/cg2_bpf none 0 0 0 0% /dev/cpuctl none 0 0 0 0% /acct none 0 0 0 0% /dev/cpuset none 0 0 0 0% /dev/freezer none 0 0 0 0% /dev/memcg none 0 0 0 0% /dev/stune tmpfs 2292348 264 2292084 1% /linkerconfig tracefs 0 0 0 0% /sys/kernel/tracing debugfs 0 0 0 0% /sys/kernel/debug none 0 0 0 0% /config binder 0 0 0 0% /dev/binderfs none 0 0 0 0% /sys/fs/fuse/connections sys_call（比如open） 图来源：https://blog.csdn.net/weixin_42792088/article/details/132800522 Linux中的虚拟文件系统（virtual file system） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_computorBase/OperateSystem.html":{"url":"coding/0_computorBase/OperateSystem.html","title":"Operate System","keywords":"","body":"1. 目录2. 视频课程3. 什么是操作系统（what）3.1. 从功能角度：3.2. 从硬件资源角度3.3. 操作系统的历史3.4. 操作系统结构4. 操作系统基础操作4.1. 启动4.2. 中断、异常和系统调用5. TODO:6. 面试题6.1. 进程隔离相关6.1.1. why 为什么需要进程间隔离？6.1.2. what-----进程之间的隔离主要体现在哪里？ how如何实现的？ TODO ---字节 视频课程 什么是操作系统（what） 从功能角度： 从硬件资源角度 操作系统的历史 操作系统结构 操作系统基础操作 启动 中断、异常和系统调用 TODO: 面试题 进程隔离相关 why 为什么需要进程间隔离？ what-----进程之间的隔离主要体现在哪里？ how如何实现的？ TODO ---字节 1. 目录 网易面试官: 操作系统是你必须迈过去的一道坎。不然工作十年后，你会被应届生卷死 2. 视频课程 https://www.bilibili.com/video/BV1wv4y1S7xm?p=2&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 清华 计算机操作系统 笔记，参考： https://blog.csdn.net/iwanderu/article/details/103934127 3. 什么是操作系统（what） 3.1. 从功能角度： 自然： -----------> 硬件资源角度 3.2. 从硬件资源角度 目的： 封装硬件资源，给APP进程使用 具体： 操作系统将 三大硬件资源，分别抽象成软件概念： cpu ----- 进程 磁盘------文件 内存-------地址空间 操作系统的软件层次： Shell + kernel Shell 是对用户的: 比如GUI（Linux、Windows、Android 界面 ）、命令行等 kernel：真正提供功能的 ​ （1） kernel底层：中断、I/O、设备驱动 kernel： OS Kernel的特征: 1、并发 ​ 计算机系统中同时存在多个运行的程序 -----> 需要OS管理和调度 补充：并发与并行的区别，很自然： 并行指的是一个时刻 ----> 自然，对于cpu，不存在并行 （多核除外) 并发指的是一小段时间，时间片轮转上 2、共享 “同时”访问 互斥共享 3、虚拟 利用多道程序设计技术,让每个用户都 觉得有一个计算机专门为他服务 4、异步 程序的执行不是一贯到底,而是走走停 停,向前推进的速度不可预知 但只要运行环境相同,OS需要保证程序 运行的结果也要相同 3.3. 操作系统的历史 如果要理解深刻，必须知道历史。。。因为历史给出了为什么是这样 3.4. 操作系统结构 4. 操作系统基础操作 4.1. 启动 知识点： ●计算机体系结构概述 ●计算机内存和硬盘布局 ● 开机顺序 启动流程： 4.2. 中断、异常和系统调用 ● 背景 ●中断、异常和系统调用相比较 ●中断和异常处理机制 ●系统调用的概念 ●系统调用的实现 ● 程序调用与系统调用的不同之处 ● 开销 DISK:存放OS BIOS:基本I/O处理系统 Basic Input Output System 5. TODO: 《计算机组成原理》 全量课程： https://www.bilibili.com/video/BV1Wv411x7zP?p=2&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 6. 面试题 6.1. 进程隔离相关 参考： https://blog.csdn.net/s2311307/article/details/108862748 Android的进程间通信（一） 之 进程隔离简述 6.1.1. why 为什么需要进程间隔离？ 来自：https://blog.csdn.net/s2311307/article/details/108862748 安全性：为了避免A进程写入B进程的情况发生 很自然 6.1.2. what-----进程之间的隔离主要体现在哪里？ how如何实现的？ TODO ---字节 -----> TODO: 链接到知识点里 主要是内存的隔离 实现： 采用了虚拟地址空间，两个进程各自的虚拟地址不同，从逻辑上来实现彼此间的隔离。-----> TODO: 具体的过程！！！图 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_computorBase/refactor.html":{"url":"coding/0_computorBase/refactor.html","title":"Refactor","keywords":"","body":"1. 目录2. 重构3. 代码写法：差异性封装 重构 代码写法：差异性封装 1. 目录 2. 重构 教程： https://www.bilibili.com/video/BV1mr4y1V7aD/?spm_id_from=333.788&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 文档：https://hardcore.feishu.cn/docx/doxcn4HcvfoSVUvkLALvzfD4B5c 3. 代码写法：差异性封装 目的、好处： 调用形式上统一（优雅，避免了if else 逐个判断） 差异性，封装在一起，利于修改 手段： 差异化处理 《---------------》抽取公共部分 方法一： 父类封装差异性： 不同的差异，由不同的子类处理 父类抽取公共部分，子类处理差异化： 例子： //解析init.rc时 ServiceParser::ParseLineSection 解析行时，根据不同的关键词，选择不同的SectionParser。比如：service 选择 ServiceParser；import 选择 ImportParser section_parser->ParseLineSection(std::move(args), state.line); // 【】section_parser 调用处，形式上统一 ----------> TODO: 从设计角度来看：1、很合理：不同的类型，不同类来处理； 2、但是父类的抽象方法，是如何抽象出来的？ 方法二： map表封装差异性（C语言常用的方法）: 不同的差异，由不同的处理函数 // \\\\system\\\\core\\\\init\\\\service_parser.cpp Result ServiceParser::ParseLineSection(std::vector&& args, int line) { if (!service_) { return {}; } auto parser = GetParserMap().Find(args); if (!parser.ok()) return parser.error(); return std::invoke(*parser, this, std::move(args)); // 【】调用处，形式上统一，看不出来差异 } const KeywordMap& ServiceParser::GetParserMap() const { constexpr std::size_t kMax = std::numeric_limits::max(); static const KeywordMap parser_map = { // 【】map封装差异性 ................... {\"group\", {1, NR_SVC_SUPP_GIDS + 1, &ServiceParser::ParseGroup}}, ................... {\"keycodes\", {1, kMax, &ServiceParser::ParseKeycodes}}, {\"memcg.limit_in_bytes\", {1, 1, &ServiceParser::ParseMemcgLimitInBytes}}, {\"memcg.limit_percent\", {1, 1, &ServiceParser::ParseMemcgLimitPercent}}, {\"memcg.limit_property\", {1, 1, &ServiceParser::ParseMemcgLimitProperty}}, {\"memcg.soft_limit_in_bytes\", .............................. {\"onrestart\", {1, kMax, &ServiceParser::ParseOnrestart}}, {\"reboot_on_failure\", {1, 1, &ServiceParser::ParseRebootOnFailure}}, {\"restart_period\", {1, 1, &ServiceParser::ParseRestartPeriod}}, {\"rlimit\", {3, 3, &ServiceParser::ParseProcessRlimit}}, .............................. {\"sigstop\", {0, 0, &ServiceParser::ParseSigstop}}, {\"socket\", {3, 6, &ServiceParser::ParseSocket}}, {\"task_profiles\", {1, kMax, &ServiceParser::ParseTaskProfiles}}, {\"timeout_period\", {1, 1, &ServiceParser::ParseTimeoutPeriod}}, {\"user\", {1, 1, &ServiceParser::ParseUser}}, }; // clang-format on return parser_map; } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_computorBase/用户_用户组.html":{"url":"coding/0_computorBase/用户_用户组.html","title":"用户_用户组","keywords":"","body":"1. 目录2. 用户3. 参考： https://www.youtube.com/watch?v=pkWmqa9tEt8 目录 用户 参考： https://www.youtube.com/watch?v=pkWmqa9tEt8 1. 目录 [TOC] 2. 用户 错误概念： 用户访问文件 ---------> 错误！！！ 本质上，是进程访问文件 Users 和 Group： 目的：---------》 本质就是访问权限的管理方式 Users: 1、运行的权限范围是 用户： 能侵入的权限 Every process (running program) on the system runs as a particular user. 系统上的每个进程(运行的程序)都是作为特定用户运行的 . 2、静止的，都有主了： 被侵入需要的权限 Every file is owned by a particular user. 每个文件是由一个特定的用户拥有. 3、自然，权限匹配，才能访问 The user associated with a running process determines the files and directories accessible to that process. 与正在运行的进程相关联的用户定该进程可访问的文件和目录 groups： ----------> 目的：避免Users，一个一个赋予权限，太麻烦 生活化例子： 看朋友圈动作，必须是一个人；即user 我的朋友圈，属于我 谁能看我的朋友圈，一定是我指定的 ​ 或者在某一个分组里的 // 查看当前登录的用户信息： [root@tianyun ~]# id uid=0(root) gid=0(root) groups=0(root) // root用户的 [root@tianyun ~]# id root uid=0(root) gid=0(root) groups=0(root) //alice用户的 [root@tianyun ~]# id alice uid=1002(alice) gid=1002(alice) groups=1002(alice) [root@tianyun ~]# 3. 参考： https://www.youtube.com/watch?v=pkWmqa9tEt8 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_computorBase/解耦.html":{"url":"coding/0_computorBase/解耦.html","title":"解耦","keywords":"","body":"1. 目录2. 解耦案例2.1. 尽量不修改安卓framework层代码2.2. 退而求其次-----如果修改，插桩3. 其他架构案例3.1. 一个soc，三个系统，为啥显示要共一个host？4. framework代码解耦 解耦案例 尽量不修改安卓framework层代码 退而求其次-----如果修改，插桩 其他架构案例 一个soc，三个系统，为啥显示要共一个host？ framework代码解耦 1. 目录 [TOC] 2. 解耦案例 2.1. 尽量不修改安卓framework层代码 比如，监听前台应用的切换： weichat ----> launcher 不在framework的ams里监控，这样耦合太深 用无障碍监听 （优点：修改放到APP里，这样对系统代码0修改-----> 大版本迁移0成本） https://blog.csdn.net/yzwfeng/article/details/124584900 判断某App位于前台还是后台的6种方法 2.2. 退而求其次-----如果修改，插桩 不得已，要修改安卓系统层代码（framework层或native层） -规定： 使用插桩的方式 : 1、在aosp中函数插装(+注释) 2、函数实现放到一个单独文件里，与 原文件解耦 3. 其他架构案例 3.1. 一个soc，三个系统，为啥显示要共一个host？ 一个soc： host仪表 + 安卓主控 + 安卓副驾---------> 全部在host渲染？ 原因： 这样，只需要适配一个底层就行 -------> 为了硬件更加快速的适配？ TODO： 4. framework代码解耦 代码解耦： -----> 自研，独立成函数、独立成类 功能解耦：-----> 独立成模块，各个模块之间通过通信 插桩：-----> 一个功能，一行代码 SDK 结构： 第一层应该是权限校验，判空等 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_IPC/":{"url":"coding/0_IPC/","title":"0 IPC","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_IPC/AndriodIPC.html":{"url":"coding/0_IPC/AndriodIPC.html","title":"Andriod IPC","keywords":"","body":"1. 目录2. 进程设计的意义/初衷2.1. 进程天然内存隔离，系统为什么采用多进程呢？2.2. APP的多进程2.3. 总结 涉及到IPC的场景3. 进程间通信（IPC）---Binder3.1. 前戏3.1.1. Linux IPC通信方式的种类：3.1.2. Parcel + Parcelable3.2. 0层流程-----一次Binder通信3.3. 0层结构-----Binder架构（存在三个ipc）3.4. 功能实现之管理结构(后面拆除掉)3.4.1. 管理模型，类似于其他C/S架构3.5. 功能实现之核心结构3.6. Binder的创建3.6.1. Binder是什么3.6.2. Binder驱动的创建时机3.6.3. Binder的注册时机3.7. AIDL3.8. 分析一次Binder调用(核心)3.8.1. client--->BinderProxy--->binder驱动3.8.2. binder驱动--->BinderProxy--->server3.9. binderService流程3.10. Binder的 同步调用 / 异步调用3.10.1. 异步3.11. 优缺点：3.12. 实现机制3.13. 参考：3.14. 其他细节3.14.1. binder安全机制3.14.2. 一些函数3.15. 参考3.16. 面试题4. Binder线程池 TODO5. 框架的背后6. 自然法则7. 技巧之 aidl的调试8. IPC前提------序列化9. 格式9.1. 使用逻辑： 进程设计的意义/初衷 进程天然内存隔离，系统为什么采用多进程呢？ APP的多进程 总结 涉及到IPC的场景 进程间通信（IPC）---Binder 前戏 Linux IPC通信方式的种类： 内存共享 管道 消息队列 socket 信号量 为啥安卓要重新做一个Binder呢（对比）？ Parcel + Parcelable 0层流程-----一次Binder通信 0层结构-----Binder架构（存在三个ipc） 功能实现之管理结构(后面拆除掉) 管理模型，类似于其他C/S架构 功能实现之核心结构 Binder的创建 Binder是什么 Binder驱动的创建时机 Binder的注册时机 AIDL 分析一次Binder调用(核心) client--->BinderProxy--->binder驱动 binder驱动--->BinderProxy--->server binderService流程 Binder的 同步调用 / 异步调用 异步 例子： 优缺点： 实现机制 参考： 其他细节 binder安全机制 一些函数 参考 面试题 Binder线程池 TODO 框架的背后 自然法则 技巧之 aidl的调试 IPC前提------序列化 格式 使用逻辑： 1. 目录 2. 进程设计的意义/初衷 我们谈到IPC，那么其实就有疑问了，不要有那么多进程不就行了？不就不存在进程隔离了吗？ 2.1. 进程天然内存隔离，系统为什么采用多进程呢？ ----安全(隔离)/稳定/内存分配 2.2. APP的多进程 一个APP为啥要做成 多进程？见下图： 主要（也是开发技巧）： 1、突破522M内存限制（虚拟机给一个java进程的） 2、稳定：将 需要稳定的重要代码与不稳定的分离开，不至于一起crash ​ 比如 微信的消息 接受功能。不能因为微信界面进程crash，而收不到消息！！！！！！，不然信息丢掉了 举例子： QQ等应用就是多线程 2.3. 总结 涉及到IPC的场景 APP进程间、APP进程与FrameWork的系统进程、FrameWork的系统进程与native（部分是jni） native 与 kernel进程之间（TODO: 跨了进程？） 3. 进程间通信（IPC）---Binder 3.1. 前戏 因为要谈论andriod的Binder，不得不： 2、为啥不用linux本身的，为啥andriod自己要开发一套Binder机制？（即优缺点） 1、-----> 自然，先要列举一下Linux本身的IPC通信方式 3.1.1. Linux IPC通信方式的种类： 1、2、3、4、5、6 注意：c嵌入式开发，经常使用信号量 如何遍历记忆？: 内存共享 生活化模型，合租房子： 我家的客厅就是你家的客厅。。。注意：内存共享，没有使用内核空间 共享内存的缺点： 我家的客厅就是你家的客厅，那还有安全可言嘛 ----> 官方：没有同步控制：1、访问出现紊乱 2、信息安全没有保障 注：由图知道，进程地址空间，全部地址----------> 只是映射到 物理内存 ​ 所以，从本质物理上看，共享内存，就是共享的物理内存（地址空间相同） 管道 生活化模型，管道走线： 一边人塞进去，另一边人拉出来 管道，利用文件作为中间介质（利用了内核空间） TODO, 注意：管道的方向是一定的？单向的 缺点： 1、两次复制 A ---> 管道 ----> B （模型: 一推一拉） 2、管道会阻塞（管道有多大） 消息队列 消息队列（存在于内核中）-------> 也是利用内核空间内存 消息的发送方和接受方，要约定好消息体的类型（和大小） 生活化模型，快递模型： 快递公司， 内核中的消息队列：负责接收、存储、发送快递包裹（消息）。 快递包裹，消息：有一个唯一的标识号（消息类型），发件人（发送方）将包裹交给快递员（消息队列），然后快递员将包裹存储到快递公司的仓库（消息队列缓冲区）中。 自然： 收件人（接收方）需要从快递公司的仓库中取出包裹，只能取走属于自己的包裹： 根据唯一标识取（实际上就是发取双方的协议） 如果没有属于自己的包裹，收件人需要等待，直到快递员把包裹送到仓库中。 socket 这个图和 管道 很相似 -------> 感觉没啥区别？ 与管道区别: 方向性不同：Socket通信是双向的，而管道通信是单向的。 应用范围不同：Socket通信可以在不同的机器之间（网络）进行通信，而管道通信只能在同一个机器上的进程之间进行通信。 传输方式不同：Socket通信是面向连接的，而管道通信是面向数据流的。 缺点： 两次copy 信号量 为啥安卓要重新做一个Binder呢（对比）？ 进程通信对比 2、或者说， 共享内存和 Socket的一个 中间态：取Socket的copy + 共享内存的内存映射 补充： 后面几种（除了共享内存），都有一个特点： 必须通过内核空间 3.1.2. Parcel + Parcelable 模型：图 TODO 目的在于： 拆解成基本类型，通过内核（IoCtrl） 本质：Parcel + Parcelable 。与类没有任何关系， 已经拆解成基本类型了 ​ 可以打包的数据，自然：Parcelable(Intent、Bundle) + 基础数据类型 + list + map + Binder（TODO: 如何做的？？？） 推论：Parcel作用就是拆解 类----> 基本数据类型序列 应用场景：跨进程传输，打包解包必须（必须int传输） 3.2. 0层流程-----一次Binder通信 IPC.eddx 分层设计思想：类比于 五层TPC/IP协议体系，见 http://gityuan.com/2016/09/04/binder-start-service/ 好处： 从功能实现角度看，层与层具有独立性, 例如应用层可以使用传输层提供的功能而无需知晓其实现原理; 设计灵活, 层与层之间都定义好接口, 即便层内方法发生变化,只有接口不变, 对这个系统便毫无影响; 结构的解耦合, 让每一层可以用更适合的技术方案, 更合适的语言; 从维护角度看，方便维护, 可分层调试和定位问题; 3.3. 0层结构-----Binder架构（存在三个ipc） 参考： https://www.cnblogs.com/yocapl/p/12422617.html 逻辑化简： 1、上图中步骤1、2、3是虚线的，并不是直接调用。系统调用Binder驱动完成的 2、上图存在三个进程：client进程、server进程、Service Manager进程 ---> 任意两个之间的交互都是通过Binder？ 3、从应用角度：应用层只需要实现client 和 server； 4、对于应用层来说，看到的 就是 client调用 server 5、背后的架构：C/S架构 6、从实现机制上看，有点儿类似linux共享内存 7、从数据拷贝次数来看，Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次。共享内存不需要拷贝，Binder的性能仅次于共享内存。---> 为什么不用共享内存？共享内存需要处理并发同 基于0层的生活化模型： 床柜挪房间模型： 两个房间：两个进程。进程内存隔离 两个房间之间有个客厅： 内核，通往客厅的门只能通过小的基本类型数据 拆床说明书（即组装床说明书）Parcelable、同样拆柜子说明书：Bed implements Parcelable --------> 这个其实不是AIDL。不得不：两边有一模一样的 拆哪个东西的约定：AIDL协议--------> 即int code表征执行哪个方法。。。不得不：两边有一模一样的AIDL 目标：床柜挪房间 ---------- > 不得不： 1、这边房间需要拆床 ，拆完的 基本部件才能通过门，到另一个房间 2、到另一个房间后，怎么知道这次拆的是床的 ------>AIDL协议 3.4. 功能实现之管理结构(后面拆除掉) 0层结构图中的： 一般C/S架构必然有 管理者，server用来注册；client端用来查询 所以，ServiceManager 一句话本质： 维护了 binder名-------Binder列表： 比如 “Activity” ----- AMS的Binder AMS的Binder 何时注册到 ServiceManager呢？见《系统启动流程>中的publishBinderService流程 Q： ServiceManager本身底层也是 Binder, 他怎注册呢？ A: 自然，必然是固定的，不注册。 ServiceManager对应的handle为0，取到对应binder TODO: 如果是APP开发者自己定义的Service，binderService时，走的是AMS，没有注册到ServiceManager嘛？ 注意：后面看流程，先把管理serviceManager给去除了 3.4.1. 管理模型，类似于其他C/S架构 再比如：DNS 服务器，也是维护了 域名----IP的列表 3.5. 功能实现之核心结构 Binder的物理本质 : 一个词总结： 共享内存 一句话总结： Binder 是在 共享内存的基础上， 以性能（增加copy）为代价，换取了 安全性 注意：1、上图是在 共享内存 图的基础演化而来。差别在于： ​ （1）内存映射 的双方不同： 共享内存是两个APP进程 ；Binder是 内核进程 与 server端 ​ （2）mmap()功能的物理实现 即 图中1和2 数据流： client 发送数据 ----> kernel ( kernel 内核空间地址，映射到了物理内存，则server能感受到) 从数据的流转来看（数据结构的变化）, Binder的本质： 经过内核，不得不： 1、传输的数据，不得不拆解成int、string等基本类型（TODO: 经过内核时，是不是更基本？） -----> 所以，parcel拆解，是不得不的 2、AIDL协议也是不得不的，AIDL要做两件事情：（1）保证 触发与接收函数一致，通过code（2）保证拆合，原则一致，有同一套说明书 （Parcelable保证的！！！！！不是AIDL） AIDL从模型的角度的本质：即上面保证（协议） 官方描述： mmap() 是操作系统中一种内存映射的方法。 内存映射就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。 基于上图，一句话： 整个Binder机制，唯一核心的就是映射1（ kernel内存地址 和 物理内存 的映射）创建 -------> 在server端 ， Binder的创建流程中，见下 3.6. Binder的创建 目标：整个Binder机制唯一核心------- 映射的创建 3.6.1. Binder是什么 不同角度： 机制: Binder是一种进程间通信机制; ----> 这个角度来看： Binder 是 安卓的 神经系统 从功能看：Binder就是一种服务（虽然可能不是service，比如主线程的Binder）。所以，天生的，Service，底层必然是Binder 应用层: Binder是一个能发起通信Java类; ---> 对外的接口 Framework/Native: Binder Client、 Server、 Service Manager和Binder驱动程序, 形成一套C/S的通 信架构 驱动: Binder是一个虚拟物理设备驱动; ----> 真正实现功能的地方 物理角度：Binder的本质 见上 --------> 记忆锚点： 应用层来看、Framework/Native、驱动、物理角度 3.6.2. Binder驱动的创建时机 进程创建的时候，一般就创建了。比如： 问题1：为啥要在APP创建时，要第一时间初始化Binder驱动呢？ A: 因为创建APP进程之后，会将自己的Binder给到AMS来管理（后续，AMS让APP创建Activity） -----> 见APP启动流程 ​ 自然，在这之前，要创建Binder 问题2：zygote进程有自己的 binder嘛？ video7 A：没有。 linux角度：因为主要功能是生孩子（fork）。linux不允许fork的有多线程，会产生死锁 ----> 规则 代码角度：TODO 3.6.3. Binder的注册时机 （1）0号引用 ServiceManager 的Binder不需要注册 （2）对于一个普通的APP定义的service，何时注册到 ServiceManager 的？ 3.7. AIDL aidl 目的： 就是 对外接口 Proxy和stub，自动生成。不用APP开发者自己写 为啥不能纳入framework呢？没办法，因为AIDL里面的具体接口函数，不清楚 所以，AIDL是封装 ​ AIDL也是没能纳入framework层的妥协，利用编译抽取公共功能--------> TODO: 背后的背后： 收集这个技巧！！ 核心的核心就是 Ibinder如何传递的 注意： 两个 APP源代码，必须有相同的 .aidl文件 文件 推论：虽然Server端有Proxy，但是没有用到 TODO: AIDL编译也可以生成native的proxy和stub？？？？？？ 从APP开发者来看： AIDL是接口 -----> 自然，server和client都要（复制一份一模一样的 或者 编译共用一个） AIDL的本质，一句话： ​ 1、从代码角度：对proxy和stub进行封装 ------> 通过编译.aidl文件，自动生成 proxy 和 stub文件 ​ 2、从模型角度： 见上 3.8. 分析一次Binder调用(核心) 前提条件： 默认 client 已经持有 server端的 binder了（物理上持有的是啥？）通过 manger 3.8.1. client--->BinderProxy--->binder驱动 即0层架构图的 以 APP 获取AMS服务为例子，即ServiceManager.getService方法 ： 前提，已经持有ServiceManager对应的Binder了 角色： client ---- APP BinderProxy ---- ServiceManagerProxy jni BpBinder Binder驱动 ------- 即 ServiceManager对应的0号 Binder 3.8.2. binder驱动--->BinderProxy--->server 以ServiceManager.addService为例子： 3.9. binderService流程 注：如上所说，Binder本质就是体现一个服务 (但不一定都是Service) 原图： 化简： 1、2、5、6删除。Client 通过 AMS 、Server也通过AMS，自然 ，先必须找ServiceManager 触发点： MainActivity.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE); // 唯一核心代码 唯一一行核心代码： AMS把 Service的Binder给到 Client端： onServiceConnected() 之前流程。调用栈： 也是上图的一句话总结 总结： 上图总共 8次跨进程 通信！！！！ 繁琐的展开流程如下： 1）Activity作为Client发起bindService，最终会调度到AMS 去执行bindService。在这个过程中，Client要去调用 AMS的代码，所以此时就会涉及到跨进程调度，基于第三章的Binder通信模型我们不难知道，Client会先和 ServiceManager通信，从ServiceManager中拿到AMS的IBinder。 2）Activity拿到AMS的IBinder后，跨进程执行AMS的BindService函数； 3）由于AMS管理所有的应用进程，因此AMS中持有了应用进程的Binder，所以此时AMS可以发起第4步也就是跨进 程调度scheduleBindService(); 4)Server端会在收到AMS的bindService的请求后，会将自己的IBinder发送给client，但是Server必须通过AMS才能 将Binder对象传过去，所以此时需要跨进程从ServiceManager中去拿到AMS的binder； 5）Server端通过AMS的binder直接调用AMS的代码publishService(),将service的Binder发送给AMS； 6）经过层层调用，最终AMS讲Server端的binder通过回调connect函数传递给了Client端的Activity； 以上就是bindService的全流程，这个流程主要的目的是将Server端的Binder对象发送给Client端。从此以后，Client 端就可以通过Server端的binder与Server端像调用自己的代码一样完成跨进程通信了 3.10. Binder的 同步调用 / 异步调用 结论：默认都是同步调用 ​ 即 A 应用调 B应用，等待B应用的返回结果 同步调用，图： 关注点：（1）client 休眠（ 在等待结果时）； （2）Server端 是在binder线程上 （非主线程） 为什么默认都是同步？同步为何是自然的？ 1、同步是自然的 2、很多情况，Client调Server是需要 获取结果（reply）的： 比如BOOK中例子，获取Server端的getBookList() ​ 从模型角度： 要等待结果，必须休眠 ​ 从代码角度： // Client 端 public java.util.List getBookList() { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List _result; try { _data.writeInterfaceToken(DESCRIPTOR); boolean _status = mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); //【1】 ............ _result = _reply.createTypedArrayList(com.example.aidl.Book.CREATOR); //【2】 } ............ return _result; } 必须等【1】执行完，_reply才有数据，【2】才能用_reply 3.10.1. 异步 异步调用，图： 对比同步，异步注意点： client不会休眠（自然也不会等待结果） 代码层面的区分点： //Proxy中： mRemoteBinder.transact(REQUEST_CODE, _data, _reply, 0);// flag = 0 // flag = 0 表示同步调用（默认），1 表示表示异步调用（自然， 异步调用_reply必须为null） 补充：1即 IBinder.FLAG_ONEWAY 从aidl的接口定义角度： 自然，oneway的aidl的接口定义是不能有返回值的 （返回值都是由_reply承载的） ​ 比如： oneway interface IApplicationThread{..........} 使用方法： oneway关键字，决定了 代码中 flag = 1 IPCThreadState角度： TODO: https://www.jianshu.com/p/db2df0a4e037 线程角度： TODO 对于ONEWAY接口，所有调用在server端都被串行化(尽管不同应用发起请求是并行的) 例子： onesay主要用于系统服务向应用端发起binder调用： scheduleLaunchingActivity: 系统服务向应用端发起oneway binder调用，让应用端启动acitvitiy IWindow：WMS向应用端发起oneway binder调用 IServiceConnection: 应用端bindService完成时，AMS向应用端发起的oneway binder调用 IIntentReceiver：AMS发起oneway binder调用 分发广播 具体例子： // IApplicationThread.aidl oneway interface IApplicationThread{ void scheduleTransaction(........); // 同步生命周期的。即启动应用侧 acitvitiy // 所有方法，不能有返回值 } 结论： 系统侧----> APP侧，必须是 oneway 的aidl ​ TODO: APP侧绝不能阻塞系统侧 APP侧 ----> 系统侧，一般可以是 同步aidl： 自然，APP里AIDL一般不加oneway 3.11. 优缺点： oneway binder 优点： 1，异步：应用端处理这些oneway binder调用，如果很耗时，也不会阻塞系统服务 2，串行化，系统会逐个分发binder 调用 3.12. 实现机制 TODO: 3.13. 参考： https://www.jianshu.com/p/db2df0a4e037 Android Framework学习之Binder的oneway机制 https://blog.csdn.net/yu8fei/article/details/109389362?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109389362-blog-123662130.235%5Ev32%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109389362-blog-123662130.235%5Ev32%5Epc_relevant_default_base3&utm_relevant_index=2 Binder的同步与异步 3.14. 其他细节 3.14.1. binder安全机制 上面说binder比其他IPC机制更加安全，体现在内核 对 UID/PID进行有效性检测。 TODO: 具体如何校验的？ 3.14.2. 一些函数 Binder.getCallingPid(); //获取 调用binder的进程pid（自然是在 在服务端 ） 3.15. 参考 http://gityuan.com/2016/09/04/binder-start-service/ http://gityuan.com/2015/10/31/binder-prepare/ https://blog.csdn.net/carson_ho/article/details/73560642 https://developpaper.com/principle-and-use-of-android-binder/ https://blog.csdn.net/carson_ho/article/details/73560642 -->Binder优质文章 一些结论： 一个Binder就是一个线程。比如： AMS实现了Ibinder接口，是一个Binder, 所以也是一个binder线程 Binder机制：https://blog.csdn.net/carson_ho/article/details/73560642 这3大过程每一次都是一个完整的BinderIPC过程 http://gityuan.com/2016/09/04/binder-start-service/ 《Binder预习资料.pdf> 3.16. 面试题 https://blog.csdn.net/xuyin1204/article/details/118546330?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162599351116780274143599%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162599351116780274143599&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-118546330.pc_v2_rank_blog_default&utm_term=binder&spm=1018.2226.3001.4450 Binder相关面试题目 4. Binder线程池 TODO 5. 框架的背后 6. 自然法则 7. 技巧之 aidl的调试 [Android AIDL系列 1] 手动编译aidl文件，生成Java、C++[android]、C++[ndk]、Rust接口_aidl ndk-CSDN博客 编译结果里搜索 编译命令是啥？ Android R系统aidl文件怎么对应的java文件找不到了?_aidl生成的java文件-CSDN博客 -------------------> 验证ok 重要的事情说三遍-I ,-p等后不接空格 直接跟参数，不要空格，不要空格 例1： ./prebuilts/sdk/tools/linux/bin/aidl \\ -I./frameworks/base/core/java/ \\ -I./frameworks/base/location/java/ \\ -I./frameworks/base/graphics/java/ \\ -p ./prebuilts/sdk/current/public/framework.aidl \\ -oaidl-out \\ ./frameworks/base/core/java/android/view/IWindowSession.aid 例2： ./prebuilts/sdk/tools/linux/bin/aidl \\ -I./frameworks/base/core/java \\ -p./prebuilts/sdk/current/public/framework.aidl \\ -oaidl-out \\ ./frameworks/base/core/java/android/view/IWindowSession.aidl 注意: 要加 ./prebuilts/sdk/current/public/framework.aidl ，否则编译不过！！！！！预编译好的，因为有些aidl依赖于其他aidl 8. IPC前提------序列化 见《IPC前提 序列化.md》 9. 格式 9.1. 使用逻辑： 跳转使用逻辑 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_IPC/IPC前提_序列化.html":{"url":"coding/0_IPC/IPC前提_序列化.html","title":"IPC前提_序列化","keywords":"","body":"1. 目录2. IPC前提------序列化2.1. 序列化的本质是啥？2.2. 安卓序列化源码分析2.2.1. 0层2.2.2. J_parcel的获取与recycle()2.2.3. 构造的过程是怎样的？2.2.4. parcel与Ibinder的关系？？？3. TODO：序列化最终的承载的容器是什么？buffer？4. 从数据结构看Parcel4.1. Parcel.dataSize() 计算：5. cpp Parcel的使用5.1. parcel5.2. parcel的梳理5.3. 多参数函数，多参数如何序列化与反序列化的？-----分层分析5.3.1. 序列化流程：5.3.2. 反序列化流程：5.4. TODO： 从模型角度，利用了什么语言特性实现的Aidl接口？6. TODO：如何寻找到对端对象的？7. 技巧之序列化调试7.1. 以偏概全 之parcel数据 IPC前提------序列化 序列化的本质是啥？ 安卓序列化源码分析 0层 J_parcel的获取与recycle() 构造的过程是怎样的？ parcel与Ibinder的关系？？？ TODO：序列化最终的承载的容器是什么？buffer？ 从数据结构看Parcel Parcel.dataSize() 计算： cpp Parcel的使用 parcel parcel的梳理 多参数函数，多参数如何序列化与反序列化的？-----分层分析 序列化流程： 反序列化流程： 如何寻找函数 如何创建 参数（对象）-----createFromParcel TODO： 从模型角度，利用了什么语言特性实现的Aidl接口？ TODO：如何寻找到对端对象的？ 技巧之序列化调试 以偏概全 之parcel数据 1. 目录 2. IPC前提------序列化 2.1. 序列化的本质是啥？ Java序列化的本质是将Java对象保存为二进制字节码。-----> 进而可以传输 + 存储 传输有哪些，传输为什么要序列化？ 传输：网络传输、进程间通信IPC 为什么？----> 本质在于：同一进程间，对象的传递 传地址内存。。。同一进程有统一的内存 不同进程间，内存是独立的 存储为什么序列化？？（-----> 电脑上存储都是二进制的） 一座大厦好比一个对象，你要把这座大厦搬到另外一个地方去，你想直接挪肯定不行吧？(一般来说，只有传值，没有传对象)但我可以搬砖头吧，一个一个搬，然后搬到目的地重新组合成一个大厦，而序列化就起到了将大厦分成砖头的作用. TODO：最底层逻辑，如何做到的呢？？？ TODO：为什么会很高效？？？没有序列化结构，只是序列化数据 补充:HW笔记 序列化结果: 字节序列 TODO: 序列化，底层的承载是啥？一个buffer吗？还是？ 2.2. 安卓序列化源码分析 --->Parcel序列化 2.2.1. 0层 https://blog.csdn.net/tkwxty/article/details/107916160 内核 Todo：内核调用怎么理解？？？--->系统调用 用户空间与内核空间怎么理解？？？ 2.2.2. J_parcel的获取与recycle() //parcel.java private static final Parcel[] sOwnedPool = new Parcel[POOL_SIZE];//1 6个对象的对象池 public static Parcel obtain() { final Parcel[] pool = sOwnedPool; synchronized (pool) { Parcel p; for (int i=0; i但是有其他引用 if (DEBUG_RECYCLE) { p.mStack = new RuntimeException(); } p.mReadWriteHelper = ReadWriteHelper.DEFAULT;//todo:作用？？？ return p; } } } return new Parcel(0);//3 新建，没加入对象池里面！ } //1 用了对象池：1、由于parcel对象创建+释放的非常频繁---->消耗资源 2、不是轻量级对象 // 3 自然的，没加入代表在使用---->recycle时，有可能加入对象池（前提：有空位）,见#3_1 public final void recycle() { if (DEBUG_RECYCLE) mStack = null; freeBuffer(); final Parcel[] pool; if (mOwnsNativeParcelObject) { pool = sOwnedPool; } else { mNativePtr = 0; pool = sHolderPool; } synchronized (pool) { for (int i=0; i 2.2.3. 构造的过程是怎样的？ //Parcel.java private Parcel(long nativePtr) { if (DEBUG_RECYCLE) { mStack = new RuntimeException(); } init(nativePtr); } 2.2.4. parcel与Ibinder的关系？？？ 3. TODO：序列化最终的承载的容器是什么？buffer？ parce如何序列化的？-----> //化简之val信息流 Parcel::writeChar(val) writeAligned(val) *reinterpret_cast(mData+mDataPos) = val; // 一行关键代码 所有的write，最终都走到writeAligned： writeAligned（写入对齐） 参考： https://blog.csdn.net/qq_32019367/article/details/122616157 4. 从数据结构看Parcel 1、源码角度： 2、模型角度： 4.1. Parcel.dataSize() 计算： parcel数据量Parcel.dataSize()值为： 求和Σ （4（ 记录byte长度的int） + byte 数据本身） 4是额外的开销，记录所用的byte长度 以writeByteArray为例子： android_os_Parcel_writeByteArray{ parcel->writeInt32(length); // 记录后面保存的byte长度 memcpy(dest, ar + offset, length); } 以Parcel::writeString16为例子： writeInt32(len); // 记录长度 memcpy(data, str, len); 5. cpp Parcel的使用 Android native进程间通信实例-binder篇之——用parcel传输数组 - 啊源股 - 博客园 (cnblogs.com) https://blog.csdn.net/lxgwm2008/article/details/8767146 Android源码之Parcel 真正的序列化与反序列化接口 ------------> byte[] public final native byte[] marshall(); public final native void unmarshall(byte[] data, int offest, int length); 作用类似于序列化和反序列化。即将当前Parcel的数据序列化为byte数组，或者将byte数组反序列化到当前Parcel中。 注：unmarshall后，如果要读取数据，首先需要将文件指针移动到初始化位置，即setDataPosition(0)。 Android native进程间通信实例-binder篇之——简单的单工通信 - 啊源股 - 博客园 (cnblogs.com) --------------> 化简native Binder 5.1. parcel 最后一定要加上setDataPosition(0)，将偏移指回最开始 https://developer.aliyun.com/article/919839 Android 原生 Parcel 使用 - IT工具网 (coder.work) 5.2. parcel的梳理 5.3. 多参数函数，多参数如何序列化与反序列化的？-----分层分析 5.3.1. 序列化流程： readParcelableCreator:3328, Parcel (android.os) readParcelable:3273, Parcel (android.os) readFromParcel:240, WindowConfiguration (android.app) :224, WindowConfiguration (android.app) :49, WindowConfiguration (android.app) createFromParcel:257, WindowConfiguration$1 (android.app) createFromParcel:254, WindowConfiguration$1 (android.app) readParcelable:3282, Parcel (android.os) readValue:3175, Parcel (android.os) readFromParcel:1956, Configuration (android.content.res) :1976, Configuration (android.content.res) :89, Configuration (android.content.res) createFromParcel:1964, Configuration$1 (android.content.res) createFromParcel:1962, Configuration$1 (android.content.res) readParcelable:3282, Parcel (android.os) readFromParcel:69, MergedConfiguration (android.util) relayout:1735, IWindowSession$Stub$Proxy (android.view) // -----------> 这里 relayoutWindow:7621, ViewRootImpl (android.view) performTraversals:2719, ViewRootImpl (android.view) doTraversal:2020, ViewRootImpl (android.view) run:8410, ViewRootImpl$TraversalRunnable (android.view) run:973, Choreographer$CallbackRecord (android.view) doCallbacks:797, Choreographer (android.view) doFrame:732, Choreographer (android.view) run:958, Choreographer$FrameDisplayEventReceiver (android.view) handleCallback:938, Handler (android.os) dispatchMessage:99, Handler (android.os) loop:223, Looper (android.os) main:7720, ActivityThread (android.app) invoke:-1, Method (java.lang.reflect) run:612, RuntimeInit$MethodAndArgsCaller (com.android.internal.os) main:997, ZygoteInit (com.android.internal.os) client侧--------------------stub层代码 //序列化流程： @Override public int relayout(android.view.IWindow window, int seq, android.view.WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, long frameNumber, android.graphics.Rect outFrame, android.graphics.Rect outContentInsets, android.graphics.Rect outVisibleInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outBackdropFrame, android.view.DisplayCutout.ParcelableWrapper displayCutout, android.util.MergedConfiguration outMergedConfiguration, android.view.SurfaceControl outSurfaceControl, android.view.InsetsState insetsState, android.view.InsetsSourceControl[] activeControls, android.graphics.Point outSurfaceSize, android.view.SurfaceControl outBlastSurfaceControl) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try { _data.writeInterfaceToken(DESCRIPTOR); // 当前aidl类名：android.view.IWindowSession _data.writeStrongBinder((((window!=null))?(window.asBinder()):(null))); // writeStrongBinder直接write Binder数据？ 这一步跨进程了嘛？ _data.writeInt(seq); if ((attrs!=null)) { _data.writeInt(1); attrs.writeToParcel(_data, 0); // LayoutParams数据写入parcel } else { _data.writeInt(0); } _data.writeInt(requestedWidth); _data.writeInt(requestedHeight); _data.writeInt(viewVisibility); _data.writeInt(flags); _data.writeLong(frameNumber); if ((activeControls==null)) { _data.writeInt(-1); } else { _data.writeInt(activeControls.length); } boolean _status = mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, 0); // 所有的数据进入了parcel，给了android.os.IBinder mRemote; // 【】 通过code指定函数 if (!_status && getDefaultImpl() != null) { return getDefaultImpl().relayout(window, seq, attrs, requestedWidth, requestedHeight, viewVisibility, flags, frameNumber, outFrame, outContentInsets, outVisibleInsets, outStableInsets, outBackdropFrame, displayCutout, outMergedConfiguration, outSurfaceControl, insetsState, activeControls, outSurfaceSize, outBlastSurfaceControl); } _reply.readException(); _result = _reply.readInt(); if ((0!=_reply.readInt())) { outFrame.readFromParcel(_reply); } if ((0!=_reply.readInt())) { outContentInsets.readFromParcel(_reply); } if ((0!=_reply.readInt())) { outVisibleInsets.readFromParcel(_reply); } if ((0!=_reply.readInt())) { outStableInsets.readFromParcel(_reply); } if ((0!=_reply.readInt())) { outBackdropFrame.readFromParcel(_reply); } if ((0!=_reply.readInt())) { displayCutout.readFromParcel(_reply); } if ((0!=_reply.readInt())) { outMergedConfiguration.readFromParcel(_reply); } if ((0!=_reply.readInt())) { outSurfaceControl.readFromParcel(_reply); } if ((0!=_reply.readInt())) { insetsState.readFromParcel(_reply); } _reply.readTypedArray(activeControls, android.view.InsetsSourceControl.CREATOR); if ((0!=_reply.readInt())) { outSurfaceSize.readFromParcel(_reply); } if ((0!=_reply.readInt())) { outBlastSurfaceControl.readFromParcel(_reply); } } finally { _reply.recycle(); _data.recycle(); } return _result; } 总结：序列化过程可以看到： （1）把当前Iwindow接口名、各个函数参数 ----------> 统一进入parcel （2） 如何确定是哪个函数？ 通过code ---------------------> 合理性证明：以上都是约束、协议 （3） 每一层做每一层的事情： AIDL级别： 序列化 多个参数（parcelable） 与Aidl的反序列化一致 类级别：序列化类的内部属性 与类的反序列化一致 ---------------------> 从这个角度来看： 为啥：L调用A，可以省去 AIDL级别 的序列化？？？？？？ （1）因为反射的作用？？？？？？？ （2）是不是也可以自己做一个 AIDL 链接 cpp-----java呢？ 5.3.2. 反序列化流程： 如何寻找函数 Stub.onTransact ——--> 函数code 4 找到对应relayout 给定 Parcel 如何创建 参数（对象）-----createFromParcel 1、在AIDL编译出的java里(IWindowSession.java) //onTranction: if ((0!=data.readInt())) { // TODO: 这里为啥是0呢？ 安卓在优化 _arg1 = android.graphics.Region.CREATOR.createFromParcel(data); } 特点： （1）这里不存在反射 （2）android.graphics.Region.CREATOR 类的寻找，是通过 脚本编译生成的java类完成的！！！！！！ 2、似乎也有反射方法（优化：提前缓存）: 接口一： HashMap>> // 抄 Parcelable.Creator readParcelableCreator(@Nullable ClassLoader loader) // --------> 接口作用：从 类名（比如Intent） 获取对应类的CREATOR // 创建creator，这里也是java反射 Field f = parcelableClass.getField(\"CREATOR\"); creator = (Parcelable.Creator) f.get(null); ClassLoader parcelableClassLoader = (loader == null ? getClass().getClassLoader() : loader); // Avoid initializing the Parcelable class until we know it implements // Parcelable and has the necessary CREATOR field. http://b/1171613. Class parcelableClass = Class.forName(name, false /* initialize */, parcelableClassLoader); 场景： 传输的类是抽象类（或者父类），接收端不知道是哪个具体子类！！！！！不好写死 反序列化ClientTransaction的过程中，parcel数据中带了一些 List mActivityCallbacks----> 抽象类 这些callback可能是某个具体的子类，比如 TopResumedActivityChangeItem----> 具体类 接收端是没法在代码中写死的：比如TopResumedActivityChangeItem.CREATOR.createFromParcel TODO: 类名什么时候被序列化进去的？？？？？？ -上述精髓： 只缓存了类Intent的创建方式CREATOR --------> 从Intent角度： 创建方式CREATOR只是其一个属性值（静态的），实际上是一个匿名类 创建方式是静态方法 接口二： T readParcelable(@Nullable ClassLoader loader) // 直接读取，并创造下一个Parcelable类 调用栈： readParcelableCreator:3320, Parcel (android.os) readParcelable:3273, Parcel (android.os) readParcelableList:3053, Parcel (android.os) :204, ClientTransaction (android.app.servertransaction) :44, ClientTransaction (android.app.servertransaction) createFromParcel:211, ClientTransaction$1 (android.app.servertransaction) createFromParcel:209, ClientTransaction$1 (android.app.servertransaction) onTransact:1276, IApplicationThread$Stub (android.app) execTransactInternal:1159, Binder (android.os) execTransact:1123, Binder (android.os) 5.4. TODO： 从模型角度，利用了什么语言特性实现的Aidl接口？ 6. TODO：如何寻找到对端对象的？ AIDL编译出的stub java文件 从java层来看：是拿到对端的代理proxy 从cpp层来看： 7. 技巧之序列化调试 7.1. 以偏概全 之parcel数据 （1）大小 dataSize() （2）前三位 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_IPC/socket.html":{"url":"coding/0_IPC/socket.html","title":"Socket","keywords":"","body":"1. 目录2. 多个客户端对一个服务端-------多线程实现方式（cpp）3. 多个客户端对一个服务端------epoll实现方式4. TODO: 更底层----socket阻塞的唤醒5. 面试题：6. TODO： 目录 多个客户端对一个服务端-------多线程实现方式（cpp） 多个客户端对一个服务端------epoll实现方式 TODO: 更底层----socket阻塞的唤醒 面试题： TODO： 1. 目录 recv、select和epoll都是阻塞方法。阻塞方法，不占CPU！！！ 2. 多个客户端对一个服务端-------多线程实现方式（cpp） 实现方式： 为每个客户端安排一个线程 通过在服务器端建立两个线程，主线程用来监听客户端的接入，当有新的客户端接入时，服务器为新的客户端建立服务线程，通过服务线程来实现服务器与客户端的通信 https://blog.csdn.net/m0_67391521/article/details/124164855?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-124164855-blog-129757444.235^v38^pc_relevant_anti_t3&spm=1001.2101.3001.4242.1&utm_relevant_index=3 C++SOCKET多线程网络编程实现多个客户端与服务器通信 3. 多个客户端对一个服务端------epoll实现方式 https://blog.csdn.net/youaremyalllove/article/details/128508470 从socket开始讲解网络模式（epoll） -------------> 好文: 代码 + 图片 补充：？ https://blog.csdn.net/CHNIM/article/details/130891045 linux上的epoll如何使用，并用C++实现多客户端服务器 https://zhuanlan.zhihu.com/p/658504209 TCP Socket性能优化秘籍：掌握read、recv、readv、write、send、sendv的最佳实践 ------------------------------> 性能调优 4. TODO: 更底层----socket阻塞的唤醒 https://zhuanlan.zhihu.com/p/366365883 linux网络编程之带你了解epoll的本质（内部实现原理） --------------------> TODO： 好文！！！！解释了为啥epoll如此高效： 5. 面试题： https://blog.csdn.net/weixin_44844089/article/details/115655642 操作系统面试题：进程如何阻塞？进程阻塞为什么不占用CPU？ https://blog.csdn.net/Shangxingya/article/details/112427967 操作系统~复习线程状态转换的过程, 对比租阻塞和挂起的区别, 以及上下文切换消耗什么资源 --------------------> 阻塞与挂起的区别: 一个被动，一个主动 相同点： 线程都放弃CPU的使用 https://blog.csdn.net/wang_Bo_JustOne/article/details/51597671 关于线程阻塞的问题，留着看了 ----------------> 结论： 1、 非阻塞模式的使用并不普遍，因为非阻塞模式会浪费大量的CPU资源。 2、I/O多路复用 非常好。时间复杂度O（1） 6. TODO： https://blog.csdn.net/qq_41872247/article/details/125211491 Zygote 为啥用的是poll？一对一呀 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_IPC/线程间通信.html":{"url":"coding/0_IPC/线程间通信.html","title":"线程间通信","keywords":"","body":"1. 线程间通信-----Handler1.1. 前言---从应用角度1.1.1. 使用目的：1.1.2. 其他 线程通信的方式1.1.3. Handler场景例子详解1.1.4. 使用逻辑：1.2. 0层模型----锚点1.3. 1层架构图：1.4. 串线之驴子：Looper.loop()--基于0层模型图1.5. 不得不之 Looper线程唤醒（核心）1.6. 串线之人：Handler.sendMessage流程---为死循环提供玉米（数据）+唤醒（驴子）：1.6.1. 问题：何时切的主线程呢？？？1.6.2. for 确定一直在循环嘛2. 1 、线程如何block？？？？2.1.1. 次要补充： msg获取2.1.2. 次要补充： 新消息入队规则：2.2. 机制 --> 如何完成线程切换的：2.3. 补充1：准备消息循环looper2.4. 从架构师 角度看Handler2.5. 关于 MessageQueue2.6. Handler容易导致的内存泄漏2.7. ThreadLocal机制2.7.1. 相关问题2.8. 消息屏障2.8.1. 从设计角度，看 消息屏障2.9. 使用注意事项2.10. 疑问2.10.1. 子线程发一个消息2.11. 相关面试题2.11.1. 一个线程可以有几个Looper？可以有几个Handler？2.11.2. 线程安全问题：2.11.3. 多对一、多对多2.11.4. 取消息函数next（）为啥也加锁了？2.11.5. Todo 以什么样的模型 来思考并发编程呢？何处该加锁呢？2.11.6. Handler 内存泄漏原因是什么？为什么其他的内部类没有说过有这个问题？2.11.7. Looper死循环为什么不会导致应用卡死？会消耗大量资源嘛？-----Done2.11.8. Handler 消息阻塞 为什么不会导致应用卡死？2.11.9. handler实现延时任务 VS Timer延时任务(计时器)2.11.10. 总结2.12. TODO: epoll与select区别2.13. 安卓系统根本动力3. 线程间通信--------本质4. 线程、进程（抛开安卓、抛开语言）4.1. 线程同步/异步（功能）4.1.1. 与 互斥的区别：4.1.2. 支撑 线程同步 功能的结构4.1.3. 线程同步与线程通信的关系4.2. 线程互斥/非互斥（功能）4.2.1. 支撑线程互斥功能的结构4.3. 线程通信(功能)4.3.1. 支撑线程通信功能的结构5. TODO: 上面Handler和Binder分析方式完全不一样6. 框架的背后7. 自然法则8. 格式8.1. 使用逻辑： 线程间通信-----Handler 前言---从应用角度 使用目的： 其他 线程通信的方式 Handler场景例子详解 使用逻辑： 0层模型----锚点 1层架构图： 串线之驴子：Looper.loop()--基于0层模型图 不得不之 Looper线程唤醒（核心） 串线之人：Handler.sendMessage流程---为死循环提供玉米（数据）+唤醒（驴子）： 问题：何时切的主线程呢？？？ for 确定一直在循环嘛 1 、线程如何block？？？？ 次要补充： msg获取 次要补充： 新消息入队规则： 机制 --> 如何完成线程切换的： 补充1：准备消息循环looper 从架构师 角度看Handler 关于 MessageQueue Handler容易导致的内存泄漏 ThreadLocal机制 相关问题 消息屏障 从设计角度，看 消息屏障 使用注意事项 疑问 子线程发一个消息 相关面试题 一个线程可以有几个Looper？可以有几个Handler？ 线程安全问题： 多对一、多对多 取消息函数next（）为啥也加锁了？ Todo 以什么样的模型 来思考并发编程呢？何处该加锁呢？ Handler 内存泄漏原因是什么？为什么其他的内部类没有说过有这个问题？ Looper死循环为什么不会导致应用卡死？会消耗大量资源嘛？-----Done Handler 消息阻塞 为什么不会导致应用卡死？ handler实现延时任务 VS Timer延时任务(计时器) 总结 TODO: epoll与select区别 安卓系统根本动力 线程间通信--------本质 线程、进程（抛开安卓、抛开语言） 线程同步/异步（功能） 与 互斥的区别： 支撑 线程同步 功能的结构 关于锁的深入 线程同步与线程通信的关系 线程互斥/非互斥（功能） 支撑线程互斥功能的结构 线程通信(功能) 支撑线程通信功能的结构 TODO: 上面Handler和Binder分析方式完全不一样 框架的背后 自然法则 格式 使用逻辑： 1. 线程间通信-----Handler 1.1. 前言---从应用角度 1.1.1. 使用目的： Handler的存在就是为了解决在子线程中无法访问UI的问题（自然，进程间不可以），多用于切换主线程 从线程模型的角度（抛开安卓、UI）来看，Handler本质就是线程 所以，Handler本质与主线程 没关系、与UI没关系 常见的使用场景： 非子线程想要界面操作，比如： 网络交互后切换到主线程进行UI更新 Binder通信后，Binder线程切换到主线程进行UI更新 由此引发的问题： 1、如何使用？ 2、如何完成切换线程的呢？机制 3、 1.1.2. 其他 线程通信的方式 1.1.3. Handler场景例子详解 EX 1: 比如： Toast服务给Toast回调，为什么要用message？为什么不直接回调呢？ Binder线程，切换到main线程去真正show《------因为界面变化必须在主线程 EX 2： TODO: 输入法的六个桥梁之间，有哪些是用了Handler 转Binder线程 为主线程的？why？ EX 3： 在子线程里发送： 主线程里接收： 如果要msg携带多个参数呢？ 一些细节： Message msg = Message.obtain(); 与 new Message() 1.1.4. 使用逻辑： 一句话描述：子线程用了主线程的Handler发消息（补充，含有looper的线程都可以） 例子： public class MainActivity extends AppCompatActivity { TextView mTxtShowTest; Button mBtn1, mBtn2, mBtn3; //2、在主线程里new Handler.------->为什么这样??? private MyHandler myHandler = new MyHandler(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTxtShowTest = (TextView) findViewById(R.id.mTxtShowTest); mBtn1 = (Button) findViewById(R.id.mBtn1); mBtn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread(new Runnable() { //3、在子线程里发消息 @Override public void run() { Message msg = Message.obtain(); msg.what = 1;//要传递的数据 myHandler.sendMessage(msg); } }).start(); } }); } class MyHandler extends Handler {//1、通过继承拿到Message（含数据） @Override public void handleMessage(Message msg) { int what = msg.what; switch (what) { case 1: mTxtShowTest.setText(\"新建Handler子类方法\"); default: //nothing } } } } 1.2. 0层模型----锚点 切换线程，不得不的模型： 注意忽略掉类名，与代码无关 见 handler.eddx 生活化的模型： 磨玉米模型 人物： 人（调用线程）：人，可以有多个人 ----> 一般来说是 非主线程 驴（Looper线程）：干活线程(有些活，必须这个线程干，就像磨一般都是驴来拉) 旋转杆：Looper，负责旋转整个线程 ----> Looper的旋转，才导致玉米msg不断被取出next()，是永恒的动力 绑绳： ThreadLocal---------绑绳，是线程相关量，让Looper与对应线程绑定 装玉米的磨：msgQueue(自然,一个线程一个) 磨洞：取玉米，一个一个取的 一个个排队的玉米： msg，注意：玉米之间是线性的，一个一个网磨的洞里漏 ​ 玉米的排队顺序：是人指定的， 按照玉米的 着急程度排序 （质量高的 玉米， 人给 赋了值when，安排靠前 加工） Handler：是添加玉米/取玉米的瓢(添加msg的工具/处理msg的工具), 有多个, 绑在磨上(自然,1、一个线程可以多个2、自然,在Looper 线程里生成,与Looper绑定3、自然各个调用线程都能用) 自然的结论： 1、 一个线程可以有多个Handler(瓢),只有一个Looper(驴子),只有一个MessageQueue(磨) 2、Handler(瓢)的生成，必须在Looper线程下--------驴子的瓢，给人用 3、所有的一切都是主线程的（Looper线程），是一个输入系统。调用线程没有任何东西。 纵向流程： 1、正常情况下，驴子看自己的磨里（Looper线程的queue）没有玉米（msg），不需要磨，驴子就睡地上了（Looper线程阻塞，挂起？） ​ 人也在干自己的事情（调用线程做自己的事情） 2、人通知驴去干活，两件事情： （1）人用瓢 往磨里 填加 玉米： 调用线程 通过Handler 往 Looper线程的queue里加 msg ----> 这一步是简单的，因为人和驴的磨之间，没有墙（共进程），可以直接加（共内存） （2） 人把驴弄醒wake 由此可见，最核心的是（2），如何弄醒驴子 xaingxue的模型： 1.3. 1层架构图： 见 handler.eddx 对外接口： 最终都归结为：Handler. enqueueMessage Queue. enqueueMessage 即消息入队列 1.4. 串线之驴子：Looper.loop()--基于0层模型图 基于0层模型图中，最核心的就是 死循环 // Looper.java public static void loop() { final Looper me = myLooper(); final MessageQueue queue = me.mQueue; for (;;) { // 死循环：for内部没有return或break ........... Message msg = queue.next(); // might block 【1】获取下一个msg block线程的地方，见下 try { msg.target.dispatchMessage(msg); // 【2】分发msg 给target处理，见下 } ........... msg.recycleUnchecked(); // 用完的msg回收消息池 TODO } } 时机：由 0层模型图，自然：Looper.loop() 自然是被 Looper线程调起来的----> 对于主线程，是ActivityTread的main里Looper.loop() 作用：做了两件事情，同 0层模型图一致： 【1】获取下一个msg ( block线程的地方，见下) 【2】分发msg 给target处理 自然 补充【1】 queue.next()获取下一个msg block线程的地方 链接: 基于0层模型图，为什么一定要有 Looper线程的block? A: 不得不： 1、如果没有block，那么主线程一直在Loop里循环跑，根本不会有其他代码会被执行。驴子在空跑 2、主线程还需要处理其他很多事情，比如Input、view等等 ------> 似乎不是理由？ // MessageQueue.java Message next() { for (;;) { // 遍历queue，获取下一个msg，不是死循环 //【1】阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回。见下 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. Message prevMsg = null; Message msg = mMessages; if (msg != null && msg.target == null) { //cg: 【消息屏障】 syncBarrier // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null && !msg.isAsynchronous()); //cg: get asynchronous msg，找到异步消息 } ........... // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; msg.markInUse(); return msg; // 【2】获取头节点 } 【1】阻塞block操作 nativePollOnce()： 其中参数 nextPollTimeoutMillis 代表下一个消息到来前，还需要等待的时长（-1一直等） （1）作用 nativePollOnce()阻塞Looper线程。 自然：只有当nativePollOnce()返回后，next()从mMessages中提取一个消息 （2）具体做了啥？ 见 技术点pollOnce与wake （3）何时nativePollOnce()会有返回？ 1.5. 不得不之 Looper线程唤醒（核心） pollOnce与wake~----最核心代码，线程间通信 这里就是Android系统的Handler消息机制的消息循环的核心实现，使用了Linux的epoll事件处理机制。当消息队列为空时，常规的循环实现是调用sleep/usleep释放cpu，当时间到了之后，会获得CPU资源进行一次消息检查； Handler的消息循环采用Linux kernel的epoll机制： 当消息队列为空时，会挂起释放CPU资源，只有当消息队列有新消息到来时，才会重新获得CPU资源，进行消息处理。----------> 自然，利用epoll机制解决空耗CPU问题 相比常规实现，Android系统的Handler消息机制更加节省系统资源(CPU资源)。 相比常规实现，Android系统的Handler消息机制的生产者，把消息放入消息队列的同时，可以通知(唤醒)消息处理者。 链接：https://juejin.cn/post/6856366890936827911 最核心：epoll机制：epoll导致睡眠 ​ 往文件里写字符，唤醒epoll流程继续注意 wake() 绝对不够本质！！！！！！ 1.6. 串线之人：Handler.sendMessage流程---为死循环提供玉米（数据）+唤醒（驴子）： 链接：基于0层模型图，存在的理由（不得不）： 1、死循环需要被提供数据 2、死循环需要被唤醒 //发消息在子线程 sendMessage:611, Handler (android.os)// 对外API sendMessageDelayed:673, Handler (android.os) sendMessageAtTime:703, Handler (android.os) enqueueMessage:754, Handler (android.os) enqueueMessage:556, MessageQueue (android.os)// 队列 ------------------native--------------------- NativeMessageQueue::wake() Looper::wake() // 【1】最终真正唤醒的地方 流程，子线程中： Handler.sendMessage(msg) (msg通过obtain获得，见补充msg) 最终是调了链表MessageQueue.enqueueMessage方法(自然，不得不)，将msg加入链表 （新消息入队规则：见次要补充1：新消息入队规则） 一句话总结：发送消息，实际上就是消息入队（链表） 1.6.1. 问题：何时切的主线程呢？？？ 答：looper.loop()在主线程一直循环（for循环）, 感受到了链表里有新的msg 0层图 结构：looper也持有MessageQueue // Looper.java public static void loop() { //#4 loop()是在主线程main方法里被调起来的！！！！！！ final Looper me = myLooper(); final MessageQueue queue = me.mQueue; boolean slowDeliveryDetected = false; for (;;) { //这里就是一直说的looper循环！！！！！ Message msg = queue.next(); // might block //#3 if (msg null) { // No message indicates that the message queue is quitting. return; } 问题：关于for循环： (1) for 循环确定一直在循环嘛，即使queue没有东西？？？ 跳转A （3）对于#4，如果for是一直循环，那么 main函数之后的流程理应走不到！！！！！！---->确实是，Looper.loop()是最后一行代码 （4）App如何退出呢？ 1.6.2. for 确定一直在循环嘛 ---->即使queue没有东西？？？ A: 总结： list为空，是block状态------>#1、线程如何block？？？？ list不为0 ，被唤醒，读取------->#2、如何被第二个线程唤醒？？？？ TODO： Looper的wake机制升级 https://cloud.tencent.com/developer/article/1639805 2. 1 、线程如何block？？？？ epoll 2.1.1. 次要补充： msg获取 obtainMessage 2.1.2. 次要补充： 新消息入队规则： https://blog.csdn.net/u013008419/article/details/80001310 注意：与普通链表不同，不是添加在最后 ，而是 按照玉米的 着急程度排序 （质量高的 玉米， 人给 赋了值when，安排靠前 加工） 自然：原始的消息队列顺序是按照消息执行时间when排序的。新msg也是按照when大小插入：when小，插前面 2.2. 机制 --> 如何完成线程切换的： https://blog.csdn.net/wsq_tomato/article/details/80301851 2.3. 补充1：准备消息循环looper 因为handler里有Looper 问题： 1、循环Looper是啥？ 2、Looper的主线程无限循环，为什么没有造成ANR呢？ 循环Looper是啥？： 1、消息处理机制中，消息都是存放在一个消息队列中去，而应用程序的主线程就是围绕这个消息队列进入一个无限循环的，直到应用程序退出。 2、如果队列中有消息，应用程序的主线程就会把它取出来，并分发给相应的Handler进行处理；如果队列中没有消息，应用程序的主线程就会进入空闲等待状态，等待下一个消息的到来。 Looper初始化流程： //ActivityThread.java public static void main(String[] args) { ........ Looper.prepareMainLooper(); //#1 ........ ActivityThread thread = new ActivityThread();// (1) thread.attach(false, startSeq); if (sMainThreadHandler null) { sMainThreadHandler = thread.getHandler(); } ........ Looper.loop();// (2) throw new RuntimeException(\"Main thread loop unexpectedly exited\"); } 这个函数做了两件事情， (1)一是在主线程中创建了一个ActivityThread实例， (2)二是通过Looper类使=主线程进入消息循环中，这里我们只关注后者。 什么叫使主线程进入消息循环里？ ----> Looper.prepareMainLooper(); //#1流程 静态函数 TODO： ThreadLocal，表示这是一个线程局部变量------>如何做到的???? 注意：变量、类是没有线程概念的！！！！---->本质是内存，内存是进程级的！！！！ 2.4. 从架构师 角度看Handler 从设计模式角度： 属于生产者、消费者模式。见: 《设计模式> 从系统角度看：有进无出。1、所有的一切都是主线程的。 2、调用线程，只是用Handler做了调用，即输入 从功能角度： 发号命令的人（之后不用管事了），与干活的驴。 从本质角度：内存共享原理 ----> 共享的是哪一块内存？ msgQueue（人可以往这里添加玉米，驴子可以从这里拿玉米） ThreadLocal原理 2.5. 关于 MessageQueue 持有mMessages, mMessages 有 next属性指向下一个msg -----> msg本身就是链表了 所以, MessageQueue只是对链表的封装, 提供一个管理功能 add, remove操作 2.6. Handler容易导致的内存泄漏 参考： https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650238704&idx=1&sn=ad334840afdc2d9bdb8215e9f942e54e&chksm=88639f9fbf1416898edfc3615a7ea25f6798e3bb6f3089ca720e18b92ce67328c623561cf35e&scene=27 好文 内存泄漏全解析 郭霖;) 2017-02-28 08:00 视频： 19. Handler内存泄漏的GCRoot到底是谁-fS.vep 例子1： // MainActivity.java Message msg = Message.obtain(); msg.what = 1;//要传递的数据 myHandler.sendMessage(msg); class MyHandler extends Handler { @Override public void handleMessage(Message msg) { int what = msg.what; switch (what) { case 1: //mTxtShowTest.setText(\"新建Handler子类方法\");// 【表达1】 MainActivity.this.mTxtShowTest.setText(\"新建Handler子类方法\"); // 【表达2】MainActivity.this 代表外部类的实例 break; default: //nothing break; } } } // 持有关系 static sThreadLocal -> Looper-> MessageQueue -> Message -> handler -> MainActivity.this外部类的当前实例 因为sThreadLocal是静态的，与APP同生命周期。所以是GcRoot (1) 这里 handler -> Main2Activity.this 原因：内部类（非静态）持有外部类引用 , 见【表达2】 -----> 自然的，如果没有外部，怎么找到内部类？ TODO: 根本原因，要到JVM里找 (2) Message -> handler: 每个Message 有处理对象 handler (2~) 记忆：持有链： 瓢handler 《----玉米Message 《----磨MessageQueue 《-----旋转杆Looper 《 ------绑绳： ThreadLocal -------------> 最终结果，造成 MainActivity.this 与APP同周期？错误！！！！ A: 玉米Message 《----磨MessageQueue 这一环链接时间最短，决定了 内存泄漏时间。 例子1是造成的内存泄漏时间可能很短。 所以，需要一个前提： Message 尚未被处理，长时间在MessageQueue ，比如，延迟5分钟 执行的消息 Message 即：例子2： myHandler.postDelayed(new Runnable() { // 延迟执行 @Override public void run() { Message msg = Message.obtain(); msg.what = 1;//要传递的数据 myHandler.sendMessage(msg); } }, 50000); // 设定指定的时间time,此处为20000毫秒 解决办法： Handler 声明为静态内部类 -----> 自然，static的 与外部类没有关系了，不会再持有外部类。同时，【表达2】MainActivity.this 编译也报错，引不到外部类了 改动导致的不得不：静态内部类要使用 外部类，只能 弱引用了。。。其实自然的，因为此时内部类是静态的，外部类不一定实例化了，所以编译上一定过不去 即修改为： private static class MyHandler extends Handler { private WeakReference mReference; public MyHandler(MainActivity mainActivity) { this.mReference = new WeakReference<>(mainActivity); //【表达3】只能通过弱引用，来引用外部类，肯定无法直接 } @Override public void handleMessage(Message msg) { int what = msg.what; switch (what) { case 1: // mTxtShowTest.setText(\"新建Handler子类方法\"); // MainActivity.this.mTxtShowTest.setText(\"新建Handler子类方法\"); this.mReference.get().mTxtShowTest.setText(\"新建Handler子类方法\"); break; default: //nothing break; } } } 工具： Android内存泄漏的检测工具——LeakCanary。 TODO: 原理： https://blog.csdn.net/a820703048/article/details/112849983 应用举例：https://blog.csdn.net/weixin_35924765/article/details/117505874 实操： TODO 一句话总结： 普通内部类 + 延迟 执行的消息 Message，容易造成内存泄漏 2.7. ThreadLocal机制 要是我来设计，我肯定这样设计：一个进程级别Map，以ThreadId为key ----->问题在哪里呢？ 1、进程级别Map 做不到 只对一个线程开放，对其他线程封闭 2、用是可以用的------> 多线程同时操作 Map, 存在并发问题，需要枷锁 官方设计： 本质：1、 map线程级， 2、Map本身是Thread的私有属性 3、key是 ThreadLocal, value是存储值 从物理内存角度来看：map对象肯定是在堆里（进程都可以访问），但是因为是线程 私有 属性 ----> 达到对其他线程的封闭 ​ 即一句话：物理上，可以访问，但是没有索引 化简： 从本质上，可以看出，只需要Thread的Map就行了，真正干活的。那为啥还要Treadlocal呢？ 见下： 从功能角度： 1、存储（ 线程级） 是在线程里Thread ，真正干活的 自然，区分线程也是这里区分的 2、Treadlocal存在的必要性： ​ （1）不得不1：封装map，对外提供功能。因为map是私有的，不能直接对外 ----> 工具类的作用 ​ 推论：自然，是静态的，进程级别 static final ThreadLocal sThreadLocal = new ThreadLocal(); ​ （2）不得不2：~map里面存了很多数据，如何快速找到，需要一个key来标志数据类型，自然 ----> key的标志作用，指定要存啥类型 ​ （3）优秀的点： 封装了Map，自然不用传参key。----> 从而，安全性，其他线程不能访问 使用： 1、存放Looper，使用new ThreadLocal() ​ 存放Intent，使用 new ThreadLocal() 使用场景： 并发问题中， 同时使用的共享资源，可以被拆解成一个个独立的 线程级变量 补充： 任何用 ThreadLocal保存的变量，都是线程单例。比如 可以说 Looper 是线程单例 ----> 自然的，新的说法而已 2.7.1. 相关问题 弱引用？ 2.8. 消息屏障 生活化模型，基于封路模型： 马路上一个个 汽车（msg ），一个个排队 走。这个时候，xin 的车(异步msg ) 要来了， 屏障msg是 警察。警察插入队伍中某个位置（when），封住后面所有的车 。 基于封路模型：一些自然的不得不： 1、警察是不动的（屏障msg是不被执行的，因为处理的Target = null） 2、警察封住后面所有的车，对前面的车不封。即：前面的msg可以正常运行 3、之前 人将玉米加入 磨里，会唤醒驴子（子线程发送msg，唤醒主线程）。。。。。但是 屏障消息不会 唤醒主线程，因为本身就不需要执行 ，自然 ​ 代码证明：没有nativeWake() 本质：屏障消息就是为了确保异步消息的优先级，即：设置了屏障后，只能处理其后的异步消息，同步消息会被挡住 三种消息： 同步消息 异步消息 屏障消息 机制要解决的业务问题（背景）： 为 xin的车（VSync消息？？？）开路： VSync 16ms一次，如果用户同步消息（多个，很可能）没有执行完成，无法执行VSync消息，无法画用户界面。在用户角度，出现了掉帧或卡顿的情况。 同步屏障（自然和异步消息一起） 使用场景，很少： ViewRootImpl接收屏幕垂直同步信息事件用于驱动UI测绘 ActivityThread接收AMS的事件驱动生命周期 InputMethodManager分发软键盘输入事件 PhoneWindowManager分发电话页面各种事件 基于模型，代码： class MessageQueue{ public int postSycnBarrier() { return postSyncBarrier(SystemClock.uptimeMillis()); //currentTimeMills()系统当前时间，即日期时间，可以被系统设置修改,时间值会发生跳变 //uptimeMills() 自开机后，经过的时间，不包括深度休眠的时间 //sendMessageDelay，postDelay也都使用了这个时间戳 //意思是指，发送了这条消息，在这期间如果设备进入休眠状态(如息屏后长时间不操作手机)那么消息是不会被执行的， //设备唤醒后到了时间才会执行 } private int postSyncBarrier(long when) { synchronized (this) { final int token = mNextBarrierToken++; //屏障消息和普通消息的区别是屏障消息没有tartget //也就不会被分发处理(执行) //可以理解为是一个标志位flag final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; //【】根据时间顺序将屏障插入到消息链表中适当的位置 if (when != 0) { while (p != null && p.when 异步消息：msg.setAsynchronous(true); 即 FLAG_ASYNCHRONOUS标致 屏障如何工作的？见 取函数next() 中 【消息屏障】 2.8.1. 从设计角度，看 消息屏障 因为msg是个队列，所以，设计者想要 调节一下 msg执行顺序 小调节：when 大调节：消息屏障 2.9. 使用注意事项 1、Handler使用前，一定要在looper线程先执行 Looper.prepare() //----> 为线程创建Looper Looper.loop() // 磨转起来 为啥主线程不要？ A：要的。主线程，在main流程中，系统侧已经做了 2.10. 疑问 2.10.1. 子线程发一个消息 （1）何时主线程处理？？？---->按道理在主线程的messgeQueue排队 （2）如果主线程在执行其他流程呢 --->按道理要等着现在流程走完（即：一个msg引发的操作执行完） （3）一直走不完呢？ ----->在。。。。。会引发ANR？？？（TODO） （4）ANR的机制是啥？ 2.11. 相关面试题 2.11.1. 一个线程可以有几个Looper？可以有几个Handler？ 从模型角度： Looper.looper() 是驱动整个线程运行的 拉磨驴----> 自然，只有一个 ​ Handler是对外接口，send.msg和处理msg，自然，可以有多个 从代码角度：Looper.prepare()创建Looper之前，会判断当前线程的Looper是不是存在，存在会抛异常 --------> 所以：问题的深层次答案，只能从模型中得出（代码只能给出浅显的答案） 2.11.2. 线程安全问题： 2.11.3. 多对一、多对多 case1：多个子线程 使用 同一个Handler case2：多个子线程使用 多个Handler 如何保证多线程安全？ --------> case1不需要枷锁， 因为 函数栈sendMsg（包括局部变量） 是线程级别的，两个线程，有两套 -----> 一句话：函数栈的封闭性 堆（对象）是进程级别的，所有线程共用一个对不对？ 结论： （1）case1， 两个线程可以更改 Handler对象， 但是更改不了 sendMessage(msg) 里的msg -----> 虽然对象在堆里，但是引用是局部变量，另一个线程拿不到 （2）case1， 从 Handler角度来看，两个线程可以同时使用一个对象而不加锁。前提，自然：不改变他 总结，从代码的角度看： 一个线程能不能改变一个 对象，主要看 整个线程 有没有拿到这个对象的引用 ------>自然，推论：1、两个线程都持有Handler 引用，站在handler角度看，两个线程若改变handler，会有冲突 -----> 好在sendmsg没有修改handler ​ 2、整个过程两个msg是被各自 线程引用的，所以不会有线程间冲突 -----> 如果msg 被保存成 Handler 的属性，就会有冲突 结论： 多线程问题，该在代码何处枷锁呢？ -------->规定原则：1、 从代码内存改动的角度，临界区最小化原则，比如修改了mMessages TODO: 为啥mQuitting也要 锁进去？？？ 从代码 依赖角度， 最好不能依赖 属性，因为属性不可靠！！！（可能被其他线程所更改） 2、从模型角度，大致判断： 多个人同时用 一个瓢（极其副本），没有事情（只要不改造）。但是到磨时，就改了磨了，磨被改动了 -------> 技巧：死定着改动发生点！！！ 2.11.4. 取消息函数next（）为啥也加锁了？ 按道理， 存是多个线程并发，而取只是在主线程，只有一个线程，为啥还要加锁？ 因为其他线程的存 要与 主线程的取互斥。。。取只有主线程，不会自己和自己互斥 2.11.5. Todo 以什么样的模型 来思考并发编程呢？何处该加锁呢？ 1、什么样的模型 2、类要不要再复制一份 3、注意力放哪里？ base 于一个类， 索引 可能改变的属性。 想象不同线程 穿过？ 4、结论： 需要 索引的量 ：静态变量、类的属性 5、图中的属性，其实也代表一个函数（因为一定在函数内被改变） 5、this 锁、与 object锁、静态锁， 可以用一个模型来思考嘛？ 从数学上，证明，一个函数要不要加锁，以及枷锁的位置： 1、如果调用栈上游枷锁了，自然不用 2、找出多个函数（不同线程），或者一个函数（不同线程）， 找出所有 涉及修改属性 以及 依赖的属性（可变的） 按道理，这些都应该加锁 2.11.6. Handler 内存泄漏原因是什么？为什么其他的内部类没有说过有这个问题？ 3、为何主线程可以new Handler？如果想要在子线程中new Handler要做哪些准备？ 4、子线程中维护的Looper，消息队列无消息的时候的处理方案是什么?有什么用？ 5、既然可以存在多个Handler往MessageQueue中添加数据(发消息时各个Handler可能处于不同线程)，那它内部是如何确保线程安全的？ 6、我们使用Message时应该如何创建它？ 2.11.7. Looper死循环为什么不会导致应用卡死？会消耗大量资源嘛？-----Done 当然不会，反而是Looper驱动（looper用消息驱动的） 2.11.8. Handler 消息阻塞 为什么不会导致应用卡死？ 先技术语言翻译： 阻塞指的是 取一个消息，next() 函数中 sleep了----->线程阻塞 卡死： ANR (todo： 一定是嘛) 一句话： ANR是因为处理input消息处理超时了(其中之一)。 而 线程阻塞，正是由于queue里没有消息过来，说明没有Input，自然不会ANR了 TODO做笔记： ANR 产生的四个原因 以及 主要原理 ANR实际例子： 8、Binder有什么优势？（字节跳动） 9、Binder是如何做到一次拷贝的？（腾讯） service manager进程与Binder的关系 10、MMAP的原理讲解；（腾讯） 11、为什么Intent不能传递大数据？（阿里）限制多少? Binder驱动在哪限制? 12、描述AIDL生成的Java类细节；（字节跳动） 13、四大组件底层的通信机制；（字节跳动） 为啥不用 wait/notify ？ 2.11.9. handler实现延时任务 VS Timer延时任务(计时器) 参考： https://blog.csdn.net/fenjiehuang/article/details/65937794 Timer实现： 延迟与循环 【1】 Timer myTimer = new Timer(); myTimer.schedule(new TimerTask() { // 【】schedule方法！ @Override public void run() { ........... } }, 3000, 4000); // 延时3000毫秒开始计时，每隔4000毫秒计时一次 --->可循环 // }, 3000); // 延时3000毫秒开始 --->不可循环 handler实现：【2】 本质：for 循环方法 //定义msg.what常量 private static final int TIMER_TASK = 101; //使用handler发送延时消息：【】sendMessageDelayed方法！ mHandler.sendMessageDelayed(mHandler.obtainMessage(TIMER_TASK), 3000); //在handler的处理方法中处理消息任务 public boolean handleMessage(Message msg) { switch (msg.what) { case TIMER_TASK: //do something you want //mHandler.sendMessageDelayed(mHandler.obtainMessage(TIMER_TASK), 3000); 【】核心：加上是循环，不加是定时任务 break; default: break; } return true; } 1、从原理上看：schedule与sendMessageDelayed方法，计时器基准时间不一样~ 【3】和【4】 public void schedule(TimerTask task, long delay, long period) { ......... sched(task, System.currentTimeMillis()+delay, -period); //【3】基于系统时间 System.currentTimeMillis } public final boolean sendMessageDelayed(Message msg, long delayMillis) { if (delayMillis 结论：自然，当系统时间改变，肯定会影响Timer的任务的执行。而handler不受影响 2、Handler的任务周期可调整（优点） 原因：Handler使用即for循环，每次改变delay值即可 一句话总结： 计时器不同：系统时间 和 时钟时间的区别 补充: 发送消息屏障，也是用的 SystemClock 2.11.10. 总结 推荐使用handler使用定时任务 2.12. TODO: epoll与select区别 2.13. 安卓系统根本动力 安卓系统根本动力-----事件（事件驱动） 事件是玉米（是驴要干的事情），没有事件，拉磨驴looper不会去干活。整个系统是事件驱动的 3. 线程间通信--------本质 -本质上没有线程间通信概念： 因为进程内、线程间，本身就是共内存的 线程间通信，唯一方式！！！： 本质：一个线程设置一个变量，另一个线程去轮询 例子： // thread1 msg = \"thread1\"; //thread2 while(!msg.qual(\"\")) { // 循环读另一个线程的变量 dosomething(msg) msg = \"\"; sleep(100); } -也是Handler的化简本质，一句话handler本质 基于本质，handler有哪些额外的设计呢？ 1、为了解决性能问题，防止while空耗CPU ---------------> 消息队列空时，阻塞，释放cpu；有消息时，唤醒 （epoll机制） ​ 本质：解决空耗CPU问题，自然 2、 同步屏障 4. 线程、进程（抛开安卓、抛开语言） 基于线程模型， 线程之间关系： 同步、通信、 一个线程状态： 休眠..... 4.1. 线程同步/异步（功能） 线程同步sync------协同两个线程，即sync：通过同步建立起执行顺序的关系。 比如 你先说完，我再说。。。。。。。常见场景： A线程等待B线程执行结果 线程异步-------没有等待，同时执行。就是正常情况。两个线程各自运行各自的 ---------> 区别的标准：同一时间（不是时刻），两个线程有没有做到并发 本质区别： 有没有等待结果 4.1.1. 与 互斥的区别： 同步与互斥 的 生活化模型理解 ： 临界资源：盘子 女儿等吃爸爸放置的苹果。一起完成一件事情------> 同步 妈妈和爸爸之间，竞争关系 ------> 互斥 安卓中的例子： TODO 补充： 同步调用/异步调用是调用关系上的概念。 4.1.2. 支撑 线程同步 功能的结构 1、信号量 2、锁 例子1： 对于java，用synchronized 关键字（是自动锁） synchronized 方法和 synchronized 块 public synchronized void synMethod(){ //方法体 } public Object synMethod(Object a1){ synchronized(a1){ //一次只能有一个线程进入，将其他线程锁在外面 } } 注意：不用纠结是同步锁 还是 互斥锁，认为是同一个东西。比如，java的synchronized就是 同步锁，也是互斥锁 例子2： 在C++ 11里面，通过std::mutex的加锁和解锁来保证 同步 （ 参考 https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/4855164） #include #include usingnamespace std; mutexm; void threadFunc(int i) { m.lock(); //在这里写上你需要的代码 m.unlock(); } int main() { threadt1(threadFunc,1); threadt2(threadFunc,2); t1.join(); t2.join(); return0; } 例子3： c语言中， 关于锁的深入 参考：https://blog.csdn.net/liuwg1226/article/details/119900991 从第一性原理理解锁： 锁的实现要处理的大概就只有以下4类问题： “谁拿到了锁“，这个信息存哪里（可以是当前 class，当前 instance 的 markword，也可以是某个具体的 Lock 的实例） 谁能抢到锁的规则（只能一个人抢到 - Mutex；能抢有限多个数量 - Semaphore；自己可以反复抢 - 重入锁；读可以反复抢到但是写独占 - 读写锁……） 抢不到时怎么办（抢不到玩命抢；抢不到暂时睡着，等一段时间再试/等通知再试；或者二者的结合，先玩命抢几次，还没抢到就睡着） 如果锁被释放了还有其他等待锁的怎么办（不管，让等的线程通过超时机制自己抢；按照一定规则通知某一个等待的线程；通知所有线程唤醒他们，让他们一起抢……） 有了这些选择，你就可以按照业务需求组装出你需要锁 (可见，作者是从第一性原理来理解锁的) 4.1.3. 线程同步与线程通信的关系 线程同步 体现了 ？ 线程通信 体现了 多个线程的 合作性（类似于 A线程调用B线程，去完成一件事情），比如Handler机制 4.2. 线程互斥/非互斥（功能） 互斥，是指对于共享的进程系统资源，在各单个线程访问时的排它性 非互斥---------没对共享的做保护 4.2.1. 支撑线程互斥功能的结构 信号量、锁........见上 4.3. 线程通信(功能) 参考：https://blog.csdn.net/qq_45453784/article/details/124157666 what： 多个线程间的一种协作机制： 比如Handler机制 4.3.1. 支撑线程通信功能的结构 信号量、锁........见上 5. TODO: 上面Handler和Binder分析方式完全不一样 Binder： FMSR 分析方法。基于功能解释 ----> 注意力在功能上 ​ 优点：有章法。知道为啥这样做 Handler: 基于生活化模型，解释 -----> 注意力生活化模型上 ​ 优点：如果模型非常能反映 代码，那么更容易记忆与理解 ​ 缺点：Handler 行文之间，明显缺乏链接 6. 框架的背后 7. 自然法则 8. 格式 8.1. 使用逻辑： [跳转使用逻辑]( console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_性能/":{"url":"coding/0_性能/","title":"0_性能","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_性能/profiler.html":{"url":"coding/0_性能/profiler.html","title":"Profiler","keywords":"","body":"1. profiler之 火焰图：1.1. 为什么要有火焰图？1.2. 获取1.3. 读火焰图-----TODO1.3.1. 分析 之 性能问题点：1.4. linux火焰图1.5. 常见耗时（火焰图上很直观）1.6. 参考： profiler之 火焰图： 为什么要有火焰图？ 获取 读火焰图-----TODO 分析 之 性能问题点： linux火焰图 常见耗时（火焰图上很直观） 参考： 1. profiler之 火焰图： 1.1. 为什么要有火焰图？ systrace不能用嘛？ -----------> systrace没有每一个函数的调用时间（只是打标签的一段） 1.2. 获取 火焰图： 性能优化---启动优化 Debug.startMethodTracing_debug.startmethodtracing()-CSDN博客 https://blog.csdn.net/chuyouyinghe/article/details/131719609 官网： https://developer.android.google.cn/studio/profile/generate-trace-logs?hl=zh-cn Debug.startMethodTracing(\"sample\") Debug.stopMethodTracing(); 多次循环时： SimpleDateFormat dateFormat = new SimpleDateFormat(\"dd_MM_yyyy_hh_mm_ss\", Locale.getDefault()); String logDate = dateFormat.format(new Date()); // Applies the date and time to the name of the trace log. Debug.startMethodTracing( \"sample-\" + logDate); ------------------> 技巧： 不知道什么时候结束的时候，用计时器10s后，抛到主线程 TODO: ZHAOPIAN 参考： https://developer.android.google.cn/studio/profile/generate-trace-logs#java Generate Trace Logs by Instrumenting Your App https://developer.android.google.cn/studio/profile/record-traces Record traces https://developer.android.google.cn/studio/profile/inspect-traces Inspect traces 分析 https://zhuanlan.zhihu.com/p/511224713 android studio profiler 性能分析 ---------> 好文 https://www.jianshu.com/p/596b2ef68342 性能优化工具（十一）-Android Profiler ----> 结构 1.3. 读火焰图-----TODO 好文： 如何读懂火焰图？ 实例讲解程序性能优化 | HeapDump性能社区 https://heapdump.cn/article/3486818 1.3.1. 分析 之 性能问题点： 平顶山： 火焰图就是看顶层的哪个函数占据的宽度最大。只要有\"平顶山\"，就表示该函数可能存在性能问题。 倒T 型： 如果A方法本身就慢呢？通过火焰图也是可以看出来的，这种底层栈的宽度很宽，但是建立在其撒花姑娘的调用链线条都很窄，火焰图呈现“┻”型，那么我们基本可以确定，栈底方法本身就存在性能问题。 https://www.qinglite.cn/doc/468764776cec22698 1.4. linux火焰图 https://www.qinglite.cn/doc/468764776cec22698 调优利器-火焰图使用图鉴 1.5. 常见耗时（火焰图上很直观） 1、打印调用栈（支付宝代码里就有） ------> 该死, 非常耗时 2、Log耗时非常小------> Log耗时，可以忽略 在5us作用，也就是说打印200个log，才1ms 规定，性能验证： 开发完任何需求，主要流程，抓一下火焰图！！！！！ TODO: 开发验证 功能性验证：异常场景 性能验证 ：火焰图 开发稳定性验证：Top28应用验证 1.6. 参考： console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_性能/Systrace.html":{"url":"coding/0_性能/Systrace.html","title":"Systrace","keywords":"","body":"1. 目录2. Android系统性能调优工具介绍3. TraceView---可以看调用栈3.1. TraceView应用场景3.2. TraceView工具的使用3.2.1. 工具原理4. Systrace4.1. Systrace场景4.2. Systrace工具的使用4.2.1. 代码中触发4.2.2. 命令行4.2.3. 键盘快捷键4.2.4. 使用命令行捕获Systreace报告文件4.2.5. 模拟器 perfetto命令 抓取 trace4.2.6. atrace4.2.7. perfetto4.3. 阅读报告4.3.1. 页面结构4.3.2. 线程的不同状态-------颜色：4.3.3. 线程唤醒者分析---atrace4.3.4. 线程状态切换之 Runnable -----> Running4.3.5. 线程唤醒者分析sleep---> Running (函数调用者分析)----perfetto4.3.6. binder线程唤醒者分析----perfetto4.3.7. 如何找唤醒过程对应的代码级呢？4.3.8. mark标尺：快捷键m4.3.9. 关于log（次要）4.3.10. 选中一段时间为base4.4. 高阶---SQL语言统计信息4.4.1. google已经添加的sample4.4.2. 统计各个进程的 总占时，且排序：4.4.3. 统计各个线程的 总占时，且排序：4.4.4. 查询与某一线程 有相关调用的线程4.4.5. TODO: 理解SQL语句含义4.5. binder跨进程调用4.5.1. 调用点跳转（回跳）：4.5.2. 两种binder调用的画法不同4.6. 线程 之间 同步（同进程）4.7. 锁竞争(lock contention)4.8. 已知4.8.1. 锚点4.8.2. bufferTX4.9. 小技巧：4.9.1. 浏览器全屏F114.9.2. 两个搜索联合使用：4.9.3. 立即保存ps信息4.10. 终极目标：拼图4.11. 实战4.11.1. 应用冷启动--以Launch点击应用图标为例4.11.2. TODO: 其他章节用systrace来分析4.12. Systrace的原理4.12.1. 开源代码4.13. Perfetto快捷键4.13.1. 技巧：4.14. 遇到的坑：4.14.1. platform-tools下找不到systrace文件夹4.14.2. 没有写入权限：4.14.3. 超长slice.4.15. 参考：4.16. TODO:5. atrace5.1. 转html（perfetto网站查看）5.2. 技巧之 没有process名如何查看6. 实操（验证ok）-----trace工具编译7. 源码分析7.1. 写trace源码分析--TODO7.2. 抓trace的源码分析--TODO8. Oprofile9. Layout Inspector10. winscope(快照)---闪屏问题10.1. 参考：10.2. 官方文档11. 一些环境使用原则：12. 参考13. 补充，脚本14. TODO: 目录 Android系统性能调优工具介绍 TraceView---可以看调用栈 TraceView应用场景 TraceView工具的使用 工具原理 Systrace Systrace场景 Systrace工具的使用 代码中触发 命令行 [options] [categories] 哪些模块 perfetto命令行 键盘快捷键 使用命令行捕获Systreace报告文件 模拟器 perfetto命令 抓取 trace atrace perfetto 阅读报告 页面结构 线程的不同状态-------颜色： 线程唤醒者分析---atrace 线程状态切换之 Runnable -----> Running 线程唤醒者分析sleep---> Running (函数调用者分析)----perfetto binder线程唤醒者分析----perfetto 如何找唤醒过程对应的代码级呢？ mark标尺：快捷键m 关于log（次要） 选中一段时间为base 如何选中一段时间？ 基于选中的时间，看各个统计量 前三个cpu的 统计： Binder流的数量 高阶---SQL语言统计信息 google已经添加的sample 统计各个进程的 总占时，且排序： 统计各个线程的 总占时，且排序： 查询与某一线程 有相关调用的线程 TODO: 理解SQL语句含义 binder跨进程调用 调用点跳转（回跳）： 选中箭头，然后点Flows的跳转箭头 -对应的binder流： 耗时，调用者，被调用者 特点 两种binder调用的画法不同 线程 之间 同步（同进程） 锁竞争(lock contention) 已知 锚点 bufferTX 小技巧： 浏览器全屏F11 两个搜索联合使用： 立即保存ps信息 终极目标：拼图 实战 应用冷启动--以Launch点击应用图标为例 TODO: 其他章节用systrace来分析 Systrace的原理 开源代码 Perfetto快捷键 技巧： 遇到的坑： platform-tools下找不到systrace文件夹 没有写入权限： 超长slice. 参考： TODO: atrace 转html（perfetto网站查看） 技巧之 没有process名如何查看 实操（验证ok）-----trace工具编译 源码分析 写trace源码分析--TODO 抓trace的源码分析--TODO Oprofile Layout Inspector winscope(快照)---闪屏问题 参考： 官方文档 一些环境使用原则： 参考 补充，脚本 TODO: 1. 目录 2. Android系统性能调优工具介绍 TraceView、Systrace、Oprofile 3. TraceView---可以看调用栈 3.1. TraceView应用场景 3.2. TraceView工具的使用 https://www.jianshu.com/p/a14bfdc4109a?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation 形成一个图表，从中可以分析出每个方法的执行时间 3.2.1. 工具原理 4. Systrace 4.1. Systrace场景 包含的信息内容： 工作线程：内核+框架+应用 系统模块状态 ：CPU频率/GPU频率/system property 赋值/frame buffer队列. 优点： 1、图形化 ----> 技巧： 自己做工具，也可以这样做 2、按照时间铺开 关注点： 运行时间 线程 CPU工作频率 CPU 抢占 4.2. Systrace工具的使用 4.2.1. 代码中触发 有些要看的内容没有在现有的trace里，不够需要自己加TAG： java： // Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"onCreate\"); ................ Trace.traceEnd(Trace.TRACE_TAG_VIEW); // Trace.beginsection (\"onConfigurationChanged\"); // systemTrace, 性能 ................... Trace.endSection(); // Trace.asyncTraceBegin ................... Trace.asyncTraceEnd framework native添加： #define ATRACE_TAG ATRACE_TAG_VIEW ATRACE_NAME(base::StringPrintf(\"LoadApkAssets(%s)\", path.c_str()).c_str()); ATRACE_CALL(); // 或： #include ATRACE_BEGIN(trace.c_str()); ............. ATRACE_END(); 4.2.2. 命令行 python systrace.py [options] [categories] 目录: ‪E:\\softWare\\softWare\\systrace\\platform-tools_r33.0.0-windows\\platform-tools\\systrace\\systrace.py [options] [categories] 哪些模块 my例子： python systrace.py -o mynewtrace.html \\ -a com.example.aospsourcecode2 com.android.launcher3 \\ sched freq idle am wm sm input view perfetto命令行 adb shell perfetto -h https://juejin.cn/post/6974368361283059719 4.2.3. 键盘快捷键 https://www.jianshu.com/p/a14bfdc4109a?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation 4.2.4. 使用命令行捕获Systreace报告文件 4.2.5. 模拟器 perfetto命令 抓取 trace https://blog.csdn.net/Redmoon955331/article/details/129736238 perfetto命令 抓取 trace ------> 安卓14上，验证OK https://blog.csdn.net/tyearlin/article/details/123426616 4.2.6. atrace 见《atrace章节》 4.2.7. perfetto 优点： -可视化做的更好。可以跳转，有箭头链接 4.3. 阅读报告 阅读网站： 方法一：使用 chrome://tracing/ 方法二：直接点html，这样有进程名，更优 方法三：优选 https://ui.perfetto.dev/ 4.3.1. 页面结构 CPU大纲：红色代表cpu核心负载高 CPU使用具体页面展开： ​ 1、每个cpu在做哪些工作 ​ 2、颜色代表 线程状态 （见下） -------> 错误！！！！这里是cpu的，不是线程！！！ 事件： 4.3.2. 线程的不同状态-------颜色： 参考： https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/#/%E6%AD%A3%E6%96%87 绿色 --> 运行中 Running 对于在CPU上执行的进程，需要查看其运行时间、是否跑在该跑的核上、频率是否够等。 蓝色 --> 可运行 Runnable 对于在等待序列中的进程，需要查看是否有过多任务在等待、等待时间是否过长等。 白色 --> 休眠中 Sleeping： 这里一般是在等事件驱动。 橘色 --> 不可中断的睡眠态_IO_Block Uninterruptible Sleep | WakeKill - Block I/O 线程在I / O上被阻塞或等待磁盘操作完成。 紫色 --> 不可中断的睡眠态 Uninterruptible Sleep 线程在另一个内核操作（通常是内存管理）上被阻塞。 -上述自然，生活化模型：颜色- 红绿灯颜色 注,也可以点击线程位置,看 4.3.3. 线程唤醒者分析---atrace 注意: 看似函数一直在走,但是线程已经 sleep了. 说明函数运行 sleep了. 细长条代表线程运行。白色表示sleep了 线程唤醒者: 图中: 前蓝后绿部分,很短暂 如何找哪个线程唤醒该线程的？操作： 标尺固定时间段, 找到cpu对应这个宽度的task：必然是四个当中一个 通过看tid 17889确定 ---> 是launcher的render线程做的 即结论：render线程唤醒了ui线程 4.3.4. 线程状态切换之 Runnable -----> Running 一些结论： Runnable -----> Running 一般都是cpu调度（时间片轮转）造成的。不是开发者代码引起的 sleep ----> Running 线程角度： 线程唤醒 代码角度：开发者代码 同步调用 结束 注：同一个线程，由于调度，一会儿在cpu1运行，一会儿在cpu2运行 4.3.5. 线程唤醒者分析sleep---> Running (函数调用者分析)----perfetto 例子： 找System_server中startActivityInner是谁调用的？（如何查找调用者问题） 等价命题：即 这个线程是谁唤醒的？（线程唤醒问题） ​ 即：线程状态怎么转成Running？ 步骤： 1、选中Running slice 注：小的Runnable可能跟锁有关，先不管 -----> TODO 选择大的Runnable后面的slice 2、Running on CPU 1 跳转CPU1 被cpu0的 com.android.launcher3 1101唤醒 总之： 没有看代码，完全依照图形，找到了函数的调用者 -核心思想： 通过CPU之间的线程唤醒者 -----> 找到线程之间的调用关系 可以是两个进程的两个线程（binder调用），也可以是同进程 技巧，回跳： 4.3.6. binder线程唤醒者分析----perfetto 1、binder线程不用像非binder线程那么麻烦，因为只要点击slice（binder transaction或者 binder reply），就会有调用连线: 2、注：箭头描述的调用，时间是不准确的： 4.3.7. 如何找唤醒过程对应的代码级呢？ 4.3.8. mark标尺：快捷键m 1、方法一：选中某一slice，m 就有了从上至下的标尺 -----> 作用：统一时间段观察 方法二： 点击空白区域，任意新增mark标尺 标尺的删除，与改变颜色： 先选中： 4.3.9. 关于log（次要） 1、选中log，给出log图形化的位置，可以和其他链接起来 2、可以过滤 4.3.10. 选中一段时间为base 如何选中一段时间？ 或者在大纲里选一段时间 或者在内容中框选 如何反选？ 鼠标左键。选中时间，只是一个临时选中 TODO: 能否有标尺？ 基于选中的时间，看各个统计量 这段时间的log： 前三个cpu的 统计： 期间，前三个cpu的 有哪些线程、进程 Binder流的数量 当前时间 + 选中的进程的： 4.4. 高阶---SQL语言统计信息 4.4.1. google已经添加的sample （1）所有进程： （2）进程占用的cpu时间： 4.4.2. 统计各个进程的 总占时，且排序： select process.pid, process.name, sum(dur)/1e9 as cpu_sec from sched join thread using (utid) join process using (upid) group by upid, pid order by cpu_sec desc; 可见，前几名耗时的是audioserer、allocator、.............. -cpu占用率计算（以system_server为例子）： 0.282787991/10s的trace*4个cpu核 = 0.0028 -cpu核心空闲时长： swapper是CPU线程唤醒机制 pid = 0 占用了34s -------> swapper是占空的？也就是40s内，有34s cpu核心是没有用的 4.4.3. 统计各个线程的 总占时，且排序： select thread.name as threadname, thread. tid as tid, round (sum(dur) / 1e9,2) as cpu_sec from sched inner join thread using (utid) group by threadname, tid order by cpu_sec desc 可见，Render线程还是很耗时的。而且每个应用一个render线程 cpu占有率计算，同上 4.4.4. 查询与某一线程 有相关调用的线程 即：弄清楚线程的交互关系 TODO: 没弄懂，如何找到waker.name？ 比如：查找InputDispatcher线程 唤醒 哪些线程？ DROP VIEW IF EXISTS wakee_table; CREATE VIEW wakee_table AS SELECT waker.tid as waker_tid, wakee_runnable.utid as wakee_utid FROM thread AS waker JOIN thread_state AS wakee_runnable ON waker.utid = wakee_runnable.waker_utid WHERE waker.name = \"InputDispatcher\"; SELECT waker_tid, thread. tid, thread.name FROM wakee_table JOIN thread ON thread. utid=wakee_table.wakee_utid; 唤醒的： 4.4.5. TODO: 理解SQL语句含义 后面写自己的语句 4.5. binder跨进程调用 4.5.1. 调用点跳转（回跳）： 图形化的好处，可以点击跳转，方便 选中箭头，然后点Flows的跳转箭头 binder async rcv : 异步接收端 同理，binder transaction async 异步调用端，点击箭头，回跳 ------------> 没有return的one-way调用 -对应的binder流： 耗时，调用者，被调用者 对于trace看binder调用的优点： 跨进程binder调用，比同进程调用（很多时候，没有添加），更容易发现一些 特点 -trace监控了所有的binder调用。 在binder层面做的监控 -----> 所以没有名字 推论： 所有的跨进程调用，都会在trace中体现 --------> 问题在于，TODO：如何和代码对应？ 4.5.2. 两种binder调用的画法不同 1、oneway形式的（没有返回）： -图中特征： （1）有小箭头 （2）、调用点一定在被调用之前 2、有返回值的 即同步调用 -图中特征： （1）binder transaction & binder reply （2）图中画线调用点在被调用之后（画的有问题？），但实际上， -A、调用点为红色框点； -B、返回点是binder transaction结束点（此时拿到返回值） 4.6. 线程 之间 同步（同进程） 原理见：《线程唤醒者分析(函数调用者分析)----perfetto》 等价于： 线程状态 sleep---> Running 特征： 1、会有系统调用 sys_futex 2、在sys_futex上方，线程是sleep状态，没有执行 3、被调用线程在结束时，也会有sys_futex： 如何找主线程在等待哪个线程？ 即 主线程调用了哪个线程？ 即 主线程 被 哪个线程阻塞住了？ 即 主线程 ---性能优化经验： 一旦 一个线程阻塞了另一个线程，大概率是有优化空间的 4.7. 锁竞争(lock contention) https://blog.csdn.net/SOHU_TECH/article/details/131118616 4.8. 已知 4.8.1. 锚点 google已经为我们准备好了一些锚点-----> 大的TAG： -以这些为锚点，找其他的 1、Andriod App Startups 这段做了啥事情？ 从进程起来----> 到 第一帧绘出来 -----------> 注意，这就是APP冷启动时间 4.8.2. bufferTX 统计surfaceFlinger中每一个layer 4.9. 小技巧： 4.9.1. 浏览器全屏F11 看trace纵向是稀缺资源 ，所以，浏览器全屏F11 4.9.2. 两个搜索联合使用： 4.9.3. 立即保存ps信息 atrace下 4.10. 终极目标：拼图 -挪动线程到一起，串点成线： -------------> TODO: 这个是阅读trace的唯一目标？ 标准： 没有空白； binder调用链条完整 作用： 逻辑上完整 减少上下的滚动 ------> 美好 关联法： 抛开代码，去连图 -------> 搭建框架 极优：不依赖于代码知识！！！！！ --------> 所以，不需要看代码，而是看图说话 技巧： 动态调整 步骤： 1、按照大的概念，把各个大模块凑起来：-------> 存在很多空缺。后面工作就是填补空缺思想 2、把这个大模块链接起来 ----> 当然是Binder链接。。不能依赖于代码 TODO: 步骤 ​ 3、将新的线程（根据2中的链接）实时往pin里添加 4.11. 实战 4.11.1. 应用冷启动--以Launch点击应用图标为例 《见startApp》 4.11.2. TODO: 其他章节用systrace来分析 4.12. Systrace的原理 参考： https://blog.csdn.net/feelabclihu/article/details/106247862 好文 简易的流程图： 具体实现： Systrace抓取的trace数据，总体上可以分为两类： 一类是Java和Native在用户层发生的函数调用，一类是内核态的事件信息。 4.12.1. 开源代码 systrace的生母，谷歌开源项目https://chromium.googlesource.com/catapult。 4.13. Perfetto快捷键 技巧： 用a与d 放大缩小时，鼠标左键点击（或者鼠标悬停），成为放缩的中心 4.13.1. 技巧： 通过在时间间隔周围绘制一个矩形来选择所需的时间间隔。 使用标尺工具标记或突出显示问题区域。 依次点击 View Options > Highlight VSync，以显示每项显示屏刷新操作-------> 标出一帧 筛选Processes 5、加了界限后，立马切换其他模式 ----> 这样界线可以长久保存 4.14. 遇到的坑： 4.14.1. platform-tools下找不到systrace文件夹 https://www.jianshu.com/p/626eaebaa6a8 4.14.2. 没有写入权限： （1）主要这个文件路径不能删除 （2）这个路径是专门为trace准备的。结果不能存放在其他目录 解决办法： 方法一：重新刷机 方法二：模拟器，重新替换img 方法三（优）：adb shell setenforce 0 ------> 实际上就是关闭Selinux权限 参考：https://blog.csdn.net/qq_19004627/article/details/119612924 使用setenforce 命令进行设置: adb shell setenforce 0 //设置成permissive 模式 adb shell setenforce 1 //设置成enforce 模式 4.14.3. 超长slice. 原因： (1)、没有加成对的tag （2）、很多的超长slice -----> buffer不够，tag掉了 4.15. 参考： https://www.androidperformance.com/2019/05/28/Android-Systrace-About/#/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95 https://www.jianshu.com/p/a14bfdc4109a?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation https://blog.csdn.net/qq_23452385/article/details/131567881 Perfetto 命令行工具（Android 10 及更高版本）_android perfetto_xhBruce的博客-CSDN博客 https://perfetto.dev/docs/data-sources/cpu-scheduling perfetto的官方文档 https://huaweicloud.csdn.net/63563dbad3efff3090b5be9c.html?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-7-126672666-blog-129736238.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-7-126672666-blog-129736238.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=8 高阶 4.16. TODO: 通过transactionid找对应的方法WW 2、如何把竖向弄窄一点儿？ 3、binder Traction调用，时间轴上是往回的呢？ 4、多看几次视频，学会精髓 5、普通trace与perfetto的转换 5. atrace adb shell atrace sched freq idle am wm gfx view sync ss power rs res binder driver binder _lock input hal camera aidl disk -b 96000 -t 5 atrace优点：一定能用： 安卓新老版本都能 使用 详解： adb shell atrace \\ sched freq idle \\ CPU的排程和频率 am wm gfx view sync ss power rs res \\framework层 binder driver binder _lock \\binder调用关系 input hal camera aidl disk \\驱动：输入、相机 -b 96000 -t 5 \\ buffer大小10M左右，时间5s 5.1. 转html（perfetto网站查看） TODO atrace.out 转 perfetto显示 python systrace.py --from-file atrace.out -o atraceout2.html --------> atraceout2.html可以加载到 perfetto界面 5.2. 技巧之 没有process名如何查看 关于 各种 Process 878 等没有进程名： 法一： 需要脚本配置 法二： 点击所有进程展开 然后Chrome搜索 法三：systrace 6. 实操（验证ok）-----trace工具编译 下载源码： git clone https://android.googlesource.com/platform/external/perfetto/ && cd perfetto tools/install-build-deps ---------> install the build dependencies：可能会失败，要执行很多次 build： tools/gn gen --args='is_debug=false' out/linux tools/ninja -C out/linux tracebox traced traced_probes perfetto TODO: Running a Trace: out/linux/tracebox -o trace_file.perfetto-trace --txt -c test/configs/scheduling.cfg out/linux/tracebox -o trace_file.perfetto-trace --txt -c test/configs/android_log.cfg 7. 源码分析 7.1. 写trace源码分析--TODO 代码实现，参考weston的： trace_init(void); trace_begin(const char* name); trace_end(void); 原理：往tracing节点，按照固定格式写东西！！！！ \"/sys/kernel/tracing/trace111\", O_WRONLY | O_CLOEXEC) 7.2. 抓trace的源码分析--TODO 8. Oprofile 9. Layout Inspector 最优观察viewTree的工具 -优点： （1）图形化 ，更深刻 （2）图形与 文字相结合，并且可以点击互动 -----> 操作方便，对应关系非常明确 （3）实际上，显示的数据 比xml显示的更加完整。比如这里，显示了 “微博热搜”的小程序按钮。。。。xml没有体现 （4）可以在左边搜索。。。。当页面 view过多时，可以精确区分（图形区域不容易区分） （5）同dump一样，可以知道 TextView 具体的类 10. winscope(快照)---闪屏问题 winscope本质： -每一帧，都给整个系统拍快照 ----> 这也是理解复杂系统的关键 ---------------> 基于帧，1、所以，才可以解决闪屏问题 ​ 2、TODO: 肯定可以解决其他很多问题 方法一： winscope.html + winscope_proxy.py ----> 直接获取（封装的adb命令） 方法二：直接使用adb命令，见下，官方文档 TODO: 问题的关键在于，如何看？ 1、每个Task有个Z值，是层级 10.1. 参考： https://source.android.com/docs/core/graphics/tracing-win-transitions?hl=zh-cn 官方文档 https://www.jianshu.com/p/c28a81dc3a65 10.2. 官方文档 https://developer.android.com/studio/debug/layout-inspector 11. 一些环境使用原则： 使用linux下as调试或trace，就不能用win下As ADB之间影响 12. 参考 https://blog.csdn.net/innost/article/details/9008691 https://blog.csdn.net/u011578734/article/details/109497064 13. 补充，脚本 adb shell perfetto -o /data/misc/perfetto-traces/trace_file.perfetto-trace -t 20s sched freq idle am wm gfx view binder_driver hal dalvik camera input res memory 网站: https://ui.perfetto.dev/#!/ 做系统稳定性问题分析，当遇到系统卡死时，我们经常要使用“kill -3 pid”来打印System_Server进程各个线程的Java调用栈，根据线程状态及调用栈来更进一步定位问题点，当然某个应该界面卡顿时间长时也可以通过这个命令来抓取Java调用栈进行分析。 注意native进程是不能用kill -3来打trace的，而是使用debuggerd. https://droid10.com/Android/Android%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/ 14. TODO: https://zhuanlan.zhihu.com/p/348548041 Android性能优化机制-优先级反转问题 https://pyautogui.readthedocs.io/en/latest/index.html pyautogui操作电脑 https://blog.csdn.net/toopoo/article/details/124660769?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-124660769-blog-112331887.235^v38^pc_relevant_anti_t3&spm=1001.2101.3001.4242.4&utm_relevant_index=6 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_性能/内存.html":{"url":"coding/0_性能/内存.html","title":"内存","keywords":"","body":"1. 目录2. 应用角度：应用的内存分配原理与优化2.1. 维测：dumpsys meminfo [PID]/进程名2.2. 基础知识：2.2.1. 进程的内存占用分为两类：2.2.2. Overcommit机制：2.2.3. 低内存下的系统回收机制（安卓机制）3. 系统角度：常驻应用与后台服务3.1. 安卓系统内存分布3.2. TODO：维测 上图6种内存查看3.3. del: 特殊情况：一种特殊的系统设计3.4. 非常驻应用 与 free Memory的博弈---LMK3.4.1. del: 临时扩展：墓碑（Tombstone）机制3.4.2. del: 临时扩展：Q: 内存清理 (一键加速) 能提升性能嘛3.4.3. OOM SCORE ADJ：LMK 参考的进程重要性3.4.4. del: 次要： Activity Manager 指派 OOM_SCORE_ADJ 的特殊规则3.4.5. 维测：各个进程的OOM adjustment3.4.6. Q: 系统何时因为内存压力高而卡顿3.4.7. 解决/避免系统走入低内存的卡顿办法3.5. 各种应用的Mem与CPU占用详解3.5.1. Persistent 应用3.5.2. Perceptible/A Service/B Service 应用3.5.3. Visible 应用3.5.4. Receiver 与 Service 的 ADJ3.5.5. del:Receiver 常见的误区3.5.6. Bind Service3.6. “常驻应用”总结3.6.1. “常驻”应用定义 ：3.6.2. 常驻应用对系统的影响3.6.3. 审视常驻、后台运行的必要性3.6.4. 万不得已，必须常驻时：3.6.5. del: 临时展开：具体Service 与 Activity 如何分离？3.7. 维测 之 常驻、非常驻 内存4. 内存管理机制4.1. （安卓）前台应用内存回收-----------Activity回收4.2. Linux如何限制单个应用内存泄露的影响 ----gpt的回答 应用角度：应用的内存分配原理与优化 维测：dumpsys meminfo [PID]/进程名 基础知识： 进程的内存占用分为两类： Overcommit机制： 低内存下的系统回收机制（安卓机制） 系统角度：常驻应用与后台服务 安卓系统内存分布 TODO：维测 上图6种内存查看 del: 特殊情况：一种特殊的系统设计 非常驻应用 与 free Memory的博弈---LMK del: 临时扩展：墓碑（Tombstone）机制 del: 临时扩展：Q: 内存清理 (一键加速) 能提升性能嘛 OOM SCORE ADJ：LMK 参考的进程重要性 del: 次要： Activity Manager 指派 OOM_SCORE_ADJ 的特殊规则 维测：各个进程的OOM adjustment Q: 系统何时因为内存压力高而卡顿 解决/避免系统走入低内存的卡顿办法 各种应用的Mem与CPU占用详解 Persistent 应用 Perceptible/A Service/B Service 应用 Visible 应用 Receiver 与 Service 的 ADJ del:Receiver 常见的误区 Bind Service “常驻应用”总结 “常驻”应用定义 ： 常驻应用对系统的影响 审视常驻、后台运行的必要性 万不得已，必须常驻时： del: 临时展开：具体Service 与 Activity 如何分离？ 维测 之 常驻、非常驻 内存 内存管理机制 （安卓）前台应用内存回收-----------Activity回收 Linux如何限制单个应用内存泄露的影响 ----gpt的回答 1. 目录 2. 应用角度：应用的内存分配原理与优化 2.1. 维测：dumpsys meminfo [PID]/进程名 P13_5G:/ # dumpsys meminfo com.android.settings Applications Memory Usage (in Kilobytes): Uptime: 1051158931 Realtime: 1051158931 ** MEMINFO in pid 23721 [com.android.settings] ** Pss Private Private SwapPss Rss Heap Heap Heap Total Dirty Clean Dirty Total Size Alloc Free ------ ------ ------ ------ ------ ------ ------ ------ Native Heap 9349 9328 0 8470 9648 33840 17957 6181 Dalvik Heap 5896 5864 0 276 6144 9741 4871 4870 Dalvik Other 2091 1428 0 50 3056 Stack 548 548 0 320 552 Ashmem 8 0 0 0 28 Other dev 32 0 20 0 1016 .so mmap 6612 248 52 0 51320 .jar mmap 1524 0 0 0 31236 .apk mmap 8612 0 5872 0 30792 .ttf mmap 70 0 4 0 428 .dex mmap 206 12 188 0 356 .oat mmap 1388 0 80 0 13284 .art mmap 2065 1324 4 572 9552 Other mmap 1323 28 48 0 8080 EGL mtrack 3780 3780 0 0 3780 GL mtrack 5560 5560 0 0 5560 Unknown 299 296 0 337 360 TOTAL 59388 28416 6268 10025 59388 43581 22828 11051 App Summary Pss(KB) Rss(KB) ------ ------ Java Heap: 7192 15696 Native Heap: 9328 9648 Code: 6460 128744 Stack: 548 552 Graphics: 9340 9340 Private Other: 1816 System: 24704 Unknown: 11212 TOTAL PSS: 59388 TOTAL RSS: 175192 TOTAL SWAP PSS: 10025 Objects Views: 288 ViewRootImpl: 1 AppContexts: 12 Activities: 4 Assets: 7 AssetManagers: 0 Local Binders: 63 Proxy Binders: 68 Parcel memory: 345 Parcel count: 76 Death Recipients: 10 OpenSSL Sockets: 0 WebViews: 0 SQL MEMORY_USED: 0 PAGECACHE_OVERFLOW: 0 MALLOC_SIZE: 0 关注点： ​ Pss 与 Swap 在ART/Dalvik 虚拟机接口： / Returns the maximum amount of memory that the Java virtual machine will attempt to use long maxMemory = Runtime.qetRuntime ().maxMemory(); // Returns the total amount of memory in the Java virtual machine long totalMemory = Runtime.getRuntime().totalMemory(); Returns the amount of free memory in the Java virtual machine long freeMemory = Runtime.getRuntime().freeMemory(); ----------------> 只是Dalvik Heap，没有太多意义。 不能反映一个应用用的真正内存 2.2. 基础知识： 物理内存最小分配单位：1 个页 (page)，大小通常是 4KB 2.2.1. 进程的内存占用分为两类： Anonymous Memory：例如 Java heap, native heap，从系统分配内存来填充数据 File-backed memory：在磁盘上有对应的文件，以 mmap() 映射， 占用的内存为对文件最近存取的缓存 补充： 在磁盘上有对应的文件： （1）C语言的fopen、java的IO (2) 以 mmap() 映射: 安卓大量使用，比如jar、dex等 mmap方式，优点：见下 2.2.2. Overcommit机制： 当申请内存时， Linux 并非马上就分配内存， 而是延迟到实际存取时，才真正分配内存 ----> 例子：申请400k时： （1）到实际用的时候，才真正分配 （2）也不是一次性分配400看，而是4kB分配 优点： 代码分配内存后，有些可能分支没走到，没利用到 --------> Overcommit就会更经济 缺点： 代码里使用内存 与 实际内存分配可能不一样，造成分析困难 Q&A： 来得及不？应该来的急，分配的效率是o（1） 2.2.3. 低内存下的系统回收机制（安卓机制） 机制： 1、砍进程：退出后台的先后时间 2、对 File-backed memory 进行释放，因为磁盘中有备份 ------> 先释放，到时候按需加载 3、将 Anonymous memory swap 出去 ： swap到磁盘上（但是磁盘的速度远低于ddr----->安卓没有使用 ） 安卓对这些内存压缩。用到时候再解压 其中，常见的 file-backed memory APK 文件：映射目录结果与 resources.arsc 注： apk大部分文件压缩了，resources.arsc文件没有压缩 ----> 补充截图 DEX 文件：DEX 优化后、可由虚拟机执行的代码 so 文件：动态链接 ttf 文件：字体 问题：图片一般使用 file-backed memory 方式分配内存吗？ mmap 映射方式： 先开启一个文件得到 fd，再利用 mmap() 将其映射到内存，代码中借由操作指针的方式存取缓存在内存的文件内容 void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset); //* start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址 优点：可以使用指针任意移动读取位置，代码好写。由操作系统处理文件的读取、缓存，以及在低内存、或少用时放掉。还能轻易实现跨进程 对只读文件的加载共享 Anonymous memory 3. 系统角度：常驻应用与后台服务 常驻应用： 因为功能实现需要，必须长期、或是永久驻留在后台的应用，可能处于不断运行、也可能处于按需运行 安卓实现后台持续运行的方法： 在 AndroidManifest.xml 设 persistent=true -----> 默认做法 以 native 进程运行 -----> 安卓对native进程默认不杀。 TODO: 机制是啥？JVM检测不到？ 以 start service 运行，不停止 以 start service + startForeground 运行，不停止 -----> startForeground 前台service 间接因素：以 bind service、provider 绑定其他进程不放 自然，常驻进程越多，可用内存越少 3.1. 安卓系统内存分布 图见：《Mem.eddx》 各个内存的作用： TODO： 以pixel为例，各个大概多大？ Free Memory：没有被使用的 -----> 用来分配内存的 系统缓存： 加载的一些系统的so库 分配内存，规则： 1、分配内存时，优先从Free Memory内拿 2、Free Memory不够时，需要扩充Free Memory： （1） 非常驻应用 ----> 被杀应用，这个效果最好 ​ 但 至少保留刚退到后台的应用 （2） 释放系统缓存： 不能大量，否则会造成性能下降（用到的一些so库，不在内存里） 问题： 如果在分配内存的时候，才发现 Free Memory不够，才去 杀应用释放内存，来不及 ------> 性能不好 办法：保证一定的Free Memory， lmk机制 Free Mem 与 非常驻应用 之间有个平衡： Q: Free Memory越多越好嘛？ A: 会造成系统缓存小 ------> 性能下降 非常驻应用 刚刚退到后台，就被杀 -----> Q: 系统缓存越多越好嘛（比如把/system分区所有so库，锁在系统缓存中）？ A: 很多so，平时不会被用到 -----> 对mem的浪费 ---------------> 例子：在Free mem充足的情况下，也能保证 非常驻应用有四五个 例子： 总内存查看： sailfish:/ # cat /proc/meminfo MemTotal: 3855820 kB // ---------> pixel 手机内存3.67G. 与网上说的4G内存符合 MemFree: 1801968 kB MemAvailable: 2683916 kB Buffers: 38320 kB Cached: 986340 kB SwapCached: 0 kB Active: 594956 kB Inactive: 798328 kB Active(anon): 465368 kB Inactive(anon): 2784 kB Active(file): 129588 kB Inactive(file): 795544 kB Unevictable: 96232 kB Mlocked: 96232 kB SwapTotal: 524284 kB SwapFree: 524284 kB Dirty: 248 kB Writeback: 0 kB AnonPages: 464880 kB Mapped: 335976 kB Shmem: 3296 kB Slab: 149716 kB SReclaimable: 48524 kB SUnreclaim: 101192 kB KernelStack: 25808 kB PageTables: 31964 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB CommitLimit: 2452192 kB Committed_AS: 41658032 kB VmallocTotal: 258998208 kB VmallocUsed: 211792 kB VmallocChunk: 258688724 kB sailfish:/ # 3.2. TODO：维测 上图6种内存查看 3.3. del: 特殊情况：一种特殊的系统设计 设计理念： 把系统所有应用都设计成常驻 图见：《Mem.eddx》 采用的前提是： 封闭生态，无法安装其他应用 ----> （软件角度：后期不会增加内存） 系统应用占用的内存可控 ------> （ 硬件角度： 硬件有余量） 例子：扶手屏项目 3.4. 非常驻应用 与 free Memory的博弈---LMK 图见：《Mem.eddx》 博弈： 1、非常驻应用不能过少，否则很容易 冷启动 2、Free Memory 不能过小，否则：应用每次申请新内存，就需要触发系统机制腾出 free memory， 速度慢 冷启动应用的耗时：加载资源等 安卓的设计理念是： 安卓刻意保留最近启动过的进程在后台，避免冷启动，使得下次启动时更快 （在Free Memory足够的情况下） TODO: 为啥安卓的冷启动，不咋滴？ LMK (Low Memory Killer) ----------满足上面设计理念 前提： 保障系统始终有足够多的 free memory 算法：以进程重要性 (称为 OOM ADJ, Out of Memory Adjustment ) 与内存大小，决定砍的顺 安卓系统没有墓碑机制，必须有自己的后台应用进程生命周期的管理------> lmk机制 多任务能力 (Multi-Tasking Capability) -----------即保持后台应用个数的能力，即热启动的能力 评测开放生态系统的多任务能力：能驻留多少后装的第三方应用在后台，快速切换 多任务能力的保持，是安卓系统性能体验重要的一环，因此 LMK 的设计，既要保障有足够多的 free memory，又必须保障最近使用过的几个应用能保持在后台 3.4.1. del: 临时扩展：墓碑（Tombstone）机制 使用的系统范围： 微软WP7、ios； -设计理念： 微软不允许任何 第三方应用程序]在WP7的后台运行，特定时间内只有一个应用程序的在前台运行，如果你的应用程序没有在前台显示，就表示这些程序并没有运行，这样就不耗费运行内存和处理器资源 ----------> 简言之： 杀死所有后台应用 墓碑含义： 墓碑：应用程序已经死了，但是墓碑上记录有临终前的所有状态（后面，新启动新进程，根据记录，恢复状态） 例子： WP7手机： 当用户正在使用一个应用程序，比如游戏或者新闻阅读，这时有电话打进来，来电提示和通话页面将会在前台显示，正在运行的游戏就会消失，WP7不允许后台运行应用，这时候墓碑机制就会触发，游戏的运行状态包括画面、进度等等数据会冻结保存 -----> 杀死后台游戏 -----> 等电话结束，启动游戏 --------> 恢复状态 从任务管理角度： 墓碑机制理念：单任务（第三方程序单任务） ------> 自然，多任务的都没有墓碑机制：mac、win、linux、Android 从内存角度看： ios墓碑机制 与 安卓 lmk机制，是对等的。都是 释放 后台应用内存的机制 比较： 墓碑机制，与 Android 状态保存机制，似乎异曲同工 ------> 备忘录模式 从后台应用的生命周期来看： 是一种后台应用生命周期管理机制 疑问： 墓碑机制，要启动进程（这个会慢嘛？），需要加载资源嘛（保存了数据就不需要了嘛？） ------------> ios为啥冷启动这么快？ 参考： https://baike.baidu.com/item/墓碑机制/7558924?fr=ge_ala 墓碑机制 3.4.2. del: 临时扩展：Q: 内存清理 (一键加速) 能提升性能嘛 A: 好的系统设计下，不能 (反而冷启动，降低启动时间) 例外：一些差系统，是可以的 差系统： LMK 保留的 free memory 过少，导致需要频繁搜寻可用内存 ------> 系统设计问题 后台的非常驻应用持续运行，抢占 CPU 等系统资源 -------> 应用+系统问题（系统应该做限制） -------------------> 一键加速，优化的是这两点（而这两点，系统设计可以解决掉） 为啥 性能提升有限？ 第三方应用做一键加速，只能 kill，无法 force stop。 以 service 运行的应用，kill 后仍会重启 ----->TODO: kill 与 force stop区别 一键加速 缺点： 冷启动 3.4.3. OOM SCORE ADJ：LMK 参考的进程重要性 OOM_SCORE_ADJ 分类意义 通过何种方式达到 -1000 Native -700 ~ -800 Persistent 在 AndroidManifest.xml 设 persistent=true 0 Foreground 目前在前台运行的应用，或者正在运行 onReceive()、Service.onCreate()、onStartCommand() 100 Visible 被常驻应用 bind 住的 service/provider（自然，提升优先级），或者虽非前台、但能看到界面的应用 200 Perceptible startService() 且调用 startForeground() 500 A Service startService() 600 Home 桌面在后台时 700 Previous 前一个退到后台的应用 800 B Services startService() 且运行时间较长 >900 Cached 单纯只有 activity 、已经执行完 receiver、service、provider ADJ 等价于：Native进程不管 ​ 注： 极端情况下，ADJ= 0，也会被砍 ADJ 根据进程的状态决定， 不参考线程的状态 OOM_SCORE_ADJ 值影响因素： 上面所有、有没有activity、有没有service visible理解： 1、前台应用 2、虽非前台、但能看到界面的应用 ----> 自然也是可见的 Perceptible 可感知： 虽然不可见，但是可以感知到： 比如播放音乐、录音 下载属于Perceptible嘛？ -------> TODO: B services 安卓发展，设计的补坑： --------> TODO: 如何知道历史原因呢？ 随着版本演进，发现开发者启动的service越来越多 ------> 针对于时间较长的，做进一步区分 安卓把配置留给了开发者，让开发者给应用分类到上面那个类别里 3.4.4. del: 次要： Activity Manager 指派 OOM_SCORE_ADJ 的特殊规则 规则： 1、若应用分成不同进程运行，则每个进程根据运行的状态，指派对应的 ADJ 2、提升规则： A 应用透过 bind service, provider 方式绑定 B 应用的期间， B 的 ADJ 提升到与 A 相同 3、处罚规则： 非 foreground service 运行过久，ADJ 改为 cached ---------> 简言之：A service过久，改为B service；B service过久，改为 cached 具有 service/provider 的应用运行 activity，ADJ 改为cached 3.4.5. 维测：各个进程的OOM adjustment dumpsys meminfo Total RSS by OOM adjustment: 1,861,186K: Native 164,280K: zygote64 (pid 558) 144,104K: zygote (pid 565) 127,234K: surfaceflinger (pid 637) 113,436K: app_process (pid 19438) 109,624K: camerahalserver (pid 817) 101,520K: media.codec (pid 813) 95,348K: app_process (pid 19459) 88,416K: logd (pid 323) 73,848K: mtkfastavm (pid 301) 40,486K: android.hardware.graphics.composer@2.1-service (pid 598) 37,896K: webview_zygote (pid 1384) 27,388K: em_svr (pid 720) 25,548K: media.extractor (pid 777) 23,008K: pcmanfm (pid 23480) 22,792K: vtservice (pid 771) 22,616K: mediaserver (pid 787) 21,252K: lxpanel (pid 23477) 21,012K: android.hardware.automotive.evs@1.0-service (pid 812) 20,996K: audioserver (pid 630) 19,448K: cameraserver (pid 751) 18,380K: smartplatformserver (pid 800) 15,326K: init (pid 1) 15,296K: wpa_supplicant (pid 25964) 12,948K: media.swcodec (pid 834) 12,688K: openbox (pid 23474) 12,560K: vpud (pid 833) 11,204K: vendor.mediatek.hardware.pq@2.2-service (pid 829) 9,736K: android.hardware.audio.service.mediatek (pid 567) 9,520K: netd (pid 483) 8,956K: lxsession (pid 23461) 8,828K: android.hardware.neuralnetworks@1.3-service-mtk-neuron (pid 742) 8,776K: android.hardware.graphics.allocator@4.0-service-mediatek (pid 591) 8,720K: vendor.mediatek.hardware.mtkpower@1.0-service (pid 615) 8,432K: vendor.mediatek.hardware.gpu@1.0-service (pid 612) 8,392K: vendor.mediatek.hardware.sfs@1.0-service (pid 341) 8,308K: adbd (pid 3336) 8,100K: android.hardware.wifi@1.0-service-lazy (pid 1159) 8,040K: android.hardware.gnss@2.1-service-mediatek (pid 575) 7,864K: Xtightvnc (pid 23446) 7,644K: keystore (pid 776) 7,364K: wificond (pid 810) 7,304K: update_engine (pid 849) 7,212K: ueventd (pid 306) 7,136K: carwatchdogd (pid 319) 7,112K: networkmanager (pid 15624) 7,020K: media.metrics (pid 779) 6,868K: vold (pid 353) 6,712K: gpuservice (pid 634) 6,488K: credstore (pid 633) 6,484K: gatekeeperd (pid 845) 6,460K: init (pid 304) 6,424K: gbe (pid 709) 6,420K: android.hardware.automotive.vehicle@2.0-service (pid 569) 6,328K: drmserver (pid 753) 6,228K: mtkfastcalib (pid 827) 6,144K: android.hardware.drm@1.3-service.clearkey (pid 572) 5,904K: hwservicemanager (pid 334) 5,900K: storaged (pid 805) 5,896K: android.hardware.vibrator-service.mediatek (pid 622) 5,628K: android.hardware.sensors@2.0-service-mediatek (pid 814) 5,548K: android.hardware.lights-service.mediatek (pid 609) 5,428K: getgameserver (pid 822) 5,364K: installd (pid 775) 5,212K: android.hardware.keymaster@4.0-service (pid 408) 5,068K: android.hardware.gatekeeper@1.0-service (pid 574) 4,992K: lbs_hidl_service (pid 608) 4,984K: vendor.mediatek.hardware.nvram@1.1-service (pid 616) 4,956K: vendor.mediatek.hardware.vpu@1.0-service (pid 618) 4,952K: android.hardware.bluetooth@1.0-service-mediatek (pid 570) 4,732K: servicemanager (pid 332) 4,668K: incidentd (pid 755) 4,648K: android.hardware.thermal@2.0-service.mtk (pid 603) 4,640K: android.system.suspend@1.0-service (pid 407) 4,608K: android.hardware.health@2.1-service (pid 599) 4,572K: android.hardware.memtrack@1.0-service (pid 600) 4,544K: statsd (pid 479) 4,464K: android.hardware.drm@1.3-service.widevine (pid 573) 4,456K: netdagent (pid 857) 4,448K: aee_aed64 (pid 399) 4,424K: dumpsys (pid 8743) 4,400K: android.hardware.usb@1.1-service-mediatek (pid 606) 4,344K: android.hardware.boot@1.1-service (pid 359) 4,252K: com.android.car.procfsinspector (pid 1704) 4,220K: android.hardware.automotive.audiocontrol@1.0-service (pid 568) 4,212K: lbs_dbg (pid 743) 4,172K: vndservicemanager (pid 335) 4,120K: mlclient_test (pid 348) 4,108K: batterywarning (pid 1985) 4,096K: aee_aedv64 (pid 451) 4,064K: android.hardware.cas@1.2-service (pid 571) 3,940K: sh (pid 19436) 3,900K: logcat (pid 27704) 3,768K: android.hidl.allocator@1.0-service (pid 566) 3,732K: sh (pid 13765) 3,708K: timesync (pid 828) 3,600K: aee_aed (pid 398) 3,596K: netdiag (pid 792) 3,556K: aee_aedv (pid 450) 3,452K: thermal (pid 824) 3,372K: wlan_assistant (pid 466) 3,348K: traced (pid 732) 3,288K: ip6tables-restore (pid 485) 3,256K: thermald (pid 756) 3,192K: iptables-restore (pid 484) 3,180K: menu-cached (pid 23510) 3,112K: sshd -p 22 [listener] 0 of 10-100 startups (pid 23426) 3,084K: mobile_log_d (pid 791) 3,064K: lmkd (pid 326) 2,988K: traced_probes (pid 723) 2,772K: thermalloadalgod (pid 826) 2,744K: tombstoned (pid 460) 2,684K: fuelgauged (pid 641) 2,636K: sh (pid 336) 2,244K: connsyslogger (pid 752) 2,068K: dbus-daemon (pid 23388) 1,204K: ssh-agent (pid 23487) 667,164K: System 667,164K: system (pid 726) 1,376,891K: Persistent 268,079K: com.android.systemui (pid 1189) 148,336K: com.txznet.txz (pid 2151) 124,156K: com.android.phone (pid 1493) 115,260K: com.android.networkstack.process (pid 1323) 110,260K: com.android.car (pid 1273) 109,284K: com.android.car.systemupdater (pid 2095) 101,992K: com.mediatek.entitlement.o2 (pid 1448) 85,896K: com.mediatek.tbox.dataconnection (pid 3459) 84,892K: com.mediatek.smartratswitch (pid 1352) 84,772K: com.pvetec.ctrlcenter (pid 2179) 74,136K: com.pvetec.carcorder (pid 2082) 69,828K: com.android.se (pid 1417) 310,160K: Persistent Service 110,992K: com.txznet.txz:svr1 (pid 2539) 110,712K: com.android.bluetooth (pid 1168) 88,456K: com.txznet.adapter (pid 2435) 176,876K: Foreground 176,876K: com.android.settings (pid 23721 / activities) // ------> 只有settings在前台 873,773K: Visible 214,865K: com.pvetec.launcher1 (pid 2254 / activities) 170,272K: cn.kuwo.kwmusiccar (pid 31863 / activities) 140,816K: android.ext.services (pid 1942) 102,868K: cn.kuwo.kwmusiccar:remote (pid 31927) 100,156K: com.pvetec.carcorderservice (pid 2384) 75,884K: com.android.settings.intelligence (pid 23756) 68,912K: com.android.experimentalcar (pid 1705) 972,156K: Perceptible 308,052K: com.autonavi.amapauto (pid 3569) 184,876K: com.iflytek.inputmethod (pid 2045) 146,792K: com.iflytek.inputmethod.assist (pid 2356) 121,860K: com.autonavi.amapauto:locationservice (pid 3852) 109,276K: com.autonavi.amapauto:push (pid 4016) 101,300K: com.autonavi.amapauto:socol (pid 7468) 153,692K: Home 153,692K: com.pvetec.launcher (pid 2290 / activities) 242,564K: B Services 98,272K: cn.kuwo.kwmusiccar:pushService (pid 11569) 73,820K: com.pvetec.carcorder:gdremote (pid 2330) 70,472K: com.pvetec.presentation (pid 3143) 1,066,632K: Cached 145,812K: com.sonelli.juicessh (pid 32018) 138,064K: com.mediatek.camera (pid 5029) 134,564K: ru.meefik.linuxdeploy (pid 23046 / activities) 127,660K: com.example.myapplication (pid 23379) 119,132K: android.process.media (pid 2217) 93,724K: com.android.permissioncontroller (pid 29140) 83,244K: com.android.providers.calendar (pid 3496) 77,820K: com.google.android.car.defaultstoragemonitoringcompanionapp (pid 11251) 76,160K: com.android.webview:webview_service (pid 17588) 70,452K: com.android.dialer (pid 32036) 3.4.6. Q: 系统何时因为内存压力高而卡顿 卡顿来源： 1、砍Cached时： 导致 kswapd 忙碌运行，回收系统缓存。但系统一运行又建立缓存 ------> TODO: 经验：Cached 应用将被清完时，系统即出现明显的性能下降 2、砍B Services时：重度卡顿场景：砍到 ADJ kswapd 忙碌运行，回收系统缓存。但系统一运行又建立缓存 -------> 同上 LMK 忙碌搜索哪些进程能砍 被砍的进程又立即重启 -----> service 被砍，立马又重启，会抢占cpu。陷入循环？ OOM_SCORE_ADJ 分类意义 -1000 Native -700 ~ -800 Persistent 0 Foreground 100 Visible 200 Perceptible 500 A Service 600 Home 700 Previous 800 B Services >900 Cached 卡的直观程度： 砍到 B Services ----> 比较卡 砍到 Perceptible ----> 非常卡，黑屏（系统不停地在砍sevice，启动service，加载内存-----> 过于消耗CPU，做UI相关的CPU占用就少了） 3.4.7. 解决/避免系统走入低内存的卡顿办法 方法： del: 是否有单一前台应用占用过大，导致使用过程内存不足 自然 降低常驻应用的内存占用 问题：ADJ 0~800 的应用，是否低内存时砍不到？ 若内存持续低，会砍到。但砍到前，系统已经卡顿了 砍了会重启（del：不是立即，差个几秒），重启过程视同前台应用抢占CPU资源，导致更卡 3.5. 各种应用的Mem与CPU占用详解 3.5.1. Persistent 应用 应用侧配置： 这里 android:theme=\"@style/AppTheme\" android:supportsRtl=\"false\" android:configChanges=\"uiMode\" android:name=\"...\"> 特性： 开机后自启动 Crash 后会自动重启 可能导致的问题： 1、Mem角度： 永远占用内存：（1）不管功能是否有在使用 （2）即使有内存泄露，系统也没有机会回收 ------> 这个问题比较大 del: 只要含有 activity，内存超过 100 MB 很常见（注：一个空activity就有几十MB） ---> 正常应用都有的问题 Persistent 进程占用内存越多， 系统可用余量越小 2、CPU角度： CPU Schedule: 只要运行，与前台应用同样优先级抢占 CPU （Persistent 的意外代价） -------> 特别注意：原先可能，设置为Persistent防止被砍（内存），但是却提高了cpu的优先级 开机慢：del：过多 persistent 应用，开机时系统会忙于启动这些应用 TODO: Persistent 与前台应用同样CPU优先级，这个是否合理？ 3.5.2. Perceptible/A Service/B Service 应用 Start service 后，成为 A service。执行时间长，或 A service 过多，成为 B service。A service, B service 可占用的 CPU 资源较前台小，必要时可适度让给其他应用，适合用户不感知的任务 public int onStartCommand(Intent intent, int flags,int startId); 返回 START_STICKY：当进程未 stop 前被砍，系统会重启进程与服务，并重走onStartCommand()，此时 intent 为 null。因此可根据 intent 是否为 null，判断是否重启 返回 START_NOT_STICKY：当进程未 stop 前被砍，系统不会重启进程。 适合不紧急、可直接结束的后台任务。 返回 START_REDELIVER_INTENT：当进程未 stop 前被砍，系统会重启进程与服务，并重走onStartCommand()，且带入上次的 intent ----------> TODO: 不懂 Service 执行 startForeground() 后，成为 foreground service，ADJ 成为 perceptible。设计的本意，是执行用户可感知的任务，且需要跟前台给予相同 CPU 资源，例如播放音乐。但此设计存在被误用的漏洞，被各种应用误用。 如何限制A service, B service 占用CPU？ （1）把 A service, B service 限制到小核上 ------> 前台应用可以在大核上，比较快 （2）cgroup。例如：前台分配85% CPU资源，后台分配15% CPU资源 比如：用户不感知的任务-----微信收消息，差1~2s无所谓 可能导致的问题（和Persistent 很像）： 只要不是设计成 START_NOT_STICKY，永远占用内存，不管功能是否有在使用 即使有内存泄露，系统在杀进程回收前，已经进入卡顿状态 -------> 唯一与Persistent 区别的点：内存写泄漏可能被回收 只要含有 activity，内存超过 100 MB 稀松平常 Perceptible：只要运行，与前台应用同样优先级抢占 CPU 占用进程越多， 系统可用余量越小 3.5.3. Visible 应用 种类： 1、虽是后台应用，但有用户可见的 activity 2、被 Persistent 进程以 bindService()、或 provider 绑定的进程（注：自然，提升原则：被 Persistent 进程）。对系统可用内存影响大的是这种。可能导致的问题： 永远占用内存，不管功能是否有在使用 即使有内存泄露，系统在杀进程回收前，已经进入卡顿状态 只要含有 activity，内存超过 100 MB 稀松平常 Perceptible：只要运行，与前台应用同样优先级抢占 CPU（同样） 占用进程越多， 系统可用余量越小 被调用者，很难察觉。 绑定关系（service、provider）如何查看： ------------> 维测：： dumpsys activity services 关键词：对应的包名 或 Connections，比如Sogou输入法 * ServiceRecord{51166c9 u0 com.sohu.inputmethod.sogou/.SogouIME} app=ProcessRecord{4a96f05 23794:com.sohu.inputmethod.sogou/u0a203} created=-1d22h3m15s150ms started=false connections=1 Connections: act=android.view.InputMethod -> 1554:system/1000 ---------------> 只有一个绑定 https://blog.csdn.net/u011386173/article/details/83414589 3.5.4. Receiver 与 Service 的 ADJ 总之： 根据 组件的运行阶段，来动态调整ADJ 1、Broadcast Receiver 应用调用 onReceive() 的过程，进程的 ADJ 为 0 离开 onReceive() 后，根据应用的其他状态来决定 ADJ 2、Started Service 执行 onCreate()、onStartCommand() 的过程，进程的 ADJ 为 0，stopService() 或stopSelf() 后，根据应用的其他状态来决定 ADJ。 在 stop 之前，ADJ 可能经历几种变化： A Service：Service 刚运行时 B Service：若系统同时运行的 Service 过多，较早启动的会放到 B Service Cached：运行超过 30 分钟、或曾经启动过 activity 3.5.5. del:Receiver 常见的误区 // AndroidManifest.xml // MyReceiver.java public class MyReceiver extends BroadcastReceiver { public void onReceive(Context context, Intent intent) { new Thread() { public void run() { // 做超过 10 秒的事， 避免主线程上运行时间久， 导致 ANR } }.start(); } } 当应用离开 onReceive(), ADJ 就不再为 0， 系统根据应用其他的状态决定 ADJ， 最差情况可能变为cached。 因此当系统进行大量广播、 或者内存较紧时， 进程可能很快被杀掉。--------> 所以，是个概率性问题。 解决方法： 跑一个service提升： 在 Receiver() 中， 需要长时间运行的， 启动 IntentService 来运行 3.5.6. Bind Service 若调用端与被调用端分属不同进程，则 bind service 可能会影响被调用端的，： OOM Score ADJ：被调用端的 ADJ 调整到与调用端同样重要 CPU scheduling：当调用端为 foreground scheduling 时 （例如前台应用，persistent,visible, perceptible)，被调用端也会被提升至 foreground scheduling -----------> cpu与Mem的双提升 若调用端与被调用端同属一个进程，则 bind service 不影响 OOM Score ADJ 与 CPUscheduling, 自然 Bind service 可带以下参数控制行为： 参数 Service 所在进程的 OOM Score ADJ Service 进程的 CPU 分配 使用场合 默认行为 与调用端一致。若调用端是 top，则 service 为 visible 与调用端一致（del：注：非常自然，不能拖累） BIND_NOT_FOREGROUND 与调用端进程一致。若调用端是top，则 service 为 visible 不根据此次 binding 影响 service进程的 scheduling（注：改了cpu） 当调用端为 system_server、persistent 进程，且不要求执行速度时 BIND_ALLOW_OOM_MANAGEMENT 不强制与调用端进程一致。service进程可能在内存不够时会被砍 与调用端进程一致 当调用端为 system_server、persistent 进程，预期可能 service执行时间常、内存大，且已经做好service 进程被砍的容错处理 BIND_WAIVE_PRIORITY 不根据此次 binding 影响 service进程的 ADJ 不根据此次 binding 影响 service进程的 scheduling 对执行速度不要求，且已经做好service 进程被砍的容错处理 BIND_ADJUST_WITH_ACTIVITY 当调用端显示可见的 activity 时， ADJ 与调用端一致 当调用端显示可见的 activity 时， service 进程为 foreground scheduling 当调用端在后台时，不要求 service进程的执行速度，且已经做好service 进程被砍的容错处理 3.6. “常驻应用”总结 3.6.1. “常驻”应用定义 ： 狭义 在 AndroidManifest.xml 设置 persistent = true 的应用 广义 应用透过某种方式，直接、间接长时间驻留在后台，即使砍了也会重启的都算。广义包含： 不停止的 started service 常驻应用在后台透过 bindService 绑住另一个进程不放，使其跟着常驻 常驻应用在后台透过 provider 绑住另一个进程不放，使其跟着常驻 应用透过 alarm manager 或其他保活手段，即使被砍了会重启 native daemon ‒ 描述、讨论是否常驻问题时，采用广义定义 3.6.2. 常驻应用对系统的影响 内存占用：常驻应用持续占用内存，减少系统整体可用内存。 一般常见的设计/实现问题有： 本质上不需要常驻的部分，也跟着常驻了，例如 activity --------> 办法：分空间： 常驻和非常驻，放到两个进程里 功能不需要持续在后台运行，只有在特别时段、条件满足时，才需要在后台驻留，但也设计成永远常驻了 ----> 设计上分时 以独立模块思考应用实现，未考虑与其他业务常驻监听的共用、或者寻求系统框架的修改支持 未考虑如何常驻时，尽量最小化内存 -----> 办法： 无法避免，尽量减小影响 本身已是常驻应用，又长时间透过 bind service、provider 绑住其他应用，导致其他应用也常驻了 CPU 占用： Persistent, Foreground, Visible, Perceptible，对系统而言，以前台应用对待。 当常驻应用在后台运行时，就会跟前台应用争夺 CPU 资源，造成前台卡顿（如果多的话） 3.6.3. 审视常驻、后台运行的必要性 1、最小权限原则： 能 service 搞定、就不要设 foreground service； 能 foreground service 搞定，就不要设 persistent。能只在某段时间常驻，就不要设计成永远常驻 2、非用户可感知、或不需及时响应的后台任务， 皆不要设置为 foreground service 需要用户可感知、需要抢占较多 CPU 的任务：音乐播放、后台导航 不需要用户感知的任务：后台下载、后台复制、长链接监听、系统状态监听 3、为了 activity 启动速度而常驻，是不被允许的理由。应用必须优化冷启动流程 3.6.4. 万不得已，必须常驻时： 1、最小化常驻内存量： 除了 Launcher、SystemUI、输入法，合理的后台内存常驻占用：30 MB -----> TODO: 除了是啥意思？ TODO: dump验证一下 2、常驻应用禁止长时间以 bind service, provider 绑定其他进程，必须尽快使用完且立即释放 3、播放类的应用，不应设为 persistent。且应采用以下两种方法之一进行内存优化： 分离 service 与 activity 到不同进程。 Service 运行播放或下载等需要长时间运行的任务，activity 进程在后台时成为 cached，可以被系统按需回收 -------------------> 安卓希望开发者做到的设计 当播放任务停止、或尚未开始时， 应用进程内所有的 service 必须停止，让应用在后台时成为cached 4、下载类的应用，原则上不需常驻，应用退到后台时，运行 service 进行下载即可，下载完就停止service。 若包含了需要常驻的功能，则应分离 service 与 activity 到不同进程。 5、 具备接收 Push 消息的应用，不应设为 persistent，且需要分离 service 与 activity 到不同进程 3.6.5. del: 临时展开：具体Service 与 Activity 如何分离？ 在 AndroidManifest.xml 中，以 android:process 属性（多进程）指定 service 运行在另一个进程。UI 与service 之间，借由 AIDL 通信 Provider 如果是 service 常存取的， 就运行在与 service 同一个进程 如果 Reciever 需要监听某些高频广播、或是只有 service 在才能运行的动态广播， 就跟 service运行在同一个进程 一个应用不要产生超过 2 个进程 --------> 微信有四五个进程 例子： 3.7. 维测 之 常驻、非常驻 内存 dumpsys meminfo 然后根据 Total PSS by OOM adjustment 里的 类型: 非常驻 = Cached + Previous 其他---------> 常驻进程 例子： Total PSS by OOM adjustment: 1,018,230K: Native 324,198K: android.hardware.graphics.allocator@2.0-service (pid 718) 69,909K: CameraDaemon (pid 1055) 49,889K: sh (pid 21517) 40,188K: surfaceflinger (pid 754) 39,004K: android.hardware.graphics.composer@2.2-service (pid 719) 37,921K: installd (pid 1036) 34,765K: media.codec (pid 1059) 25,700K: zygote64 (pid 1018) 21,919K: app_process (pid 21785) 20,587K: hiaiserver (pid 1070) 17,640K: webview_zygote (pid 2677) 17,329K: hiview (pid 1073) 16,171K: zygote (pid 21951) 12,606K: audioserver (pid 750) 12,299K: cameraserver (pid 1029) 11,687K: zygote (pid 670) 11,528K: dubaid (pid 1032) 11,220K: media.extractor (pid 1039) 8,079K: media.swcodec (pid 1065) 8,012K: hignss_1103 (pid 1888) 7,165K: zygote64 (pid 669) 6,941K: mediaserver (pid 1046) 6,841K: vendor.huawei.hardware.audio@5.0-service (pid 728) 6,295K: netd (pid 668) 5,998K: rild (pid 1062) 5,980K: distributedsche (pid 842) 5,762K: init (pid 1) 4,856K: distributedfileservice (pid 23475) 4,111K: logd (pid 496) 3,773K: AGPService (pid 1027) 3,747K: samgr (pid 662) 3,700K: aptouch_daemon (pid 882) 3,347K: vendor.huawei.hardware.biometrics.hwfacerecognize@1.1-service (pid 1024) 3,151K: storaged (pid 1052) 3,125K: vold (pid 515) 3,019K: displayengineserver (pid 1030) 2,645K: hsensors (pid 832) 2,532K: wpa_supplicant_hisi (pid 11930) 2,451K: vendor.huawei.hardware.hwdisplay.displayengine@1.2-service (pid 732) 2,429K: vendor.huawei.hardware.perfgenius@2.0-service (pid 745) 2,412K: adbd (pid 4647) 2,408K: locationhub (pid 845) 2,394K: init (pid 477) 2,291K: hilogd (pid 3254) 2,264K: ueventd (pid 478) 2,225K: media.metrics (pid 1045) 2,155K: keystore (pid 1037) 2,152K: audio_sa (pid 840) 2,071K: statsd (pid 1051) 2,047K: wifiservice (pid 853) 1,991K: fusion_daemon (pid 1081) 1,988K: accountmgr (pid 839) 1,974K: vendor.huawei.hardware.gnss@2.0-service (pid 729) 1,916K: hwservicemanager (pid 498) 1,913K: tee_auth_daemon (pid 584) 1,912K: chargelogcat-c (pid 24695) 1,872K: bluetoothservic (pid 841) 1,839K: nfcservice (pid 846) 1,813K: vendor.huawei.hardware.wifi@1.2-service (pid 1084) 1,725K: android.hardware.drm@1.2-service.widevine (pid 22555) 1,720K: activity_recognition_service (pid 714) 1,683K: distributedfiledaemon (pid 4590) 1,652K: hwpged (pid 1061) 1,638K: netmanager (pid 837) 1,599K: vendor.huawei.hardware.libteec@3.0-service (pid 586) 1,598K: telephony (pid 849) 1,586K: vendor.huawei.hardware.hivrar@2.1-service (pid 731) 1,564K: emcomd (pid 1021) 1,560K: powerlogd (pid 755) 1,556K: vendor.huawei.hardware.sensors@1.2-service (pid 1064) 1,540K: vendor.huawei.hardware.hwsecurity-service (pid 737) 1,530K: vendor.huawei.hardware.biometrics.fingerprint@2.2-service (pid 1083) 1,527K: bms_auth (pid 24696) 1,519K: resschedd (pid 848) 1,488K: vendor.huawei.hardware.iawareperf@1.0-service (pid 739) 1,478K: vendor.huawei.hardware.tp@1.0-service (pid 748) 1,454K: thermal-daemon (pid 1053) 1,443K: hisecd (pid 973) 1,437K: mediadrmserver (pid 1038) 1,436K: android.hardware.keymaster@3.0-service (pid 583) 1,408K: bastetd (pid 1023) 1,401K: gpuservice (pid 752) 1,396K: apexd (pid 630) 1,353K: vendor.huawei.hardware.hwhiview@1.1-service (pid 735) 1,333K: android.hardware.secure_element@1.0-service (pid 725) 1,324K: displayservice (pid 751) 1,301K: hivrarserver (pid 961) 1,290K: wificond (pid 2341) 1,221K: vendor.huawei.hardware.nfc@1.0-service (pid 744) 1,210K: android.system.suspend@1.0-service (pid 711) 1,189K: android.hardware.configstore@1.1-service (pid 716) 1,188K: vendor.huawei.hardware.hwfactoryinterface@1.1-service (pid 734) 1,149K: incidentd (pid 1035) 1,141K: lmkd (pid 753) 1,141K: drmserver (pid 1031) 1,139K: vendor.huawei.hardware.power@1.0-service (pid 746) 1,138K: modemchr (pid 5824) 1,128K: teecd (pid 585) 1,127K: bsoh (pid 972) 1,112K: iGraphicsservice (pid 1033) 1,104K: mdnsd (pid 11530) 1,094K: gatekeeperd (pid 1071) 1,075K: abb (pid 7587) 1,072K: bms_heating (pid 24688) 1,069K: vendor.huawei.hardware.hwvibrator@1.1-service (pid 738) 1,069K: vendor.huawei.hardware.motion@1.0-service (pid 742) 1,069K: hinetmanager (pid 1077) 1,065K: ip6tables-restore (pid 23307) 1,060K: vendor.huawei.hardware.hwdisplay@1.1-service (pid 733) 1,059K: bms_protocol (pid 24698) 1,058K: iptables-restore (pid 23306) 1,036K: vendor.huawei.hardware.vdecoder@1.0-service (pid 2615) 1,016K: vendor.huawei.hardware.fm@1.0-service (pid 1025) 1,000K: bms_soc (pid 24693) 981K: oam_hisi (pid 1882) 976K: powerct (pid 590) 976K: dumpsys (pid 25381) 971K: bms_behavior (pid 23421) 968K: android.hardware.usb@1.0-service (pid 2371) 956K: android.hardware.gatekeeper@1.0-service (pid 717) 937K: vendor.huawei.hardware.jpegdec@1.0-service (pid 740) 926K: pmom_cat (pid 976) 922K: android.hardware.health@2.0-service (pid 720) 908K: vendor.huawei.hardware.hwsched@1.0-service (pid 736) 901K: android.hardware.ir@1.0-service (pid 713) 901K: android.hardware.cas@1.1-service (pid 715) 893K: servicemanager (pid 497) 874K: sh (pid 25347) 865K: vendor.huawei.hardware.hwfs@1.0-service (pid 30864) 863K: vendor.huawei.hardware.light@2.0-service (pid 741) 857K: android.hardware.memtrack@1.0-service (pid 721) 856K: vendor.huawei.hardware.graphics.hwcinterface@1.1-service (pid 727) 848K: vendor.huawei.hardware.graphics.mediacomm@2.1-service (pid 730) 842K: android.hidl.allocator@1.0-service (pid 710) 832K: android.hardware.thermal@2.0-service-hisi (pid 726) 820K: android.hardware.power.stats@1.0-service.mock (pid 723) 788K: android.hardware.atrace@1.0-service (pid 582) 784K: oeminfo_nvm_server (pid 516) 773K: healthd (pid 712) 772K: vndservicemanager (pid 499) 743K: ashmemd (pid 749) 673K: usb_port (pid 24679) 603K: bms_event (pid 588) 596K: tombstoned (pid 1074) 567K: octty (pid 1881) 548K: sh (pid 21518) 543K: unrmd (pid 1068) 543K: sh (pid 21295) 439,507K: System 439,507K: system (pid 1554) 628,842K: Persistent 285,401K: com.android.systemui (pid 2532) 46,017K: com.huawei.nearby (pid 2870) 39,448K: com.huawei.harmonyos.foundation (pid 2793) 39,184K: com.android.phone (pid 2948) 38,901K: com.huawei.systemserver (pid 2885) 35,260K: com.huawei.iaware (pid 2930) 30,543K: com.huawei.HwOPServer (pid 2814) 28,550K: com.huawei.hiview (pid 2842) 21,056K: com.android.nfc (pid 7775) 20,788K: com.huawei.securityserver (pid 2905) 19,094K: com.huawei.hiaction (pid 7833) 14,312K: com.huawei.android.pushagent.PushService (pid 4502) 10,288K: com.huawei.android.extdisplay (pid 2625) 1,263,189K: Foreground 1,173,964K: com.ss.android.ugc.aweme (pid 20395 / activities) 48,692K: com.ss.android.ugc.aweme:sandboxed_process1 (pid 22879) 40,533K: com.huawei.systemmanager:service (pid 2715) 516,435K: Visible 235,438K: com.huawei.android.launcher (pid 15880 / activities) 103,570K: com.huawei.hwid.core (pid 28866) 38,852K: com.huawei.lbs (pid 6826) 38,327K: com.huawei.hiai.engineservice (pid 8308) 34,877K: com.huawei.android.totemweather (pid 32766) 25,166K: com.huawei.recsys (pid 3970) 16,943K: com.huawei.ohos.photos (pid 15301) 11,968K: com.huawei.vassistant:interactor (pid 7751) 11,294K: com.android.se (pid 16286) 165,223K: Perceptible 141,366K: com.sohu.inputmethod.sogou (pid 27072) 23,857K: com.huawei.hwid.persistent (pid 16738) 46,218K: A Services 46,218K: com.android.settings (pid 24673) 330,651K: Previous // 非常驻【1】 330,651K: com.tencent.mm (pid 8370 / activities) 481,183K: B Services 263,578K: com.tencent.wework (pid 17292) 71,241K: com.tencent.mm:push (pid 8218) 46,303K: com.tencent.wework:wemeet (pid 17335) 45,173K: com.tencent.wework:push (pid 17433) 33,167K: com.huawei.health:DaemonService (pid 13511) 21,721K: android.process.media (pid 24718) 3,370,049K: Cached // 非常驻【2】 753,926K: com.xingin.xhs (pid 21134 / activities) 724,920K: me.ele (pid 32299 / activities) 362,519K: com.zhihu.android (pid 11390 / activities) 292,510K: com.tencent.wework:sandboxed_process0:com.tencent.smtt.services.ChildProcessService$Sandboxed0 (pid 17563) 225,933K: com.xingin.xhs:pushservice (pid 22605) 219,601K: com.xingin.xhs:longlink (pid 21417) 130,959K: com.zhihu.android:channel (pid 12627) 99,871K: com.huawei.intelligent (pid 3249) 77,907K: com.huawei.appmarket (pid 24743) 59,598K: com.huawei.intelligent:web (pid 19665) 55,858K: me.ele:channel (pid 2161) 53,735K: com.huawei.hiai (pid 14227) 48,953K: me.ele:sandboxed_privilege_process0 (pid 1779) 45,003K: com.huawei.meetime (pid 21489) 37,625K: me.ele:gpu_process (pid 1758) 32,592K: com.huawei.webview:sandboxed_process0:org.chromium.content.app.SandboxedProcessService0:1 (pid 12254) 31,715K: com.huawei.intelligent:player (pid 20586) 27,030K: com.huawei.hwid.container2 (pid 23061) 25,007K: com.huawei.hwid.container1 (pid 16974) 21,308K: com.huawei.webview:sandboxed_process0:org.chromium.content.app.SandboxedProcessService0:0 (pid 1585) 16,594K: com.huawei.localBackup (pid 23755) 16,574K: com.huawei.hwid (pid 19228) 10,311K: com.huawei.webview:sandboxed_process0:org.chromium.content.app.SandboxedProcessService0:0 (pid 22022) Total PSS by category: 1,056,414K: Native 833,516K: Dalvik 403,112K: EGL mtrack 354,496K: GL mtrack 342,395K: .dex mmap 246,891K: .art mmap 246,546K: .so mmap 220,783K: Dalvik Other 170,168K: Unknown 86,497K: .apk mmap 66,319K: Other mmap 49,954K: .jar mmap 36,597K: .oat mmap 3,620K: Stack 2,807K: Other dev 576K: Ashmem 393K: .ttf mmap 4K: Cursor 0K: Gfx dev 0K: Other mtrack Total RAM: 7,696,216K (status normal) Free RAM: 3,848,001K (3,370,049K cached pss + 384,152K cached kernel + 93,800K free) Used RAM: 5,636,502K (4,889,478K used pss + 747,024K kernel) Lost RAM: 740,732K ZRAM: 1,609,420K physical used for 4,193,272K in swap (4,194,300K total swap) Tuning: 384 (large 512), oom 322,560K, restore limit 107,520K (high-end-gfx) 4. 内存管理机制 4.1. （安卓）前台应用内存回收-----------Activity回收 https://zhuanlan.zhihu.com/p/604570570?utm_id=0 【解惑】App处于前台，Activity就不会被回收了？ 系统内存不足时： 直接在内核层查杀(回收)进程，并不会考虑回收哪个Activity； 进程内存不足时： 如果此进程 Activity Task数 >= 3 且 使用内存超过3/4，会对 不可见 Task进行回收，每次回收 1个 Task，回收时机为每次gc； 具体算法： 应用内存监控机制： https://zhuanlan.zhihu.com/p/604570570?utm_id=0 TODO: 一个纯的java应用，有Native Heap嘛？ 背后的背后： 释放资源 4.2. Linux如何限制单个应用内存泄露的影响 ----gpt的回答 在Linux系统中，你可以使用一些工具和方法来限制单个应用程序内存泄露的影响。这包括： 使用cgroups： cgroups（控制组）是 Linux 内核的一个功能，允许你将一组进程限制在特定的资源使用上。你可以使用 cgroups 控制应用程序的内存使用情况。具体而言，你可能会对应用程序的进程组设置内存限制。 ulimit 命令： ulimit 命令用于设置用户级别的资源限制。你可以使用 ulimit 命令来限制一个用户或一个特定的 shell 会话中进程的资源使用，包括内存。请注意，这只会对当前 shell 会话中运行的进程有效，并且可能需要在应用程序启动前设置。 ulimit -v 1000000 # 设置虚拟内存的限制（单位：KB） 使用系统监控工具： 使用工具如 top、htop 或 atop 来监视系统资源使用情况。通过监视应用程序的内存占用，你可以及时检测到潜在的内存泄漏并采取适当的措施。 内存保护工具： 一些工具和库可以帮助检测和防止内存泄漏，如 Valgrind、AddressSanitizer 等。这些工具可以在开发和测试阶段使用，帮助发现潜在的内存泄漏问题。 使用 systemd 的资源限制： Systemd 提供了一些资源限制的功能，你可以在服务单元文件中配置这些限制，包括内存限制。例如，在服务单元文件的 [Service] 部分中添加： [Service] MemoryMax=100M 请注意，这些方法并非绝对防止内存泄露，但可以帮助你限制泄漏对系统的影响。最佳实践是在应用程序开发和测试阶段识别和修复内存泄漏问题。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/0_性能/性能_.html":{"url":"coding/0_性能/性能_.html","title":"性能_","keywords":"","body":"1. 目录2. 性能专题2.1. 疑问2.2. 性能问题之咸鱼上位（优先级反转问题）2.3. 时间优化一：不养闲人、提前做事（思想）2.4. 时间优化二： 多养鱼（思想）2.4.1. 进程冷冻 引起的问题2.4.2. 参考：2.5. 做个懒人（资源紧缺时，时间紧张时）2.6. 线程阻塞优化（sleep时间段）：2.6.1. 例：优化APP冷启动------Creating EGLContext提前2.6.2. Creating EGLContext提前------代码2.6.3. 线程阻塞优化思想的总结：2.6.4. 代码修改2.6.5. 例：twoway 改为 oneway2.7. 优化大的思想2.8. 其他思想：3. CPU与内存的一些认识：3.1. -生活化模型：3.1.1. 关于功耗本质3.2. 高内存，不会耗电3.3. 高内存，不是卡顿的根因3.4. 最大限度地提高内存的使用率是好事4. TODO: 一些基本问题5. 实践之 UI框架性能5.1. 目标：5.2. 策略5.2.1. 具体5.3. TODO: 飞常准APP侧的UI优化5.4. TODO: ArkWeb 的优化5.5. TODO: 并行化技术6. 主要流程大致时间6.1. APP冷启动时间拆解（大致） TODO：6.2. 手机启动时间拆解 TODO：6.3. 一帧内 主线程cpu时间 + Render时间6.4. 屏幕旋转时间7. 性能优化之 缓存策略8. 性能理念：9. 关键词大收集10. 抛开性能优化11. 优化工具集合12. 【性能优化】Simpleperf的认识和使用13. 性能14. 语言级性能14.1. 使用SparseArray替代HashMap 性能专题 疑问 性能问题之咸鱼上位（优先级反转问题） 时间优化一：不养闲人、提前做事（思想） 时间优化二： 多养鱼（思想） 进程冷冻 引起的问题 参考： 做个懒人（资源紧缺时，时间紧张时） 线程阻塞优化（sleep时间段）： 例：优化APP冷启动------Creating EGLContext提前 Creating EGLContext提前------代码 线程阻塞优化思想的总结： 代码修改 例：twoway 改为 oneway 优化大的思想 其他思想： CPU与内存的一些认识： -生活化模型： 关于功耗本质 高内存，不会耗电 高内存，不是卡顿的根因 最大限度地提高内存的使用率是好事 TODO: 一些基本问题 实践之 UI框架性能 目标： 策略 具体 TODO: 飞常准APP侧的UI优化 TODO: ArkWeb 的优化 TODO: 并行化技术 主要流程大致时间 APP冷启动时间拆解（大致） TODO： 手机启动时间拆解 TODO： 一帧内 主线程cpu时间 + Render时间 屏幕旋转时间 性能优化之 缓存策略 性能理念： 关键词大收集 抛开性能优化 优化工具集合 【性能优化】Simpleperf的认识和使用 性能 语言级性能 使用SparseArray替代HashMap 1. 目录 2. 性能专题 2.1. 疑问 TODO: 如何被认定为性能问题？标准是啥？谁来定？ wew wewe weewe ewewe eweweewewwewe -大的思想： 一切优化，都是资源配置的更加合理化 -------> 所以，从资源的角度，寻找可以优化的点 2.2. 性能问题之咸鱼上位（优先级反转问题） 例子： A线程的优先级高，B线程优先级低，但是B线程先拿到了锁。此时，其他线程（进程？）（自然比B线程优先级高）会占用cpu时间多。 --------------> 即：B cpu执行分配时间少，执行时间长。导致A高优先级，迟迟拿不到锁，一直等待 总之，场景： -优先级低的，反而先执行 或者 分配时间多 （原因：因为1、先持有锁、 2、） -------->即，咸鱼上位 办法： 在虚拟机里，把当前持锁的进程优先级提高，占用cpu就高，很快运行完。。。然后外面高优先级的，拿到锁 为啥是虚拟机做？因为锁 + 控制优先级 都在虚拟机里 再举例子： Binder的优先级反转 TODO 2.3. 时间优化一：不养闲人、提前做事（思想） 不养闲人：即让空闲的人（进程）提前做事 如何快速启动？针对于高频应用，在bindapplication时，甚至开始startActivity时，就把surface创建起来 背后的方法论： 让空闲的人提前做事。上述优化，即：妻子炒菜，丈夫去买菜------> 优化，妻子提前把炒菜的承载 锅 刷好 关键词：1、空闲 2、提前 观测工具： trace？ TODO： 空进程，在bindApplication之后，在oncreate之前，停止，为什么在这个阶段停止呢？为什么不早一点儿，为什么不晚一点儿？ 2.4. 时间优化二： 多养鱼（思想） 线程池、对象池 --------> 虽然没用到，但是早早地养起来 好处：内存不会突然增长；复用思想；快速，拿来就用 其他例子： 更高频应用，没有startactivity，也创建一个surface，然后进程冷冻 -------> 等真正要用的时候，解冻 养鱼 和 提前做 思想的区别在于： 提前做只是提前，一定会用得到； 养鱼，很可能用不到 2.4.1. 进程冷冻 引起的问题 ------> TODO: 挪到其他章节 冷冻容易，解冻需要考虑的多。比如，冷冻过程，有tranction过来怎么办？Binder的同步调用怎么办？ 2.4.2. 参考： https://zhuanlan.zhihu.com/p/348548041 2.5. 做个懒人（资源紧缺时，时间紧张时） 做个懒人： 每一步的必要性 给出证明 能不做就不做 比如fragment加载页面，都需要加载吗？----------------> 按需加载 来源 2.6. 线程阻塞优化（sleep时间段）： 线程sleep时间段 很多时候，是在等待其他线程完成某件事情 ------------> 如果这件事 能够提前完成，就不够成阻塞 2.6.1. 例：优化APP冷启动------Creating EGLContext提前 从trace出发： 冷启动时间 = 主线程时间 + render线程 DrawFrames 时间 可能优化的sleep的三个时间段： 1、ActivityTreadMain在等待50ms，在等待： （1）被system_server唤醒，等待attachApplication:com.example.myapplication -------> 可以理解 （2）但是 system_server也有一段空白sleep。。。这段是在干啥呢？ monitor contention with owner android.anim (17) at void com.android.server.wm.WindowSurfacePlacer$Traverser.run()(WindowSurfacePlacer.java:56) -Lock contention on a monitor lock (owner tid: 604) ------> 在等604线程的锁 （3）604是动画线程，现在正在performSurfacePlacement ------> （4）总之：system_server 604 做动画performSurfacePlacement 阻塞了 system_server 1356 binder线程， 主线程又在等待 1356 去 attachAPPlication TODO： 第一个阻塞，是不是可以优化？为什么要等结果？ 2、（1）draw流程中有个同步调用sys_futex， sleep 60ms，在等待： （2）谁阻塞的？ cpu3上的Render线程的setSurface setSurface是不是一定要在这里呢？可不可以提前呢（优化的方法） 具体做法： 把Creating EGLContext 提前到 bindAPPlication （TODO： 其实setSurface本身就可以完全提前）: 注意：Creating EGLContext不能有返回值， 尤其在 bindAPPlication 时（否则，还是会阻塞主线程，没有任何收益） 代码：TODO： 优化结果：30ms 3、sleep时间段三： 主线程draw之后一段空白，这段空白，因为 绘图指令集数据给到了 render线程DrawFrame。render线程在绘制 --------> （1) DrawFrame无法提前，因为必须从主线程拿数据到render线程，无法压缩 2.6.2. Creating EGLContext提前------代码 见《Creating EGLContext提前------代码》 2.6.3. 线程阻塞优化思想的总结： 找空白sleep时间段------> 看哪个线程阻塞了？阻塞的事情是不是可以提前做？ -提前做的事情，不能有返回值（否则还是阻塞） TODO： 如果有返回值的，如何不阻塞呢？用callback？ 2.6.4. 代码修改 aosp12_28 code: /frameworks/base : commit 5a72b92f67db1cd5db14af7342b374d6c261d 2.6.5. 例：twoway 改为 oneway TODO： 具体例子 2.7. 优化大的思想 线程级优化：结构性优化（非代码级别）、sleep阻塞优化 代码级别优化：UI、native侧统一序列化 2.8. 其他思想： 按需加载 ------> 做个吝啬的人 闲时加载 ------> 即 不养闲人 3. CPU与内存的一些认识： 参考：https://www.cnblogs.com/andy-songwei/p/9845771.html 【朝花夕拾】Android性能篇之（六）Android进程管理机制 3.1. -生活化模型： 道路就像内存，车的引擎就像cpu，货物即CPU负载，交警调节交通释放道路( 移除一些等级比较低的进程来回收内存)： 1、道路 不会耗油，耗油的是车 ---------> 高内存，不会耗电; 耗电的是CPU 2、道路拥挤（剩余少），交警调节交通需要时间，车子自然跑不快 -----------> 内存少的时候，回收内存需要时间，运行大型程序会卡顿 (高内存，不是卡顿的根因) 3、道路畅通，车子拉货太重, 车子也跑不快 ----------> 应用开得太多了，手机变慢 ​ 占用cpu的进程太多，那无疑cpu总有忙不过来的时候，那肯定就会变慢了 3.1.1. 关于功耗本质 -只有变化才可能做功（才发热、消耗能量）。不变化，没有功： 推论： （1）CPU ：CPU运算，有变化，有做工 （2）内存：读写内存有变化，有做工 ​ 但是高内存，一直不读写，没有做工，不消耗能量 （3）同样适用于物理世界：道路不会发热。但是车子摩擦道路会热 （4）从这一点，推论：越发热，算力越强（同一代技术前提下） 证明： https://zhuanlan.zhihu.com/p/47860703 3.2. 高内存，不会耗电 参考：https://www.cnblogs.com/andy-songwei/p/9845771.html -cpu运行才耗电（包括CPU读写内存） -----> 推论： 1、后台进程或者按back键退出变成空进程后，其实已经被暂停了，只保留了运行状态，不会消耗cpu，一个程序会耗电，是因为它需要调用cpu来运算，现在不消耗cpu了，当然就不会耗电了。 3.3. 高内存，不是卡顿的根因 参考：https://www.cnblogs.com/andy-songwei/p/9845771.html 现象：内存被占用太多，手机卡顿 原因： 当剩余内存不多时，打开大型程序，系统会触发自身的进程调度策略，去移除一些等级比较低的进程来回收内存，以供大型程序运行。而这个进程调度策略在决定哪些进程需要被移除的过程，是一个十分消耗资源的操作，特别是一个程序频繁像系统申内存的时候，这样就导致了系统的卡顿。 3.4. 最大限度地提高内存的使用率是好事 参考：https://www.cnblogs.com/andy-songwei/p/9845771.html 比如，你的内存是8G，如果每次使用完某个进程就杀掉，那么被使用的内存基本上会始终保持在某个值，比如4G以内，那么内存的使用率就总是保存在50%以内，剩余的4G内存形同虚设，发挥用处的机会非常少。 ---------------> Android独特进程管理设计的好处 其他好处，见 《进程管理》 4. TODO: 一些基本问题 如何衡量-----> status? 如何实现？ 5. 实践之 UI框架性能 5.1. 目标： 视频来源《原生应用，天生流畅》 UI主要是交互性能，目标： （1）点击类（自然，启动、页面切换、交互时延） （2）滑动类 （自然，滑动的跟手、动画） 5.2. 策略 自然 来源 5.2.1. 具体 组件懒加载： 组件复用： 预创建------组件池： 5.3. TODO: 飞常准APP侧的UI优化 https://www.bilibili.com/video/BV1py411q7BV?t=2515.2 5.4. TODO: ArkWeb 的优化 https://www.bilibili.com/video/BV1py411q7BV?t=3017.3 5.5. TODO: 并行化技术 https://www.bilibili.com/video/BV1py411q7BV?t=4297.9 6. 主要流程大致时间 6.1. APP冷启动时间拆解（大致） TODO： 冷启动时间，大致1s 其中：fork进程 100ms、bindApplication xml解析，反射创建view render的时间 表格： 6.2. 手机启动时间拆解 TODO： 6.3. 一帧内 主线程cpu时间 + Render时间 我的车3D + 哔哩哔哩播放，一帧 19.8ms ，超过了16.6ms（60帧） 结论： 1、一般情况下，Render线程比主线程耗时少 。主线程6ms， render线程 2ms 2、如果Render线程耗时更多 -------> 证明软件UI出了问题，太多复杂，控件叠的多了 6.4. 屏幕旋转时间 7. 性能优化之 缓存策略 多养鱼 安卓例子1： 见《无障碍cache》 安卓例子2：缓存 parcelable的创建部分: 见《java反射》： 反序列化创建 parcelable，使用到的Creator ----> 缓存Creator 安卓例子3：缓存binder: Q:我记得context里面缓存过各种系统服务的binder。缓存binder操作，大概率应该可行对吧？ A ：应该是可行的，但是有一个问题就是不知道服务死没死，如果再去调用一下它看看还是不是正常的，那就达不到省时间的效果了 如果是同进程（反射可能用到），不会存在这个问题，同死同生 8. 性能理念： 1、要了解大致性能数据：总体数据 + 关键阶段数据 ​ --------> 这样才知道在哪里优化、对各个阶段时间有个大致的比例（对以后写代码也很有好处，知道关键在哪里，需要注意啥） 比如：冷启动时间、开机时间.............. ---------> 见上面《主要流程大致时间》 2、最好的优化一定是结构上的优化（不限于性能）： 比如: 新增一个线程、新增缓存模型 ------------> 而不是死扣代码写法的一点点优化 -人生亦如是： 开自己公司、带团队、做副业（新增一个线程） ----------> 而不是拼命让自己的产出多一点点，眼巴巴让领导给升职加薪 ​ 不是死扣拼命节省舍不得花钱 3、思想：耗时意味着冗余；冗余意味着耗时 9. 关键词大收集 查看displayid： 在display dump中，搜 mDisplayid 10. 抛开性能优化 抛开性能优化来看： 程序的性能优化的思想，来源于生活。无一例外。 ----> 所以，记录生活的美好，不问用处 好的程序思想 --------> 应用于生活 好的生活中思想 -------> 应用于程序 11. 优化工具集合 删减功能 裁剪 优先-------资源倾向：比如优先级设定 提前----------时间上cache 减少重复----------复用、空间上Cache 12. 【性能优化】Simpleperf的认识和使用 https://blog.csdn.net/lucky_tom/article/details/126885365 1、火焰图----------> 高频函数 ----------> 优化高频函数 2、trace缺陷： 只能看到Trace.Tag级别（比如DrawFrame耗时很长，但是不清楚底层具体哪个函数耗时长），但是看不到函数级别 log也是 Tag级别的，哪里加才显示 -----------> 火焰图可以解决 13. 性能 https://online.mediatek.com/apps/quickstart/QS00161#QSS03785 eService CR教战手册---Benchmark https://online.mediatek.com/apps/quickstart/ https://online.mediatek.com/apps/quickstart/QS00254 https://online.mediatek.com/apps/quickstart/QS00288#QSS03479 Performance 调试宝典 https://online.mediatek.com/apps/quickstart/ -----> application信息 https://online.mediatek.com/apps/quickstart/QS00038#QSS00306 深入分析Android native exception框架 ---》done https://online.mediatek.com/apps/quickstart/QS00294#QSS03909 trace ---》done boost ----> 拉频 ---------------------> 查看安卓的设置接口 14. 语言级性能 14.1. 使用SparseArray替代HashMap SparseArray LongSparseArray SparseBooleanArray SparseIntArray SparseLongArray https://blog.csdn.net/qq_29078329/article/details/124664172 相比于与HashMap， 优点： 避免了装箱拆箱过程，查询、存储等操作效率更高，而且int的存储开销也远小于Integer 规定： 尽量用SparseArray 来替代 HashMap 使用： android.util.SparseLongArray sparseLongArray = new android.util.SparseLongArray(16); sparseLongArray.put(10, 100L); sparseLongArray.get(10); mclearedSubTree.delete(10); mclearedSubTree.get(1, 0L); mclearedSubTree.size() HashMap mclearedSubTree = new HashMap<>(); mclearedSubTree.delete(10); mclearedSubTree.get(1, 0L); mclearedSubTree.size() https://m.imooc.com/article/263867 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/1_稳定性/":{"url":"coding/1_稳定性/","title":"1_稳定性","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/1_稳定性/ANR.html":{"url":"coding/1_稳定性/ANR.html","title":"ANR","keywords":"","body":"1. 目录2. ANR2.1. 监控方式一 ANR（安卓系统侧）2.2. 监控方式二：应用自身监控-------WatchDog方式2.3. del：监控方式三：应用自身监控-------log时间差2.4. del：监控方式四：应用自身监控-------FileObserver3. Input ANR3.1. ANR爆炸现场的保存3.1.1. TODO： dump数据位置3.2. Input ANR的本质模型3.3. 补充 ANR4. 面试题 Q&A4.1. ANR 的原因有哪些？5. crash ANR 监控方式一 ANR（安卓系统侧） 监控方式二：应用自身监控-------WatchDog方式 del：监控方式三：应用自身监控-------log时间差 del：监控方式四：应用自身监控-------FileObserver Input ANR ANR爆炸现场的保存 TODO： dump数据位置 Input ANR的本质模型 补充 ANR 面试题 Q&A ANR 的原因有哪些？ crash 1. 目录 2. ANR 参考： ANR问题的产生机制.pdf 2.1. 监控方式一 ANR（安卓系统侧） 目的： ANR -------> Application Not responding -------> 响应：希望事情在一定的时间内完成 事情的特征： 有一定耗时的， 比如： 输入类ANR： InputDispatching Timeout：输入事件分发超时5s，包括按键和触摸事件 组件类ANR: Service Timeout：前台服务在20s内未执行完成； BroadcastQueue Timeout：前台广播在10s内未执行完成 ContentProvider Timeout：内容提供者在publish过超时10s; -------------> 都有一个特点： 不可见，却要给用户一个反应！ TODO: ANR 与 阻塞是否等价呢？有什么区别与共同点？设计的模型 2.2. 监控方式二：应用自身监控-------WatchDog方式 前提：同进程 APP 同进程监控ANR --------> WatchDog方式 ：https://blog.csdn.net/qq_30379689/article/details/129056033 原理： 应用自己新建 WatchDog 线程 ------> 类似于 系统侧的watchDog 缺点： https://blog.csdn.net/qq_30379689/article/details/129056033 2.3. del：监控方式三：应用自身监控-------log时间差 参考： https://zhuanlan.zhihu.com/p/119293585?utm_id=0 项目-------BlockCanary： 原理： 在主线程的Looper.loop中 dispatchMessage 前和后 ------> 监控时间差 注： 【1】日志安卓原生已经加了 ----------> 从模型角度，本质：监控一次loop的时间 TODO: 画个图 因为【1】，自然，只需要继承 Printer 移花接木： 图片： 见 https://zhuanlan.zhihu.com/p/119293585?utm_id=0 //继承Printer接口 class LooperMonitox implements Printer 优点： 缺点很明显： 检测不到长久的block： 没有启动另一个线程，对于长期block的线程 -------> 没有一次完整的loop，检测不到第二次print ------> 不会有反应 -------> 根本原因：自己的线程检查自己 2.4. del：监控方式四：应用自身监控-------FileObserver 原理： 检测系统侧ANR的结果 https://zhuanlan.zhihu.com/p/119293585?utm_id=0 3. Input ANR 流程图： 见《ANR问题的产生机制.pdf》 ------------> TODO: 这不是一个好的图，因为方向和方位不对 功能主体： InputDispatcher： InputDispatcher分发的时候，记时间 APP进程分发完毕的时候，会直接知会给InputDispatcher 【1】 超时了，执行工作自然交给AMS去处理，报错，弹窗 注【1】： 如何知会？ TODO: https://juejin.cn/post/7010319858118164510#heading-27 常见实例 + 关键字眼 3.1. ANR爆炸现场的保存 system_server会马上去抓取现场的信息： 将am_anr信息输出到EventLog，也就是说ANR触发的时间点最接近的就是EventLog中输出的am_anr信息 收集以下重要进程的各个线程调用栈trace信息，保存在data/anr/traces.txt文件 当前发生ANR的进程，system_server进程以及所有persistent进程 audioserver, cameraserver, mediaserver, surfaceflinger等重要的native进程 CPU使用率排名前5的进程 将发生ANR的reason以及CPU使用情况信息输出到main log 将traces文件和CPU使用情况信息保存到dropbox，即data/system/dropbox目录 ​ -----------------------> TODO: 看一下具体的log以及文件 https://www.jianshu.com/p/f624266c8424 Android 性能优化——ANR监控与解决 https://zhuanlan.zhihu.com/p/654699274 android程序中,产生ANR原因与分析解决 CPU usage from 0ms to xxx ms later with xx% awake: 14% 1673/system_server: 8% user + 6.7% kernel / faults: 12746 minor 13% 30829/tv.danmaku.bili: 7.3% user + 6.2% kernel / faults: 24286 minor 6.6% 31147/tv.danmaku.bili:ijkservice: 3.7% user + 2.8% kernel / faults: 11880 minor 6% 574/logd: 2.1% user + 3.8% kernel / faults: 64 minor .. TOTAL: 6.4% user + 8.2% kernel + 0% iowait + 0.6% irq + 0.1% softirq CPU usage from xxms to xxxms later 73% 1673/system_server: 49% user + 24% kernel / faults: 1695 minor 33% 2330/AnrConsumer: 12% user + 21% kernel 15% 1683/HeapTaskDaemon: 15% user + 0% kernel 9.2% 7013/Binder:1673_12: 6.1% user + 3% kernel 6.1% 1685/ReferenceQueueD: 6.1% user + 0% kernel 6.1% 2715/HwBinder:1673_5: 6.1% user + 0% kernel 3% 2529/PhotonicModulat: 0% user + 3% kernel 25% 30829/tv.danmaku.bili: 4.2% user + 21% kernel / faults: 423 minor 25% 31050/thread_ad: 4.2% user + 21% kernel ... ... 27% TOTAL: 10% user + 14% kernel + 0.3% iowait + 0.9% irq + 0.3% softirq ANR对话框： 对用户可感知的进程则弹出ANR对话框告知用户，对用户不可感知的进程发生ANR则直接杀掉 3.1.1. TODO： dump数据位置 /proc/106/coredump_filter 包括调用栈 --------> 进程外？系统能力？？？？ 3.2. Input ANR的本质模型 图：TODO： com 与watchDog的本质模型，并没有本质上的差异 ---------> 见watchDog 3.3. 补充 ANR 深入理解 Android ANR 触发原理以及信息收集过程 - huansky - 博客园 (cnblogs.com) https://www.cnblogs.com/huansky/p/14954020.html ANR 触发原理 | Agehua (conorlee.top) https://conorlee.top/2022/08/08/anr-trigger-principle/ https://juejin.cn/post/6864555867023343623#heading-3 好文 https://github.com/qingmei2/blogs/blob/master/src/反思系列/反思|系列目录.md 好文 反思 https://blog.csdn.net/to_perfect/article/details/128509630 https://blog.csdn.net/rzleilei/article/details/127118071 -----------> 超级好文，尤其图画的好 失落夏天 的ANR系列文章： 总目录：https://blog.csdn.net/rzleilei/article/details/120720918 分为三块来讲： 第一块，讲解ANR发生后，是如何显示的，以及对应的日志文件如何生成的： ANR系列之一：ANR显示和日志生成原理讲解_失落夏天的博客-CSDN博客 ------> 好文，尤其图 第二块，讲四种类型的ANR是如何产生的： ANR系列之二：Input类型ANR产生原理讲解 ------> 好文，尤其图 ANR系列之三：broadcast类型ANR产生原理讲解 ANR系列之四：ContentProvider类型ANR产生原理讲解 ANR系列之五：Service类型ANR原理讲解 第三块，讲如何ANR问题如何进行分析，以及如何建立有效的机制来检测上报ANR类型问题。（未完成） ANR系列之六：ANR文件和日志如何分析 ANR系列之七：如何建立有效的机制来监控分析ANR问题 4. 面试题 Q&A 4.1. ANR 的原因有哪些？ 耗时的网络访问 大量的数据读写 数据库操作 硬件操作（比如 Camera） 调用 thread 的 join()方法、sleep()方法、wait()方法或者等待线程锁的时候 service binder 的数量达到上限 ---------> 注意！！！！！！ system server 中发生 WatchDog ANR service 忙导致超时无响应 其他线程持有锁，导致主线程等待超时 ---------> 注意！！！！！！ 其它线程终止或崩溃导致主线程一直等待 ---------> 注意！！！！！！其他线程阻塞呢？ ------------------------> TODO: 化简！！！！！！ 1、阻塞型： 其他线程持有锁，导致主线程等待超时 ​ 其他线程阻塞/终止或崩溃导致主线程一直等待 ​ service binder 的数量达到上限 ！！！ 2、忙碌型： I/O、网络 链接：https://www.jianshu.com/p/e47fcc8c1df6 5. crash console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/1_稳定性/WatchDog.html":{"url":"coding/1_稳定性/WatchDog.html","title":"Watch Dog","keywords":"","body":"1.1.1. 具体如何重启的？1.1.2. 安卓watchdog设计理念：1.1.3. del:纵向流程图----字典1.1.4. del:每一行代码注释------字典1.2. WatchDog本身2. WatchDog 与 ANR比较3. del: TODO：补充 Linux 的Watchdog4. 从模型角度，看watchDog的设计5. TODO： 具体如何重启的？ 安卓watchdog设计理念： del:纵向流程图----字典 del:每一行代码注释------字典 WatchDog本身 WatchDog 与 ANR比较 del: TODO：补充 Linux 的Watchdog 从模型角度，看watchDog的设计 TODO： \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000UI thread. mHandlerCheckers.add(new HandlerChecker(UiThread.getHandler(), \"ui thread\", DEFAULT_TIMEOUT)); // check IO thread. mHandlerCheckers.add(new HandlerChecker(IoThread.getHandler(), \"i/o thread\", DEFAULT_TIMEOUT)); // display thread. mHandlerCheckers.add(new HandlerChecker(DisplayThread.getHandler(), \"display thread\", DEFAULT_TIMEOUT)); // animation thread. mHandlerCheckers.add(new HandlerChecker(AnimationThread.getHandler(), \"animation thread\", DEFAULT_TIMEOUT)); // surface animation thread. mHandlerCheckers.add(new HandlerChecker(SurfaceAnimationThread.getHandler(), \"surface animation thread\", DEFAULT_TIMEOUT)); // Initialize monitor for Binder threads. addMonitor(new BinderThreadMonitor()); ................. } 2、判断 ```java mHandler.getLooper().getQueue().isPolling() // --------》 返回当前Looper是否没有在处理任务 Watchdog会不断判断这些线程的Lopper是否空闲，如果一直非空闲，那么必然就被阻塞了。 其他： 保存案发现场 WatchdogDiagnostics.diagnoseCheckers(blockedCheckers); TODO: 为啥会和mSFHang，扯上关系？ 1.1.1. 具体如何重启的？ // 结束进程 watchdog存在于system_server进程之下2 // 因为watchdog就是在system_server初始化的3 Process.killProcess(Process.myPid()); ---------> 结论： 杀死system_server进程 ----------> TODO: 后续呢？ https://blog.csdn.net/weixin_43228946/article/details/129898004 扩展：mtk加强的重启： pms.reboot(false, reason, false); // 掉电, 更加彻底 1.1.2. 安卓watchdog设计理念： 安卓watchdog设计理念： 检测到 抛过去的任务30s内，有没有执行完 跨线程的看门狗：c++ https://www.coder.work/article/3240296 c++ - 在 C++11 中实现看门狗定时器 ------> 同进程的！！！！！！！！ 跨进程的看门狗：TODO: !!!!!!!!! 设计Aidl接口： 正向set的接口，反向通知接口 ------> 正向通知接口里 约束 必须反向通知 跟林的聊天记录：补充 为啥不以 进程状态显示为 \"D\" 表征进程正在阻塞？（因为我们还需要考虑busy running） 1.1.3. del:纵向流程图----字典 参考：android watchdog 重启 安卓 watchdog_小星星的技术博客_51CTO博客 https://blog.51cto.com/u_87634/6566226 1.1.4. del:每一行代码注释------字典 https://blog.51cto.com/u_87634/6566226 1.2. WatchDog本身 启动： SystemServer.startBootstrapServices 中 本身是一个线程：无限循环的 --------> 可以理解为一个服务，但是不是binder 2. WatchDog 与 ANR比较 1、不同点： (1) 进程角度： WatchDog：同进程的 ： WatchDog线程对各种服务 TODO: 画图 TODO: 是不是跨进程也能这么玩？ 我在系统服务里，给APP主线程，插入一个任务，30s后，我再跨进程，查一下。。。。超时了，我就杀掉他 ANR: 跨进程：系统进程，对UI线程的监控 (2) 时机角度： WatchDog 是 定期循环， ANR机制 是有input， 才会触发 ​ -----------------> 并不是本质区别 2、相同点： （1）检测内容一样：线程有没有 阻塞 + busy Running （2）模型本质一样： 限定时间，给回调通知 -----------------> 感觉两者是同一个东西，不同场景的表达 3. del: TODO：补充 Linux 的Watchdog Linux也引入了Watchdog，在Linux内核下，当Watchdog启动后，便设定了一个定时器，如果在超时时间内没有对/dev/Watchdog进行写操作，则会导致系统重启，通过定时器实现的Watchdog属于软件层面。 参考： https://blog.51cto.com/u_87634/6566226 android watchdog 重启 安卓 watchdog 4. 从模型角度，看watchDog的设计 保活进程设计： 框架侧在API内部单独起线程，喂狗 保活线程（比如保活主线程）：【1】 难点：主线程是一个loop，一个循环不定时，那么 watchDog两种模型： 主动告知型：你不断的主动告诉我（watchDog），你有没有死（不一定是固定频率，只要不超时） 被动问型： 我定期去问你，你有没有死 从模型的角度来看，问题【1】的困难点的根源： 主动告知型：你在忙，或者你在等（比如socket、死锁、消息）--------> 都不会主动找我 被动问型： 你在忙 （异常情况） -----> 不会主动找我 你在等（比如socket、死锁、消息） ------> 我的问，触发你不再阻塞 ------> 告诉我 无论哪一种，都难以解决问题【1】 与jiyong讨论： 从模型角度： 安卓可行的原因: 我问你的时候，你也被唤醒了（ 安卓用looper-handeler机制，这个大循环会被唤醒） 【1】可行的场景： 场景一：你的循环是 固定频率的 场景二：大概知道循环多久一次，多发，不超时即可（但要注意过频） 场景三：你本身是 event触发的系统。。。。被动问，这里“问”-----> 作为event触发你 这也是安卓可行的模型解释 场景四：被动问型模型下，主动构造触发：比如新起一个线程，定时触发你的循环， ​ 比如发送一个消息触发 ---------> 安卓的策略 Q：安卓为什么可行？ A：本质因为安卓的线程 是消息驱动（正常的阻塞只会是等消息）------> 主动触发消息就好 ​ 自然：如果是其他阻塞（比如，socket等消息、下载图片），安卓策略也失效 推论：即安卓watchDOG检测的是loop 5. TODO： console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/AndriodCar/":{"url":"coding/AndriodCar/","title":"Andriod Car","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/AndriodCar/CarService.html":{"url":"coding/AndriodCar/CarService.html","title":"Car Service","keywords":"","body":"1. 目录2. 参考： 参考： 1. 目录 [TOC] 2. 参考： https://blog.csdn.net/qq_34211365/article/details/122166633 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/AndroidTool/":{"url":"coding/AndroidTool/","title":"Android Tool","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/AndroidTool/HierarchyView.html":{"url":"coding/AndroidTool/HierarchyView.html","title":"Hierarchy View","keywords":"","body":"1. 目录2. HierarchyView APP HierarchyView APP 1. 目录 [TOC] 2. HierarchyView APP 越过各种权限： HierarchyView APP ------> socket --------> wms侧viewServer ------> wms执行viewServerWindowCommand -------> 通过binder IWindow，找到应用窗口具体执行 -----> ViewRootImpl侧： dispatchCommand TODO: HierarchyView APP工具 和 sh脚本，也是用户端，体现 参考： https://www.cnblogs.com/carlo/p/4798250.html HierarchyView的实现原理和Android设备无法使用HierarchyView的解决方法 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/App/":{"url":"coding/App/","title":"App","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/App/APK_64bit_32bit.html":{"url":"coding/App/APK_64bit_32bit.html","title":"APK 64 Bit 32 Bit","keywords":"","body":"1. 目录2. 谁决定了app运行在64bit或32bit的运行环境2.1. 几个结论：2.2. 决定APK运行在32bit还是64bit环境下的规则2.3. 强制APK底层调用bit32库 谁决定了app运行在64bit或32bit的运行环境 几个结论： 决定APK运行在32bit还是64bit环境下的规则 强制APK底层调用bit32库 1. 目录 [TOC] 2. 谁决定了app运行在64bit或32bit的运行环境 2.1. 几个结论： 1、mediaserver进程只有32bit 2、32Bit进程和64bit进程间跟其他进程一样通过binder进行通信 3、app 默认运行在64bit环境（可以强制改成32bit，见后），包括：meidaplayer app 2.2. 决定APK运行在32bit还是64bit环境下的规则 https://segmentfault.com/a/1190000014161183 64bit与32bit交互，通过Binder zygote进程的建立是真正的Android运行空间 2.3. 强制APK底层调用bit32库 见 HowToReadCode.md 《断点调试环境 lib64 、lib 区分》 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/App/APP开发.html":{"url":"coding/App/APP开发.html","title":"APP开发","keywords":"","body":"1. 预加载和懒加载——ViewPager+Fragment优化 预加载和懒加载——ViewPager+Fragment优化 1. 预加载和懒加载——ViewPager+Fragment优化 目的： TODO： 参考： https://mengfou.blog.csdn.net/article/details/121220878?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-121220878-blog-82923077.235%5Ev40%5Epc_relevant_rights_sort&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-121220878-blog-82923077.235%5Ev40%5Epc_relevant_rights_sort&utm_relevant_index=5 Android插件化开发指南——实践之ViewPager+Fragment优化（预加载和懒加载） 效果： 1、----------> QQ音乐： 2、动图见： https://mengfou.blog.csdn.net/article/details/121220878?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-121220878-blog-82923077.235%5Ev40%5Epc_relevant_rights_sort&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-121220878-blog-82923077.235%5Ev40%5Epc_relevant_rights_sort&utm_relevant_index=5 见：https://blog.csdn.net/rzleilei/article/details/123252533 Android性能优化之页面优化 https://blog.csdn.net/rzleilei/article/details/125258457 启动速度优化 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/App/launcher3.html":{"url":"coding/App/launcher3.html","title":"Launcher 3","keywords":"","body":"1. 目录2. 启动流程--launcher33. Launcher3 目录 启动流程--launcher3 Launcher3 1. 目录 [TOC] 2. 启动流程--launcher3 见 《启动流程---AMS》 3. Launcher3 https://blog.csdn.net/dingfengnupt88/article/details/51800057?spm=1001.2014.3001.5502 loadAllApps()流程： // 获取需要显示在Launcher上的activity列表 List apps = mLauncherApps.getActivityList(null, user); // 其中，mLauncherApps是系统服务(即：mLauncherApps = mApp.getContext().getSystemService(LauncherApps.class);) // 获取图标icon mBgAllAppsList.add(new AppInfo(app, user, quietMode), app);// This builds the icon bitmaps. // 创建应用图标对象， -----> mIconCache.getTitleAndIcon -----> cacheLocked ---> ........ -----> PackageInfo info = mPackageManager.getPackageInfo(packageName, flags);//最终追溯到PackageManager 或者 applyCacheEntry // 启动是因为对每个icon设置了监听 icon.setOnClickListener(mLauncher); icon.setOnLongClickListener(this); 已经验证： 此外，Android11之后, 需要加: AndroidManifest.xml ; 一些问题： 1、Linux侧启动的应用 ：安卓launcher3没有参与任务栈 -----> 后续AMS 管理任务栈，会不会有问题？ ---------> 应该还好 2、launcher3 设置为透明：那么launcher3 需要运行的意义在哪里？是否可以干掉？（如果不干掉，是不是有大部分功能可以干掉？） ---------> 感觉可以干掉 参考系列： 1、https://blog.csdn.net/dingfengnupt88/article/details/51799392?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-51799392-blog-132246995.235^v38^pc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-51799392-blog-132246995.235^v38^pc_relevant_sort_base1&utm_relevant_index=2 Launcher3--初识Launcher3 2、https://blog.csdn.net/dingfengnupt88/article/details/51800057?spm=1001.2014.3001.5502 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/App/SystemUI.html":{"url":"coding/App/SystemUI.html","title":"System UI","keywords":"","body":"1. 目录2. TODO TODO 1. 目录 [TOC] 2. TODO systemui ----------> 即承载了非应用、非launcher的一切UI ？ 所以，包括： 1、悬浮窗、分屏的装饰区域 2、navigation bar、status bar 3、壁纸窗口 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/App/小程序.html":{"url":"coding/App/小程序.html","title":"小程序","keywords":"","body":"1. 小程序1.1. finclip1.2. 获取界面上的节点信息1.3. 无障碍1.4. 小程序开发1.5. JS系列(二) - V8引擎的运行原理 finclip 获取界面上的节点信息 无障碍 小程序开发 JS系列(二) - V8引擎的运行原理 1. 小程序 基础概念： 小程序与宿主，两个进程！！！！ 基于浏览器 图见 https://www.finclip.com/mop/document/develop/guide/start/host-environment.html#_1-逻辑层与视图层 两个小程序通信 （1）通过宿主linux应用通信 （2）网络通信websocket：通过远程的中间服务器 linux上，利用QT渲染 消耗----------一个页面：10M jsBridge： 小程序的js ---> 调用 小程序的cpp https://blog.csdn.net/qq_44376306/article/details/133963573 小程序，类似于webview？ 类似于 flutter？ 1.1. finclip https://www.finclip.com/mop/document/runtime-sdk/windows/windows-intro.html 1.2. 获取界面上的节点信息 参考： https://www.finclip.com/mop/document/develop/guide/framework/view.html#_6-1-什么是组件 FXML节点信息: 获取界面节点信息 界面变化通知 1.3. 无障碍 无障碍不支持，但是可以做 QT是有无障碍的？ 1.4. 小程序开发 https://www.finclip.com/downloads/ 1.5. JS系列(二) - V8引擎的运行原理 js跑在V8引擎上 -----> 必然hos也是这样做的 https://blog.csdn.net/qq_44376306/article/details/133963573 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/CodingLanguage/":{"url":"coding/CodingLanguage/","title":"Coding Language","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/CodingLanguage/c_cpp_java.html":{"url":"coding/CodingLanguage/c_cpp_java.html","title":"C Cpp Java","keywords":"","body":"1. 目录2. C语言2.1. 字符串：2.2. 字符串的数组（c指针数组）2.3. memset、memcmp、strcmp比较2.4. sizeof2.4.1. 与cpp对比2.4.2. 参考：2.5. C语言 空指针 NULL3. 如何学习一门语言4. cpp4.1. 引用的表达------include关键字（与java比较）4.2. 对象（与java比较）4.2.1. cpp—new malloc（与c的 malloc/free的比较）4.2.2. C++创建对象的两种方式 （与java的对比）4.2.3. 对象以及对象指针（对比java）4.2.4. 面试题4.3. 字符串(与c、与java对比)4.3.1. char类型字符串-----c4.3.2. string字符串-----Cpp4.4. int4.5. 容器4.5.1. vector4.5.2. 动态容器的遍历---以vector为例4.5.3. map4.5.4. set集合4.6. cpp标准输入输出cin：4.6.1. 关于 cout4.7. CPP内存机制4.7.1. 内存管理（手动管理）TODO4.8. cpp一些问题：4.8.1. 关于cpp的内存分配：4.8.2. cpp 数组声明后，必须初始化4.8.3. int 与 size_type4.9. 工具：Address Sanitizer4.9.1. 教程：4.9.2. What Can It Detect?4.9.3. 工作原理（how）4.9.4. 命令：4.9.5. 如何看结果4.10. 内存泄漏4.10.1. 对于leetcode的报错：4.11. cpp独有的东西4.11.1. 内联inline4.11.2. 日志：4.11.3. STL4.12. java、cpp 对比与记忆4.12.1. cpp 常量与JAVA常量表达：4.13. 常见面试题4.13.1. c++的const和static区别4.14. 代码重构之 lamba表达式4.15. c++ invoke ----> 从形式上统一函数调用4.16. 寻找代码对应的产物 / 查看是否编译进去某个产物5. cpp打印调用栈5.1. 代码问题汇总：5.2. 打印log6. cpp代码与C代码的转换：7. Java：7.1. Super、this、实例化7.2. 钩子、监听器、汉奸的理解7.3. 关于安卓able对象7.4. 编译器优化:7.4.1. final的log开关DEBUG7.5. import 函数名7.6. 匿名内部类8. 正则 C语言 字符串： 字符串的数组（c指针数组） memset、memcmp、strcmp比较 sizeof 与cpp对比 参考： C语言 空指针 NULL 如何学习一门语言 cpp 引用的表达------include关键字（与java比较） 对象（与java比较） cpp—new malloc（与c的 malloc/free的比较） C++创建对象的两种方式 （与java的对比） 对比java 对象以及对象指针（对比java） 对比java 基于对比，的推论： 面试题 字符串(与c、与java对比) char类型字符串-----c 取子字符串 比较字符串 ------c string字符串-----Cpp 取子字符串s.substr() int 容器 vector vector与int [] 的比较 vector的排序 动态容器的遍历---以vector为例 map set集合 cpp标准输入输出cin： 关于 cout CPP内存机制 内存管理（手动管理）TODO cpp一些问题： 关于cpp的内存分配： cpp 数组声明后，必须初始化 int 与 size_type 工具：Address Sanitizer 教程： What Can It Detect? 工作原理（how） 命令： 如何看结果 内存泄漏 对于leetcode的报错： cpp独有的东西 内联inline 日志： STL java、cpp 对比与记忆 cpp 常量与JAVA常量表达： 常见面试题 c++的const和static区别 代码重构之 lamba表达式 c++ invoke ----> 从形式上统一函数调用 寻找代码对应的产物 / 查看是否编译进去某个产物 cpp打印调用栈 代码问题汇总： 打印log cpp代码与C代码的转换： Java： Super、this、实例化 钩子、监听器、汉奸的理解 关于安卓able对象 编译器优化: final的log开关DEBUG import 函数名 匿名内部类 正则 1. 目录 2. C语言 2.1. 字符串： cpp： string 或 char * s ------> 首选string c： char * s 或 char s[] （c中的字符数组） 区别：获取长度 stirng s ------>s.size() char s[] ---------> lenstr(s) c语言中：strcmp与strncmp与memcmp的区别： https://blog.csdn.net/weixin_45380951/article/details/100699751?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.pc_relevant_default&utm_relevant_index=6 2.2. 字符串的数组（c指针数组） cpp：vector& wordDict_cpp c： char * wordDict_c, int wordDictSize ------>多重指针，指针的指针 char \\ wordDict_c[3] ------>指针数组 -------->使用方法完全一样： 取第0个字符串 wordDict_cpp[0], wordDict_c[0] 取第0个字符串的wordDict_cpp[0] [0], wordDict_c[0] [0] 关于char ** wordDict_c理解： （1）*相当于一个[], 比如 char * s = char s[] 所以，\\*\\* 即是 [] [] 具体： char *month[] = {\"January\",\"February\",\"March\",\"April\", \"May\",\"June\",\"July\",\"August\",\"September\",\"October\", \"November\",\"December\"}; ---->这里month是 char *的[]， ---->char ** point = &month; 还是 char ** point = month？？？？ 双重指针！！！！！ （2）c表达字符串数组时：指针数组 多重指针 2.3. memset、memcmp、strcmp比较 cpp没有字节级的处理，最少也是基本数据类型的处理---->比如，char、string memset、memcmp、strcmp ---->都是字节级的处理 即直接操作内存空间（字节级） 是c的用法（当然cpp也可以用） 所以，经常用到 sizeof() --->获取字节数 例子： void *memset(void *s, int c, unsigned long n); // 将s前n个字节填充c bool dp[lenstr(s) ]; // 是字符数组 memset(dp, 0, sizeof(bool)*lenstr(s)); //全部填充0 例2： memcmp(&s[i-int(tem.size())], &tem[0], int(tem.size())*sizeof(char)) 0 2.4. sizeof 总之： sizeof是c语言的东西 返回字节数 返回 类型的大小 具体用法： 1、用于数据类型-----本质 cout 2、用于变量 -----> 变量对应的数据类型的大小: int x = 4; cout 结果： sizeof(string) 32 sizeof(str) 32 sizeof(int) 4 sizeof(x) 4 sizeof(B) 4 sizeof(b) 4 3、指针变量也是变量，自然也是类型的大小 -----> 自然，跟系统有关： 32位计算机，返回4；64位计算机，返回8 char*pc=\"abc\"; int*pi; string*ps; char**ppc=&pc; void(*pf)();//函数指针 sizeof(pc);//结果为8 sizeof(pi);//结果为8 sizeof(ps);//结果为8 sizeof(ppc);//结果为8 sizeof(pf);//结果为8 4、用于数组 -----> 也是数组类型的大小，即 数组元素的大小 * 数组元素的个数 为什么？因为 数组类型 = 元素大小 + 数组长度 ​ int arr[3] = {0}; cout 5、结构体的sizeof ---> 涉及到字节对齐 2.4.1. 与cpp对比 对于cpp，推论，自然： 用于cpp的类的对象时，--------> 是 类型（即类）的大小，见上 2.4.2. 参考： https://baike.baidu.com/item/sizeof/6349467 2.5. C语言 空指针 NULL struct weston_paint_node *blurNode; if (blurNode) { // 进入了！！！！！！ } 安全起见，需要判断的指针，先赋值NULL： struct weston_paint_node *blurNode = NULL; if (blurNode) { // 没进入 } 3. 如何学习一门语言 以某一门语言为基础，搭建 学语言需要的技能树： 1、根据技能树，填充 2、填充的同时，与已经学会的语言进行比较（一样的话，就不需要记忆了） 4. cpp 4.1. 引用的表达------include关键字（与java比较） 引用其他文件的.h文件 ---->.h用来声明 被其他文件引用的类、函数 1、只在.h文件里声明，，不能在.h文件中定义值 ---->原因：include本质：.h会被复制到引用的文件中，如果定义，涉及到重复定义 2、同一个.h 可能被很多文件include ------>会造成多次编译问题，解决办法： .h文件中，增加#ifndef方式 //Parcel.h #ifndef ANDROID_PARCEL_H #define ANDROID_PARCEL_H // --------------------------------------------------------------------------- #endif // ANDROID_PARCEL_H https://blog.csdn.net/zzzkiti/article/details/40976867?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-5.pc_relevant_paycolumn_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-5.pc_relevant_paycolumn_v2&utm_relevant_index=9 对比 ： java引用的表达是import 4.2. 对象（与java比较） 4.2.1. cpp—new malloc（与c的 malloc/free的比较） https://blog.csdn.net/hahachenchen789/article/details/83056796 语言范围： new/delete是C++关键字，需要编译器支持。-----> new 是对象，自然是cpp的东西 malloc/free是库函数，需要头文件支持。 ----> C的东西 入参比较： 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。 ------> 对于面向对象的语言，这一点，很自然 malloc则需要显式地指出所需内存的大小 -----> 自然的，c是没有办法自己算出大小的 返回比较： new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符 ------> 面向对象语言，自然的 malloc内存分配成功则是返回void *，需要通过强制类型转换将void指针转换成我们需要的类型。 ------> *这一点需要注意 malloc free 是stdlib库的函数 使用必须进行压栈出栈操作 ------> TODO: 不懂 new delete 是 c++的操作符 无需进行栈栈操作 且会再new是自动调用构造函数 delete调用析构函数 -------->所以，对于类来说，尽量用new（涉及到子类的析构） 例子： \\\\Parcel.cpp status_t Parcel::write(const FlattenableHelperInterface& val) { ........... int* fds = nullptr; if (fd_count) { fds = new (std::nothrow) int[fd_count]; //(1) if (fds nullptr) { ALOGE(\"write: failed to allocate requested %zu fds\", fd_count); return BAD_VALUE; } } err = val.flatten(buf, len, fds, fd_count); for (size_t i=0 ; iwriteDupFileDescriptor( fds[i] ); } if (fd_count) { delete [] fds; //(2) } return err; } 注意： 即使在函数内部new，也要在函数结束时，记得释放 uint8_t* data = (uint8_t*)malloc(desired); if (mData) { memcpy(data, mData, mDataSize void *memcpy(void *destin, void *source, unsigned n); 数据：mData ---> data 4.2.2. C++创建对象的两种方式 （与java的对比） 内存的分配方式有三种： （1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在（不用管内存的销毁）。例如全局变量，static 变量。 （2） 在栈上创建（回收不用程序员管，自动回收------>因为叫栈，程序自动回收）。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束后在将这些局部变量的内存空间回收。在栈上分配内存空间效率很高，但是分配的内存容量有限。------>一般来说，编译期就分配好内存大小了（具体分配还是在运行期？？？） ​ （3） 从堆上分配的。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。 -------->只能在运行期申请内存 --------->所以，只有1、堆上的对象需要考虑释放 2、堆上的对象是运行期分配的内存 C++创建对象有两种方式：一句话区别：new的是在栈上创建 1、在栈上创建对象（Objects on the Stack）: int main(int argc, char** argv) { SpreadsheetCell myCell(5); // ------> 在栈上创建 if (myCell.getValue() 5) { SpreadsheetCell anotherCell(6); } // anotherCell is destroyed as this block ends. cout 2、在堆上创建对象（Objects on the Heap）: ClassName *obj1 = new ClassName(); ClassName *obj2 = new ClassName(parameter); delete obj1; delete obj2; 补充：cpp默认不会在静态存储区，创建对象的 但是，可以超纲使用（重载new/delete 操作符）：https://blog.51cto.com/u_15290941/3048752 对比java java只会在堆上创建对象 4.2.3. 对象以及对象指针（对比java） 对象的创建： A类的constructor： A(int b) 显式：A a = A(2) 隐式： A a(2) 与上面等价 对象指针： A* p = new A(2)； ---------->注意所有的new，都要有delete去销毁 （因为new是在堆上分配内存的，不是栈上） ​ 对比java 对象 A a = new A(2) -----> java new出来的是对象 本质一样： java与cpp new之后的东西，本质上是一样的（只是叫法不一样，只是语言层面符号不一样）： 1、都是堆产生一个对象 2、既然是堆里的东西，都需要主动释放 java的对象，本质是引用 或者说： cpp指针 等价于 java对象 基于对比，的推论： 1、java的对象，其实就是cpp对象的指针 2、判空时：cpp对指针判空；java对.....判空 -----> 自然，两者等价 3、java对象需要判空，cpp指针需要判空（cpp对象不需要） 4、赋值：cpp的指针赋值 等价于 java对象（实际引用）赋值 ------>都不会新建对象 5、赋值2： 但cpp对象赋值，是copy constructor。会新建对象: -------》 自然，传递的不是指针 ​ A a1 = a0 同理，cpp函数传参，传递对象，也会先copy constructor 对于java，传递的是对象的引用！！！ 6、推论：无论cpp还是java，对象永不为空（java对象本质是对象的引用）------> 自然的，对象都出来了，都占用了堆内存，怎会为空呢？ java的对象不初始化就为空-------> 实际上是引用 cpp对象，永不为空 --->（1）、cpp的对象声明，是包含了初始化的（java的声明，只是声明，声明和初始化两者分开） 是default constructor！！！！！ cpp，已经初始化，可以直接用 （2）、cpp需要判空的是指针，指针可能为空（本质原因：cpp指针 《------>类似于 java对象） （3）、cpp指针判空用nullptr （C语言用NULL） 7、从代码形式角度看声明，字符串：自然，java是引用，还没初始化 cpp声明： java声明： java必须单独初始化 8、从代码形式角度看声明，基本数据类型：自然， 两个都不是引用，即都有默认值 cpp： java： 4.2.4. 面试题 ① 、T *t =new T; ② 、T *t =new T(); ③、T t; 自然结论： a、内存上：new的都是在堆里，比如① 和② ； 非new都是在堆里，比如3 b、根据内存，自然new的（堆里）需要手动管理内存；3不需要 c、① 和② 的不同点：Todo，没能真正理解！！！！ ​ （1）程序员显示定义了构造函数都一样 ​ （2）程序员没有显示定义构造函数 -----》 编译器会为该类合成一个默认的构造函数： ① 的类内部的成员变量这个时候执行默认初始化，其值是未定义的。 ② p内部的成员变量会执行值初始化，即以0的形式进行初始化（整数就为0，bool就为false，string 就为空） 参考： https://blog.csdn.net/iaccepted/article/details/38613089 4.3. 字符串(与c、与java对比) 4.3.1. char类型字符串-----c 取子字符串 操作： 比较字符串 ------c 方法一：memcmp：（可以不是string的比较！！！！！） 比较两个string 或 比较两个string的 前三位： memcmp(&s1, &s2, 3*sizeof(char)) --->C语言的方法 注意: s1 只要是字符串就行，string 或者 char*的字符串 入参是指针 方法二： strcmp(str1, str2) 4.3.2. string字符串-----Cpp C++标准程序库中的string类，与上面的char*的字符串比较： 优势： 不必 担心内存是否足够、字符串长度等等 使用方法： #include using namespace std; 取子字符串s.substr() 4.4. int C++如何取得int型的最大最小值 當題目涉及到求最大最小值時，最初的比較數字就應當設置爲INT_MAX或INT_MIN，更爲安全。 中有INT_MAX和INT_MIN的宏定義可直接使用。 或者自行定义宏 #define INT_MAX 0x7fffffff #define INT_MIN 0x80000000 INT_MAX = 2147483647 INT_MIN = -2147483648 4.5. 容器 4.5.1. vector 类似于java int[]： 类似1： 初始化：vector nums = {2,3,1,1,4}; cpp形式初始化 vector nums{3} -----> nums 含3 vector nums{1,3} -----> nums 含1,3 cpp形式初始化 vector nums(3) -----> nums含 0, 0 ，0 类似2：索引：nums[i] nums.at 注意：对于指针，不能用p[i] !!!!!, 只能p->at(i) 不同于 java int[] --->动态数组，增删 insert、erase push_back、pop_back #### vector与int [] 的比较 ``` bool wordBreak(string s, vector& wordDict) { } ``` vector是动态数组，可以运行期确定大小 --->即vector dp2(int(s.size())); 可以编译通过 int [] 编译期确定大小 --- > bool dp[int(s.size())] = {false}; ---->编译不通过 方法： (1)利用cpp的vector （优） (2)给int [] 足够的空间，比如这里已知s长度小于300： bool dp[300] = {false}; (3) 利用c的方式， 利用memset运行期分配空间大小： ​ bool dp[int(s.size()) + 1]; // 这里可以编译通过，原因在于，这里只是声明，编译器并没有分配空间 ​ memset(dp, 0, sizeof(bool)*(int(s.size()) + 1)); vector的排序 // sort algorithm example #include // std::cout #include // std::sort #include // std::vector bool myfunction (int i,int j) { return (i myvector (myints, myints+8); // 32 71 12 45 26 80 53 33 // using default comparison (operator ::iterator it=myvector.begin(); it!=myvector.end(); ++it) std::cout 4.5.2. 动态容器的遍历---以vector为例 vector遍历： 方法一： 索引i遍历，for (int i = 0; i 方法二：iterator遍历： ​ for (vector::iterator it = res.at(i).begin(); it ​ 或 while (it != res.at(i).end()) {it++;} ---->结论：涉及到动态数组的删除与增加，谨慎用for！！！！！（it强行++了！），多用while！！ //---->原因：for为什么不对？因为erase之后，it自动指向下一个，不应该再强制it++，需要判断 vector::iterator it = res.at(i).begin(); while (it != res.at(i).end()) { ​ if (int(*it) -22) { ​ res.at(i).erase(it); ​ } else { ​ it++; // 有条件的下一个！！！！！ ​ } } 4.5.3. map 初始化 遍历 iterator： 《-----------iter++; map::iterator iter; iter = _map.begin(); while(iter != _map.end()) { cout first second first second 增删改查： 增：mem.insert({start, true}); ---->注意：不同于java，这里增一个pair，即 {key，value} 删： 改： 查：find(key) 4.5.4. set集合 https://en.cppreference.com/w/cpp/container/set 遍历 iterator，同map 4.6. cpp标准输入输出cin： https://blog.csdn.net/bravedence/article/details/77282039 作用：cin可以连续从键盘读取想要的数据，以空格、tab或换行作为分隔符 例子： #include using namespace std int n, m; cin >> n >> m; 输入： 4 5 输出与输入： cin>>a>>b>>c; cout4.6.1. 关于 cout cout 本质：cout实际上是一个iostream类的对象，流对象。。。--->每一次调动ostream& operator这个函数重载了 --->所以《《 之间可以填任意数据类型的数据 ------>推论： 1、输出操作符“>>”，作用：将数据输出到std::cout输出流的缓冲区上。 2、std::endl作用：显示请求刷新 ---->缺少后，暂时不会刷新 3、可以打印很多数据，而且 4、printf 输出需要格式化字符串，比如printf(\"%d\", n); --->c的做法，比较麻烦（根因：c没有类的概念） 4.7. CPP内存机制 参考：https://blog.csdn.net/m0_68981107/article/details/127548736 cpp内存模型： TODO: 对比java的 1.栈用来存放：非静态局部变量/函数参数/返回值等，栈向下增长。 2.堆用于程序运行时动态内存分配，堆是可以上增长的。 3.数据段–存储全局数据和静态数据。 4.代码段–可执行的代码/只读常量。 注意点： 1、 向上增长、向下增长 2、全局变量和 静态变量（静态全局变量、静态局部变量）的比较（面试题）： ​ ① 相同点：都在数据段（静态存储区） ​ ② 记忆： 全局变量： 全局，即 ​ 作用域：所有文件（自然，其他文件需要用extern来再次声明一下，才能引用到） ​ 生命周期：跟执行的时机有关 静态全局变量 = 静态 + 全局变量 ​ 静态static即： （1）作用域 : 限制文件内 （2）生命周期同程序 静态局部变量：= 静态 + 局部变量 ​ 静态static即：................................ ​ 局部，即：限定在函数体内 ​ 总之，作用域：函数体内 生命周期：同程序 int globalVar = 1; // 全局变量 ----》 全局所有文件 static int staticGlobalVar =1; //静态 全局变量 ②static限定了作用域（在该文件内） void Test() ( static int staticVar = 1; //静态 局部变量 int localVar = 1; int num1[10] = {1,2,3,4}; 4.7.1. 内存管理（手动管理）TODO 方式一： view框架里面，java和native绑定，死亡机制 方式二：手动delete 方式三：智能指针 4.8. cpp一些问题： 4.8.1. 关于cpp的内存分配： 静态分配内存：《---->在编译期间就分配了内存大小《----->栈上分配（静态变量是在静态方法区、注意：栈上存在动态分配） 常见的有：局部变量中的int[]、array对象 动态分配内存：《----->在运行期间分配内存大小《------->在堆上分配 《------>必须手动管理内存 例子：new或者mallo的对象、vector类（内部自动使用new和delete来管理内存） ------->对cpp，上述写法错误 （解决方法，用vector、或者 找到数组大小上限） vector可以的原因是，动态增长的，编译期间有个初值？？？？ 对于java是可以的，因为int dp = new int[] ----->这是在堆上生成的（运行期间） https://zhidao.baidu.com/question/304646543.html https://www.cnblogs.com/nulisaonian/p/6100535.html 4.8.2. cpp 数组声明后，必须初始化 声明，不初始化，本质上来说，是可以的，是有数值的 但数值是随机的（上一次内存的遗留！！！） 4.8.3. int 与 size_type string.size()、lenght()返回size_type size_type 本质是无符号整数，int是有符号整数。。。规定：与int 运算（加、减、否则，会出现很多意想不到的结果，例子： a是无符号整数--->导致1-a也是无符号整数，即是正的，但很明显1-a = -3是个负数，转化成正数，就非常大 4.9. 工具：Address Sanitizer 4.9.1. 教程： https://www.youtube.com/watch?v=hhpzDFvXopk Address Sanitizer in C++ (A Tutorial) https://github.com/google/sanitizers https://www.cnblogs.com/justin-y-lin/p/11314059.html gcc存储已经集成了!!!! https://hanpfei.github.io/2019/05/19/AddressSanitizer_on_linux/ Linux 下的 AddressSanitizer 4.9.2. What Can It Detect? 4.9.3. 工作原理（how） 4.9.4. 命令： window下AddressSanitizer没能搞定，主要linux下，编译以及运行命令： g++ -fsanitize=address -O0 -fno-omit-frame-pointer -g -o main main.cpp && ./main 注意:g++(c++语言)不是gcc (c语言), 不能用错!!!! 遇到报错: Asan runtime does not come first in initial library list; you should either link runtime to your application or manually preload it with LD_PRELOAD 解决方法: mv /etc/ld.so.preload /etc/ld.so.preload.bak rm -rf /etc/ld.so.preload Ilvm-symbolizer 符号化工具属于 Ilvm包,Ubuntu 下具体的安装方法可以参考 LLVM Debian/Ubuntu nightly packages. 4.9.5. 如何看结果 分析日志:23912是进程号 读取四个字节的数字出错了 4.10. 内存泄漏 C++造成内存泄漏的原因汇总： https://blog.csdn.net/qq_18824491/article/details/78902636?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242.1&utm_relevant_index=3 对于C++的内存泄漏，总结一句话：就是new出来的内存没有通过delete合理的释放掉！！！！！！！！！ ------->在函数体内，1、不用new，创建对象，系统自动回收内存 2、new对象（返回指针），系统不会回收，需要手动 比喻：1、申请内存就像不停打开网页 2、没有及时关闭网页 3、new 网页，谁new应该谁关 4、如果不关网页，系统掉电重启，内存会全部清掉 4.10.1. 对于leetcode的报错： 42ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000058 at pc 0x00000037ac7d bp 0x7ffe70f719a0 sp 0x7ffe70f71998 ----->最后定位下来，是p1与p2循环next了 ------>leetcode报错类型是有问题的？？？？？（linux下AddressSanitizer没有报错！！） leetcode这种问题如何定位？？？？？ (1)二分 print--------->每一行都能打印 (2)linux内存泄漏工具 -------->OK的 (3)二分return（log不起作用时修改代码功能定位） ---------->既然抛了error，那么一定是某一行有问题，所以，逐行改变return位置 ------>逼出哪一行出了问题 37处return会有error！！！！！ 4.11. cpp独有的东西 4.11.1. 内联inline 内联，可以关闭，尤其定位问题，调用栈时，需要关闭！！！！！ 4.11.2. 日志： Step0. 在CMakeLists.txt中添加 find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log ) target_link_libraries( # Specifies the target library. native-lib ... # Links the target library to the log library # included in the NDK. ${log-lib} ) Step1. 在cpp文件中添加 // 引入log头文件 #include // log标签 #define TAG \"这里填写日志的TAG\" // 定义info信息 #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__) // 定义debug信息 #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__) // 定义error信息 #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__) Step2. 输出日志 LOGD(\"user info-----------------------name:%s, age:%d, sex:%s.\", \"xxx\", 18, \"男\");` LOGE(\"cg, 1, class name:%s\", env->GetStringUTFChars(name, 0)); 4.11.3. STL STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器） 在C++标准中，STL被组织为下面的13个头文件： 、、、、、、、、、、、和 4.12. java、cpp 对比与记忆 4.12.1. cpp 常量与JAVA常量表达： cpp： const JAVA：final 4.13. 常见面试题 4.13.1. c++的const和static区别 https://blog.csdn.net/qq_31484941/article/details/80742096 字节： 1、输入法的难点 ​ 通信 4.14. 代码重构之 lamba表达式 参考：https://www.jianshu.com/p/4af34e151d63 理解： lambda表达式即匿名函数 作用: 可以用作对重复代码的重构 //原始函数 void Window::SetInset (UIRect &rect) { .....重复[1]...... WindowSceneManager *curManager = ...........; .....重复[2]...... curManager->Setinset(rect);//非公共部分【3】,差异点:函数Setinset(参数rect也是函数?);相同点curManager } void Window::SetMode (int mode) { .....重复[1]...... WindowSceneManager *curManager = ...........; .....重复[2]...... curManager->SetMode (mode); } //代码重构 --------以上重复,自然,提取公因式为公共函数:提取1------- 提取1: void Window::ApplyOnCurManager() { .....重复[1]...... WindowSceneManager *curManager = ...........; .....重复[2]...... } 基于提取1,但是后面会用到提取1中的参数(即公共部分与差异部分有耦合性,造成了提取失败): 将非公共部分【3】的差异部分(函数Setinset、参数rect),进行封装差异????-----》修改2 修改2: void Window::ApplyOnCurManager (ProcessType setParams) { .....重复[1]...... WindowSceneManager *curManager = ...........; .....重复[2]...... //利用setParams差异性封装(对于公共部分函数ApplyOnCurManager) ---->从公共角度,只有封装差异,才能一样 setParams(curManager); } 基于修改2,需要 using ProcessType = std::function; //TODO:抽象是如何来的?? 目的:提取公共部分 (1)本质是封装函数,成为公共部分,自然是函数类型 std::function (2)参数为什么是WindowSceneManager *curManager???而不是rect? 因为参数也要是公共部分,即公共部分提取成参数(),非公共部分使用[],在原来函数里捕获!!! --------------------------------------------------- void Window::Setinset(UIRect &rect) { //基于修改2 ApplyOnCurManager(ProcessType setParams); //抽象 即: curManager->Setinset(rect);//差异性...... 从最终代码来看,差异性一定还是在原函数里 } void Window::Setinset(UIRect &rect) { //基于修改2 ApplyOnCurManager(ProcessType setParams); //抽象 setParams即: [&rect//1、表示lambda执行时,可以访问外部的变量!](WindowSceneManager *curManager//2、匿名函数的参数?) {curManager->Setlnset(rect);//差异性} //具体 1、并指定访问这些变量时是通过值拷贝还是引用访问. 2、std::function } TODO: 从最初--->最终代码:差异性,一定还在原函数里;公共部分,被公共函数抽出来 lamba的作用在于,将原函数里的差异性封装成匿名函数...............传参(匿名函数)给公共部分函数,自然代码没有差异 最基本的思想:对差异性进行封装,对公共部分进行提取 (角度,从原函数角度,从功能角度,从lambda角度,从最初--->最终角度,从功能角度) 从lambda角度: 从capture角度 从Setinset角度: lambda就是对Setinset的封装:封装成抽象的、相同的lambda; Setinset被延迟执行了,在下一个函数里执行的(在原函数里定义) 从定义---执行角度:在原函数里定义,在下一个函数里执行 从封装差异角度:差异最终是体现在原函数处 lambda的内核Setinset ([&rect])中,即定义处 从提取公共角度来看: lambda就是提取公共的一个极度的扩展 // 1. lambda封装差异性(下一个函数,公共部分+lambda) --->优点,场景,很多情况下,公共部分与差异耦合严重,无法用公共函数抽取 // 2.这里定义function形式(传参+执行在下一个函数里) 上述也即: 公共部分与差异部分有耦合性----抽取公共函数的方法 java lamba 与cpp lamba差异在哪里?那么java是否可以这样取优化代码? 再举例子：抽成单独的函数end_section // \\\\system\\\\core\\\\init\\\\parser.cpp void Parser::ParseData() { ............ auto end_section = [&] { // 定义处（没有执行） if (auto result = section_parser->EndSection(); !result.ok()) { parse_error_count_++; LOG(ERROR) 4.15. c++ invoke ----> 从形式上统一函数调用 参考： https://blog.csdn.net/jiemashizhen/article/details/134349951 invoke(函数f指针，函数f参数1，函数f参数2) 具体例子，见《refactor.md ---------代码写法：差异性封装》 4.16. 寻找代码对应的产物 / 查看是否编译进去某个产物 1、寻找代码对应的产物 2、查看修改代码是否，编译进产物 $ file libweston-14.so.0.0.02 libweston-14.so.0.0.0: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=806e8e9c14f4be71d4d2416cda7079dc16f18537, with debug_info, not stripped3 $ grep \"gl_renderer_repaint_output\" -nr libweston-14.so.0.0.0 //【】不在这里4 $ grep \"gl_renderer_repaint_output\" -nr ./5 grep: ./libweston-14/gl-renderer.so: binary file matches // 【】6 5. cpp打印调用栈 核心函数：backtrace_symbols #include void *callstack[128]; int frames = backtrace(callstack, 128); char **strs = backtrace_symbols(callstack, frames); //【】 backtrace_symbols qDebug() ----------------------------> 验证ok 结果： kwin Window::setDecoration: backtrace_symbols=================== /usr/lib64/libkwin.so.5(_ZN4KWin6Window13setDecorationESt10shared_ptrIN12KDecoration210DecorationEE+0x34) [0x7f8fab4a50] /usr/lib64/libkwin.so.5(+0x3e36c0) [0x7f8faf36c0] /usr/lib64/libkwin.so.5(_ZN14KWaylandServer20XdgToplevelInterfaceD2Ev+0x24) [0x7f8fbcfa28] /usr/lib64/libkwin.so.5(_ZN14KWaylandServer20XdgToplevelInterfaceD0Ev+0x14) [0x7f8fbcfa64] /usr/lib64/libkwin.so.5(+0x1d8354) [0x7f8f8e8354] /usr/lib64/libkwin.so.5(_ZN14KWaylandServer7Display14dispatchEventsEv+0x20) [0x7f8fb813e0] /usr/bin/kwin_wayland(+0x1364a4) [0x558a1274a4] /usr/bin/kwin_wayland(+0x886fc) [0x558a0796fc] /usr/bin/kwin_wayland(+0x57430) [0x558a048430] 参考： https://blog.csdn.net/MrWangHao/article/details/136165005?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-136165005-blog-130274179.235^v43^pc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-136165005-blog-130274179.235^v43^pc_blog_bottom_relevance_base7&utm_relevant_index=5 5.1. 代码问题汇总： Shape *shape; void setGraphicType() { ................. Triangle triangl; shape = &triangl; // ----------> 【1】cpp典型的错误写法。对象内存被释放了，但是地址被传出去了 ................ } ----------------->现象： shape->getGLSLVertexShader(); //【2】 shape->getGLSLFragmentShader(); //【3】 - 不好定位：因为函数return时，暂时不会被立即释放： 【2】可以执行，但是【3】执行失败了！！！！！ 正确方法： 方法一：内部new 指针，就不会释放 void setGraphicType() { ................. shape = new Triangle(); // new指针，内存不会释放 ................ } 但是：要注意内存泄漏：考虑shape指针对应内存的释放 方法二：在 出函数 之前，return出去（return的过程，会复制一份。内部的对象仍然会释放掉） Shape shape = getGraphicType(); Shape getGraphicType() { ................. Triangle triangl; // 【】会被释放掉。但在此之前会被复制一份 ................ return triangl; } 5.2. 打印log 打印布尔值： bool ret = true; // 或者 false ALOGI(\"The value of ret is: %s\", ret ? \"true\" : \"false\"); 6. cpp代码与C代码的转换： // cpp BlurFilter::prepare() // C prepare(BlurFilter blurFilter) 7. Java： 7.1. Super、this、实例化 一、 子类实例化过程调了Super publicA( ) extends B { Super(a,b,c) ..... } 此时： super 时， 会调B相应的构造方法 且执行方法里面内容 但只有一个实例this！！！！ this 表示这个唯一实例，而不是本类的。。。。。 子类在构造中调super的必要性在于 ：给父类的属性初始化 关于this： ​ （1）this和super都指向同一个实例，内存地址一致！！！！！ ​ （2）this永远代表实例 ，除了以下两种情况 ：（this.方法（）《>方法（）） ​ this.name = name; 以及在构造方法中重载this（a,b,c） >这两种this是本类的意思 二、 子类实例化过程没有调Super publicA( ) extends B { ..... } 等价于：默认调了父类无参构造方法, 而且是第一句就调了Super!!!! publicA( ) extends B { Super() } 每个类会默认有无参构造方法！！！！ 总之，记忆： https://blog.csdn.net/z56zzzz/article/details/78086434 ​ 0层：本质: 其物理本质！！！！一句话描述，记忆： ​ 1、无论this在父类还是子类中 ： （1）this.成员变量：当前类的变量， 注释：成员变量 《---->this.成员变量，编译器会自动加this！！！！！！！！(属性是静态的，同时存在，读取时就近原则（一个的话，自然就一个） idea跳转也是如此) （2）this.方法：当前运行类（即子类）的方法！ 更 抽象： 究其本质：子类存了两份成员，this.成员 和super.成员！！！！！（但一个是静态，一个是运行态） //FatherClass.java public class FatherClass { private String name; //父类成员变量，1、子类实例拥有，虽然同名，但是会存储两份 2、子类实例拥有，但无法调用 2、子类实例通过super.方法（）访问、修改,例如super.getName() 3、本类通过，this.name或name！！！！！！！！！！=>就近原则 private int age; protected String houseDress = \"dfjsifjioasjf\"; //子类实例继承该变量，1、虽然同名，但是会存储两份 2、子类实例可以直接调用，通过super.houseDress public String getName() { return name; } private String smile() { //子类实例访问不到的 ........ } public void setName(String name) { this.name = name; //记忆：this.成员变量 仅仅代表本类的 System.out.println(this.toString());//记忆： ！！！！！！！！！this.方法=>当前运行类的方法 } public String toString() { //子父同名，子类实例继承该方法 1、虽然同名，会有两份 2、子类实例可以调用，super.方法（） ........ } } //SonClass.java public class SonClass extends FatherClass{ private String name = \"aaaa\"; private int age; protected String houseDress = \"dasfafgs\"; public SonClass(){ } public void setFair(String fair) { this.fair = fair; } public String toString() { } } 7.2. 钩子、监听器、汉奸的理解 listener监听器。。。。。自然是塞给了谁，监听谁。。。。。谁new的，自然谁是主人 callback即listener，以后所有的callback就叫监听器 越做z，越要熟悉安卓。。。。。然后对比记忆 安卓是主干，是根本！！！ callback（listener），更应该叫钩子： 持有钩子的模块一直运行，某一时间利用钩子钩起钩子创造者 Q：Z有很多hook到A的流程，为什么这么多流程都可以hook到A里面=？？？？？？ A：因为有汉奸，伪装成A（继承于A），又把A的的调用流程转到了Z里 ----> 话说回来：这也是使用抽象（InterFace）的好处！扩展性强！ 7.3. 关于安卓able对象 Runnable ----》 可以执行的对象，把函数run() 封装成一个对象，本身与线程无关 Drawable ----》 可以画的对象 7.4. 编译器优化: 7.4.1. final的log开关DEBUG // private boolean isChangingPackagesOfCurrentUserLocked() { final int userId = getChangingUserId(); final boolean retval = userId == mSettings.getCurrentUserId(); if (DEBUG) { if (!retval) { Slog.d(TAG, \"--- ignore this call back from a background user: \" + userId); } } return retval; } 反编译services.jar，如下： 可以看出： 1、编译器做了很多优化 2、编译器对 final的 log开关DEBUG做了优化 ： 因为final，编译过程直接去掉 相关log（自然，因为永远无法走到，编译器一定会去掉的） ----------> 缺点： 难以debug修改开关DEBUG，来打印日志！！！ 7.5. import 函数名 //OomAdjuster.java： import static android.os.Process.setThreadPriority; //直接使用 setThreadPriority(app.getPid(), THREAD_PRIORITY_TOP_APP_BOOST); java可以import类的方法名-------> 感觉必须是静态方法（否则没有意义） 7.6. 匿名内部类 匿名内部类的理解：（1）定义了子类 （2）没有名字（自然，匿名） 比如： HashMap， Thread 以及 handler 例子： 定义了一个Map的子类：（子类在定义的时候，就定义了初始化过程put） public final /*static*/ Map RESULT_MESSAGE = new HashMap(){ { put(RESULT_CODE_OK, \"ok\"); put(RESULT_CODE_BADREQUEST, \"bad request\"); put(RESULT_CODE_UNAUTHORIZED, \"unauthorized\"); put(RESULT_CODE_FORBIDDEN, \"forbidden\"); put(RESULT_CODE_TOOMANYREQUEST, \"too many request\"); put(RESULT_CODE_INTERNALSERVERERROR, \"Internal Server Error\"); } }; 参考：https://blog.csdn.net/u013786868/article/details/53261207 Map属性的初始化方式 8. 正则 匹配test开头的一行： test\\/.* test前加空格 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/CodingLanguage/java反射.html":{"url":"coding/CodingLanguage/java反射.html","title":"java反射","keywords":"","body":"1. 反射1.1. 为什么要用反射？精髓在哪里？1.2. 反射的使用1.3. 反射性能1.4. 反射性能消耗的根因：1.5. 反射性能优化1.6. MethodHandle调用---------函数指针1.7. 理念！2. 反射性能数据3. 测性能的注意事项4. 类名不定、函数名不定、参数个数不定------反射5. 补充 反射 为什么要用反射？精髓在哪里？ 反射的使用 反射性能 反射性能消耗的根因： 反射性能优化 MethodHandle调用---------函数指针 理念！ 反射性能数据 测性能的注意事项 类名不定、函数名不定、参数个数不定------反射 补充 反射 1. 反射 1.1. 为什么要用反射？精髓在哪里？ 安卓源码中反射的场景： XML ------> 类： new view() byte --------> 类： 反序列化创建 parcelable，使用到的Creator 参考：android对象序列化Parcelable浅析 - xerrard - 博客园 (cnblogs.com) https://www.cnblogs.com/xerrard/p/5144386.html ---------------> 总之: （1）都是从二进制 到 类的过程 （2）一般都是很多个类-----> 反射，大量简化代码量！！！！！！ 注意，安卓为了优化性能，缓存策略： 安卓的Parcelable mCreators，就用了缓存策略！！！！！！！！！ ！！！！！！ 即：在真正binder通信时，没有反射 从设计角度看Creator： 只是把反序列化过程 要用的反射部分，从 parcelable 里抽出来 ------------> 为啥要这样？ （1）我们要用缓存策略，反射太耗时 （2）不可能缓存 Parcelable 对象的，因为没一个对象都是不一样的，参数是parcel里的数据 （3）所以，抽出公共部分，并缓存公共部分：（太TM神了!!!!!!） Parcelable 对象的创建部分，即 Creater（这个对于同一个类的Parcelable ） 总结： 1、缓存对象 2、缓存不了对象，缓存对象的创建方式 Creater 3、Creater是永远不变的、静态的，不是对象 -反射，可以实现的功能（或者 为啥要用反射）： （1）从编译角度，可以避开编译约束: 私有，不可见 （2）从代码角度, 可以实现 统一，大量简化代码量（一行代码，可以new 出各种类）-------> 语言，架构层面 （3） 从功能角度：同（1） (4) 从代码 扩展性、弹性角度： 反射有着非常好的弹性。比如，新增一个MyView，xml解析器创建view的代码，不需要改动一行 1.2. 反射的使用 参考： https://blog.csdn.net/weixin_56442629/article/details/115430249 .java反射 [《Debug Skills的反射章节》 1.3. 反射性能 https://blog.csdn.net/googdev/article/details/100039092#:~:text=%E4%B8%8B%E9%9D%A2%E6%98%AF%E6%88%91%E4%BB%AC%E7%9A%84%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%EF%BC%88%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D%E5%9D%87%E4%B8%BA%E6%AF%AB%E7%A7%92%EF%BC%89%EF%BC%9A,%E6%98%BE%E7%84%B6%EF%BC%8C%E5%9C%A8Android%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E9%9D%9E%E5%B8%B8%E6%85%A2%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%9A%84%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E5%88%86%E5%88%AB%E9%9C%80%E8%A6%811332%E6%AF%AB%E7%A7%92%E3%80%816384%E6%AF%AB%E7%A7%92%E3%80%812891%E6%AF%AB%E7%A7%92%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%99%E5%8F%AA%E9%9C%80%E8%A6%81312%E6%AF%AB%E7%A7%92%E3%80%81358%E6%AF%AB%E7%A7%92%E3%80%81774%E6%AF%AB%E7%A7%92%E3%80%82 https://www.skoumal.com/en/is-android-reflection-really-slow/ https://www.itzhimei.com/archives/2852.html Java反射 反射性能和优化 方法调用有三种：直接调用、反射调用、MethodHandle调用 1.4. 反射性能消耗的根因： 1、方法 查找和动态绑定： ------> 解决方法： 方法句柄（MethodHandle），类似于指针，不需要动态绑定 每次调用方法都需要进行一次方法查找和动态绑定 2、反射对象的创建： ----> 办法： 缓存反射信息 反射对象的创建和操作的性能较低，因为需要进行一些安全检查和复杂的对象初始化过程。 TODO: METHODY 反射能力： 一法破万法 同理 所有数据 序列化成 byte[] 同理，参数可以任意多个 MethodType methodType(Class rtype, List> ptypes) 1.5. 反射性能优化 1、主要很耗时的函数，有些函数不耗时： Class.forName这个方法比较耗时 （它实际上调用了一个本地方法，通过这个方法来要求JVM查找并加载指定的类） getFields 。。。。。。。。。。。。 2、优化-----------缓存策略： 把Class.forName返回的Class对象缓存起来，下一次使用的时候直接从缓存里面获取，这样就极大的提高了获取Class的效率 同理，在我们获取Constructor、Method等对象的时候也可以缓存起来使用 https://blog.51cto.com/u_16213578/7527733 TODO: 安卓的Parcelable mCreators，似乎就用了缓存策略 3、关闭安全检查 通过setAccessible(true)的方式可以关闭安全检查： jdk在设置获取字段，调用方法的时候会执行安全访问检查，而此类操作会比较耗时，所以通过setAccessible(true)的方式可以关闭安全检查，从而提升反射效率 4、高性能反射工具包ReflectASM 1.6. MethodHandle调用---------函数指针 参考： JVM角度看方法调用-MethodHandle篇 - 知乎 (zhihu.com) https://blog.csdn.net/seanxwq/article/details/122179781 --------------》 好文，详细使用 性能上： MethodHandle = 直接调用 >> 反射 本质上，性能好的原因： 结论：非静态化使用MethodHandle是不会比直接反射更快的 方法调用9——MethodHandle方法调用checkCustomized优化 - 简书 (jianshu.com) ---------> 好文 https://www.jianshu.com/p/a9cecf8ba5d9 若要访问私有的成员,得先申请一下 con.setAccessible(true); ----------------> 忽略访问权限，似乎对提升性能没有帮助 1.7. 理念！ 在讨论性能的时候，一定要知道背景--------------------------是否是在高频调用的背景下 1、有些调用不是高频的，允许一定反射 2. 反射性能数据 测试代码： hideContent package com.example.myapplication; import androidx.appcompat.app.AppCompatActivity; import android.content.ComponentName; import android.content.Intent; import android.os.Build; import android.os.Bundle; import android.util.Log; import android.view.View; import android.view.inputmethod.InputMethodManager; import android.widget.Button; import java.lang.invoke.MethodHandle; import java.lang.invoke.MethodHandles; import java.lang.invoke.MethodType; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class MainActivity extends AppCompatActivity { private static String TAG = \"chenjinke2\"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button1); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // Intent intent = new Intent(); // //跳转其他APP的固定页面，需要APP的包名，activity的全路径 // //在要跳转的APP的activity的配置添加 android:exported=\"true\"，将activity暴露出来 // ComponentName name = new ComponentName(\"com.wj.app2\",\"com.wj.app2.activity.ReceiveActivity\"); // intent.setComponent(name); //// startActivity(intent); // startActivityAsUser(); int b = sum(); // myTEST(); // myTest2(); // MethodHandle String javaVersion = System.getProperty(\"java.version\"); System.out.println(\"当前 Java 版本是：\" + javaVersion); Log.d(TAG, \"mytest: 当前 Java 版本是：\" + javaVersion); // 创建测试数据 ComponentName componentName = new ComponentName(\"com.example\", \"com.example.MainActivity\"); Intent intent = new Intent(); // intent.setComponent(); // 测试直接调用性能 testDirectInvocationPerformance(intent, componentName); // 测试普通反射接口 method.invoke性能 testReflectionPerformance(intent, componentName); try { // 不定参数形式 testReflectionPerformanceWithArgs(intent, componentName); } catch (NoSuchMethodException e) { throw new RuntimeException(e); } catch (InvocationTargetException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } // 测试 MethodHandle 性能 testMethodHandlePerformance(intent, componentName); // 测试 static MethodHandle 性能 testStaticMethodHandlePerformance(intent, componentName); // 测试 MethodHandle.invoke 性能 testMethodHandleInvokePerformance(intent, componentName); // 测试 static MethodHandle.invoke 性能 testMethodHandleStaticInvokePerformance(intent, componentName); // test3(); } }); } private void testMethodHandlePerformance(Intent intent, ComponentName componentName) { try { if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) { long startFindTime = System.nanoTime(); MethodHandles.Lookup lookup = MethodHandles.publicLookup(); MethodType methodType = MethodType.methodType(Intent.class, ComponentName.class); MethodHandle setComponentMethod = lookup.findVirtual(Intent.class, \"setComponent\", methodType); Log.d(TAG, \"mytest: MethodHandle Find Method Time：\" + (System.nanoTime() - startFindTime) + \" 纳秒\" ); long totalDuration = 0; long startTime = System.nanoTime(); for (int i = 0; i intentClass = Intent.class; Class[] parameterTypes = {ComponentName.class}; Method method = intentClass.getMethod(\"setComponent\", parameterTypes); Log.d(TAG, \"mytest: 普通反射接口 method.invoke Find Method Time：\" + (System.nanoTime() - startFindTime) + \" 纳秒\" ); long totalDuration = 0; long startTime = System.nanoTime(); for (int i = 0; i [] getParameterTypes(Object[] parameters) { Class[] parameterTypes = new Class[parameters.length]; for (int i = 0; i myClass = intent.getClass(); // 获取 myMethod 方法，注意这里的参数类型是不确定的，所以可以传递一个可变参数 Object[] parametersArrays = {componentName}; // 前一个返回值 Method myMethod = myClass.getMethod(\"setComponent\", getParameterTypes(parametersArrays)); Log.d(TAG, \"mytest: 普通反射不定参数接口： Find Method Time：\" + (System.nanoTime() - startFindTime) + \" 纳秒\" ); long totalDuration = 0; long startTime = System.nanoTime(); for (int i = 0; i = Build.VERSION_CODES.O) { return MethodHandles.lookup().findVirtual(Intent.class, \"setComponent\", MethodType.methodType(Intent.class, ComponentName.class)); } return null; } private void testStaticMethodHandlePerformance(Intent intent, ComponentName componentName) { try { if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) { // MethodHandles.Lookup lookup = MethodHandles.lookup(); // MethodType methodType = MethodType.methodType(Intent.class, ComponentName.class); // MethodHandle setComponentMethod = lookup.findVirtual(Intent.class, \"setComponent\", methodType); long totalDuration = 0; long startTime = System.nanoTime(); for (int i = 0; i = android.os.Build.VERSION_CODES.O) { MethodHandles.Lookup lookup = MethodHandles.lookup(); MethodType methodType = MethodType.methodType( Intent.class, ComponentName.class); MethodHandle setComponentMethod = lookup.findVirtual(Intent.class, \"setComponent\", methodType); long totalDuration = 0; long startTime = System.nanoTime(); for (int i = 0; i = android.os.Build.VERSION_CODES.O) { // MethodHandles.Lookup lookup = MethodHandles.lookup(); // MethodType methodType = MethodType.methodType( Intent.class, ComponentName.class); // MethodHandle setComponentMethod = lookup.findVirtual(Intent.class, \"setComponent\", methodType); long totalDuration = 0; long startTime = System.nanoTime(); for (int i = 0; i 結果： 1、反射性能测试结果，基于调用100w次求平均： D mytest: 直接调用方式平均耗时：4 纳秒 D mytest: method.invoke接口 Find Method Time：431154 纳秒 ------> 【1】 查找method 用时0.4ms D mytest: method.invoke接口：429 纳秒 D mytest: method.invoke不定参数接口： Find Method Time：96000 纳秒 D mytest: method.invoke不定参数接口：322 纳秒 D mytest: method.invoke不定参数接口 + 关闭校验： Find Method Time：69462 纳秒 D mytest: method.invoke不定参数接口 + 关闭校验：323 纳秒 ------> 【2】 D mytest: MethodHandle Find Method Time：280847 纳秒 D mytest: MethodHandle.invokeWithArguments 调用平均耗时：3612 纳秒 D mytest: MethodHandle.invoke 调用平均耗时：1024 纳秒 结论： 2、反射主要耗时： （1）查找类，未测 ----------> 耗时，缓存 （2）创建类，未测 ----------> 耗时，缓存 （3）查找方法：0.4ms 见【1】 ----------> 耗时，缓存 （4）反射调用method.invoke：0.3us 见【2】 ----------> 不耗时 安卓代码实测： mytest testOrigin: 831805 580 048 mytest testOrigin in: 831805 614 279 ----> 进入 testOrigin 耗时30us mytest startActivity: 831805 725 587 mytest: method.invoke endTime: 831805 764 971nm ----> 直接调用，进入startActivity 40us mytest: method.invoke: Find Method Time: 24616 nm mytest: method.invoke startTime: 831813 459 510 nm mytest: method.invoke endTime: 831813 489 048 nm ----> 反射调用，进入startActivity 30us mytest: method.invoke startActivity Time: 12650384 nm 3. 测性能的注意事项 环境： cpu当前负载（其他进程的影响） debug版本 log打印量 函数复杂程度 是否跨进程 其他进程的影响 -------> 所以，理念：测试性能，绝对值没有意义。只有相对值！！！！ 正常耗时、反射耗时 ----------> 百分比 性能测试（包括反射性能），环境影响很大，规定： (1) 串行测试： 对照组一定要在同一调用流程里 -----------> 保证环境相对不变 （2） 流程中不能有跨进程 --------> 对面进程不可控 （3）针对于反射： 函数进入前 + 进入后 记时 4. 类名不定、函数名不定、参数个数不定------反射 一法通万法： // 目标类 String targetClassName = parcel.readString(); Object target = prepareTargetInstance(targetClassName); // TODO: 目标类，是不是不用缓存？ if (target == null) { return; } // 目标函数名 String targetMethodName = parcel.readString(); // 构建参数1, 参数2...... ArrayList paras = new ArrayList<>(); prepareParas(lparcel, paras, sb); // TODO:假设参数2 paras.add(new Bundle()); Class targetClass = target.getClass(); // 获取 myMethod 方法，注意这里的参数类型是不确定的，所以可以传递一个可变参数 Object[] parametersArrays = paras.toArray(new Object[paras.size()]); // 缓存策略 Method targetMethod; if (targetClassMethod.containsKey(key)) { targetMethod = targetClassMethod.get(key); } else { targetMethod = targetClass.getMethod(targetMethodName, getParameterTypes(parametersArrays));// 【1】 时间，1ms 目标类可以是子类，但是参数不能是子类！！！！ targetClassMethod.put(key, targetMethod); } targetMethod.setAccessible(true); targetMethod.invoke(target, parametersArrays); //【2】 注意： 【1】 如果参数parameterTypes传子类实例（获取到子类名），反射 getMethod 方法找不到方法 根因：----------> 因为函数签名是包括参数的，根据函数签名找的 ​ 自然，但是 targetClass 可以是子类！！！！！！！ 5. 补充 反射 https://zhuanlan.zhihu.com/p/519992996 JVM角度看方法调用-反射篇 https://zhuanlan.zhihu.com/p/524591401?utm_id=0 JVM角度看方法调用-MethodHandle篇 https://www.jianshu.com/p/58642c6bd672 方法调用9——MethodHandle方法调用checkCustomized优化 ​ ---------------》 好文，系列文章 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/CodingLanguage/JNI.html":{"url":"coding/CodingLanguage/JNI.html","title":"JNI","keywords":"","body":"1. 目录2. JNI2.1. 0层2.2. JNIEnv结构2.3. JavaVM2.4. jobject thiz2.5. JNI基础2.5.1. 数据类型对应表2.5.2. JNI的命名规则2.5.3. Field and Method IDs2.6. JNI 操作 java 对象2.6.1. 操作 jarray2.6.2. 操作 jstring2.6.3. 操作 jobject2.6.4. 操作 Field2.6.5. 操作 method2.6.6. 创建java对象2.7. 参考文章： 目录 JNI 0层 JNIEnv结构 JavaVM jobject thiz JNI基础 数据类型对应表 JNI的命名规则 Field and Method IDs JNI 操作 java 对象 操作 jarray 操作 jstring 操作 jobject 操作 Field 操作 method 创建java对象 参考文章： 1. 目录 2. JNI 2.1. 0层 见： https://www.jianshu.com/p/87ce6f565d37 2.2. JNIEnv结构 JNIEnv: JNI的第一个参数，JNIEnv 的本质是一个与线程相关的结构体，里面存放了大量的 JNI 函数指针：是functions的集合 JNIEnv与线程一一对应 --->所以，JNIEnv的作用：通过这个 JNIEnv* 指针，就可以对 Java 端的代码进行操作： 调用 Java 函数 操作 Java 对象 struct _JNIEnv { /** * 定义了很多的函数指针 **/ const struct JNINativeInterface* functions; #if defined(__cplusplus) /// 通过类的名称(类的全名，这时候包名不是用.号，而是用/来区分的)来获取jclass jclass FindClass(const char* name) { return functions->FindClass(this, name); } //通过 jmethodID FromReflectedMethod(jobject method) { return functions->FromReflectedMethod(this, method); } jfieldID FromReflectedField(jobject field) { return functions->FromReflectedField(this, field); } jobject ToReflectedMethod(jclass cls, jmethodID methodID, jboolean isStatic) { return functions->ToReflectedMethod(this, cls, methodID, isStatic); } jclass GetSuperclass(jclass clazz) { return functions->GetSuperclass(this, clazz); } ... } 2.3. JavaVM JavaVM : JavaVM 是 Java虚拟机在 JNI 层的代表, JNI 全局只有一个 JNIEnv : JavaVM 在线程中的代表, 每个线程都有一个, JNI 中可能有很多个 JNIEnv，同时 JNIEnv 具有线程相关性，也就是 B 线程无法使用 A 线程的 JNIEnv JVM 的结构图如下：注意：JNIEnv与线程一一对应 2.4. jobject thiz java对象中的This，比如MainActivity的对象 2.5. JNI基础 2.5.1. 数据类型对应表 ------>作用在于：接口处参数用法，java--->cpp，例如int[] array --->jintArray //java public native int setToNativeArray(int[] array); //jin.cpp Java_com_example_NativeDemo_MainActivity_setToNativeArray(JNIEnv *env, jobject thiz, jintArray jintArrs) { // TODO: implement setToNativeArray() } 基础数据类型 Java Type Native Type Description boolean jboolean unsigned 8 bits byte jbyte signed 8 bits char jchar unsigned 16 bits short jshort signed 16 bits int jint signed 32 bits long jlong signed 64 bits float jfloat 32 bits double jdouble 64 bits void void N/A 引用类型 2.5.2. JNI的命名规则 extern \"C\" JNIEXPORT jint JNICALL Java_com_example_NativeDemo_MainActivity_setToNativeArray(JNIEnv *env, jobject thiz, jintArray jintArrs) { // TODO: implement setToNativeArray() return 0; } jint是返回值类型 Java_com_example_NativeDemo 是包名 MainActivity 是类名 setToNativeArray是方法名 2.5.3. Field and Method IDs 2.6. JNI 操作 java 对象 2.6.1. 操作 jarray 将一个 Java int[] 对象传入 C++ 2.6.2. 操作 jstring 2.6.3. 操作 jobject 2.6.4. 操作 Field 2.6.5. 操作 method 2.6.6. 创建java对象 2.7. 参考文章： https://juejin.cn/post/6844904192780271630#heading-14 https://www.jianshu.com/p/87ce6f565d37 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/CodingLanguage/js.html":{"url":"coding/CodingLanguage/js.html","title":"Js","keywords":"","body":"1. js语法1.1. 输入输出log2. 控件2.1. 滚动3. Web 开发 & 鸿蒙ACE4. 鸿蒙其他4.1. 应用流转迁移4.2. 分布式数据库4.3. 分布式任务调度4.4. HarmonyOS官方文档4.5. OpenHarmony官方文档 js语法 输入输出log 控件 滚动 Web 开发 & 鸿蒙ACE 鸿蒙其他 应用流转迁移 分布式数据库 分布式任务调度 HarmonyOS官方文档 OpenHarmony官方文档 1. js语法 https://blog.51cto.com/u_16099196/6441732 1.1. 输入输出log 结果： 其他： alert() 浏览器弹出警示框 console.log() 浏览器控制台打印输出信息 prompt() 浏览器弹出输入框，用户可以输入 2. 控件 2.1. 滚动 overflow属性是控制元素内容超出父级元素可视范围时的表现情况。它的属性值有： （1）visible：“溢出”部分会呈现在元素框之外。 （2）hidden：隐藏“溢出”的内容。 （3）scroll：“溢出“内容显示滚动条。 （4）auto：自动确定是否需要显示滚动条 例子： 3. Web 开发 & 鸿蒙ACE Web 开发范式中定义一个页面需要三个文件，html，css 和 js 文件 鸿蒙ACE（UI框架）： https://www.elecfans.com/d/1975305.html https://blog.csdn.net/weixin_41559503/article/details/128851385 ------> 好文 4. 鸿蒙其他 4.1. 应用流转迁移 4.2. 分布式数据库 4.3. 分布式任务调度 RemoteInputAbilitySlice.java ---------> 远程输入法 分布式剪切板 4.4. HarmonyOS官方文档 https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/syscap-list-0000001407929604-V3 4.5. OpenHarmony官方文档 华为鸿蒙操作系统(OpenHarmony) v1.0 开发者文档： https://www.bookstack.cn/read/openharmony-1.0-zh-cn/readme-%E5%9B%BE%E5%BD%A2%E5%AD%90%E7%B3%BB%E7%BB%9FREADME.md https://zhuanlan.zhihu.com/p/423765456 内核 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/CodingLanguage/python.html":{"url":"coding/CodingLanguage/python.html","title":"Python","keywords":"","body":"1. 读取文件-----读取部分2. xml文件解析3. 合并pd---------> 如何高效？4. 列名----->升序排序5. 截取pd5.1. 自定义规则筛选列 ------> 非常优，可扩展性非常强5.2. 选取列5.3. 删除某一列5.4. 筛选行6. 转置T7. 生物信息分析---Python版的DESeq27.1. R语言版DESeq2：7.2. Python版的DESeq27.3. 画图8. python爬虫 xml文件解析 合并pd---------> 如何高效？ 列名----->升序排序 截取pd 自定义规则筛选列 ------> 非常优，可扩展性非常强 选取列 删除某一列 筛选行 转置T 生物信息分析---Python版的DESeq2 R语言版DESeq2： Python版的DESeq2 画图 python爬虫 1. 读取文件-----读取部分 import pandas as pd df = pd.read_table('example.csv',nrows=5) // 前五row print(df) 2. xml文件解析 import xml.etree.cElementTree as ET path = '' def praseXML(filePaths): global dict_clin fileCounts = 0 global path for path in filePaths: fileCounts += 1 tree = ET.ElementTree(file=path) root = tree.getroot() revse(root, dict_clin, fileCounts) # // 定义为，收集以root为根的所有，不包含root级的 deepth = 0 def revse(root, dict_clin, fileCounts): global deepth deepth += 1 # 递归基 if(not root): return if(deepth == 3) : return # for node in root: collectingInformation(node, dict_clin, fileCounts) #收集n同级别的 revse(node, dict_clin, fileCounts) deepth = deepth -1 3. 合并pd---------> 如何高效？ # 方法一：时间：3h 内存： 3h内存就溢出了 merged_df = pd.DataFrame() for sample_dic in metadata: barcode = sample_dic[\"associated_entities\"][0][\"entity_submitter_id\"] file_name = sample_dic[\"file_name\"][:] print(\"file_name:\" ) print(file_name) print(\"barcode:\" ) print(barcode) sample_df = pd.read_table(sample_path + '\\\\' + file_name, names = [barcode], skiprows=[0,2,3,4,5]) #【1】频繁创建对象 merged_df = pd.concat([merged_df, sample_df], axis = 1) #【2】 频繁合并 【3】merged_df增长速度非常快，不知道为啥？几十个G print(\"sample_df:\" + str(sys.getsizeof(sample_df)/1024/1024) + \" merged_df:\" + str(sys.getsizeof(merged_df)/1024/1024)) merged_df.to_csv(root_path + '\\\\Results.csv') print(\"Results are saved to: \" + root_path + '\\\\Results.csv') # 方法二：时间：4min 内存： 4G dfs = (pd.read_table(sample_path + '\\\\' + sample_dic[\"file_name\"][:], skiprows=[0,2,3,4,5]) for sample_dic in metadata) #【5】 连续读取，不存在 频繁合并 【6】内存上：dfs最大值，就是多个文件字节之和 res = pd.concat(dfs) res.to_csv(root_path + '\\\\Results.csv') ------------------------------> 总之，两种方法，在时间和空间上都是天差地别的： 时间上：方法一多了（1）频繁创建对象 （2）频繁合并操作 空间上：：方法一多了（1）频繁创建对象 （2）merged_df大小急速增加（TODO：不知道为啥） 参考： https://www.360doc.com/content/23/0716/10/1088733714_1088733714.shtml 4. 列名----->升序排序 # 对列名进行升序排序 unstranded_Results_df = unstranded_Results_df.sort_index(axis=1) 5. 截取pd 5.1. 自定义规则筛选列 ------> 非常优，可扩展性非常强 筛选unstranded_Results_df中 列索引 columns 包含 表groupe_df['bcr_patient_barcode'] 列中文字（包含任意一个都行） filtered_columns_df = unstranded_Results_df.filter(items=[col for col in unstranded_Results_df.columns if hasWantGroupOrNot(groupe_df['bcr_patient_barcode'], col)]) #自定义规则 def hasWantGroupOrNot(groupe_df_serise, column_name): for barcode in groupe_df_serise: if barcode in column_name: return myRem(barcode) return False 5.2. 选取列 截取 ['gene_id', 'gene_name'] 两列 baoliu_df = unstranded_Results_df[['gene_id', 'gene_name']] 5.3. 删除某一列 # 删除 gene_name 列 clin_test_grouped_df.drop('gene_name', axis=1, inplace=True) 5.4. 筛选行 精髓：构造group_condition = [True, False, ............] # 测试组: 根据条件进行分组 group_condition = ((df['breast_carcinoma_progesterone_receptor_status'] == 'Negative') & (df['breast_carcinoma_estrogen_receptor_status'] == 'Negative') & ( ( (df['lab_proc_her2_neu_immunohistochemistry_receptor_status'].isnull()))| (df['lab_proc_her2_neu_immunohistochemistry_receptor_status'] == 'Equivocal') | (df['lab_proc_her2_neu_immunohistochemistry_receptor_status'] == 'Indeterminate') | (df['lab_proc_her2_neu_immunohistochemistry_receptor_status'] == 'Negative')) & ( ( (df['lab_procedure_her2_neu_in_situ_hybrid_outcome_type'].isnull())) | (df['lab_procedure_her2_neu_in_situ_hybrid_outcome_type'] == 'Negative'))) test_grouped_df = df[group_condition] 6. 转置T 7. 生物信息分析---Python版的DESeq2 7.1. R语言版DESeq2： https://naiv.fun/Misc/TCGA.html 图：最终结果 ----------------> 用python版，可以做出同样结果 7.2. Python版的DESeq2 参考：https://cloud.tencent.com/developer/article/2228284 Python版的DESeq2尝鲜 7.3. 画图 https://www.jianshu.com/p/a19e099de544 Python版RNA-seq分析教程：DEseq2差异表达基因分析 8. python爬虫 参考： https://blog.csdn.net/lemonbit/article/details/114957452?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-9-114957452-blog-128834558.235^v40^pc_relevant_anti_vip&spm=1001.2101.3001.4242.6&utm_relevant_index=12 40行Python代码一键把html网页保存为pdf，太方便了！ https://blog.csdn.net/Galoa/article/details/79873163 Python爬虫: 单网页 所有静态网页 动态网页爬取 https://pythonjishu.com/yophpzdhyczaznu/ Python实现爬取需要登录的网站完整示例 https://ylmx5201314.blog.csdn.net/article/details/130794156?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-130794156-blog-124296992.235%5Ev40%5Epc_relevant_rights_sort&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-130794156-blog-124296992.235%5Ev40%5Epc_relevant_rights_sort&utm_relevant_index=1 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/CodingLanguage/R.html":{"url":"coding/CodingLanguage/R.html","title":"R","keywords":"","body":"1. R1.1. log1.2. 遇到包安装问题，如何解决？2. 各种包2.1. ChAMP包3. TCGA3.1. TCGA临床数据xml R log 遇到包安装问题，如何解决？ 各种包 ChAMP包 TCGA TCGA临床数据xml 1. R 运行 1、Rscript.exe main.R 2、GUI 1.1. log 1.2. 遇到包安装问题，如何解决？ 2. 各种包 2.1. ChAMP包 source(\"https://bioconductor.org/biocLite.R\") options(BioC_mirror=\"http://mirrors.ustc.edu.cn/bioc/\") biocLite(\"ChAMP\") options选择中科大镜像 3. TCGA 1、下载 https://zhuanlan.zhihu.com/p/658541630?utm_id=0 2、pd 读取数据的使用 https://blog.csdn.net/qq_21402983/article/details/124554283 https://naiv.fun/Misc/TCGA.html 3.1. TCGA临床数据xml import xml.etree.cElementTree as ET import os import re import sys sourceDir = sys.argv[1] filepath = [] for dirName, subfolders, filenames in os.walk(sourceDir): if len(filenames) > 1: file_xml = [i for i in filenames if r'.xml' in i] if file_xml: filepath.append(os.path.join(dirName, *file_xml)) else: filepath.append(os.path.join(dirName, *filenames)) def None2unknow(str): if dict_clin[str]: dict_clin[str][-1] = \"unknow\" if dict_clin[str][-1] is None else dict_clin[str][-1] else: dict_clin[str].append(\"unknow\") with open('result.txt', 'w') as F: F.write(\"ID\\tSurvival_time\\tStatus\\tRace\\tGender\\tAge\\tGrade\\tStage\\tT\\tN\\tM\\n\") for path in filepath: tree = ET.ElementTree(file=path) root = tree.getroot() dict_clin = {\"ID\": [],\"Survival_time\": [],\"Status\": [], \"Race\": [],\"Gender\": [],\"Age\": [],\"Grade\": [], \"Stage\": [],\"T\": [],\"N\": [],\"M\": []} for n in root.iter(): # basic information if n.tag.endswith(\"bcr_patient_barcode\"): dict_clin[\"ID\"].append(n.text) if n.tag.endswith(\"days_to_last_followup\"): dict_clin[\"Survival_time\"].append(n.text) if n.tag.endswith(\"vital_status\"): dict_clin[\"Status\"].append(n.text) if n.tag.endswith(\"race\"): dict_clin[\"Race\"].append(n.text) if n.tag.endswith(\"gender\"): dict_clin[\"Gender\"].append(n.text) if n.tag.endswith(\"age_at_initial_pathologic_diagnosis\"): dict_clin[\"Age\"].append(n.text) if n.tag.endswith(\"neoplasm_histologic_grade\"): dict_clin[\"Grade\"].append(n.text) if n.tag.endswith(\"pathologic_stage\"): dict_clin[\"Stage\"].append(n.text) if n.tag.endswith(\"pathologic_T\"): dict_clin[\"T\"].append(n.text) if n.tag.endswith(\"pathologic_N\"): dict_clin[\"N\"].append(n.text) if n.tag.endswith(\"pathologic_M\"): dict_clin[\"M\"].append(n.text) for key in dict_clin.keys(): None2unknow(key) F.write(dict_clin[\"ID\"][-1]+\"\\t\"+ dict_clin[\"Survival_time\"][-1]+\"\\t\"+ dict_clin[\"Status\"][-1]+\"\\t\"+ dict_clin[\"Race\"][-1]+\"\\t\"+ dict_clin[\"Gender\"][-1]+\"\\t\"+ dict_clin[\"Age\"][-1]+\"\\t\"+ dict_clin[\"Grade\"][-1]+\"\\t\"+ dict_clin[\"Stage\"][-1]+\"\\t\"+ dict_clin[\"T\"][-1]+\"\\t\"+ dict_clin[\"N\"][-1]+\"\\t\"+ dict_clin[\"M\"][-1]+\"\\n\") https://www.jianshu.com/p/e41b1e43182d console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Features/":{"url":"coding/Features/","title":"Features","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Features/其他特性.html":{"url":"coding/Features/其他特性.html","title":"其他特性","keywords":"","body":"1. 任意门1.1. 用户角度----效果1.2. 实现机制（猜测）1.2.1. 必然：1.2.2. 【2】的实现：1.2.3. 【3】的实现：1.2.4. 关于大数据2. 窗口的流转 用户角度----效果 实现机制（猜测） 必然： 【2】的实现： 【3】的实现： 关于大数据 窗口的流转 1. 任意门 TODO：com 1.1. 用户角度----效果 图片：长按 + 左右移动 --------> 识别为任意门 https://www.bilibili.com/video/BV18e411H72q/?spm_id_from=333.337.search-card.all.click&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 文字：长按？OR 长按+拖动？ TODO：如果文字仅长按，微信自己弹出来的复制分享怎么办？ https://www.bilibili.com/video/BV1zW4y1w7iD/?spm_id_from=333.337.search-card.all.click&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 1.2. 实现机制（猜测） 1.2.1. 必然： 【1】原APP进程 ---->【2】 框架侧插桩，框架侧拿到数据(原APP进程) ----> 【3】 给到renyimen的服务 -----> 【3】服务调用 APP2的接口，给到数据 从代码实现角度（编译角度）： 框架侧对 APP侧插装 1.2.2. 【2】的实现： 方式一： view有clipdata相关接口：能拿到string数据、viewImage的url数据 参考：https://stackoverflow.com/questions/21751429/android-how-can-i-get-image-from-clipdata 方式二： 类似于相册里的分享/备忘录里文字的分享。。。。。分享是安卓原生的功能 ----> 必然·很多APP2都适配过！！！！！ 1.2.3. 【3】的实现： 大部分需要三方应用适配 实在不行，用方式二 1.2.4. 关于大数据 在【2】----> 【3】的中间：优先推荐最有可能的目标应用 2. 窗口的流转 1、无边界流转：产品功能角度，一个硬件屏幕上，无边界流转 结构实现，必然有： 窗口级实现（自由浮窗） display级别实现（ virtualDisplay） 2、跨屏流转：屏-----物理屏幕 关键点：如何实现，一半窗口在物理屏幕1上，另一半在物理屏幕2上？ 法一： 结构实现：两个物理屏幕 对应 一个display。。。。最大限制，两个物理屏要一样高 法二： 没有中间态（一边remove、一边add） ----------> 大概率这个 3、无边界的贯穿显示：带鱼屏，整个作为一个display console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Features/多用户.html":{"url":"coding/Features/多用户.html","title":"多用户","keywords":"","body":"1. 目录2. 用户 & 用户组---linux用户3. 安卓用户----> 目标：安卓多用户模式3.1. 维测：4. 深入理解Android系统多用户机制5. 多用户起来的时机6. 一些结论： 目录 用户 & 用户组---linux用户 安卓用户----> 目标：安卓多用户模式 维测： 深入理解Android系统多用户机制 多用户起来的时机 一些结论： 1. 目录 2. 用户 & 用户组---linux用户 设计的目的： 用户，用户组（权限组？） ------------> 用户组：（1）文件 （2） 进程？ 为什么要有用户组？ 与进程组什么区别？ UID ------ 用户id， 1000(chenjinke) GID ------ 用户组id， 1000(chenjinke) 1、当前用户 ---------------- id $ id uid=1000(chenjinke) gid=1000(chenjinke) 组=1000(chenjinke),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare) 2、查看所有用户的UID和GID信息----------- cat /etc/passwd 注： 安卓阉割，没有 /etc/passwd chenjinke@chenjinke-VirtualBox:/proc/2160/task/2750$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash // --------> root用户， 0:root用户组 daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin syslog:x:102:106::/home/syslog:/usr/sbin/nologin // -------》 syslog用户 messagebus:x:103:107::/nonexistent:/usr/sbin/nologin _apt:x:104:65534::/nonexistent:/usr/sbin/nologin uuidd:x:105:111::/run/uuidd:/usr/sbin/nologin avahi-autoipd:x:106:112:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin dnsmasq:x:108:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin rtkit:x:109:114:RealtimeKit,,,:/proc:/usr/sbin/nologin cups-pk-helper:x:110:116:user for cups-pk-helper service,,,:/home/cups-pk-helper:/usr/sbin/nologin speech-dispatcher:x:111:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false whoopsie:x:112:117::/nonexistent:/bin/false kernoops:x:113:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin saned:x:114:119::/var/lib/saned:/usr/sbin/nologin avahi:x:115:120:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin colord:x:116:121:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin hplip:x:117:7:HPLIP system user,,,:/var/run/hplip:/bin/false geoclue:x:118:122::/var/lib/geoclue:/usr/sbin/nologin pulse:x:119:123:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false // ---------> gnome用户组 gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false chenjinke:x:1000:1000:chenjinke,,,:/home/chenjinke:/bin/bash // ---------> chenjinke用户，用户组也是1000:chenjinke vboxadd:x:999:1::/var/run/vboxadd:/bin/false sddm:x:122:127:Simple Desktop Display Manager:/var/lib/sddm:/bin/false mpd:x:123:29::/var/lib/mpd:/usr/sbin/nologin 3、cat /etc/group： 所有用户组的GID信息 注： 安卓阉割，没有 /etc/group chenjinke@chenjinke-VirtualBox:/proc/2160/task/2750$ cat /etc/group root:x:0: daemon:x:1: bin:x:2: sys:x:3: adm:x:4:syslog,chenjinke tty:x:5: disk:x:6: lp:x:7: mail:x:8: news:x:9: uucp:x:10: man:x:12: proxy:x:13: kmem:x:15: dialout:x:20: fax:x:21: voice:x:22: cdrom:x:24:chenjinke floppy:x:25: tape:x:26: sudo:x:27:chenjinke audio:x:29:pulse dip:x:30:chenjinke www-data:x:33: backup:x:34: operator:x:37: list:x:38: irc:x:39: src:x:40: gnats:x:41: shadow:x:42: utmp:x:43: video:x:44: sasl:x:45: plugdev:x:46:chenjinke staff:x:50: games:x:60: users:x:100: nogroup:x:65534: systemd-journal:x:101: systemd-network:x:102: systemd-resolve:x:103: input:x:104: crontab:x:105: syslog:x:106: messagebus:x:107: netdev:x:108: mlocate:x:109: ssl-cert:x:110: uuidd:x:111: avahi-autoipd:x:112: bluetooth:x:113: rtkit:x:114: ssh:x:115: lpadmin:x:116:chenjinke whoopsie:x:117: scanner:x:118:saned saned:x:119: avahi:x:120: colord:x:121: geoclue:x:122: pulse:x:123: pulse-access:x:124: gdm:x:125: chenjinke:x:1000: sambashare:x:126:chenjinke vboxsf:x:999: vboxdrmipc:x:998: sddm:x:127: 安卓系统 linux用户id： 换目录了： cat /data/system/packages.list ---------------------> 应用的 sailfish:/etc # cat /data/system/packages.list com.android.cts.priv.ctsshim 10048 0 /data/user/0/com.android.cts.priv.ctsshim default:privapp:targetSdkVersion=28 none 0 28 com.android.internal.display.cutout.emulation.corner 10029 0 /data/user/0/com.android.internal.display.cutout.emulation.corner default:targetSdkVersion=29 none 0 1 com.android.internal.display.cutout.emulation.double 10010 0 /data/user/0/com.android.internal.display.cutout.emulation.double default:targetSdkVersion=29 none 0 1 com.android.providers.telephony 1001 0 /data/user_de/0/com.android.providers.telephony platform:privapp:targetSdkVersion=24 1065,1005,3002,3003,3001,3007,2002,3006 0 29 com.android.dynsystem 1000 0 /data/user/0/com.android.dynsystem platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.android.providers.calendar 10053 0 /data/user/0/com.android.providers.calendar default:privapp:targetSdkVersion=29 1065,3003 0 29 com.android.providers.media 10039 0 /data/user/0/com.android.providers.media media:privapp:targetSdkVersion=29 2001,1065,1023,3003,3007,1024 0 1023 com.qti.service.colorservice 1000 0 /data/user/0/com.qti.service.colorservice platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 1 com.android.theme.icon.square 10020 0 /data/user/0/com.android.theme.icon.square default:targetSdkVersion=29 none 0 1 com.android.internal.systemui.navbar.gestural_wide_back 10019 0 /data/user/0/com.android.internal.systemui.navbar.gestural_wide_back default:targetSdkVersion=29 none 0 1 com.qualcomm.shutdownlistner 10076 0 /data/user/0/com.qualcomm.shutdownlistner platform:targetSdkVersion=29 none 0 29 com.android.wallpapercropper 10079 0 /data/user/0/com.android.wallpapercropper platform:privapp:targetSdkVersion=29 none 0 29 com.android.theme.color.cinnamon 10023 0 /data/user/0/com.android.theme.color.cinnamon default:targetSdkVersion=29 none 0 1 com.android.theme.icon_pack.rounded.systemui 10025 0 /data/user/0/com.android.theme.icon_pack.rounded.systemui default:targetSdkVersion=29 none 0 1 com.android.documentsui 10042 0 /data/user/0/com.android.documentsui platform:privapp:targetSdkVersion=28 none 0 29 com.android.externalstorage 10046 0 /data/user/0/com.android.externalstorage platform:privapp:targetSdkVersion=29 1023 0 29 com.android.htmlviewer 10056 0 /data/user/0/com.android.htmlviewer default:targetSdkVersion=29 none 0 29 com.android.companiondevicemanager 10061 0 /data/user/0/com.android.companiondevicemanager default:targetSdkVersion=29 3002,3001 0 29 com.android.quicksearchbox 10092 0 /data/user/0/com.android.quicksearchbox default:targetSdkVersion=28 3003 0 29 com.android.mms.service 1001 0 /data/user/0/com.android.mms.service platform:privapp:targetSdkVersion=24 1065,1005,3002,3003,3001,3007,2002,3006 0 29 com.android.providers.downloads 10039 0 /data/user/0/com.android.providers.downloads media:privapp:targetSdkVersion=29 2001,1065,1023,3003,3007,1024 0 29 com.android.messaging 10059 0 /data/user/0/com.android.messaging platform:targetSdkVersion=28 3003 0 10001040 com.android.theme.icon_pack.rounded.android 10002 0 /data/user/0/com.android.theme.icon_pack.rounded.android default:targetSdkVersion=29 none 0 1 ru.meefik.busybox 10102 0 /data/user/0/ru.meefik.busybox default:targetSdkVersion=28 none 0 46 com.qualcomm.qti.telephonyservice 10077 0 /data/user/0/com.qualcomm.qti.telephonyservice platform:targetSdkVersion=29 none 0 29 com.android.theme.icon_pack.circular.themepicker 10013 0 /data/user/0/com.android.theme.icon_pack.circular.themepicker platform:targetSdkVersion=29 none 0 1 com.android.providers.downloads.ui 10039 0 /data/user/0/com.android.providers.downloads.ui media:privapp:targetSdkVersion=29 2001,1065,1023,3003,3007,1024 0 29 com.android.pacprocessor 10062 0 /data/user/0/com.android.pacprocessor platform:targetSdkVersion=29 3003 0 29 com.android.simappdialog 10060 0 /data/user/0/com.android.simappdialog platform:targetSdkVersion=29 none 0 29 com.android.networkstack 1073 0 /data/user_de/0/com.android.networkstack network_stack:privapp:targetSdkVersion=29 3003 0 290000000 com.android.internal.display.cutout.emulation.tall 10003 0 /data/user/0/com.android.internal.display.cutout.emulation.tall default:targetSdkVersion=29 none 0 1 com.android.modulemetadata 10099 0 /data/user/0/com.android.modulemetadata default:targetSdkVersion=28 none 0 29 com.android.certinstaller 10067 0 /data/user/0/com.android.certinstaller platform:targetSdkVersion=29 none 0 29 com.android.theme.color.black 10004 0 /data/user/0/com.android.theme.color.black default:targetSdkVersion=29 none 0 1 com.android.carrierconfig 10082 0 /data/user/0/com.android.carrierconfig platform:privapp:targetSdkVersion=29 none 0 1 com.android.theme.color.green 10007 0 /data/user/0/com.android.theme.color.green default:targetSdkVersion=29 none 0 1 com.android.theme.color.ocean 10014 0 /data/user/0/com.android.theme.color.ocean default:targetSdkVersion=29 none 0 1 com.android.theme.color.space 10006 0 /data/user/0/com.android.theme.color.space default:targetSdkVersion=29 none 0 1 com.android.internal.systemui.navbar.threebutton 10018 0 /data/user/0/com.android.internal.systemui.navbar.threebutton default:targetSdkVersion=29 none 0 1 com.qti.qualcomm.datastatusnotification 1001 0 /data/user/0/com.qti.qualcomm.datastatusnotification platform:privapp:targetSdkVersion=24 1065,1005,3002,3003,3001,3007,2002,3006 0 29 android 1000 0 /data/system platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.android.contacts 10085 0 /data/user/0/com.android.contacts default:privapp:targetSdkVersion=28 3003 0 10731 com.android.camera2 10100 0 /data/user/0/com.android.camera2 default:targetSdkVersion=28 3003 0 20002000 com.android.theme.icon_pack.rounded.launcher 10005 0 /data/user/0/com.android.theme.icon_pack.rounded.launcher default:targetSdkVersion=29 none 0 1 com.android.egg 10064 0 /data/user/0/com.android.egg platform:targetSdkVersion=29 none 0 1 com.android.mtp 10039 0 /data/user/0/com.android.mtp media:privapp:targetSdkVersion=29 2001,1065,1023,3003,3007,1024 0 29 com.android.nfc 1027 0 /data/user/0/com.android.nfc platform:privapp:targetSdkVersion=29 3002,3003,3001 0 29 com.android.ons 1001 0 /data/user/0/com.android.ons platform:privapp:targetSdkVersion=24 1065,1005,3002,3003,3001,3007,2002,3006 0 29 com.android.stk 1001 0 /data/user_de/0/com.android.stk platform:privapp:targetSdkVersion=24 1065,1005,3002,3003,3001,3007,2002,3006 0 29 com.android.launcher3 10084 0 /data/user/0/com.android.launcher3 default:privapp:targetSdkVersion=29 none 0 29 com.android.backupconfirm 10040 0 /data/user/0/com.android.backupconfirm platform:privapp:targetSdkVersion=29 none 0 29 com.android.internal.systemui.navbar.twobutton 10011 0 /data/user/0/com.android.internal.systemui.navbar.twobutton default:targetSdkVersion=29 none 0 1 com.android.provision 10080 0 /data/user/0/com.android.provision platform:privapp:targetSdkVersion=29 none 0 29 com.qualcomm.qti.radioconfiginterface 1001 0 /data/user/0/com.qualcomm.qti.radioconfiginterface platform:privapp:targetSdkVersion=24 1065,1005,3002,3003,3001,3007,2002,3006 0 29 org.codeaurora.ims 1001 0 /data/user/0/org.codeaurora.ims platform:privapp:targetSdkVersion=24 1065,1005,3002,3003,3001,3007,2002,3006 0 1 com.android.statementservice 10045 0 /data/user/0/com.android.statementservice default:privapp:targetSdkVersion=29 3003 0 1 com.android.hotspot2 10063 0 /data/user/0/com.android.hotspot2 platform:targetSdkVersion=29 3003 0 29 com.android.settings.intelligence 10087 0 /data/user/0/com.android.settings.intelligence default:privapp:targetSdkVersion=29 none 0 29 com.android.calendar 10089 0 /data/user/0/com.android.calendar default:targetSdkVersion=28 3003 0 29 com.android.internal.systemui.navbar.gestural_extra_wide_back 10008 0 /data/user/0/com.android.internal.systemui.navbar.gestural_extra_wide_back default:targetSdkVersion=29 none 0 1 com.qualcomm.qti.auth.secureextauthservice 1000 0 /data/user/0/com.qualcomm.qti.auth.secureextauthservice platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 1 com.android.providers.settings 1000 0 /data/user_de/0/com.android.providers.settings platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.android.sharedstoragebackup 10050 0 /data/user/0/com.android.sharedstoragebackup platform:privapp:targetSdkVersion=29 1023 0 29 com.android.printspooler 10073 0 /data/user/0/com.android.printspooler default:targetSdkVersion=29 none 0 29 com.android.theme.icon_pack.filled.settings 10033 0 /data/user/0/com.android.theme.icon_pack.filled.settings default:targetSdkVersion=29 none 0 1 com.android.dreams.basic 10066 0 /data/user/0/com.android.dreams.basic default:targetSdkVersion=29 none 0 29 com.android.webview 10091 0 /data/user/0/com.android.webview default:targetSdkVersion=29 3003 0 373018655 com.android.se 1068 0 /data/user/0/com.android.se platform:privapp:targetSdkVersion=29 none 0 29 com.android.inputdevices 1000 0 /data/user_de/0/com.android.inputdevices platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.android.bips 10071 0 /data/user/0/com.android.bips default:targetSdkVersion=29 3003 0 29 com.android.theme.icon_pack.circular.settings 10035 0 /data/user/0/com.android.theme.icon_pack.circular.settings default:targetSdkVersion=29 none 0 1 com.android.musicfx 10052 0 /data/user/0/com.android.musicfx default:privapp:targetSdkVersion=29 3002 0 10400 com.android.cellbroadcastreceiver 10044 0 /data/user_de/0/com.android.cellbroadcastreceiver platform:privapp:targetSdkVersion=29 none 0 29 com.android.theme.icon.teardrop 10024 0 /data/user/0/com.android.theme.icon.teardrop default:targetSdkVersion=29 none 0 1 android.ext.shared 10058 0 /data/user_de/0/android.ext.shared platform:targetSdkVersion=29 none 0 1 com.android.onetimeinitializer 10078 0 /data/user/0/com.android.onetimeinitializer default:privapp:targetSdkVersion=29 none 0 29 com.android.server.telecom 1000 0 /data/user_de/0/com.android.server.telecom platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.android.keychain 1000 0 /data/user/0/com.android.keychain platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.android.printservice.recommendation 10068 0 /data/user/0/com.android.printservice.recommendation default:targetSdkVersion=29 3003 0 4 com.qualcomm.qti.rcsbootstraputil 1001 0 /data/user/0/com.qualcomm.qti.rcsbootstraputil platform:privapp:targetSdkVersion=24 1065,1005,3002,3003,3001,3007,2002,3006 0 25 com.android.dialer 10081 0 /data/user/0/com.android.dialer default:privapp:targetSdkVersion=28 3002,3003,3001 0 2900000 com.android.gallery3d 10098 0 /data/user/0/com.android.gallery3d default:targetSdkVersion=28 3003 0 40030 com.android.theme.icon_pack.filled.systemui 10031 0 /data/user/0/com.android.theme.icon_pack.filled.systemui default:targetSdkVersion=29 none 0 1 android.ext.services 10038 0 /data/user_de/0/android.ext.services platform:privapp:targetSdkVersion=29 none 0 290000000 com.android.calllogbackup 10036 0 /data/user/0/com.android.calllogbackup default:privapp:targetSdkVersion=29 1065 0 29 com.android.localtransport 1000 0 /data/user/0/com.android.localtransport platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.android.packageinstaller 10047 0 /data/user_de/0/com.android.packageinstaller platform:privapp:targetSdkVersion=29 1065 0 29 com.android.carrierdefaultapp 10070 0 /data/user/0/com.android.carrierdefaultapp platform:targetSdkVersion=29 3003 0 29 com.android.theme.font.notoserifsource 10017 0 /data/user/0/com.android.theme.font.notoserifsource default:targetSdkVersion=29 none 0 1 com.android.theme.icon_pack.filled.android 10016 0 /data/user/0/com.android.theme.icon_pack.filled.android default:targetSdkVersion=29 none 0 1 com.android.proxyhandler 10037 0 /data/user_de/0/com.android.proxyhandler platform:privapp:targetSdkVersion=29 3003 0 29com.android.theme.icon_pack.circular.systemui 10015 0 /data/user/0/com.android.theme.icon_pack.circular.systemui default:targetSdkVersion=29 none 0 1 com.android.inputmethod.latin 10101 0 /data/user_de/0/com.android.inputmethod.latin default:targetSdkVersion=28 none 0 28 org.chromium.webview_shell 10097 0 /data/user/0/org.chromium.webview_shell default:targetSdkVersion=28 3003 0 1 com.android.managedprovisioning 10041 0 /data/user/0/com.android.managedprovisioning platform:privapp:targetSdkVersion=29 3003 0 29 com.android.dreams.phototable 10095 0 /data/user/0/com.android.dreams.phototable default:targetSdkVersion=28 none 0 29 com.android.smspush 10072 0 /data/user/0/com.android.smspush default:targetSdkVersion=29 none 0 29 com.android.wallpaper.livepicker 10055 0 /data/user/0/com.android.wallpaper.livepicker platform:targetSdkVersion=29 none 0 29 com.android.apps.tag 10051 0 /data/user/0/com.android.apps.tag default:privapp:targetSdkVersion=29 none 0 101 com.android.theme.icon.squircle 10034 0 /data/user/0/com.android.theme.icon.squircle default:targetSdkVersion=29 none 0 1 com.android.storagemanager 10088 0 /data/user/0/com.android.storagemanager default:privapp:targetSdkVersion=29 1065 0 29com.android.bookmarkprovider 10065 0 /data/user/0/com.android.bookmarkprovider default:targetSdkVersion=29 none 0 29 com.android.settings 1000 0 /data/user_de/0/com.android.settings platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.qualcomm.qti.ims 1001 0 /data/user/0/com.qualcomm.qti.ims platform:privapp:targetSdkVersion=24 1065,1005,3002,3003,3001,3007,2002,3006 0 1 com.android.theme.icon_pack.filled.launcher 10030 0 /data/user/0/com.android.theme.icon_pack.filled.launcher default:targetSdkVersion=29 none 0 1 com.android.networkstack.permissionconfig 1073 0 /data/user/0/com.android.networkstack.permissionconfig network_stack:privapp:targetSdkVersion=29 3003 0 290000000 com.android.cts.ctsshim 10069 0 /data/user/0/com.android.cts.ctsshim default:targetSdkVersion=28 none 0 28 com.android.theme.icon_pack.circular.launcher 10001 0 /data/user/0/com.android.theme.icon_pack.circular.launcher default:targetSdkVersion=29 none 0 1 com.android.vpndialogs 10043 0 /data/user/0/com.android.vpndialogs platform:privapp:targetSdkVersion=29 none 0 29 com.android.email 10093 0 /data/user/0/com.android.email default:targetSdkVersion=24 3003 0 7008110 com.android.music 10094 0 /data/user/0/com.android.music default:targetSdkVersion=28 none 0 29 com.android.phone 1001 0 /data/user_de/0/com.android.phone platform:privapp:targetSdkVersion=24 1065,1005,3002,3003,3001,3007,2002,3006 0 29 com.android.shell 2000 0 /data/user_de/0/com.android.shell platform:privapp:targetSdkVersion=29 1065,3002,1023,1002,3010,3011 0 29 com.android.theme.icon_pack.filled.themepicker 10021 0 /data/user/0/com.android.theme.icon_pack.filled.themepicker platform:targetSdkVersion=29 none 0 1 com.android.wallpaperbackup 1000 0 /data/user/0/com.android.wallpaperbackup platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.example.myapplication 10103 1 /data/user/0/com.example.myapplication default:targetSdkVersion=33 none 1 1 com.android.providers.blockednumber 10036 0 /data/user_de/0/com.android.providers.blockednumber default:privapp:targetSdkVersion=29 1065 0 29 com.android.providers.userdictionary 10036 0 /data/user/0/com.android.providers.userdictionary default:privapp:targetSdkVersion=29 1065 0 29 com.android.emergency 10086 0 /data/user_de/0/com.android.emergency platform:privapp:targetSdkVersion=29 none 0 29 com.android.internal.systemui.navbar.gestural 10012 0 /data/user/0/com.android.internal.systemui.navbar.gestural default:targetSdkVersion=29 none 0 1 com.android.location.fused 1000 0 /data/user_de/0/com.android.location.fused platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.android.theme.color.orchid 10026 0 /data/user/0/com.android.theme.color.orchid default:targetSdkVersion=29 none 0 1 com.android.deskclock 10096 0 /data/user/0/com.android.deskclock default:targetSdkVersion=28 none 0 29 com.android.systemui 10083 0 /data/user_de/0/com.android.systemui platform:privapp:targetSdkVersion=29 1065,3002,1023,3001,3006 0 29 com.android.theme.color.purple 10022 0 /data/user/0/com.android.theme.color.purple default:targetSdkVersion=29 none 0 1 com.android.bluetoothmidiservice 10054 0 /data/user/0/com.android.bluetoothmidiservice platform:targetSdkVersion=29 3002 0 29 com.android.permissioncontroller 10049 0 /data/user_de/0/com.android.permissioncontroller platform:privapp:targetSdkVersion=29 none 0 290000000 com.qualcomm.fastdormancy 1000 0 /data/user/0/com.qualcomm.fastdormancy platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.android.traceur 10074 0 /data/user/0/com.android.traceur platform:targetSdkVersion=29 none 0 2 com.android.bluetooth 1002 0 /data/user_de/0/com.android.bluetooth platform:privapp:targetSdkVersion=29 3002,3003,3001,3007,1002,3010,3011,3005,1016 0 29 com.qualcomm.timeservice 1000 0 /data/user/0/com.qualcomm.timeservice platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.qualcomm.atfwd 1000 0 /data/user/0/com.qualcomm.atfwd platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 com.android.wallpaperpicker 10090 0 /data/user/0/com.android.wallpaperpicker default:targetSdkVersion=23 none 0 1 com.qualcomm.embms 10075 0 /data/user/0/com.qualcomm.embms platform:targetSdkVersion=24 3003 0 1 com.android.providers.contacts 10036 0 /data/user/0/com.android.providers.contacts default:privapp:targetSdkVersion=29 1065 0 29 com.android.captiveportallogin 10057 0 /data/user/0/com.android.captiveportallogin network_stack:targetSdkVersion=29 3003 0 290000000 com.android.theme.icon.roundedrect 10009 0 /data/user/0/com.android.theme.icon.roundedrect default:targetSdkVersion=29 none 0 1 com.android.internal.systemui.navbar.gestural_narrow_back 10028 0 /data/user/0/com.android.internal.systemui.navbar.gestural_narrow_back default:targetSdkVersion=29 none 0 1 com.android.theme.icon_pack.rounded.settings 10032 0 /data/user/0/com.android.theme.icon_pack.rounded.settings default:targetSdkVersion=29 none 0 1 android.auto_generated_rro_vendor__ 10000 0 /data/user/0/android.auto_generated_rro_vendor__ platform:targetSdkVersion=29 none 0 1 com.android.theme.icon_pack.circular.android 10027 0 /data/user/0/com.android.theme.icon_pack.circular.android default:targetSdkVersion=29 none 0 1 com.example.myapplication 10103 1 /data/user/0/com.example.myapplication default:targetSdkVersion=33 none 1 1 com.android.settings 1000 0 /data/user_de/0/com.android.settings platform:privapp:targetSdkVersion=23 1065,3002,1023,3003,3001 0 29 userid 的确定： 在app安装的时候，系统会给这个app自动分配一uid （如果在AndroidManifext.xml里使用android:sharedUserId属性指定，就用指定的） 数据存放路径： /data/user/0/com.example.myapplication ------> usr0 用户组：1065,3002,1023,3003,3001 3. 安卓用户----> 目标：安卓多用户模式 1、安卓用户表达使用者的意思 2、从linux角度： linux用户 多了u0 ，u10 -----------> 所以，安卓用户只是linux用户的子集 比如： 400%cpu 223%user 19%nice 66%sys 85%idle 2%iow 4%irq 2%sirq 0%host PID USER PR NI VIRT RES SHR S[%CPU] %MEM TIME+ ARGS 925 system 18 -2 7.7G 309M 242M S 179 8.1 9:39.59 system_server 16755 u10_a39 20 0 4.9G 63M 33M S 28.0 1.6 0:00.87 android.process.media 817 mediaex 20 0 258G 17M 11M S 14.6 0.4 0:00.75 media.extractor aextractor 819 media 20 0 74M 14M 11M S 14.3 0.3 0:00.86 mediaserver 2020 u0_a84 20 0 5.1G 115M 67M S 2.6 3.0 0:54.69 com.android.launcher3 16952 root 20 0 35M 2.9M 1.6M R 2.3 0.0 0:00.16 top 640 root 20 0 5.1G 88M 63M S 2.3 2.3 0:02.19 zygote64 784 shell 20 0 135M 4.2M 2.6M S 1.6 0.1 2:52.00 adbd --root_seclabel=u:r:su:s0 677 nobody 20 0 35M 2.4M 1.7M S 1.6 0.0 0:00.25 ashmemd 1708 radio 20 0 5.4G 76M 44M S 1.3 2.0 0:25.09 com.android.phone 476 logd 30 10 155M 20M 1.7M S 1.3 0.5 22:41.77 logd 16953 u10_a89 20 0 4.8G 51M 24M S 1.0 1.3 0:00.07 com.android.calendar 16870 u10_a81 20 0 4.9G 55M 27M S 1.0 1.4 0:00.15 com.android.dialer 16666 u10_a96 20 0 4.9G 53M 26M S 1.0 1.4 0:00.14 com.android.deskclock 16702 u10_a73 20 0 4.8G 48M 22M S 0.6 1.2 0:00.07 com.android.printspooler 16617 root 20 0 0 0 0 R 0.6 0.0 0:00.12 [kworker/u8:7] 16553 root 20 0 0 0 0 S 0.6 0.0 0:02.64 [kworker/u8:3] 15882 root RT 0 0 0 0 S 0.6 0.0 0:10.91 [kschedfreq:2] 13000 root 0 -20 0 0 0 S 0.6 0.0 0:00.00 [kworker/u9:2] 2445 nfc 20 0 5.0G 75M 41M S 0.6 2.0 0:08.01 com.android.nfc 3.1. 维测： 查看安卓用户： sailfish:/etc # pm list users Users: UserInfo{0:机主:13} running 4. 深入理解Android系统多用户机制 深入理解Android系统多用户机制android 多用户Jason_Lee155的博客-CSDN博客 5. 多用户起来的时机 UserController.java --------> AMS的一个类 UserController的finishUserUnlockedCompleted 6. 一些结论： 新增一个多用户，system_process永远只有一份。但是有很多系统应用会复制多分。 验证：pstree + 线程号 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/wayland/kwin.html":{"url":"coding/wayland/kwin.html","title":"Kwin","keywords":"","body":"1. Kwin1.1. kwin的架构和原理1.2. kwin进程展开1.3. wayland详解1.4. kwin源码在线2. kwin源码阅读2.1. 窗口管理之焦点窗口：2.2. 窗口管理2.3. 输入Input2.4. 输入法：2.4.1. 虚拟键盘florence2.4.2. 虚拟键盘Onboard2.4.3. 其他：没有虚拟键盘的2.4.4. 一些结论2.5. 参考：3. KDE 圆角3.1. LightlyShaders3.2. KDE-Rounded-Corners3.3. KDE-Rounded-Corners4. kwin的插件特效5. 0层6. Wayland7. weston8. 一些理解9. TODO:10. 2023-02-24 如何开发一个 kwin 特效插件11. KDE-Rounded-Corners特效11.1. TODO11.2. vertex着色器11.3. fragment着色器11.4. 最终KDE的shapecorners插件11.4.1. 产物12. GDB kwin的架构和原理 kwin进程展开 wayland详解 kwin源码在线 kwin源码阅读 窗口管理之焦点窗口： 窗口管理 输入Input 输入法： 虚拟键盘florence 虚拟键盘Onboard 其他：没有虚拟键盘的 一些结论 参考： KDE 圆角 LightlyShaders KDE-Rounded-Corners KDE-Rounded-Corners kwin的插件特效 0层 Wayland weston 一些理解 TODO: 2023-02-24 如何开发一个 kwin 特效插件 KDE-Rounded-Corners特效 TODO vertex着色器 fragment着色器 最终KDE的shapecorners插件 产物 GDB 1. Kwin KDE如何处理窗口管理？-腾讯云开发者社区 (tencent.com) -------> 没啥内容 https://wenku.baidu.com/view/540df51eac1ffc4ffe4733687e21af45b307fefa.html?_wkts_=1699511709596&bdQuery=kwin+架构 https://www.linuxprobe.com/kwin-kde.html KWin即将内置高级窗口分屏布局 https://blog.csdn.net/a8039974/article/details/122867167 wayland详解 -----> 好文， 虽然是Weston，但是应该与Kwin一样，都是实现了wayland协议 1.1. kwin的架构和原理 是什么？ kde桌面环境的，图形架构 Kwin主要由以下几个部分组成: 1.渲染引擎:Kwin使用OpenGL作为其渲染引擎，它负责将窗口和桌面渲染为图像。 ----> 说法有误，render在应用内。合成在 KWin KWin 是一个 X Window System 的窗口管理器和一个 Wayland 合成器 2.事件处理: Kwin通过Qt的事件系统来接收和处理用户输入。 3.窗口管理: Kwin负责管理窗口的创建、销毁和移动 4.特效和过渡:Kwin提供了许多特效和过渡效果，例如窗口淡入淡出、窗口滑动等 Kwin的原理是，当用户打开一个窗口时，Kwin会创建一个新的窗口对象，并为其分配一个唯一的标识符。然后，Kwin 会根据用户的操作和系统状态来管理窗口的显示和隐藏。当用户点击窗口时，Kwin会将其激活，并将其移动到屏幕中央。 此外，Kwin还提供了许多特效和过渡效果，使得用户能够更轻松地使用计算机 SwitchEvent: 切换事件 (窗门切换) SwitchEvent 类通常包含以下属性: 。SwitchEvent::Type: 表示切换事件的类型，可以是切换到上一个窗口、下一个窗口或特定窗口的事件 。SwitchEvent::Modifiers: 表示切换事件时使用的修饰键，例如 Alt、Shift 等 。SwitchEvent::Direction: 表示切换的方向，可以是向前切换或向后切换 。SwitchEvent::Window: 表示切换事件所涉及的窗口对象 1.2. kwin进程展开 进�� USER PR NI VIRT RES SHR � %CPU %MEM TIME+ COMMAND 15941 chen 20 0 5494012 220668 154216 S 2.2 2.8 4:08.60 QXcbEventReader // -------> 事件 15940 chen 20 0 5494012 220668 154216 S 1.9 2.8 4:23.12 kwin_x11 // ------->主线程，合成也在这里？ 16156 chen 20 0 5494012 220668 154216 S 0.3 2.8 1:50.21 llvmpipe-0 16163 chen 20 0 5494012 220668 154216 S 0.3 2.8 1:05.68 llvmpipe-7 16166 chen 20 0 5494012 220668 154216 S 0.3 2.8 1:06.32 llvmpipe-10 16169 chen 20 0 5494012 220668 154216 S 0.3 2.8 1:34.99 llvmpipe-13 16009 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:01.50 QDBusConnection 16154 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.06 QQmlThread 16157 chen 20 0 5494012 220668 154216 S 0.0 2.8 1:20.53 llvmpipe-1 16158 chen 20 0 5494012 220668 154216 S 0.0 2.8 1:18.47 llvmpipe-2 16159 chen 20 0 5494012 220668 154216 S 0.0 2.8 1:16.29 llvmpipe-3 16160 chen 20 0 5494012 220668 154216 S 0.0 2.8 1:13.13 llvmpipe-4 16161 chen 20 0 5494012 220668 154216 S 0.0 2.8 1:11.32 llvmpipe-5 16162 chen 20 0 5494012 220668 154216 S 0.0 2.8 1:08.64 llvmpipe-6 16164 chen 20 0 5494012 220668 154216 S 0.0 2.8 1:06.42 llvmpipe-8 16165 chen 20 0 5494012 220668 154216 S 0.0 2.8 1:04.73 llvmpipe-9 16167 chen 20 0 5494012 220668 154216 S 0.0 2.8 1:09.25 llvmpipe-11 16168 chen 20 0 5494012 220668 154216 S 0.0 2.8 1:14.88 llvmpipe-12 16170 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16171 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16172 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16173 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16174 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16175 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16176 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16177 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16178 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16179 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16180 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16181 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16182 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16183 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 16187 chen 20 0 5494012 220668 154216 S 0.0 2.8 0:00.00 kwin_x11 注意： kwin相当于安卓的框架层，wms与合成器 KDE，是launcher，桌面环境 1.3. wayland详解 https://blog.csdn.net/a8039974/article/details/122867167 TODO 1.4. kwin源码在线 https://invent.kde.org/plasma/kwin/-/blob/master/src/inputmethod.cpp 2. kwin源码阅读 2.1. 窗口管理之焦点窗口： 结构：stacking_order 窗口栈结构 // layers.cpp stacking_order: 增删改：addWaylandWindow、updateStackingOrder、removeFromStack、removeWindow 查：findWindowToActivateOnDesktop、findToplevel 使用： //input.cpp const QList &stacking = Workspace::self()->stackingOrder(); // -------> 维护了一个栈，大概率焦点窗口，就是 一句话核心： window = input()->findToplevel(position()); // Top窗口，大概率认为是focus的 使用层： InputDeviceHandler::setHover(Window *window) ----> // 传给Input模块 InputDeviceHandler::setFocus(Window *window) 2.2. 窗口管理 Wayland/Weston 窗口管理 窗口管理涉及的内容： 窗口堆栈的改变，focus的变化等 与安卓对比： 1、Wayland/Weston 没有安卓所谓的AMS（Activity的创建与管理、进程的创建与管理） -------> 可见，窗口管理，才是必须的 2、窗口堆栈： 对于安卓，没有，只有Activity的堆栈（究其根因：安卓是单窗口系统）；对于 Wayland，是有的窗口堆栈 -------> linux窗口管理中的（窗口堆栈），一部分被AMS承担了 3、窗口的切换： 窗口管理的操作（如窗口堆栈的改变，focus的改变） https://blog.csdn.net/a8039974/article/details/122867167 https://blog.csdn.net/qqzhaojianbiao/article/details/129790817?spm=1001.2014.3001.5502 Wayland窗口系统 2.3. 输入Input 参考： 1、 https://blog.csdn.net/qqzhaojianbiao/article/details/130932031 KWin事件总结和相关类介绍 -------> 好文 2、收藏图 主要类： TouchInputRedirection input.cpp InputEventFilter InputKeyboardFilter 2.4. 输入法： 2.4.1. 虚拟键盘florence 参考: https://www.xmodulo.com/onscreen-virtual-keyboard-linux.html virtual keyboard --------> 验证ok，可以输入（仅限英文） 启动： florence 结构： florence是一个单独进程，类似service ------> 目前手动执行命令启动（不同于安卓） 一些基本情况： florence 目前是最好的 + 开源的 https://www.linuxlinks.com/best-free-open-source-virtual-keyboards/ kde环境下可运行 2.4.2. 虚拟键盘Onboard 2.4.3. 其他：没有虚拟键盘的 https://www.jianshu.com/p/563b1f8aff97 https://medium.com/@damko/a-simple-humble-but-comprehensive-guide-to-xkb-for-linux-6f1ad5e13450 kde下应用如何支持输入法？ https://planet.kde.org/weng-xuetian-2023-01-06-how-to-make-your-application-support-input-method-under-linux/ How to make your application support Input method under Linux？ 1、Create a connection to input method service. 2、Tell input method, you want to communicate with it. 3、Keyboard event being forwarded to input method 4、input method decide how key event is handled. 5、Receives input method event that carries text that you need to show, or commit to the application.6、 6、Tell input method you are done with text input 7、Close the connection when your application ends, or the relevant widget destructs. ---------------> 流程跟安卓一模一样！必然，结构决定的 不一样的点：linux侧这些是APP做的，安卓是IMMS做的 2.4.4. 一些结论 从代码来看，kwin依赖于QT QT源码下载： https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.15/5.15.0/single/ 参考： https://www.cnblogs.com/kn-zheng/p/17689855.html 2.5. 参考： https://blog.csdn.net/qqzhaojianbiao 好文： KWin事件总结和相关类介绍 Wayland中跨进程调用过程 Weston中shm window渲染 Wayland窗口系统 https://blog.csdn.net/qqzhaojianbiao/article/details/129734727?spm=1001.2014.3001.5502 Weston介绍 3. KDE 圆角 3.1. LightlyShaders git clone https://github.com/Luwx/LightlyShaders cd LightlyShaders; mkdir qt5build; cd qt5build; cmake ../ -DCMAKE_INSTALL_PREFIX=/usr -DQT5BUILD=ON make //---------> 这一步及前面是OK的 sudo make install (kwin_x11 --replace &) 疑问： 必须kwin_x11？？？！！！ 编译遇到的错误，缺少Qt5OpenGL： 报错： CMake Error at /usr/lib/arm-linux-gnueabihf/cmake/Qt5/Qt5Config.cmake:28 (find_package): Could not find a package configuration file provided by \"Qt5OpenGL\" with any of the following names: Qt5OpenGLConfig.cmake qt5opengl-config.cmake Add the installation prefix of \"Qt5OpenGL\" to CMAKE_PREFIX_PATH or set \"Qt5OpenGL_DIR\" to a directory containing one of the above files. If \"Qt5OpenGL\" provides a separate development package or SDK, be sure it has been installed. Call Stack (most recent call first): CMakeLists.txt:13 (find_package) 办法： sudo apt install libqt5opengl5-dev 参考：https://github.com/sonic-pi-net/sonic-pi/issues/2032 3.2. KDE-Rounded-Corners git clone https://github.com/alex47/KDE-Rounded-Corners 3.3. KDE-Rounded-Corners https://github.com/matinlotfali/KDE-Rounded-Corners 注意： 4. kwin的插件特效 5. 0层 6. Wayland 参考：Wayland与Weston简介_weston linux-CSDN博客 -------> 好文 7. weston 8. 一些理解 wayland是协议--------------kwin和weston都一样 比如：wayland-client-protocol.h 文件（比如wl_surface_set_input_region 接口，指定surface和region分发事件） 9. TODO: windowDamaged(KWin::EffectWindow *w): 10. 2023-02-24 如何开发一个 kwin 特效插件 https://www.jianshu.com/p/c6dc9771414d 2023-02-24 如何开发一个 kwin 特效插件 https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwjy9eaQmpmFAxXMZvUHHelwAG8QFnoECBEQAQ&url=https%3A%2F%2Fblog.justforlxz.com%2F2023%2F06%2F25%2FHow-to-develop-a-kwin-special-effects-plugin%2F&usg=AOvVaw0yj3iA9Tu9Mce_3PNgMWTI&opi=89978449 开发一个KWin 特效插件 11. KDE-Rounded-Corners特效 https://github.com/matinlotfali/KDE-Rounded-Corners -----------> 功能：圆角+阴影 11.1. TODO 着色器代码本身可以加日志嘛？ glGetShaderInfoLog获取到的日志为空的 https://www.cnblogs.com/hwx0000/p/12733649.html OpenGL常犯的错误及查错方法总结 ---------> 策略： （1）用安卓app去检查frag文件 （2）寻找opengl源码 （3）二分法去逼：二分法编译 11.2. vertex着色器 cpp中默认的vertexSource: #version 300 es in vec4 position; in vec4 texcoord; out vec2 texcoord0; uniform mat4 modelViewProjectionMatrix; void main() { texcoord0 = texcoord.st; gl_Position = modelViewProjectionMatrix * position; } 11.3. fragment着色器 #version 300 es precision highp float; uniform sampler2D sampler; uniform sampler2D corner; in vec2 texcoord0; out vec4 fragColor; void main(void) { vec4 tex = texture(sampler, texcoord0); vec4 texCorner = texture(corner, texcoord0); tex.a = texCorner.a; fragColor = tex; } ------------------> 生效了，与Dim Inactive特效有关联 cpp中默认的fragment： #version 300 es precision highp float; uniform sampler2D sampler; in vec2 texcoord0; out vec4 fragColor; void main(void){ vec2 texcoordC = texcoord0; fragColor = texture(sampler, texcoordC); } ------------------> 生效了，与Dim Inactive特效有关联 遇到的问题： 接口：glGetShaderiv .h .so: aarch64-poky-linux/kdelibs4support/5.108.0-r0/recipe-sysroot/usr/lib64/libEGL.so cpp: ? OpenGL ES着色器文件frag，关键点： 1、报错： Error compiling shader:[ERROR: 0:35: 'texture2D' : type is for Vulkan api only //【】---------> texture2D，没有这个接口，应该是texture() ERROR: 0:35: 'texture2D' : cannot construct this type ERROR: 0:35: 'constructor' : too many arguments ERROR: 0:35: 'a' : field selection requires structure, vector, or matrix on left hand side ERROR: 0:53: '+' : wrong operand types no operation '+' exists that takes a left-hand operand of type 'float' and a right operand of type 'const int' (or there is no acceptable conversion)//【】：float + int，统一换成 float + float ERROR: 0:54: 'clamp' : no matching overloaded function found ERROR: 0:56: '2、需要设置着色器精度：浮点数精度 precision highp float; -验证frag的技巧： 可以在安卓下使用 + 验证，是通用的 11.4. 最终KDE的shapecorners插件 文件存放位置： frag： /usr/share/kwin/shaders/shapecorners.frag /usr/share/kwin/shaders/shapecorners_core.frag metadata.json： /usr/share/kwin/builtin-effects/kwin4_effect_shapecorners/metadata.json /usr/share/kwin/effects/kwin4_effect_shapecorners/metadata.json ---------> 删 // /usr/share/kwin/shaders/shapecorners_core.frag 最终ok版本 #version 300 es precision highp float; uniform sampler2D front; // The painted contents of the window. uniform float radius; // The thickness of the outline in pixels specified in settings. uniform vec2 windowSize; // Containing `window->frameGeometry().size()` uniform vec2 windowExpandedSize; // Containing `window->expandedGeometry().size()` uniform bool disableRoundedTile; uniform vec2 windowTopLeft; /* The distance between the top-left of `expandedGeometry` and * the top-left of `frameGeometry`. When `windowTopLeft = {0,0}`, it means * `expandedGeometry = frameGeometry` and there is no shadow. */ uniform vec4 shadowColor; // The RGBA of the shadow color specified in settings. uniform float shadowSize; // The shadow size specified in settings. uniform vec4 outlineColor; // The RGBA of the outline color specified in settings. uniform float outlineThickness; // The thickness of the outline in pixels specified in settings. uniform vec4 modulation; // This variable is assigned and used by KWinEffects used for proper fading. uniform float saturation; // This variable is assigned and used by KWinEffects used for proper fading. in vec2 texcoord0; // The XY location of the rendering pixel. Starting from {0.0, 0.0} to {1.0, 1.0} out vec4 fragColor; // The RGBA color that can be rendered vec2 tex_to_pixel(vec2 texcoord) { return vec2(texcoord0.x * windowExpandedSize.x - windowTopLeft.x, (1.0-texcoord0.y)* windowExpandedSize.y - windowTopLeft.y); } vec2 pixel_to_tex(vec2 pixelcoord) { return vec2((pixelcoord.x + windowTopLeft.x) / windowExpandedSize.x, 1.0-(pixelcoord.y + windowTopLeft.y) / windowExpandedSize.y); } bool isDrawingShadows() { return windowSize != windowExpandedSize && shadowColor.a > 0.0; } bool isDrawingOutline() { vec2 one_edge = vec2(windowSize.x/2.0, 0.0); return texture(front, pixel_to_tex(one_edge)).a > 0.5 && outlineColor.a > 0.0 && outlineThickness > 0.0; } float parametricBlend(float t) { float sqt = t * t; return sqt / (2.0 * (sqt - t) + 1.0); } /* * \\\\brief This function generates the shadow color based on the distance_from_center * \\\\param distance_from_center: Distance of the rendering point and the reference point that is being used for rounding corners. * \\\\return The RGBA color to be used for shadow. */ vec4 getShadowColor(float distance_from_center) { if(!isDrawingShadows()) return vec4(0.0,0.0,0.0,0.0); float percent = -distance_from_center/shadowSize + 1.0; percent = clamp(percent, 0.0, 1.0); percent = parametricBlend(percent); if(percent 0.1 && abs(sin(angle)) > 0.1; vec2 center; float distance_from_center; vec4 c; float r; if (disableRoundedTile) { r = outlineThickness; center = start + r * vec2(cos(angle), sin(angle)); distance_from_center = distance(coord0, center); c = tex; } else { r = radius; center = start + radius * (diagonal? sqrt(2.0) : 1.0) * vec2(cos(angle), sin(angle)); distance_from_center = distance(coord0, center); c = getShadowColor(distance_from_center); } if(isDrawingOutline()) { vec4 outlineOverlay = vec4(mix(tex.rgb, outlineColor.rgb, outlineColor.a), tex.a); if (distance_from_center windowSize.x - r) tex = shapeCorner(coord0, tex, vec2(windowSize.x, 0), radians(135.0)); // Section TR else if (coord0.y windowSize.y - r) { if (coord0.x windowSize.x - r) tex = shapeCorner(coord0, tex, vec2(windowSize.x, windowSize.y), radians(225.0)); // Section BR else if (coord0.y > windowSize.y - outlineThickness) tex = shapeCorner(coord0, tex, vec2(coord0.x, windowSize.y), radians(270.0)); // Section B } else { if (coord0.x windowSize.x - r) tex = shapeCorner(coord0, tex, vec2(windowSize.x, coord0.y), radians(180.0)); // Section R // For section x, the tex is not changing } // Apply the saturation and modulation. This is essential for proper fades in other KWin effects. if (saturation != 1.0) { vec3 desaturated = tex.rgb * vec3( 0.30, 0.59, 0.11 ); desaturated = vec3( dot( desaturated, tex.rgb )); tex.rgb = tex.rgb * vec3( saturation ) + desaturated * vec3( 1.0 - saturation ); } tex *= modulation; // Send to output fragColor = tex; } // 5.0 ; vertex插件没有定义，使用的是代码里硬编码的： #version 300 es in vec4 position; in vec4 texcoord; out vec2 texcoord0; uniform mat4 modelViewProjectionMatrix; void main(){ texcoord0 = texcoord.st; gl_Position = modelViewProjectionMatrix * position; } 11.4.1. 产物 so位置： sh-3.2# find /usr -name \"*shapecorners*\" /usr/share/kwin/effects/kwin4_effect_shapecorners /usr/share/kwin/builtin-effects/kwin4_effect_shapecorners /usr/share/kwin/shaders/shapecorners.frag /usr/share/kwin/shaders/shapecorners_core.frag /usr/lib64/plugins/kwin/effects/configs/kwin_shapecorners_config.so ------> 这里 /usr/lib64/plugins/kwin/effects/plugins/kwin4_effect_shapecorners.so ------> 这里 主要metadata.json位置：（次要的没导入，也ok） /usr/share/kwin/builtin-effects/kwin4_effect_shapecorners/metadata.json /usr/share/kwin/effects/kwin4_effect_shapecorners/metadata.json //【1】 -------> 注意：似乎【1】路径也要加，先加后删除！ ok的脚本： push.bat adb shell mkdir -p /usr/share/kwin/effects/kwin4_effect_shapecorners adb shell mkdir -p /usr/share/kwin/builtin-effects/kwin4_effect_shapecorners ::adb push metadata.json /usr/share/kwin/effects/kwin4_effect_shapecorners/ adb push metadata.json /usr/share/kwin/builtin-effects/kwin4_effect_shapecorners/ adb shell mkdir -p /usr/lib64/plugins/kwin/effects/configs/ adb shell mkdir -p /usr/lib64/plugins/kwin/effects/plugins/ adb push kwin_shapecorners_config.so /usr/lib64/plugins/kwin/effects/configs/ adb push kwin4_effect_shapecorners.so /usr/lib64/plugins/kwin/effects/plugins/ adb shell mkdir -p /usr/share/kwin/shaders/ adb push shapecorners.frag /usr/share/kwin/shaders/ adb push shapecorners_core.frag /usr/share/kwin/shaders/ ::使能 ::kwriteconfig5 --file kwinrc --group Plugins --key kwin4_effect_shapecornersEnabled true ::qdbus org.kde.KWin /KWin reconfigure pause 12. GDB console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/多线程/":{"url":"coding/多线程/","title":"多线程","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/多线程/多线程的模型.html":{"url":"coding/多线程/多线程的模型.html","title":"多线程的模型","keywords":"","body":"1. 模型（不谈代码）2. RPC的架构3. RPC的前提------序列化4. vialite的作用 TODO 模型（不谈代码） RPC的架构 RPC的前提------序列化 vialite的作用 TODO 1. 模型（不谈代码） 2. RPC的架构 https://blog.csdn.net/qq_44279357/article/details/127075107 Cap‘n Proto 介绍（有例子） --------> 提取图 https://blog.csdn.net/weixin_44225613/article/details/120267975 使用gRPC进行跨语言服务通信 Protocol Buffers(Protobuf) 作为序列化框架！！！！ 3. RPC的前提------序列化 无拷贝序列化： 无拷贝序列化 ｜ 青训营笔记 - 掘金 (juejin.cn) https://juejin.cn/post/7204872302638104632 4. vialite的作用 TODO 原理 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/多线程/线程池与binder线程池.html":{"url":"coding/多线程/线程池与binder线程池.html","title":"线程池与binder线程池","keywords":"","body":"1. 角度：2. 线程池2.1. 疑问：2.2. 模型：2.3. 池子具体实现2.3.1. c++2.3.2. java2.4. 参考：2.5. 语言级-----Java并发编程中四种线程池3. binder线程池4. Binder4.1. 补充：Binder的 同步调用 / 异步调用4.2. Q & A4.3. 一些数据4.4. 从驱动角度 ----> 看Binder 线程池 疑问： 模型： 池子具体实现 c++ java 参考： 语言级-----Java并发编程中四种线程池 binder线程池 Binder 补充：Binder的 同步调用 / 异步调用 Q & A 一些数据 从驱动角度 ----> 看Binder 1. 角度： 结构 模型 设计模式 https://zhuanlan.zhihu.com/p/568078030 线程池的实现 https://zhuanlan.zhihu.com/p/644170642?utm_id=0 携程ANR 优化实践 - Binder开辟线程数过多导致主线程ANR异常 2. 线程池 目标： new Thread 定位： 非功能型\\优化型 2.1. 疑问： a、从java角度来说，就是一个对象 b、对于linux系统来说，是一个进程，是一个运行 ---------> 1、如何保证不退出的？内部有没有 死循环？ 2、从池子角度：池子如何管理这些 运行的？ 从Thread角度：池，就是new Thread的一种方式 3、如果不使用会怎么样？ new Thread： （1）从整体的硬件角度： 减小创建和销毁开销 （自然） 4、Q: 使用池子的具体场景有哪些？ A： 任何需要新new Thread的场景 从模型来看，哪些必然需要使用池子？ 线程池的本质思想： 复用思想（这里是复用线程） 模型： 结构： 线程池 是 进程级别的东西 -----------> 一个进程，创建一个（足够了） 设计模式： 生产者消费者模式 或 领导者跟随者模式 线程过多会带来调度开销 --> 具体指的是什么 创建开销 防止过分调度 线程数过多会导致额外的线程切换开销 ->不懂 小的疑问： Q: 向Pool里添加Task后，唤醒线程去取Task执行 -------> 那么，唤醒了几个线程？ Q: 同Handler一样，唤醒是核心。唤醒机制是怎样的？ 2.2. 模型： 图见： https://zhuanlan.zhihu.com/p/568078030 线程池的实现 从模型图，必然的结论： 1、线程池里的线程，都在死循环 代码证明 hideContent https://zhuanlan.zhihu.com/p/568078030 // 线程池中的线程（消费者）该干的事儿 static void thread_worker(void thrd_pool) { thread_pool_t pool = (thread_pool_t)thrd_pool; task_queue_t *que; task_t task; for (;;) { pthread_mutex_lock(&(pool->mutex)); que = &pool->task_queue; while (que->count == 0 && pool->closed == 0) { // pthread_mutex_unlock(&(pool->mutex)) // 阻塞在 condition // =================================== // 解除阻塞 // pthread_mutex_lock(&(pool->mutex)); pthread_cond_wait(&(pool->condition), &(pool->mutex)); } 2、 从模型结构，可以看出： 整个事件流 反向，就是Handler机制： 多个线程 抛Task --------> 一个线程 执行 线程池： 一个(多个)线程 抛Task --------> 多个线程 执行 自然， 线程池 和 Handler机制 在 结构上，是 极大相似的 --------------------> 代码实现上，必然也极大相似 2.3. 池子具体实现 2.3.1. c++ https://blog.csdn.net/jisuanji111111/article/details/121811803?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-121811803-blog-126914327.235^v39^pc_relevant_anti_vip&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-121811803-blog-126914327.235^v39^pc_relevant_anti_vip&utm_relevant_index=8 操作系统--线程池（C++） 已经有的库： ThreadPool（https://github.com/progschj/ThreadPool）- 是一个轻量级的线程池，只依赖于C++11的标准库，非常易于使用和集成PPL（https://docs.microsoft.com/zh-cn/cpp/parallel/concrt/collection-of-concrt-task-scheduler-samples?view=msvc-160）- 并行模式库（Parallel Patterns Library）是由Microsoft开发的一个高性能并行库，其中包括一个高效的线程池框架QtConcurrent（http://doc.qt.io/qt-5/qtconcurrent-index.html）- Qt链接：https://www.zhihu.com/question/397916107/answer/3092414094 Folly ------> 依赖太重 自己实现，见： https://blog.csdn.net/jisuanji111111/article/details/121811803?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-121811803-blog-126914327.235^v39^pc_relevant_anti_vip&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-121811803-blog-126914327.235^v39^pc_relevant_anti_vip&utm_relevant_index=8 操作系统--线程池（C++） 安卓的binder线程池，用的是？ 2.3.2. java 已经有的库： https://zhuanlan.zhihu.com/p/644065710 Java线程——如何正确使用Java线程池 2.4. 参考： https://blog.csdn.net/jisuanji111111/article/details/121811803?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-121811803-blog-126914327.235^v39^pc_relevant_anti_vip&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-121811803-blog-126914327.235^v39^pc_relevant_anti_vip&utm_relevant_index=8 操作系统--线程池（C++） https://zhuanlan.zhihu.com/p/636156144 轻松掌握C++线程池：从底层原理到高级应用 https://zhuanlan.zhihu.com/p/568078030 线程池的实现 https://zhuanlan.zhihu.com/p/644170642?utm_id=0 携程ANR 优化实践 - Binder开辟线程数过多导致主线程ANR异常 https://blog.csdn.net/weixin_45144862/article/details/126914327 C++线程池 2.5. 语言级-----Java并发编程中四种线程池 https://blog.csdn.net/riemann_/article/details/97617432 3. binder线程池 一对多问题（多执行）情况： 同时调用太多了问题（不限于binder线程池，甚至不限于线程池）： 4. Binder 4.1. 补充：Binder的 同步调用 / 异步调用 -------> 代码角度，区别： 是否有oneway 所有同步调用都存在的问题（不限于Binder）: 等待（即阻塞） 所有异步都存在的问题： 爆了？ https://blog.csdn.net/shusuanly/article/details/128924394 Binder线程数耗尽引起系统异常分析 解决办法： （以Handler 为例子） 1、弄一个队列，排队 2、队列满了就不要了，拒绝 办法能解决上述问题嘛？ 写demo主动构造异常 ---------> 不要空对空 地分析问题 -------> 问题demo集 TODO: binder线程数最大16，能不能增加数量，以解决binder线程池耗尽的影响？ https://blog.csdn.net/software_test010/article/details/125608505 APP性能设计及优化专题——影响性能的不良实现 4.2. Q & A binder为啥是单向？ 图： https://blog.csdn.net/software_test010/article/details/125608505 安全性角度： app进程也可以使用mmap映射同一块区域，但是前面我们已经说过为了保证安全性，app进程就不要实现mmap了 具体图，见：https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650275124&idx=1&sn=169ff3356aee27ee6b4d9e47bbe45423&chksm=88630c5bbf14854d6592147b7a6adac7de9ab3244a474455b33059cf19bb33a7c36792410d3d&scene=27 Binder机制总结之驱动层分析 -----------> 极好的文章！！！！ 4.3. 一些数据 Binder 通信的数据大小限制： 图： https://zhuanlan.zhihu.com/p/666600922 --------------------> TODO： 为啥是这个数据？ https://blog.csdn.net/software_test010/article/details/125608505 APP性能设计及优化专题——影响性能的不良实现 4.4. 从驱动角度 ----> 看Binder Binder机制总结之驱动层分析 (qq.com) https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650275124&idx=1&sn=169ff3356aee27ee6b4d9e47bbe45423&chksm=88630c5bbf14854d6592147b7a6adac7de9ab3244a474455b33059cf19bb33a7c36792410d3d&scene=27 Android-深入理解Binder（一）_/dev/binder-CSDN博客 https://blog.csdn.net/weixin_43580319/article/details/123994514 驱动文件 /dev/binder ： 1、/dev/binder 是 驱动文件 ，在内存中 （内存中的虚拟文件系统（Virtual File System，VFS）） ----> 自然，不涉及硬盘的读写 2、驱动部分 ------> 在内核中实现 3、从驱动来看： /dev/binder 本质上是与驱动的 接口 ： 程序 -----> open(\"/dev/binder\") -----> 驱动 ？？？？？？ 4、从内核角度：/dev/binder 是一个设备 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/文件系统结构/文件系统结构.html":{"url":"coding/文件系统结构/文件系统结构.html","title":"文件系统结构","keywords":"","body":"1. 目录2. sd卡挂载的点（安卓）3. 分区Linux 目录 sd卡挂载的点（安卓） 分区Linux 1. 目录 2. sd卡挂载的点（安卓） 参考： https://blog.csdn.net/Ian22l/article/details/105974356 https://www.jianshu.com/p/4fd23c4a1173 Android SdCard路径说明 /sdcard -----> /storage/self/primary //注：其中，sdcard是软连接 /storage/self/primary -----> /mnt/user/0/primary /mnt/user/0/primary -----> /storage/emulated/0/ 结论： 1、最终连接到 /storage/emulated/0 2、这是真实的sd卡，挂载的linux目录 目的： 设计角度，为啥要有 /sdcard 指向 实际挂载点呢？ 1. **统一路径：** 提供一个统一的路径可以简化应用程序和用户对存储的访问。无论设备是否有内置存储或外部SD卡，开发者和用户都可以使用相同的路径来引用主要的用户存储。 2. **透明性：** Android系统可以动态地切换存储位置，例如，用户可能更换了SD卡，或者设备可能具有多个存储设备。通过使用 `/sdcard` 作为一个指向实际挂载点的符号链接，系统能够在不同设备上提供透明的访问，而无需修改应用程序的代码或用户的期望。 3. **简化开发：** 开发人员可以更轻松地编写应用程序，因为他们可以假设 `/sdcard` 是主要的用户存储，而无需关心实际的物理路径。这简化了应用程序的设计和维护。-----------> // 此时 软链接就是一个Adapter层，解决实际指向的层 总体来说，使用 `/sdcard` 作为主要用户存储的符号链接是为了提供一种简化、一致和透明的方法，以适应不同设备和存储配置的变化。 /sdcard 与分区的关系： /sdcard 不是一个独立的分区，而是一个指向设备存储的挂载点 3. 分区Linux 在Linux系统中，常见的分区类型包括： 1. **根分区（/）：** 包含操作系统的核心文件，Linux系统的安装通常需要一个根分区。 2. **交换分区（swap）：** 用于虚拟内存，可以帮助系统在物理内存不足时进行交换，提高系统性能。 3. **/home：** 存放用户的主目录，包括个人文件、文档和配置文件。 4. **/boot：** 存放引导加载程序和内核镜像文件，通常是一个独立的分区。 5. **/var：** 包含经常变化的数据，例如日志文件、缓存文件和数据库文件。 6. **/tmp：** 用于存放临时文件。 7. **/usr：** 包含用户安装的应用程序和文件。 8. **/opt：** 用于存放额外安装的软件包。 9. **/mnt和/media：** 通常用于挂载其他存储设备，如移动硬盘或光盘。 10. **/srv：** 存放服务相关的数据。 这只是一些常见的分区类型，具体的分区设置可能因个人需求和系统用途而有所不同。 分区与目录区别： 分区是大的功能的划分 目录是基于分区的 举例： windows的C盘是分区，内部是目录 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/虚拟化/虚拟化.html":{"url":"coding/虚拟化/虚拟化.html","title":"虚拟化","keywords":"","body":"1. 目录2. Introduction3. Hypervisor虚拟机概念3.1. 理解：3.2. 具体代码级别的验证：3.3. Hypervisor是如何垫上一层的？接口是怎样的？如何去适配?4. Android 虚拟化5. 容器与虚拟化区别 目录 Introduction Hypervisor虚拟机概念 理解： 具体代码级别的验证： Hypervisor是如何垫上一层的？接口是怎样的？如何去适配? Android 虚拟化 容器与虚拟化区别 1. 目录 2. Introduction 3. Hypervisor虚拟机概念 https://blog.51cto.com/u_16099316/6615775 Hypervisor是一种虚拟化管理程序，它负责管理虚拟机和物理设备之间的交互 全虚拟技术： 图： https://blog.51cto.com/u_16099316/6615775 1、Hypervisor运行在裸硬件之上，充当主机操作系统，则： （1）Hypervisor管理虚拟服务器运行客户端操作系统，保证客户端系统的完全隔离 （2）全虚拟化的性能略差：Hypervisor需要消耗一些资源 -------------> TODO: 容器化技术的图？ 半虚拟化技术： 在原有的OS之上添加一个很小的模块，利用原有的OS做任务调度、内存管理以及硬件设备交互等 本质：是利用原有的OS提供了一个模拟的运行环境，并由该系统处理一些事物。在这种模式下每一个虚拟机都是一个常规的进程，通过原有的OS进行调度。 疑问：每一个虚拟机都是一个常规的进程？？？？？ TODO: 两个init.rc（容器方案）、Hypervisor、chroot方式区别？ 容器与Hypervisor的区别？ 3.1. 理解： 从硬件资源角度：操作系统和Hypervisor 都是为了共享硬件资源： 操作系统-------------让多个APP共享硬件资源 Hypervisor ----------- 让 多个操作系统 共享硬件资源 具体策略之内存----------还是沙箱模型： OS会给每个线程分配特定的内存区域一样（资源沙箱） -------> VMM也会给每个OS分配特定的内存区域（资源沙箱） ------>沙箱模型， 推论： 1、del: OS会有拥有自己的机器的错觉 ： 沙箱内的一切资源都可以被OS所使用，沙箱以外的任何资源的使用都需要VMM的调解 del: 所以，从进程角度：感觉也是自己拥有机器的错觉 2、具体策略之硬件外设----------虚拟化： 虚拟化 - 准虚拟化 - 物理的(也称作\"直通\" 或 \"原生的\") 图来源： https://blog.51cto.com/u_16099316/6615775 自然，从结构上来说，Hypervisor是 OS 和 HW（HardWare）之间的插桩点：驱动 详细： 虚拟化： 当一个OS访问设备的配置寄存器时硬件会产生一个捕获。VMM的捕获处理程序检查OS的请求，根据模拟设备的状态确定该请求的含义，然后把模拟设备的结果返回给OS使OS继续运行。 ---------> 移花接木 参考：https://zhuanlan.zhihu.com/p/185946700 虚拟化，其含义：虚拟化 硬件！！！ 参考： https://zhuanlan.zhihu.com/p/185946700 3.2. 具体代码级别的验证： 3.3. Hypervisor是如何垫上一层的？接口是怎样的？如何去适配? virtio input 是 Hypervisor的 图见收藏 TODO: 待验证：按照图里的意思，底层的硬件事件被linux 读取，事件传到kwin模块 ---------------------> kwin根据区域，决定是否传给安卓 ---------------------> 如果传给安卓，则通过Hypervisor协调： vittio_input传输给安卓的kernel Q&A: Q: input链路绕路了：为啥要经过kwin？（直接由Hypervisor读取，向两边分发，会快） A： 因为kwin知道安卓区域范围 具体代码：Connection::processEvents()函数中，必然 case LIBINPUT_EVENT_TOUCH_DOWN: { #ifndef KWIN_BUILD_TESTING TouchEvent *te = static_cast(event.get()); const auto *output = te->device()->output(); if (!output) { qCWarning(KWIN_LIBINPUT) absolutePos(output->modeSize()), output); // 必然这里会加上区域区分 Q_EMIT te->device()->touchDown(te->id(), globalPos, te->time(), te->device()); break; } TODO: 其他从硬件过来的，或者Android使用硬件能力 --------> 链路是怎样的？ Hypervisor本质是啥？对什么的封装？ linux和安卓kernel差异的封装？ 4. Android 虚拟化 Android 虚拟化 ------> 指的是Android系统的HAL层没有接硬件，而是转接到 linux（通过virtual-IO、virtual图形等） TODO: google官网 HAL层本质：通信协议、标准化接口 隔离安卓代码与硬件厂商（隔离硬件厂商的差异，让硬件厂商适配） Android 虚拟化 的好处： 1、不需要通过 2、安卓大版本升级情形： 不需硬件重新适配安卓大版本 参考：Android虚拟化之一：为什么需要虚拟化 - 知乎 (zhihu.com) Android 虚拟化框架 (AVF) 概览 | Android 开源项目 | Android Open Source Project (google.cn) 架构 | Android 开源项目 | Android Open Source Project (google.cn) 5. 容器与虚拟化区别 图来源： https://zhuanlan.zhihu.com/p/27289278 特性 容器 虚拟机 技术原理 共享操作系统内核， 隔离用户空间 模拟硬件和操作系统，隔离整个操作系统 资源占用 较少的内存和存储空间 较多的内存和存储空间 灵活性 仅限于与主机操作系统兼容的操作系统 支持多种操作系统 启动时间 秒级 分钟级 安全性 较低 较高 隔离性 中度（隔离用户空间） 强（独立操作系统） 示例 Docker、Kubernetes VMware、VirtualBox 从结构上看，两者之间根本区别在于 分支分开的地方不一样： 一个是在 用户空间分开，成为两个（自然，内核和驱动是共用） 另一个是 驱动上一层（hypervir）就分开 （自然，整个OS都是隔离的，两个内核） 参考： 容器基础知识：容器和虚拟化的区别_容器化和虚拟化区别-CSDN博客 分开的点不一样，对应不同的技术： 比如多用户技术（自然，system_server是共用的） 多输入法技术是system_server中IMMS分开，其他一样（自然，以下都是共用的） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Naturalaw/":{"url":"Naturalaw/","title":"Naturalaw","keywords":"","body":"1. Introduction Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Naturalaw/ReadingAndThinking.html":{"url":"Naturalaw/ReadingAndThinking.html","title":"Reading And Thinking","keywords":"","body":"1. 目录2. 开篇宗义3. 待整理3.1. 补充 待整理3.2. 如何写技术文章3.3. 杂项4. 思考4.1. 结构4.1.1. 功能与结构4.1.2. 结构是更本质的东西4.1.3. 结构之-------主次4.1.4. 结构之-------锚4.1.5. 认识结构的工具4.1.6. 结构之-------化简4.2. 结构应用----之思想结构4.3. 抽象与具体4.3.1. 抽象是个骗子4.3.2. 抽象 是圭臬，是化简的有利工具4.3.3. 抽象与具体，两条腿走路才能走远4.3.4. 应用：学习之抽象 与 具象4.3.5. 工具：拆解抽象-----具体到数字4.3.6. 悟--------在抽象与具象 之间，不断循环，反复横跳4.4. 时间性/周期性4.5. 智慧4.5.1. 只做80分4.5.2. 控制论4.5.3. 识别智慧，内化为意识和行为4.6. 思考模式、驱动模式4.7. 思想工具：4.7.1. 如何深刻？4.7.2. 第一性原理4.7.3. 背后的背后、原理的原理4.7.4. 思想之 证明5. tags5.1.1. 描述事物的工具--------SCQA模型5.1.2. 描述事物的工具--------5W2H5.1.3. 追问问题的根本原因------5Why5.1.4. 思想工具之 复利/复制/继承性5.1.5. 思想之化简5.1.6. 化简推论：重要的只有一个5.1.7. 这世间最不可靠的就是意志力5.1.8. 分析人的三模型5.2. 技巧5.3. 生活化模型----理解、记忆的利器5.4. 结构类比之 人就是计算机5.5. 人生架构5.6. 分析、理解、记忆的工具----目的论5.6.1. 写技术文章（流程性）的结构一5.7. 写技术文章的结构二5.8. 结构的收集5.9. 结构之 “一”5.10. 如何在一个领域做到顶尖？5.11. 有人说了假话5.12. 心理5.12.1. 立志5.12.2. 心流5.12.3. 空杯心态5.12.4. 焦虑5.12.5. 假装5.12.6. 比较5.12.7. 表达是门技术 ---> 需要去研究5.12.8. 关于选择5.13. 其他小点5.13.1. 每前进一步，把之前所有方法再轮一遍5.13.2. 每天给你自己暗示，5.13.3. 永远不要用毅力、努力，5.13.4. 对比，一定要强烈、一定要客观5.13.5. 坚持输出，以输出倒逼理解！5.13.6. 跟对人、读好的书、好的csdn5.13.7. 如何深刻？学习、知识、理解5.13.8. 积木思想：5.13.9. 问题5.13.10. 执行力5.13.11. 绩效问题：5.13.12. TODO：5.13.13. 英语是个好东西5.13.14. to整理6. 学习如何学习6.1. 总论---学习方法论6.1.1. 简--繁 的无限循环：6.1.2. 功能 结构的 无限循环6.1.3. 闭眼6.1.4. 追求一6.2. 结构之 知识框架6.3. 学习动力与阻力6.4. 动力： 成瘾-----奖励机制6.5. 阻力：缓解痛苦6.6. 学习之无招胜有招6.7. 无招胜有招之目的论6.8. 无招胜有招之链接实操6.8.1. 理想的学习知识路径：6.8.2. 从记忆中搜索的路径：6.9. 如何化简？6.10. 学习之底层逻辑6.11. 学习之 以问题、面试问题驱动6.12. 学习知识之各个维度------拆解|切割6.13. 学习效果拆解 &checkList6.14. 学习材料6.15. 如何超快速学习新事物？7. checklist7.1. 思想模型7.2. 精力模型8. 道，天道9. 觉察系统10. 阅读10.1. 为什么要读书？读完书就忘10.2. 书单10.3. 如何训练思维的深度？10.4. 思考快与慢：10.5. 穷查理宝典10.6. 如何成为技术领域的高手？10.7. 大家&大书10.8. 不要骗自己-------费曼方法10.9. 费曼学习法更一般的理论10.10. 教育10.11. 性11. 管理11.1. 管理他人11.2. 自我管理11.2.1. 每周checklist11.2.2. 时间管理12. 文章&演讲 list12.1. 丘成桐12.2. 陆奇12.3. 普通聊天如何缓解尴尬？13. 关于辩论13.1. 辩论的前提14. 翟东升2021年预测15. 随时记录美好15.1. 专利查询网站 开篇宗义 待整理 补充 待整理 如何写技术文章 杂项 思考 结构 功能与结构 结构是更本质的东西 结构之-------主次 结构之-------锚 认识结构的工具 结构之-------化简 结构之 -------------标签（化简的利器） 结构应用----之思想结构 抽象与具体 抽象是个骗子 抽象 是圭臬，是化简的有利工具 抽象与具体，两条腿走路才能走远 应用：学习之抽象 与 具象 工具：拆解抽象-----具体到数字 悟--------在抽象与具象 之间，不断循环，反复横跳 时间性/周期性 智慧 只做80分 控制论 识别智慧，内化为意识和行为 思考模式、驱动模式 思想工具： 如何深刻？ 第一性原理 背后的背后、原理的原理 应用一：成瘾机制分析 思想之 证明 tags 学习知识 如何成瘾？ 成瘾机制的消除 描述事物的工具--------SCQA模型 描述事物的工具--------5W2H 追问问题的根本原因------5Why 思想工具之 复利/复制/继承性 思想之化简 为什么要化简 如何化简？ 一些好的化简的例子 生活、记忆化简之 合并同类项 化简推论：重要的只有一个 这世间最不可靠的就是意志力 分析人的三模型 执行模型 技巧 生活化模型----理解、记忆的利器 结构类比之 人就是计算机 人生架构 分析、理解、记忆的工具----目的论 写技术文章（流程性）的结构一 写技术文章的结构二 结构的收集 结构之 “一” 如何在一个领域做到顶尖？ 有人说了假话 心理 立志 心流 空杯心态 焦虑 假装 比较 表达是门技术 ---> 需要去研究 关于选择 其他小点 每前进一步，把之前所有方法再轮一遍 每天给你自己暗示， 永远不要用毅力、努力， 对比，一定要强烈、一定要客观 坚持输出，以输出倒逼理解！ 跟对人、读好的书、好的csdn 如何深刻？学习、知识、理解 积木思想： 问题 执行力 绩效问题： TODO： 英语是个好东西 to整理 学习如何学习 总论---学习方法论 简--繁 的无限循环： 功能 结构的 无限循环 闭眼 追求一 结构之 知识框架 学习动力与阻力 动力： 成瘾-----奖励机制 阻力：缓解痛苦 学习之无招胜有招 无招胜有招之目的论 无招胜有招之链接实操 理想的学习知识路径： 从记忆中搜索的路径： 如何化简？ 学习之底层逻辑 学习之 以问题、面试问题驱动 学习知识之各个维度------拆解|切割 学习效果拆解 &checkList 学习材料 如何超快速学习新事物？ checklist 思想模型 精力模型 道，天道 精力管理 降低消耗 他耗： 内耗 抓大放小 睡眠 checkList 内与外 的关系 极简主义 与 扣 到底要不要 一个光鲜的外壳？ 关于心态、心境--------动力问题 得到课程 时间管理 checkList 善护念 觉察系统 阅读 为什么要读书？读完书就忘 书单 如何训练思维的深度？ 思考快与慢： 穷查理宝典 如何成为技术领域的高手？ 大家&大书 不要骗自己-------费曼方法 费曼学习法更一般的理论 教育 性 管理 管理他人 自我管理 每周checklist 时间管理 文章&演讲 list 丘成桐 陆奇 普通聊天如何缓解尴尬？ 关于辩论 辩论的前提 翟东升2021年预测 随时记录美好 专利查询网站 1. 目录 2. 开篇宗义 写文字是为了修剪脑袋（释放脑袋）， 同时也是为了修剪笔记本身（提取主次） -------> 所以，最终都是为了遗忘。。。。为了本质与真 希望，你的笔记越记越少 你的关注点决定你达到什么样的高度、成为什么样的人（化简后的点） 这个世界，存在着太多的噪音（别人的噪音，你自己内心的噪音），阻碍了本质的认识 --------------------> 这也是，非常努力的情况下，没有结果的原因 规定： 笔记里任何一句话，不超过十五个字 (多余的以括号形式补充) ------> 以突出核心，增强阅读性 -生活，是理解抽象的 唯一手段 代码亦如是 人因梦想而伟大，因筑梦而踏实-------------> 用热爱，链接索引生活的一切 TODO： 重构你所有的认知，见闻。思想。 我的学习，有两次大的提升。 第一次是：总结技巧 第二次是：总结结构，化简 长长的坡，毕生追求： 努力活到110岁 努力掌握很多智慧的模型 努力找一个长的赛道 用结构去化简一切！！！！！！！！！！！！！！！！！！！（眼耳鼻舌身意） 用模型去获得智慧！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ 如果化简后，只留一个关键词，那便是： 目标（功能）+ 目标实现的证明（~~即拆解~~） ---------> 本质上，同金字塔原理 3. 待整理 技术文章写法（思考方法），向下拆解功能需求（自然）： 1、功能0层（目标） ----> 基于功能0层的功能1层 -----> 结构1层 ---> 基于结构1层的 核心流程 ----> 核心流程中的关键一行代码 ----> 基于功能0层的结构0层 -----> 结构1层 -----> 基于结构0层的 核心流程0层 写技术文章或者思考：不是做解答题（代码具体怎么写的），不是手抄作业（记录代码流程、调用栈流程） 而是证明题（+填空题）：已知功能目标 ----> 证明需要什么结构承载 本质一点： 基于功能角度，能证明（拆解）出这样的结构吗？（结构为什么是这样？） 基于这样的结构，能证明出代码是这样的嘛？ 图： 功能0层图、功能1层图 结构0层图、 核心流程0层（主要体现信息流） + 关键一行代码（调用栈），见xuji 关于链接，即向下拆解： 要体现 合理性、自然、不得不、必然性 达到理解力的极限 手段便是证明（道法自然） 例子：基于功能0层 证明 功能1层 基于功能1层，证明结构1层 .............. 证明代码的写法 核心路径，一定要成为高频路径 如果只留一个关键词，那便是： 功能（目标） 拆解 = 展开 = 化简 模型是更本质的、更泛化的结构（例子，抛开输入法不谈，一对多问题的解决方案） 仍然是机械记忆！！！！！ 只有基于功能，看结构，才有意义 结构是功能的承载。如果不想着功能（目的），结构是没有意义的（没有意义，自然记不住，不深刻） ----------> 检验理解了的标准： 结构是怎样的？ 基于功能角度，能拆解出这样的结构吗？（结构为什么是这样？） 2、结构-1层（功能-1层图）: 从结构-1层了解：wms这个人为什么会出生？ 为什么需要被出生？ ----> 即功能本身的来源的必然性 即：从-1层来证明 0层功能是必须的，不得不的 同金字塔原理模型的泛化关键： （1）如何确定谁作为root？ 结论？ 功能？？ （2）向下的链接是什么？支持的论据（观点？） 证明不得不？ -------------------> TODO：是不是所有的树形，都能用金字塔原理？？？？？？？？ 理解力来源：观察 + 悟 3.1. 补充 待整理 对于小模块（代码阅读层面）（比如图形的Compositor、WorkspaceScene、EffectsHandlerImpl）： 也要做证明： -1层功能 拆解的0层功能 由哪个类/模块（结构）来 承载 规定：1层结构图，要标注核心类，承载了哪些功能 --------> 自上而下 注意用语： EffectsHandlerImp ---------> 修改为 EffectsHandlerImp （绘制effects） （承载effects的绘制） 只有自上而下，才有合理性（才自然协调）！！！ 自下而上（实际代码阅读）： 代码层面阅读： 1、触发流，依赖真实环境的调用栈（一杆到底） 2、信息流，不一定依赖调用栈（依赖于代码信息传递） 3、实事流： void EffectsHandlerImpl::paintWindow(EffectWindow *w, int mask, const QRegion &region, WindowPaintData &data) { if (m_currentPaintWindowIterator != m_activeEffects.constEnd()) { (*m_currentPaintWindowIterator++)->paintWindow(w, mask, region, data); // 实事流 --m_currentPaintWindowIterator; } else { m_scene->finalPaintWindow(static_cast(w), mask, region, data); // 触发流 } } 触发流最好用onCreate接口，以区别 实事流 规定：信息流，要基于结构画（触发流，不重要） 学习别人的表达-------思考表达背后的思考逻辑 观察力的手段-----------------差异性：和我的差异在哪里？为什么有这个差异？差异的部分，哪个更合理？？？ 3.2. 如何写技术文章 按功能，来拆解出几篇文章（文章主体功能）、拆解出文章标题 一句话：功能、模块思想 原则： 1、小功能--小文章 ----小分支（链接到大分支上） ​ 简言之，文章之间是，按照功能拼积木。不是写在一篇文章中的流水线 2、不能将 大功能 拼接在 小功能上 ，即 大功能 不能写在小文章里！ 3、千万避免写流水线文章（纵向流程）， 而是要 按照模块 功能写文章 圆角为例子：不能是 流水线。。。以小例子，把整个功能拆散了，尤其是事务的机制 ​ 也不能把圆角放到《自由窗口》章节去写，应该属于SF特效的章节 ----------> 各司其职，谁是主要承载者，谁来写（其他文章引用） 按照功能拆： 事务机制（大功能，大文章）---sf执行事务（大功能，大文章）---具体圆角（具体小功能）一行生效代码 规定1： 任何一张图： 方向一定要正确（上下左右），方向大于天-------------> 不正确的，不看 元素，最好不超过超过5个 ------------> 超过十个的，只能作为字典(删除、隐藏)，不能作为记忆 一切为了体现结构：上下左右、主要类（忽略次要类） --------> 检验标准：用一句话能把结构讲清楚 -------------------> 不利于记忆 规定重中之重： 善护念： 要经常保护主要结构(关键流程) 不要被次要的 结构打乱了 --------> 写文章，或者思考时 具体手段：（1）文章：主要结构 + 其他章节（把所有零散的，放到一起）： （2）隐藏所有字典 (3) 主次要章节，在标题就做重要性区分 规定重中之重plus： 化简是人生永恒的主题，也是无时无刻的主题： （就像性能优化之于系统） 具体手段： 删减重复、相似归一、本质模型、一句话总结、自然 观察牛人的文章写法、说话逻辑、如何组织结构的 第一性原理，自己创造出 所有的知识点（知识像呼吸空气一样，不知不觉） 规定2： 源码分析的唯一目的：突出主干，突出结构，做好最大化简化（尽可能删除不重要代码） 例子： https://blog.csdn.net/tianzhaoai/article/details/128943124?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-128943124-blog-136080207.235^v43^pc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-128943124-blog-136080207.235^v43^pc_blog_bottom_relevance_base7&utm_relevant_index=10#:~:text=流程分析-,源码分析,-ActivityThread.java 规定3： 只做证明（即只从上向下，即创造事务）（不是理解事务，不是理解具体，不是从下往上） 规定3.1：只能用 “承载了....功能”，而不是 “干了什么” viewRootImpl 承载了哪些功能（承载是静态的） 规定4： 给出 //【】关键一行。。。。。。实质做事情的一行代码 规定6: 补充 Q & a 章节 TODO： 1、SurfaceFlinger 启动 时，为什么会初始化egl相关的 // 初始化OpenGL 图形库相关配置 mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY); 2、 native window api connect(struct ANativewindow* window） https://mp.weixin.qq.com/s?__biz=MzUyMjI5OTU1Ng==&mid=2247484433&idx=1&sn=57e262d2c555e579943e2d4504de2b2c&chksm=f9ccb5dacebb3cccc91fb3c0a785bc0b71ce8a16754de1745005e10a95e34bd1ad6d3e280d63&scene=178&cur_album_id=3231071844901011460#rd 3.3. 杂项 TODO: 关于高频(非关键)、针对性/关键性 的思考： 比如： adb shell dumpsys SurfaceFlinger | grep -A 30 \"HWC layers\" A----after 角度之 1层生命周期图 角度之 5w2h（针对于每一个功能点） 角度之 how（谁来承载） 角度之 cpu、gpu层面 damage是窗口级别 client给server。系统级别有吗？ 4. 思考 4.1. 结构 4.1.1. 功能与结构 功能是确定的、唯一的、显而易见的 结构是有差异的 结构是功能的承载；功能是结构的目的 -所以，结构是被证明出来的 4.1.2. 结构是更本质的东西 任何事物（无论抽象、具象），最重要的是结构。 土木结构，软件结构，人脑结构，思维结构，社会结构，收入结构 1、结构决定功能 有了结构，功能是自然的事情。（比如，代码所有类都new出来了，之间的相互功能，以及时序都是自然的。。。。再比如，排兵布阵好了，怎么工作也是自然的。。。再比如，车能跑，因为圆形轮子结构）物体如此，代码如此，社会组织更是如此。 2、结构决定行为 A是B的妈妈（家庭结构），所以A抚养B。李yang是杨qichao圈子人，所以，一直重用他。Window 在结构上包含了view体系，所以event最先是流过window，然后到rootView的 再例，屁股（结构）决定脑袋（行为想法） 3、认知与结构。认知，主要是认知结构！！！！！每一次对结构的严重冲击是好事。比如盲人摸象 代码结构，与代码流程，代码结构是更本质的东西 -------> 推论：1、基于结构，去做一切事情（去理解、去记忆、去认识、去画图、去推导、去设计、去分析原因） ​ 从结构上看问题，从结构上认识问题，从结构上想问题，万物皆结构！！ ​ 2、如果出错，一定是结构认识不清 ​ 3、时刻提醒自己，从功能、行为去反推 结构，比如：（虽然最初难以，认出结构） 行为：一个女人在给一个孩子喂奶 ------> 反推结构： 女人是孩子的母亲 ---------> 在生活中，人一定是主动反推了结构的。否则： ​ 无法理解后面女人给孩子换尿布的行为； ​ 无法理解后面女人抱着小孩子逗他玩的行为。 4、为什么要结构？看清----记住 -----删减 没有结构，你不可能看清事务，尤其是代码（乱糟糟的） 没有结构，你无法把握关键点 没有结构，你无法删减事务（--------> 从而无法记忆） 思考：脑子里，不应该有文字 简之: 把握关键行为（喂奶） ----> 反推 结构 （母子关系） ----> 通过结构，去理解/推断其他行为（换尿不湿） 所以，理解代码也是如此： 关键行为----> 反推结构 4、其次重要的是，重要结构的创建过程 所有事物都是主干与次要部分。1、2、3不是好的组织方式。包括上面 软件结构要类比具体事物结构，尤其是树。 自然理解一件事情，要忘记一件事情。比如，计算机中如何组织大量数据？树怎么生长和组织了这么多叶子？ 理解.....的本质在于理解结构！！！！！（比如代码结构比功能，比时序更本质; 如何有个好绩效？？？？-----> 占据领导心中核心排名） 如果你下次不理解一些东西，问一问自己，它的结构是什么，你搞清楚了嘛？ 记忆更本质的东西 通过琐碎的问题，来看到整个结构。。。。。一定要有很多问题 如果无法组织成体系（内化为一句话），就无法真正驾驭、成为能力 一盘散沙的知识，越多越是祸害。背后的原因就是知识结构（柳冠中说过同样的话：知识是包袱。https://www.bilibili.com/video/BV1Sg411U73L/?spm_id_from=333.337.search-card.all.click 柳冠中《美的竞争力-----> 0:49:00位置 TODO: 总结他的方法。记性不好，但是能整合知识。但是能看到本质。） 结构是记忆与理解的锚点！我们记不住行为，从结构的角度记忆行为很好。。。。结构是静态的-----> 更容易记忆 关于记忆锚点的选择：记忆锚点尽量选择主结构，原因在于：可以从主结构推导次结构，反之则不行 做加法的同时，为什么要做减法？？？？----> 原因：化简出主干（记忆点） ------> 应用：做笔记，先写，再删 数学的结构和红楼梦的结构很像------丘成桐 鸡兔同笼问题，数学结构很美妙 -------- 杨振宁 前天刷短视频， 一位清华学子问杨振宁：怎么在20——30岁之间尽快找到自己的职业方向？ 杨振宁就举例了一个自己的小故事：小时候，父亲教他「鸡兔同笼」的数学题目，他学得很快；等到他做父亲的时候，他也教他的孩子「 鸡兔同笼」，孩子学得也很快。但唯一不同的就是：一年后，他的孩子已经完全不记得这些东西了，就好像从没学过一样，而他一直还记得。 杨振宁总结到：这不是训练出来的，就是自己天生对于数学结构的喜欢。一个人如果能够很早知道他对哪个方向是特别接近，这就有很大的好处， 或许就是未来值得去发展的方向。 你有天生的对于某些东西的「偏爱」，且对于「偏爱」能够加以训练和培养，就是人生重要的事业线。 4.1.3. 结构之-------主次 主次是贯穿于任何事情的！！！！！（要有这个意识） 抓住了主次，人生便有了锚 主要问题、主要矛盾、主要作业、主要流程 -任何事情，任何事物，都要问一句，1、结构是怎样的？？问一句，2、主次是怎样的？？？ 尤其是抽象的事情 -----> 比如，代码最主干的逻辑，买房子最主要的几个目的 执行：当分清了事物的主次，选两个以内（很多情况下，只能保证一个！！！！！！）的主次，保证这两个主要的事情达到目标即可，不管其他细节，最好不完美（这样证明两个主要的目标保证了） 例子1：买房的主次是什么？---> 增值+学区是首要的！！！！！ ​ 买合肥房子最大的失误是什么？省政府南迁，比地铁是主 ​ 上海房子没有学区，原因：那段时间学区房大降，学区政策还没定下来 例子2：每天干的事情的主次是啥？完成某一部分代码 不能因为修补房子，干了一天，恋于修正房子 例子3：简单粗暴往往很有效，比细致分析 ------> 抓住主 例子4：代数中，很多个参数，可以组成一个特征量？ 例子5：对于软件，软件架构+关键流程是主、骨架 ，代码是次、肉。 此外，软件的主和次是依附的关系，所以，软件应该很容易 思想：人对万事万物都要讲究主次（否则我们没法认识事物的），上帝也一样（泰勒展开） 抓不住主次的后果： 做事，越做越错。比如买房 学习，越学越糊涂。比如看代码，陷入细节，不能自拔 主次应用： 1、断舍离 2、舍次要：把生活中的繁杂外包出去（保姆、洗衣服用洗衣机、吃饭外卖） 抖音 参哥，创业相关： 1、不要被 有价值的 垃圾束缚住 ---------> 次要东西要舍弃 2、在一个屎一样的赛道竞争（仅限于创业？），只能获得一坨屎 ----------> 因为主是塞到 3、越聪明的人越简单（即：考虑的越复杂，这个人越蠢） -------> 创业如此、生活如此、学习也如此 4、确认一个项目是不是好的项目：只要看这个领域是否有人赚钱了 ​ ----------> 不要去分析，因为客观因素太多了，无穷无尽 5、如何成功？--------> 抄。简简单单，且容易成功 ​ ----------> 这个就是模板的作用 + 复制思想 6、君子不利于危墙之下 7、一个人最大的难点在于，知道自己的边界在哪里？？？ 4.1.4. 结构之-------锚 很多时候，主次可以提现锚 4.1.5. 认识结构的工具 如何认识结构？如何区别结构的主次？如何避免分析过程中的遗忘甚至颠倒主次？ 思维导图 4.1.6. 结构之-------化简 人不可能理解、记忆复杂的东西： 唯有 折叠/化简 展开（链接） 一个普通结构，人 -只有具体才能理解，只有抽象才能记忆 -规定：任何抽象（抽象结论），下面要有例子； 任何一个典型例子，要总结其抽象 ---> 使用于理解、记忆、记笔记 太阳底下无新鲜事情-------> 所以，发明是抽象在具体中迁移 ​ 比喻也是 化简的极致/抽象的极致，应该是忘记 过河弃伐 最彻底的化简，是证明 （无需任何记忆了） ### 结构之 -------------标签（**化简的利器**） -在结构上标签化 是一种非常符合人脑的化简，自然的化简方法 TODO: 可能是唯一认识事物的方法 例1： 这个人很美、很勤快、很有天赋、很努力、很man。。。。。。 例2：标签化整个显示过程： 显示----测量 布局 layout draw ---- render 送显 ------------> (1) 结构上的：显示是整体；测量、布局是view层次的；render & 送显 是buffer层次的 ​ (2) 标签化：流程用词汇替代 例3： 写文章也要标签化 --------> 人是无法记忆与理解长篇大论的 比如：例1、例2、例3 关于标签的写法： 目标/功能 --------标签名，例如： 获取真实尺寸----------测量 4.2. 结构应用----之思想结构 应用层思想：技巧集（说话技巧），方法集、工具集、思想工具集（比如比喻、先假设） 中层思想：本质、思想集（解耦思想、正反馈机制思想） 底层思想：自然法则集、必然性 上下关系（如类继承一样）： 1、越是底层： 通用性越好，越抽象（越能涵盖更多）、个数越少 ​ 越是顶层：通用性差，针对性好 ​ 2、下是上的支撑逻辑（抽象），上是下的具体（应用） ​ 3、形成过程：上层抽象形成下层，下层指导上层具体实践 比如： 能让你眼前一亮，或者是好用的工具/方法，背后一定存在着好的抽象、好的自然法则 ----> 注意总结 4.3. 抽象与具体 4.3.1. 抽象是个骗子 1、要十分警惕抽象，因为抽象是极具欺骗性的。 ---> 比如，安卓调的。让我们以为自己懂了，骗了自己：安卓的什么调的？时机是什么？为什么会调？从整个流程来看，调用的不得不在哪里？ 所以，一定要 防止被骗 2、抽象具有模糊性。 比如：兴趣是最好的老师，每个人都知道，但是99%的人仍然学不好。----------> 问题出在哪里？ 兴趣如何理解？具体包括？获取兴趣的具体步骤是啥？ 一个“兴趣”词语，毁掉一个智慧真理，障碍了人心 比如：文字本身就是抽象，就非常具有模糊性。。。。一个人可以洋洋洒洒说一万字，可是空无一物 比如：大家都一直说，看问题要抓本质。但是很多时候，仅仅停留在本质这个词上，不得进一步 正因为 抽象具有模糊性，所以，不同人对抽象的不同理解与实践，早就了不同的认知水平、人生： 比如： ​ 科学家眼里的 “为人民服务” -------> 具体理解：一生奉献在事业上，死在事业上的勇气 ​ 正课眼里的“ .....................” -------> 具体理解：口号，话术 ​ 普通人，，，，，， 推论： 想打马虎眼，可以说一些抽象、大的话 4.3.2. 抽象 是圭臬，是化简的有利工具 3、要奉 抽象 为圭臬，因为 抽象才能升华、才能无招胜有招（举一反十）、才能举重若轻、才能轻松。 TODO: 例子： 才能化简 -你的抽象能力（化简能力），决定你能cover多少事情（知识、能力）！！！！！ -------------> 学过之后，达到自然状态，然后忘记 4.3.3. 抽象与具体，两条腿走路才能走远 只有具体才能理解，只有抽象才能记忆 见下 只有抽象才能演绎（指导）， 只有具体才能执行： 比如知道 兴趣是最好的老师，都说烂了。但问题在于，如何找到具体路径让学生感兴趣、甚至沉迷呢？而不仅仅是念叨要 有兴趣、要专注.......... ---> 具体：正反馈，及时反馈。 ---> 再具体：见下 -如何让好的抽象发挥作用呢？TODO 规定： （1）所有的知识、结论、尤其真知灼见、至理名言，必须 抽象-具体的步骤（具象） 两方面来看 （2）抽象 -----具体 之间，给出走向具体的角度-------工具：5w2h分析工具 （3）很多时候，问题出在：意识中，以为是具体，实际上是抽象 ​ ----------> 办法： 任何时候，用5w2h去检验？ ​ 比如： 结论之后（抽象），必举例子（具体） 李氏替换原则（抽象），设计模式（具体） 设计模式（抽象），具体安卓代码应用（具体） 兴趣是最好的老师（抽象），兴趣点是啥？培养步骤是啥？执行步骤是啥？（具体） 上山是抽象，选哪一条路、骑车上 是具体 （5why2How） 与别人沟通时，说了一个概念（抽象），具体这个概念的具体事情（具体）：只有说到具体，别人才能理解 与自己沟通时，比如要提高 沟通能力（抽象）: 从哪些方面？框架有哪些？有哪些技巧？什么时候说什么话？ （具体） 写技术文章时，自己经常性的提示词 “本质”，但是你写出来的东西，真的就能体现本质嘛？ 5w2h： what：本质从整体上规定事物的性质及其基本发展方向，本质由事物内部矛盾构成，是比较单一、稳定不变、深刻的东西，靠思维才能把握 how: 如何找到那么几十万行代码的本质？ ​ 规定了事物的性质 的角度： 一行关键代码 通知bindService以及拿到 对方Binder ，可以利用service了 ----------> 关键函数就一行 ​ 稳定不变的角度：要利用别人的服务， 任何语言，任何代码，任何系统，甚至是生活（拿到别人号码），都必然如此 ​ 深刻：体现了模型。拿到你的东西，才能利用你 where：Binder处于哪个线程？（一次binder，切换了很多线程，还有内核） ​ Binder 在安卓系统整体框架的位置（java-native-内核都有） ​ Binder在...................................地位 why： 不得不的： 各种通信方式，只有binder安全，又效率高 how: Binder 的机制 4.3.4. 应用：学习之抽象 与 具象 TODO: 总结 4.3.5. 工具：拆解抽象-----具体到数字 为了避免抽象欺骗我们（被自己骗）、必须学会拆解抽象，做一个高能量的人： 1、拆解高能量： （1）睡眠上 ：多少小时、什么时间睡 （2）身体锻炼上：多久跑一次步 （3）说话语气上：要有激情----五米以外要能听见 （4）心态上：挑战高难度任务 2、拿纸，记录上面每一条 -----> 每天看，并执行 4.3.6. 悟--------在抽象与具象 之间，不断循环，反复横跳 比如： 学习方法论的 《简--繁 的无限循环》 比如： 泛化、延拓 在抽象与具象 之间，不断循环，反复横跳 -----------> 应用于任何思想、脑力的东西！！！！ 人如导管，不留一物 代码如导管，不留一行 知识如导管，不留一物 贪嗔痴，不留一物 4.4. 时间性/周期性 忽略了时间性/周期性。。。。很重要： 1、万物都存在时间性 2、此时良药，他时砒霜 3、个人是依附于大周期而生存。大于大周期，于个人而言，无意义 李嘉诚：只有盈利的生意，没有永远的生意 ---------------> 所以，要比别人知道下一个获利的生意是啥？ ​ -预见性！！！！！ 获利，了结！！！！ 股市有时间性 李嘉诚第一个投入塑胶花生产、3000家以后就放弃塑胶花生产 --------> 时间性 67年抄底房地产，17年 7折抛售房地产 --------> 时间性 -----------------> 从时间性的角度来看，李做投资，也会非常成功 时间性拆解 --------> 了解世界最新消息：英文、报纸 ​ ----------> 联想、迁移 4.5. 智慧 4.5.1. 只做80分 1、其他用来改进、创新 2、防止过度，导致焦虑、早衰，高度紧张 4.5.2. 控制论 控制欲望、控制焦虑 转移方法？ 4.5.3. 识别智慧，内化为意识和行为 4.6. 思考模式、驱动模式 对于重要的事情，持续问问题 ------->作为课题 然后写出答案（只有纸面上，才能在脑中成体系，才能清晰） 4.7. 思想工具： checkList：为什么难的事情，坚持不了，简单的事情，也坚持不下来？ ----> 1、大量简单的事情，如同满地珠子，总有很多会被遗忘 。利器：简短的checkList，周期性看 checkList是一根线，看似没价值，但是保证所有珠子都在思想的线上 4.7.1. 如何深刻？ 深刻是抽象的东西 规定：对重要的东西 1、了解怎么用 2、了解背后的东西（背后的原理） 3、理解背后的自然法则…（出去自然，别无他物）：为什么记不住？ 因为你感悟的深度不够，以至于理解上不自然—————-----> 适用于一切 https://baijiahao.baidu.com/s?id=1743010636038377873&wfr=spider&for=pc 规定：对重要的东西，必须给出背后的自然法则，并写出来 4.7.2. 第一性原理 4.7.3. 背后的背后、原理的原理 应用一：成瘾机制分析 比如： 这么多年， 成瘾的点 喜欢养鸟、造鸟笼 幻想：幻想人鸟和谐、给鸟一个可爱的家，幻想以后老鸟可以下蛋、养小鸟 视觉激励：看到鸟很开心听觉激励：鸟的叫声很悦耳 迷恋于刷墙、迷恋于修家里的坏了的东西 幻想： 家，更趋于完美 ；妻子看了很高兴。 视觉激励：把破损的墙刷白，修复，看上去很有成就感 痴迷于刷抖音，可以连续刷一天 视觉激励：美女无穷性：新鲜感 可以吃东西，吃到发胀还想吃 味觉激励触发了动物性 痴迷于黄色网站 幻想：视觉激励：美女无穷性：新鲜感触发了动物性 --------> 共同点：不难：难会产生痛苦、会有意志力消耗 完成前的幻想 完成后的奖励 无穷性：给予无穷的新鲜感。这是 永动 的动力 很显然：养鸟做不到、刷墙做不到 ----> 一定会造成后期的厌倦 触发的越底层，越自然，越容易成瘾：动物性（生理性）-----> 人性 -----> 社会性 4.7.4. 思想之 证明 -证明是彻底的理解 1、因为无需掺杂任何记忆------------记忆是不可靠、不可信、不自然的 2、证明是彻底的自然、彻底的本原 3、证明是彻底的化简。。。对于代码来说，已经证明一定是这样，就不需要记忆代码了 规定： 余生只做 证明 证明 = 不得不 例子： 解答的数学思路，做到不得不是这样的，就到家了 ---------> 柳智宇 代码架构，不得不是这样的 代码的每一个行，每一个函数功能，不得不是这样的 5. tags 为什么绝大部分人能忍受干苦力活、在烈日下暴晒，却忍受不了学习的苦呢？ ----------> 这其实是很自然的： 原因： （1）干苦力：有及时激励（每天的工钱、又有新的墙被刷完，可见性）---> 不会枯燥 （2）学习知识，没有及时的奖励 -------> 这就极度极度的枯燥，像是在沙漠里行走，满眼枯燥 难的东西，一直不理解 --------> 痛苦 角度： 背后---------使用（更好的） 背后的背后—-------使用（这种才是可迁移的、跨项目的，甚至跨语言的使用） 因为：背后的背后，一定是底层的、通用的思想和架构，比如，消息屏障是背后。背后的背后，就是消息屏障原理的设计初衷、设计思想，即消息屏障背后的模型，以及。这种就可以移到 新的项目上（新项目肯定是没有handler了的） 背后的背后，相关问题： 原理为什么要这样设计？有没有不得不 你能想出其他设计嘛？你怎么样才能想出其他原理？可不可以那样设计？ 哪一种设计是最好的？ 了解了背后（原理），可以更好使用工具；了解了背后的背后（原理为什么是这样设计的出来的），可以更好的创造工具 如一级指针可以改变 值 二级指针可以改变一级指针的值一样 TODO： 你问得问题和思想，都是有层次的 学习知识 如何成瘾？ 可迁移的机制： ----> 多研究 嗑瓜子理论（https://wiki.mbalib.com/wiki/%E7%93%9C%E5%AD%90%E7%90%86%E8%AE%BA） 游戏理论 成瘾的根本原因是：有一套反馈机制在里面 ------> 正反馈机制、及时反馈 ​ 反馈机制做了哪些事情：1、修正 2、奖励 -及时的奖励机制 学习很难像游戏一样搭建奖励机制的原因在于： 1、学习带来的反馈是延时的，很难及时，比如背诵一个单词，猴年马月才能用上，才能体现在分数或生活中 2、学习带来的奖励也很难量化 ----> 比如背诵一个单词，只是结果上多背了一个单词。在激励上，多了多少？对英语提升影响多大？？ 3、游戏的激励更为直观：成功闯关，此成就只有20%的玩家获得。鲜花、排行榜、音效 TODO:我搭建的及时激励有: 1、数“技巧”个数（越多，我越离厉害更进一步 ） 2、0层图的个数，简洁程度 3、不得不的 “锚点”个数 4、方法集元素个数 5、本质的个数 6、美感、譬喻、比喻个数 7、兴奋点、关注点：得到了新的思想工具，思想世界又丰富了 ----> 思想世界 与 物质世界：获得思想世界新的东西，让我亢奋，比物质世界里买新东西还亢奋 刷抖音，让我痛苦，我搜集不到好的 思想、思想工具。反而让 思想世界凌乱 8、有多少个 “无招胜有招” -----> 决定你的lever 9、有多少个 “不得不” 10、多少个自然 成为熟悉安卓架构的少有的前百分之20% 幻想： 成为专家之后，年薪百万，然后住豪宅，给家里人都买保险。后半生便无忧了 幻想自己成为专家后的自信。理解深刻后的喜悦 注意： 1、及时激励应该是知识本身，或者知识相关。不应该是： 激励是一个礼物、一块糖 2、专注（过于抽象）只是奖励的副产品 弄懂复杂的物理知识，就像生理上的射精------蔡志忠 -----------> 成瘾机制的消除 你喜欢刷墙，有很强烈的意愿去 看到墙刷完后的效果 5.1.1. 描述事物的工具--------SCQA模型 S（Situation）情景 ——由大家都熟悉的情景、事实引入。 C（Complication）冲突 ——实际情况往往和我们的要求有冲突。 Q（Question）疑问 ——怎么办？ A（Answer）回答 SCQA模型是一个“结构化表达”工具。所以，写技术文档，也可以从这些角度进行阐述 5.1.2. 描述事物的工具--------5W2H 5W2H是描述事情的全面性，时间、地点、人物、原因、过程、结果。 案例2：设计一款app的调查问卷，你会如何设计调查问卷上的问题？ what(做什么)：你用这款app做什么事情？ when（何时）：你通常在什么时间使用这款app？ where（何地）：你会在什么场景使用它？ why（为什么）：你为什么选择这款app？ who（是谁）：如果你觉得你喜欢这个产品，你会推荐给谁？ how （怎么做）：你觉得我们需要什么功能才是比较新颖的？ how much（多少钱）：如果你认为这是个对你有帮助的APP，你会花什么价格去购买app里的服务？ 5.1.3. 追问问题的根本原因------5Why 5.1.4. 思想工具之 复利/复制/继承性 快速复制是一个极大的利器（不需要完全从0到1，再困难的来一遍） 例子： 1、人类与动物最大的区别不是 发明和使用工具，而是语言。--------------《时间简史-----> 原因在于： 语言，让知识和经验，可以在 人与人、人与人类幼崽之间快速 复制、继承 ------> 人类升级可以利用软件升级 动物的升级只能靠既然选择，然后刻在基因里 ------> 动物的升级是硬件升级，周期千万年 2、站在巨人肩膀上 ----- 牛顿 IT为啥可以垄断，形成巨大财富？ 原因： 快速的复制性，一份代码，可以马上在几亿台设备运行 -----> 突破了时间、地点、材料的限制 抖音上主播卖货： 1、原来面向一个客户，复制成面向亿万客户 2、如何写文案？别人十万点赞的文案，拿过来，改一改，便轻轻松松1万 ----> 复制的威力(抄) ​ 看到谁就抄谁！！ 3、 抖音参哥： ​ 做生意，千万不要做一个匠人（深耕一个领域）！！反匠人精神！！----------> 90%的生意都有周期性，比如钢材生意，就几年 ​ 而是要利用复制的威力！！！！ 举例子： 觉得工厂比较有技术、自己做的二十年产品有价值 -----------> 实际上这些都是脏活、累活、不出成绩的活。。。关键每有垄断性，可以找到任意的工厂买 ​ 有这个精力，可以多开几家淘宝店 复制要做到： 1、低成本 2、快速 规定： 重要的事情，难的事情，一定要做到可复制/可继承 list： docker环境、aosp代码注释 5.1.5. 思想之化简 为什么要化简 人不可能理解复杂东西 人不可能记忆复杂东西 人不可能执行复杂的东西（多次）： 多次执行一个复杂东西，耗时耗力---------> 人的意志力多宝贵 人不可能关注复杂的东西： 重要的事情只有一个，所以不可能分心 ------------>化简是我们终生的课题，甚至是时刻的课题 从目的论的角度： 化简，让目的更加清晰 如何化简？ 化简的具体目标是什么？化简的具体工具是什么？ 化简具体工具： 1、提取重复 比如重构函数，提取重复； 比如 把常见的要做的脚本(电脑启动时，启动多个软件)，多个封装到一个脚本中 my_start 比如：把一个成功的商业模式疯狂复制 2、上面的复制思想 比如：你会了一件事情之后，就可以不做了。教会别人，让别人做 3、 代码化简-----见how...... -----------> 是不是可以应用到生活？ 一些好的化简的例子 例子1： 代码化简-----见how...... 例子2：软件结构、行文结构，如下 key1 -------> key2 -------> key3 -------> key4......... | | 具体。。 关注点在key上。。。。。。然后对每个key展开 key常常是目的 生活、记忆化简之 合并同类项 比如： 记忆adb命令： 刚开始记忆很多很多adb命令 ----> 记忆有哪些key(录屏、滑动) -----> 类似的操作放一起后，只需要记忆 屏幕相关、手势相关、app相关（最终只需要记忆三个名词） 5.1.6. 化简推论：重要的只有一个 重要的事情只有一件、重要的代码只有一行、重要的笔记只有有一句话 -----> 理解程度的衡量标准 5.1.7. 这世间最不可靠的就是意志力 比如：励志、发誓、承诺、高三打鸡血熬夜学习、纵欲、身处 为什么？因为都基于意志力，人的意志力是非常稀缺的，一消耗就没了 所以： 1、一切靠意志力的东西，都是非常不可靠的：绝不相信 相对可靠的有： 固定的流程、规章制度、法律-------------> 好的约束 好的周围环境 自身：提高精神力（身体、脑力） 5.1.8. 分析人的三模型 信息模型、认知模型、执行模型 （输入） （function） （输出） 任何一个复杂系统也这样分析 TODO: 人生模型之 执行模型 -----> 一定要 目标感很强 。技巧： ​ TODOList： 月度-周-日 执行模型 关于动力、关于阻力 5.2. 技巧 取其神，忘其形 -------> 真传一句话，假传万卷书 如何识别形，又如何提取神？ 技巧，比热情重要，热情会消散。而技巧不会 5.3. 生活化模型----理解、记忆的利器 生活化模型的本质：将新知识类比桥接到旧的已经获得的知识体系上。。。以已知链接未知。。。。 生活化模型，是学习新知识、记忆新知识点极大的利器 任何一个知识点（尤其代码调用流程），给出生活中的类比、或者形象化 比如：费曼的恐龙多高多大，三层楼高但是头进不来 不用担心 比如 ：输入法imm、imms、ims 媒婆相亲 比如：looper线程，驴拉磨 比如：APP启动，皇子继承皇位模型 为什么能这样做？ 太阳底下没有新鲜事 为什么要这样做？ 1、得到不得不，得到自然2、也是可复制思想的要求。讲旧知识复制到新知识上，这样减少消耗 3、也是合理性思想的要求。如果找不到生活化模型，必然不合理 记忆，在于形象化、生活化、具体化 尤其代码调用流程，其实是模块调用流程更合适，（我记不住步数太多的流程。。。子系统内部不适用？），流程生活化，极大提高记忆力 大的流程，编生活模型故事，理解本质。。。。。。之后小流程、内部流程、细节由 大的流程 撑起来 （不得不） 注意： -基于模型，去记忆代码。 而不是根据代码记模型 · 5.4. 结构类比之 人就是计算机 把人 类比于计算机 ---------> 计算机的问题，用人的方法解决；人的问题，用计算机方式来解决 1、人 和计算机一样，都是 事件驱动： 安卓主线程有个handler（queue列表）处理事件；分重要性：消息屏障机制 人要有：时光序、桌面日历； 分重要性：重要不紧急 2、人 和计算机一样，都需要监控进程（杀毒软件、监控计算机运行状态）， 计算机：360、鲁大师；安卓：防止自启动软件 人： 人也要有一套觉悟进程，独立于人，观察人的思想、行为： 比如，淫欲心起、食欲心起，一念起，即可察觉，然后熄灭 ​ 觉察、觉察、觉察!!! 3、人 和计算机一样，需要稳定性： 计算机：程序，尤其操作系统，需要稳定，长期而不出错 ------> 方法：找出稳定性报错，逐渐修改逐渐完善 人：情绪要稳定 ------> 方法：找出情绪不稳定性，逐渐修改逐渐完善 4、人 和计算机一样，需要好的CPU： 5、人 和计算机一样，需要大的内存： 方法：脑袋内存不够------> 人借用笔记，作为脑子的内存（要点：笔记要非常快能所引到） 6、人 和计算机一样，快速搜索用map： 人脑: (1)快速搜索，用的是关键词 ​ (2)喜欢贴标签（本质就是关键词）：好的、坏的、有能力的 7、人 和计算机一样，大量搜索、记忆用树结构： 8、用计算机，重构人整个系统 比如： 认知系统、运算系统、察觉系统、执行系统 5.5. 人生架构 身体 > 脑子 > 关系：身体会影响脑子 坐久了，会影响思维 思考久了，容易睡不着 ----> 利用身体运动反作用 5.6. 分析、理解、记忆的工具----目的论 **目的论：目标---出发----不得不：** 锚：出发点（触发点）------------目标 由此 过程就是不得不的了：~因为目标是，所以，第一步；因为目标是，所以，第二步 基于锚，我们体会到了 每一步的 不得不，对事物的理解就到家了， 自然， 分析比较透彻了（因为证明了不得不） 理解的深刻了 过程不得不，只需记忆锚就好（自然是记忆的好工具） 推论： 1、合理性分析：也是这个方法的应用，即 针对于目标，该步骤的合理性在哪里？ 2、生活也要如此，当我们处在 漫长的过程中，一定想一想，当下的操作，对于出发点 和 目标是必要的嘛？？ ------> 我们经常会忘记目标，而且目标不停摆动 3、不得不 与 费曼技巧（创造知识）说的是一个东西。 区别在于： 不得不 似乎对已有的事物没有完全瓦解，只是对已有事物证明其合理性------------> 应用在对已有知识 不太熟悉的情况下？ ​ 创造知识 要求完全瓦解 --------------> 对熟知的事物，从0开始，似乎更彻底 从更高层次上看， 证明 不得不 是化简的极大利器，是理解的极大利器，更是记忆的极大利器 ​ 目的论分析 是 合理性(自然) 的有利工具（有了自然，就不需要记忆了） TODO: 从不得不角度， 代码 跟数学好像---------- 把一道题（不一定是证明题）的解答步骤，做到不得不，就完全理解了 生活也是如此------------炒菜有很多步骤，但最合理的只有一个（比如，买菜的时机是你想出去溜达的时候，吵豇豆前要先煮一下才软，这些都是合理性上的不得不），把步骤想到不得不的时候，你就完全理解炒菜了，也不需要记忆了 所以，不得不 是 理解 多个步骤、流程性 东西的 利器？？？？？？ ​ TODO: 背后的背后： -思考角度|关注的点，如此的重要 -----------> 可以将三件完全不相关的领域 一剑串起（某一角度） -----------> 一个角度，决定着 某一领域的 修为。。。。这也是真传一句话的原因 TODO: 把 不得不 用在 任何事、任何时 上？？？？？？似乎只能是流程性的 5.6.1. 写技术文章（流程性）的结构一 也按照上述思路 规定： 行文格式 大的锚（目标-------触发点） 阶段性1的锚（目标1------触发点1） ​ 非常小的目的-----小的触发点-----小的不得不 ​ 阶段性2的锚（目标2-------触发点2） 例子：比如目的是打开SSH开关 ---------> 这是你的关注点，也是写文章的锚点 具体怎么打开，不要关心 规定： 在过程中，一直问自己： 目标是啥？ （触发点是啥？） 5.7. 写技术文章的结构二 0层，必须有锚点 其他目录是流程目录：大目录之间是流程，小目录间也是 -----> 目录相当于函数调用（关键的） 必须有总结 引用只能引用总结 0层图有0层图大总结 各个小流程里，有小节的总结 5.8. 结构的收集 结构的收集： 水平时间线（鱼骨线，主题-------主题------主题）-----------------核心是一条线 树------------------核心是树根 链表------------------核心是头节点（一法通万法的根本就在这里，一法为根） 多线程的结构---------------排队 最强的创新永远是结构上的创新。。。最强的性能优化，永远是结构上的优化 大破大立 5.9. 结构之 “一” 重要的只有一个。 人的关注点永远也只有一个 -----------> 集中一段长时间只学习一样东西，才能学好 -\"一\" 是结构中的结构： 一生二二生三三生万物 道法自然 如何识别一呢？从结构上看 是树的根 是链表的第一个节点 是鱼骨图的鱼骨 什么人做什么事情----------资源的合理配置 （也是结构） 5.10. 如何在一个领域做到顶尖？ 梦想 成魔成疯 5.11. 有人说了假话 为什么越拼命，活的越累？ ---------> 有人说了假话，甚至大部分人。甚至整个教育体制 教育的目的就是 奴役 优秀，只是更好吃的羊 5.12. 心理 任何行为都是心理、激素作用？？ 每天暗示自己：（1）你是个天才 （2）这个原理让我高潮 （3）人际关系的拿捏、权利让我高潮 5.12.1. 立志 此生，为道而生，为自然法则而生 我要用 道 来驾驭万物！ 智慧、思维于我是一种天赐的礼物 5.12.2. 心流 你如何在修理电器、养花种草上获得心流，你便可以培养同样的心流在其他事情上 5.12.3. 空杯心态 5.12.4. 焦虑 zhangyitang 5.12.5. 假装 你想成为什么样的人，先从假装开始（先从暗示开始） 5.12.6. 比较 从根本上来看，人是不可能与他人比较的 -------> 原因在于：与他人的比较都是浅层次的比较：年薪、职级、成绩、房子、、、、、、 -------> 浅层次的比较 危害极大，1、让人只盯着表象，于发展无意义 2、让人陷入焦虑 只有与自己比较，才能触及根本。从而，才能进步。与自己比较的内容：自己的内核有没有提升 5.12.7. 表达是门技术 ---> 需要去研究 5.12.8. 关于选择 规定：任何大的选择，基于未来3~5年去做。 站在未来看现在，才能做好选择。 -技巧： 当前犹豫的事情，时间尺度拉到未来十年，就好选择了 EX : 转岗去做通信的东西，就是一个彻底傻逼的行为，原因：违背了历史进程，违背了行业发展 5.13. 其他小点 如何鉴定一个view是特定某个？1、在断点调试中，会标明子类名 2、log中大小 3、眼睛观察时，可以改变大小（最好颜色） --------> 区别化 面向对象，什么时候new，比什么时候调用方法要重要！！！前者是基础 充分涌流，英文对编程很重要，可以在网上链接全世界的开发者和网站！！！！！ 好的断点调试环境下，可以调试z侧的Zeus 我是个笨人。。。笨人理解事物的方式就是， 1、慢化: 不停地细化、分解问题，然后一条条回答，确定 一定要梳理，q&a，否则跟没做过一样，比如输入法 画完图没有用，太泛 2、记录，与回顾 3，任何事情都要有 更抽象。。。。。这才是你的。你忘不掉的 任何时候，非主线程需要标识！！！！！ 按照功能去分层，分类！分代码 如何界定真懂和假懂 做项目工程或者阅读代码时，一定要有文档输出。1，理思路 2 记忆 3 回顾 我跟周围领域边界是什么。。。。跟周边啥关系 绑定，addwin，bind 记忆之锚 万物皆对象与关系（对象的高级就是架构） 测试用例方法:一步一步走。。。。不要跳跃！！！ 刷完版本，点hipay 更新代码，导入so，点hipay 不要走捷径，走捷径会让你死的很惨 测试用例不过， 1，绑定关系原则:测试套里其他的过没过？ 2，相互影响关系原则:为了排除测试用例之间的影响， 不要被自己骗了。。。。问一句，不这么样，又会怎样？如果没有，你会怎么做？ 理清，透彻！！！！如何达到呢？ 如何不囿于代码？？ 贫穷不是因为懒惰‘ 农民工：勤劳、能吃苦、善良 5.13.1. 每前进一步，把之前所有方法再轮一遍 ------->方法便成指数级增长 例子： 1、进步:云帆引入方法，可以将其他盘代码引入As工程源码作为source 基于进步的拓展:那么可以做的事情就非常多了，比如将Z侧代码引入source断点调试，依赖源码 再拓展: 打通ndk调试（A侧和Z侧），以同样方法引入cpp 再再拓展: 2、云构建ok了，其实可以做很多事情。。。。 比如，串所有代码？ 再比如， 5.13.2. 每天给你自己暗示， 你是计算机天才，高手 5.13.3. 永远不要用毅力、努力， ------>因为它有对应的副作用同样强！！！！ 太用力跑不远！！！！ 股市上也是，太要快，反而跌的惨 5.13.4. 对比，一定要强烈、一定要客观 例子： 1、如果练好说话：把自己说的话录音（客观）下来，与别人同样的话录音下来，同时放映对比（强烈） 2、看自己胖不胖：用手机后置摄像头（客观）拍照片，对比以前照片 再例子：看书，划重点，用颜色笔划重点 5.13.5. 坚持输出，以输出倒逼理解！ --->(关键是，倒逼思考) 任何学习都是如此 读书也是如此: 输入（看书）+头脑内整合（思考）——>输出（写作）=收获 理解事物也是如此 5.13.6. 跟对人、读好的书、好的csdn ----> 学会挑选，避免糟粕！！ 如何挑选？看评价，长期的！ 大量的信息涌进来，鱼龙混杂----> 大部分观点是错的！！ ----------------> 所以，要跟对人！！！！跟对时间上检验过的人！！！ ----------------> 即使你自己没有独立思考能力，跟对了人，也就。。。 5.13.7. 如何深刻？学习、知识、理解 1、要反向才能深刻----> 时刻提问题，时刻怀疑！！！！！！ 所以，我们可以推导出任意事物的学习方法： 任何学习一定是伴着很多问题的：1、自己给自己提问题 2、网上搜面试问题（别人给你提的问题） 2、实践 + 实践后的总结 才能深刻 要学一个东西，一定要尽量实践，比如做题、比如动手实验、比如动手写代码、写项目 --------->纸上得来终觉浅（听人说也是如此） 3、抛开不谈技巧： 做.........时，抛开.........不谈，必然要解决的问题是？ 做安卓显示时，抛开安卓不谈，显示这一功能必须要解决的问题是啥？ 1、不能让开发者自己一笔笔画吧，自然是 有一个基础元素的概念，让开发者自己去组装 -----> 即控件概念 2、必然有人把 基础元素的数据 转化成 显示数据 ------>即render系统（这里可以看出，渲染是必然的，但是不一定要并发） 3、如果有多个窗口呢，怎么办？ -----> wms 总之，如何深刻？规定： 1、抛开不谈 2、不允许用 wms、window manager sevice 来作为标题 -----> 用功能文字 作为标题（并证明不得不） 而应该是显示系统、如何转换数据？ 如何协调各个窗口之间？ 见 Graphic.md 5.13.8. 积木思想： 积木思想（先拆再串），应对繁多的方法： 拆成独立的木块（这个种类不多）。弄透了独立木块（工具），然后再整合（串） 学习也是，要用积木思想，先拆再整合 5.13.9. 问题 问题是技术存在的唯一理由 一个人有多牛在于他能解多难的问题 问题是检验技术的唯一标准 只有好的问题才能让人深刻！！！！ 5.13.10. 执行力 对于有拖延症和慢性格的你来说，执行要比理解全，要重要。。。大于一切！！！！！ 5.13.11. 绩效问题： 绩效b，你的问题在于不会展示自我！！！不够自信！！！主管不相信你 https://zhuanlan.zhihu.com/p/30489002?utm_source=wechat_session&utm_medium=social&utm_oi=903075405244817408&utm_campaign=shareopn 云帆: 当时给浩哥留下了好印象（弄好了编译，让代码跑起来）-----> 后面好活都让他做了！！！！为什么我没有做到？？我当时只想着查接口资料。。。我似乎也不知道系统代码可以替换的！！！！！！ 冬郎: 会表现，尤其领导面前-------->知识管理！！！！而我认为这些没有用！！！！ 朱明亮：你能够独当一面嘛？？？技术上呢嘛，气势上呢嘛？ 海涛：如何绩效好？两种：1、你在重要的角色上，这个项目没了你，其他人很难完成这个角色（至少做起来比较困难） 2、简单的事情上，做出亮点。做的漂亮。 你的绩效总是垫底，不感到委屈吗？ 年中绩效评价时，其中一个团队成员问我，为什么自己的工作量并不比别人差，但是绩效排名却不理想。 好吧，这个问题对于很多管理者来说着实是一件头疼的事情。但作为团队leader，总有一天要面对这类问题。我也只能根据我的理解去给他一些建议： 为什么一起入职的小伙伴，短短的一段时间后就在绩效考核上拉开了差距呢？ 我们建立一个较为理想的模型：我们将团队的工作任务看作一块三明治，分为困难、普通以及简单任务，在对团队成员并不存在主观偏见的情况下，leader会倾向于按照“平均”的原则去分配工作。 一般情况下，所得到的最终结果会是：有人完成的很理想，有些人完成的很差。但是，从团队绩效的整体完成情况来看，并不理想。 可以预见的是，如果继续按照上述方式分配工作，团队绩效依然无法有较大的改观，此时，作为leader不得不作出一些调整——按照能力去匹配工作。 带来的效果一般也是显而易见的，团队整体的绩效得到了保证。 现在回到最初的问题，我们心里是否有答案了呢： 丙的工作量并不比其它人少，为什么绩效排名靠后？ 我想答案可以简单概括为，丙的可替代性较高。 进一步去思考，可以将以上过程称为绩效阶层分化。通俗的说，我们以往的工作效果导致了我们被划分为了甲类、乙类以及丙类员工（为了便于理解，暂且这样称呼）中的一种，而leader出于对团队绩效负责的原则，采取了最低风险的工作分配方式，更加剧了绩效阶层的固化。 丙类员工的悲哀在于，他就像站在拥挤的地铁车厢门口的人，稍不注意便会被挤下车。然而，我们被划分至丙类员工并不是最糟糕的事情，最糟糕的是我们从未去思考自己是如何一步步走向丙类的。 经了过对绩效阶层分化的理解，看上去作为丙类员工的我们似乎已经无路可走了。事实真的是这样吗？回顾上面的思考过程，我们会发现导致我们一步步走向丙类的直接原因，便是对于复杂、重要工作任务完成的效果差。而根本原因，在于能力缺失，或态度消极。在职场上的一条永远成立的定律：先有做事情的能力，才会有做事情的机会。 因此，扭转局面的唯一机会便是：踏踏实实地提升自身的能力，去主动承担并且完成复杂、重要的工作。绩效与薪资挂钩往往使大家捡了芝麻丢了西瓜，仅仅纠结于眼前的利益，而忘记了改进自身能力去追求自身更高价值的机会。不善于反思自己，将绩效评价结果简单地归结于偏见，甚至更加消极怠工，是对自身最大的不负责。 最后，我所理解的绩效考核的最终目的是帮助员工去发现、理解及改进自身问题，因此完整的绩效评价应该包括结果评价、绩效面谈辅导两个主要部分。也就是说，这是一个工作效果集中复盘，帮助团队成员发现成长机会，并且与他一起制定提升措施的过程，按PDCA模式去挖掘自身潜力。 许多管理者甚至将绩效考核权利当成自己树立威信的杀手锏，如果你偏要拿出一副“老子说谁行谁就行”的嘴脸，那我也只能祝你以及你的团队好运了。。。。。 5.13.12. TODO： 了解impl与接口关系，为什么要这样设计 泡脚 静态方法如果修改一个量，基本上都要加锁 ----> 因为不同线程会同时修改这个值 你在华为，做的最大的错事就是，你太怂了！！！！！！导致了后面一系列问题，绩效，分的蛋糕 任何一个新名词，任何一个新逻辑，任何一件事情，都问一句:本质是啥（what)？最底层逻辑是啥（how)？（害怕被名词欺骗，害怕被自己骗） 不停地what，when，how，why -----> 不停进行交替，这样你可以追到本质 比如，序列化，本质是啥 工作逻辑 原理逻辑 做的笔记，必须是自己的深刻理解（1，自己的 2，深刻浓缩） 一个模块的开发，一定由上至下来设计接口。由上至下来写接口。。。。。为什么是这样的？因为一个接口的功能是由它的调用者决定的！！！使用者 父类调想要调到子类方法: 可以直接在子类里增加，instance判断 2 父类增加这个方法，子类复写（不用父类里用instanceof 判断） 只是子类的方法，不要在父类里 ------> 各有什么优劣？ 第二种更好，原因在于:第一种在父类里了解了当前类是子类，即父类了解了子类逻辑，并调用子类逻辑。。。。----------> 子类逻辑下沉到父类里了。。。这不好，产生了耦合，以后。。。。。这样做，父类里会有大量instanceof 尤其是父类里面引用了子类 ------> 这本身就是耦合，本身引用方向就很不对！！！ 原则，父类不需要对子类是哪一种进行感知。。。做自己的逻辑，这样不会耦合？ 即使只有一个子类去override，还是第二种好 例子: 如何hook安卓流程 1，实现安卓所要的接口抽象，塞给安卓。。安卓回调时，回调到z 比如，无障碍流程 2，继承安卓的类，恶意复写 比如元能力恶意复写activity的内容 静态如何调用非静态？ 静态不能在方法中调用，但是，可以把非静态变量赋值给静态变量 而且方法可以当做callback（变量)，所以，非静态可以转化静态 -----> 例如安卓Toast, Notication 其实有些架构是必然的，比如，通知，要考虑不同应用，则必然manager在另一个进程里 为什么？为什么？为什么？ 回调，回调到子类还是父类？（其实都是一个实例，层次不一样）其实都可以，哪种更合理？ 读书最重要的是读目录，尤其是技术书！！！！比如安卓艺术探索艺术 断点调试适合向下 每天要有计划。。。规定，所有的计划要细化。。。。所有的学习或新东西，要输出东西 集中精力 一定要学会化简！！！！！比如，看代码要学会化简。。。把握住核心的几行代码。然后去理解与记忆。。。其他代码能删则删。。。这想要那也想要，最后一定是不深刻！！！！！！ 你是一只狼 大计划，接下来追求: 1，每天锻炼身体 ----> 细化 2，锻炼脑袋 ----> 对知识和金钱保持 强烈欲望！！！好奇好奇，可以走得更远 3，审视每个想法。念起即断 4，反思。复盘一切 5，每天身体和思想都清零， 以输出倒逼理解。。。又一例子，做笔记，做的笔记是你的理解。而不是你抄黑板 又一例子，写toast代码给开发者，先设计好开发者怎么用，以此输出为出发点 对外接口是一个类（模块)存在的意义以及其本质！！！！！！！ 要想把握一个模块，一定牢牢把握其对外接口。比如，了解一个接口怎么使用，入口在demo里。再比如，了解一个类是干啥的，看其有哪些对外接口。。。 如何让她意识到自己的错误。走她的路，让她明白。。。生日时，她没给祝福，生气。没给礼物时，生气！ 如何克服焦虑和拖延: 努力干砸每一件事情！干就完了！ 从本质上讲，调用函数就是信息传递！！！就是蝌蚪，电流 ----------> 传递了两个信息: 1 、某个事 2、干这个事的一些东西-----> 其中1，可以转化为2 5.13.13. 英语是个好东西 原因在于： 1、是你成为迈进高阶大门的 钥匙 2、将大部分人拦在门外 5.13.14. to整理 人世间有太多的羁绊，阻碍你的前进：性欲、面子、强迫症、手机、感情、亲情、执念、 要思考怎么进步，这才是根本 万物皆是对象 既然是对象，必然有层！！！！ -----> 所有事情，分层！！！！0层设计！！！ 问题集: 问题比对的东西重要！！！！ 问题《-----> 根因 熬夜➕久坐，伤神 熬夜会变笨 餐巾纸 放慢大招： luyin、log -----> 录音别人的问题，问题是理解本质的神器 可叠加式进步 朝闻道夕死可矣 遇到难的问题，一时解决不了，不要强攻。。。。隔一段时间再解决（第一，不耗精力，第二，换脑子） 用输出检验输入，检验理解 注意每天给自己清零 机器要一直跑，人要常休息、常思考。 沉下去 要活的有智慧 长度 书籍:稀缺，穷爸爸富爸爸 抓crash log是虚拟机在死亡之前发出来的。所以跟安卓或者z没有关系。 方向性问题，一定不要听你同级别同年龄的人，的话，（比如yangyunfan说andriod比算法有前途） 近期emui会有需求。 如何理解，分析，思考，解决问题，问题拆解，原子性 Android studio 6.3.2，比如EA保存高质量图片 对比网上很难搜到的东西一定要有记录，比如docker的安装。studio的配置！！！ -2深度参与了嘛 -1 提高自己的沟通能力！！！！ 0，每日问一下，你的技术达到最好了嘛？今天是否追到根？能力提升了嘛？ ----------> 你总结了很多，入脑内化了嘛？ 每天看一遍 图的话，闭眼想关键点 时间，力量 所有的复杂配置要记录关键流程，以免后续返工时，又浪费时间 给一个不得不的理由 1、技术思维，向上下扎到根，向上捅破天，，， 竞品思维 产业思维：安卓如何做的，苹果如何做的，你可以怎么做 和一个有心机的人竞争，两种方式，可以赢他，一种是比他更有心机，这种能赢，但只是险胜。第二种是更纯粹，但在思维，思想上，高纬度碾压 陈浩，怎么样才能挣到他一样的年薪？找那个段位的人聊天。。。。他说的是对自己人生知识智慧的提炼(不会出现在书本，不会出现在互联网上) 看虎嗅，看36氪 越底层越重要，身体，家人，赚钱能力 不能短视！！！！ 多找跃华聊天，他就是你的陈浩！！！ 每件事情都是有一定意义的，要识别其意义，并总结下来 理解一样东西，不快，但是弄懂了就彻底懂了 方案，一遍不懂就十遍，任何难的东西，解决方法----------> 每天看一遍 厉害的人，是其抽象能力厉害！！！手机跟无线射频没什么两样，就是多了个显示屏 可以无时无刻把玩业务，这样你的时间就多了。比如，做输入法，在自己的手机里很多安装输入法，有空时对比把玩 比起商用完善的项目，github上的demo更有价值 ------------> 原因在于：1、GitHub给了源码 2、初期代码都是核心代码 开源项目代码中Java太多，如何看呢？跑起来，通过log找主类？和流水线 串线、串流程、走读代码最好的方法是，打调用栈---------> 非常快，且准确！！！ 难点在于跑起来， 哪些串线：流程串线以及关键量的流转串线 代码走读就是串线，包括Z，包括任何代码！！无论是应用代码，框架代码，A代码还是z代码！！！！关键在于如何跑起来？ 如何跑起来：1，代码要能编译----------> 开源软件apk；框架代码匹配手机 2 构造触发点：流程向上游找触发点！！！！（1）点击apk触发，以用户角度触发 （2）主动去调。。。上游的任意一个函数----------> 这里的可操作性非常大！！！！！！上游函数很多，有些易调到，比如Imm可以直接被apk获得，从而可以调control框架代码里的接口！！！！！----------> 实现了button调用框架代码！！！！ 规定，跳转画完的流程图，之后也一定加调用栈验证一下，很快！ 规定，画完图，用一两句总结一下，这个图的流程，创建了谁，又怎么流转的 一个量的流转图，要回答从哪里来，怎么流转的，最终去了哪里，做了什么 时序图，中重要的量，也要回答上述问题 一个方法，尤其重要的方法，你必须回答，是不是触发点，这个方法做了什么（很可能是做了一些事情，作为另一个流程的触发点） 那到底他是做了他这一级的事情，还是向下递归的事都是他做的呢 一个方法做了什么，还是一个类做了什么！！！！！！ 三方应用app出问题-----> 先看我们测试demo有没有覆盖这个场景 -------------> 这也是demo APP存在的意义！！！！！ 看代码，要回答：从哪里来？属于哪个进程？？？（即属于哪一侧？） -----> 总之一句话，一定要有好的问题？？？？----------> 好的问题哪里来 你总结了很多方法，有没有在任何一件事情上，考虑能否应用？将方法应用范围延拓！！！ 无论是知识，还是专利创新，一定要吸收别人的！ 杨云帆有个习惯，走在路上，游泳的时候在想事情。很有效果，换脑子，换心情 输入法架构的必要性在哪里: 时序图体现了具体怎么做，但是不能回答为什么这样做 从类图里可以回答为什么这样做 从组建图里可以更可以回答为什么这么做，这么做的必要性！！！！ 有迹可循的创新: 迁移与联想能力 任何细节的补充只能依附于主干，加强主干，不能扰乱主干。。。记忆，知识点，都要联系主干 不断加强主干！！！！附属的自然强 一级一级地抽象出主干！！！！！ 主干与分支关系：站在主干理解分支，站在主干记忆分支 ----------> 具体应用： 理解时序图，要站在类图上（高维度） 理解时序图，要站在组件图上 理解动态，一定要站在静态的基础上 理解与记忆，一定是主干与分支，抽象与具体，相结合的产物 把琐碎、细节挂到主干，核心上 -----> 推论：画图也是如此，不要一张图画很多东西。一张时序图，画一个东西，然后挂载到主干图 高手在于，拆分、链接、主干ji -----> 站在全貌上看，做局部 ----------> 对于Z，安卓永远是主干！！！！ 1.学着用肉体操纵精神： ----------> 治愈拖延，自律就很容易 我们无法自律、无法坚持的本质原因：消耗意志力资源，但其极其有限。用精神控制肉体，终究会失败的。 例子，如何坚持读书？不要管你想不想读，先把书拿出来，看一会儿，逐渐会发现你看进去了 你把你的身体,放到一个场景中,你的精神怎么办呢?嘿嘿,它会自然而然地接受这个场景,并且顺势地\"继续下去\",甚至还会将做这件事的“痛苦\"化为“快乐”。 所以啊,为什么要学会\"用肉体控制推动精神\",而不是相反?还因为你的精神会在你还没行动前,就给你设置了一大堆障碍、想象出一百万种失败场景把你吓尿。 2训练感官的能力; 3.让自己突然变开心的能力; 这三种能力同时满足:很重要,但是大e 没有的要求,并且还是很多听起来不错的\"能 力\",比如自律、抗拖延、调节情绪.. 力的基础。借个时髦的词儿,叫\"元能力\"比。 每天百分之十五的时间学习总结 每天百分之十五的时间思考提升的方法，建立长久 很多事情，如何从长的尺度去看？？？？？ 有些人不哄女生，而是和女生讲道理 原因在于，考虑长期的相处方式，而不是像渣男一样，一时的哄骗 太用力的人跑不远。 努力不应该是某种需要被时常觉知的东西,意 志力是短期内会用完的精神能量。 真正坚持到最后的人靠的不是激情,而是恰到 好处的喜欢和投入。 当坚持不再成为需要被言说的事实或是需要被 排练的步骤时,它就成为了我生活的一部 分,而不是什么挂在生活之上的负担。 最长久的陪伴不费心力。如果你真的喜欢 人,真的想在他身边一辈子,就不会说有多么 爱他,而是觉得\"每天能和他在一起,就很 好。 太用力的爱不仅让自己累,也让身边的人累。 https://www.zhihu.com/question/304174916/answer/825079036 把所有问题都放在纸上思考 系统性、流程化 人和动物的差别在于工具 人与人的差别也在于工具-----> 要善于用工具、善于用人！！！！ 绝不看抖音与朋友圈 每天留半个小时抄写经书。半个小时深度思考 高手是深度思考的高手；是自我管理的高手 思考本质的东西 每天早起 每天喝温水 每天晚上列计划，第二天执行 总论：任何事物总是守衡，均衡的。你要想达到一定目标，就要主动构建差异化 例子1: 睡眠只是其中之一 例子2: 绝大部份时间，要时刻利用大脑深度思考一些东西；也要学会利用十分钟，让大脑完全放空 例子3、坐大部分时间，也要学会站 例子4、大部分时间睁眼看东西，有时候闭上眼睛，看的更清楚 例子5、 做一个极简主义者、本质主义者！！！！！！！！！！！！ 把精力放在本质上 我一直强调主干（本质），却没能做到！！！！！！！！！ 比如工作中，只做主干的核心活，放弃噪音 比如，问题没能一眼看穿本质 如何剔除噪音、寻找主干？？？ 1、识别入口和出口（即起与终） 2、 你把你的身体,放到一个场景中,你的精神怎 么办呢?嘿嘿,它会自然而然地接受这个场 景,并且顺势地\"继续下去\",甚至还会将做这 件事的“痛苦\"化为“快乐”。 所以啊,为什么要学会\"用肉体控制推动精 神\",而不是相反?还因为你的精神会在你还没 行动前,就给你设置了一大堆障碍、想象出一 百万种失败场景把你吓尿。 元能力二:训练感官的能力 问你几奇fti题。 你有没有刻意训练过自己耳朵,让它能ぜ ashi: adibility级 组件级 dialog 里view不属于 contentView的体系。。。delegate是塞给了contentview极其子类 ----------> 所以他说，目前无障碍功能是contentview粒度的，contentView级别的 contentview粒度----------> 是其对无障碍边界的高度概括。。。而我为什么不能？ 点灰的地方，dialog里的安卓view会收到响应，这是AgpwIndow做的。----------> 具体代码？ gongashi从架构上推导出，能不能做，有必然性。。。。 不要先用代码去验证，先从架构，有哪些类，从而推导能做哪些事情。。。 哪些类，支撑流程到哪一步 了因: 思考那些不得不的东西，市场，代码，fupiao，题目解法 log不稳定，怎么办 ----------> log要稳定，要有层次，要干净 log能解决一切，包括类在哪里创建。。。项目中，有没有一个类，以及其子类！！！！！！ viewtree与client关系 clinet单例，新Windows，清掉之前的 -----> 所以，单例也是可以的 只给出解决方法，而不给出缘由，这不是解答！ 了因: 可叠加式进步 可叠加式，如Git，如备份，如docker的commit。毁坏了，瞬间恢复。。。叠加式在于，之前所做，没有浪费，为后期垫脚！！！！！！ 进步 了因: 管理，也讲究减法 学习毕晟，流程化，把账号给别人 利用加分警告早点填表 马占福把计划交给必胜执行，自己早早下班 催人，一定要针对一个人，打击一个人。邮件或群里批评最差的 催人，催主管，让主管施压 任何事情，只和pm对接！！！！！ 有很多问题时，只要针对最多的那个子系统打，不要铺开 如何逼人做事，每半个小时反馈一下 学习知识，更要学习别人的智慧，管理，集合其他人的优点 如何催一群人？一个个打电话，效率低，，，，把所有人拉到一个群里，完成的退群 了因: 理解一定要基于例子，但是也一定要抽象、提炼、甚至升华，，，，看透本质的能力，，，，反思能力，，，轻装上阵，，，，精力，，心流，，，，时间的任何利用，，，你必须非常非常努力，同时着眼于当下，，为什么如是因，如是因！不要管结果。。。。。兴趣也不是最好的老师，而是兴趣导致的坚持。任何事情都怕坚持！！！。。。遇到问题，一定冷静再冷静。。。。。利用一切零碎时间思考，优于集中时间。。。。任何事情，一定要找到深层次的原因，深层次，这样才。。你要成为领导者，不要畏畏缩缩！！。。。人与人之间的差距在于工具，实体工具，思想工具。。。。。。。不着于象。。。。。重心永远在工作上，永远！！！。。。。。。对面若有人，那么你一定比他强，你是能啃硬骨头的人。。。。思路哪里来，参考（参考别人，z参考A)。。。。。刻骨，让公司离开你难受。。。。。做任何事情都要分清主次，尤其是做决定的拼命去学。。。时候。。。。我要成为领导者。。。。思考。。。拉筋，，，聚焦，，，，google ！！！ 27了，真可怕。。。。如何客观评价自己？。。。。对于理解，文字（包括代码是非常操蛋的东西。理解时，脑子想着的东西越具象越好。。。数据永远不会骗人，眼睛会。。（瘦与胖，通过手机视频。。。。。。聚焦事业！！！！。。。。。这短短的一生，我们都将失去，播放大胆一些，勇敢一些，爱一个人，追一个梦，爬一座山。。。。。主动当责。。。。。不可替换。。。。。身体和事业，其他都是副产品。。。。自信！！！！自信。。。。。沉下去。只争朝夕！身体！！！！梳头！！！！格局!!!!!!!!!自我管理与他人管理（必须安排计划表），，，刑法：晚上床上不准手机！！！白天不准床 。。。。？男生说话，不要说带情绪的话，尤其负面情绪的。。。放下。。。军人好睡，犯人好睡（无3c电子产品，千万不要手机）。。无韭菜、洋葱、豆腐、青椒。。。。助眠：牛奶。。。。看书，尤其纸质。。。暗的环境。。。脸皮要厚！。。。声音大！。。。。不要急，慢慢来。。。。。人生就是问题组成的。。。。太有意思了。。。。人脉资源！！！。。。多建立忘年交！。。。。让你的领导毫无顾忌的骂你。。。。能发动各种资源，超过个体价值。。。静能生智（带降噪耳机，闭目）。。。。太有意思了！！！。。。 人生在于做减法，因为做减法留下的东西是本质，而且能留在脑子里；任何问题都记着做减法（人生方向，题目解法，阅读代码，代码架构，做笔记，）。。。。代码运行就是水流，分叉聚合。。。代码如何做减法：分主次—————主，代码流水始终出不来的类为主类，用一次的便是次要的（砍掉）。。。。极致的努力与爱。。 找老婆如找工作，多试。。。。。人活着就是为了解决问题而活，钱名是副产品。。。。情商高，会夸人，苏神，锦科。。。。任何事情都有其底层逻辑。。。。。难问题的解决方法------每天看一下。。。。学会拒绝。。。。念头纷飞，最好的方法是替代，读书。。。学很难很难问题的方法，每天看一遍，尤其睡前。。。。看人与看事一样，先看了轮廓，轮廓最重要。。。。。。。。。单线程去做某些事情，做到专注。。。。。最好的状态是自然。。。任何事情都不要做足，帮人，吃饭，性。。。。缺憾才是恰到好处。。。。学一样东西，先要忘了它（它去理解其存在设计的必要性），学会了更要忘记（学会抽象出其精髓）。。。。。。。。方向大致正确，绝不能很正确。。。。。。多看高手思考的文章与话（一句话胜过十年书，十年磨难你才能总结出的:方向大致正确）。。。。难的问题，深的问题，每天看一遍 。。。。。对人，也要抓住干。。。。。方向大致正确 组织充满活力。。。。极度努力，你可以踢掉公司，而非。。。。。。。30岁了，要学会*聚焦。。。。。行痴。。。。。。任何事物的发展都要由具象到抽象，不断抽象的过程(数学的发展、人的真知、学习，题目---------方法的总结、工作：具体代码，文档设计，领导项目，领导公司，愿景)。。。理解问题一定要具体（结合具体例子），理解后一定要抽象(抽象总结)。。。。性格！！！！！！！！！！！！终其因，是你的性格导致你在组内无法出头。。。。。。关于坚持 、自律、克制欲望终极目标------------------美学 。。。。。。大胆一些。。。。。疯狂去学。。。。抓主干，对技术、着迷，其他永远是顺带的能力。。。。。声音大，气势上压倒别人。。。。记忆与理解，必须依赖具体例子、场景，同时必须总结抽象化。。。。。成为时间的朋友，做一个长跑着。。。。。你必须快速升职加薪，你没钱花了。。。。。学习一定要使用倒逼方法，题目倒逼，代码倒逼（现对名词，知识体系框架名词大概了解一下即可）。。。。充分利用反馈机制。。。。知识，最后一定要有框架，目录！。。。。说话，老余，声音稳定，有底气。。。。。分析思路要清晰。。。。任何事情，强行都不好（感情，学习，记忆，理解，交际），要自然。。。。深刻，向下。。。。。爱。。。屎尿渠，，，，，，被需要的时候才是有价值的，，，， 升级，年薪百万。，，，，一日即一世，，，，，囫囵吐枣，，，抓住主干，熟悉主干后，完善细节，，，，，，，，，，，，如果你的工作招聘一个高中生通过一至三个月就能上手那么你的价值在哪里？，，，，没有年薪百万，没有高职级我会死掉，，，，求求你，让我再多看一道题，多学一个知识点，，，，，，，，，认真，空间，是你的就是你的，，，，，，本质，基础：事物一定要触及本质(不耗时)..打好基础，好时，，，，， 自然是本质本质是自然，，，，，，，，，，加完班的无聊感导致，，一天就是一生，一次就是一生，，，，，求求你，让我再学一会儿，再进步一次，，，求求你，让我追下去，再追下去，，，如魔如疯，，，，一定要识别什么是好的，是深刻的！！学会主动找好的，深刻的，，，，，充分利用切换，加班不可怕，，， 注重效率，即领悟本质的时间！！ 噪音信息太多，害处非常大，----------> 挑选被别人检验过的，尤其评价好的！！！ 纸上记录： 疑问回答 模式推进问题 计划完成 声音记录： 录音！！！！！ 锚⚓️ 记忆之锚 逻辑之锚 源码，逻辑之锚 很多事情，如何从长的尺度去看？？？？？ 有些人不哄女生，而是和女生讲道理 原因在于，考虑长期的相处方式，而不是像渣男一样，一时的哄骗 太用力的人跑不远。 努力不应该是某种需要被时常觉知的东西,意 志力是短期内会用完的精神能量。 真正坚持到最后的人靠的不是激情,而是恰到 好处的喜欢和投入。 当坚持不再成为需要被言说的事实或是需要被 排练的步骤时,它就成为了我生活的一部 分,而不是什么挂在生活之上的负担。 最长久的陪伴不费心力。如果你真的喜又区 人,真的想在他身边一辈子,就不会说有多么 爱他,而是觉得\"每天能和他在一起,就很 好。 太用力的爱不仅让自己累,也让身边的人累。 https://www.zhihu.com/question/304174916/answer/825079036 把所有问题都放在纸上思考 系统性、流程化 人和动物的差别在于工具 人与人的差别也在于工具-----> 要善于用工具、善于用人！！！！ 绝不看抖音与朋友圈 每天留半个小时抄写经书。半个小时深度思考 高手是深度思考的高手；是自我管理的高手 思考本质的东西 每天早起 每天喝温水 每天晚上列计划，第二天执行 关于睡眠： 裸睡，低温 随时带着腿黑 十二点必须关灯关手机 准点睡，最重要的是准点起，7点半 白天多晒太阳，抑制褪黑素。回家就关灯，留小灯。 休息不一定要睡觉，而在于放空大脑 总论：任何事物总是守衡，均衡的。你要想达到一定目标，就要主动构建差异化 例子1: 睡眠只是其中之一 例子2: 绝大部份时间，要时刻利用大脑深度思考一些东西；也要学会利用十分钟，让大脑完全放空 例子3、坐大部分时间，也要学会站 例子4、大部分时间睁眼看东西，有时候闭上眼睛，看的更清楚 例子5、 做一个极简主义者、本质主义者！！！！！！！！！！！！ 把精力放在本质上 word适合展示具体细节东西。但是很缺乏结构性、框架性东西。如刘刚所说，很散 程序员不是写代码的，代码只是表象 要像SE一样，不写代码，但其实代码都是他写的。 1、把已经写好的代码，转化成对象，事物之间的架构、逻辑。 2、要解决的问题，从对象的架构和逻辑上分析可行性解决方案。。。。-----> 这本质上与代码无关了！ 好的程序猿，一定心中没有代码！！！！！！ gongashi他告诉我，1、不要关注于代码，要有对象提炼。 2、弄懂z之前，一定把安卓的流程弄的非常熟练 调用栈不知道底，如何知道底， 网上搜 找地图 6. 学习如何学习 6.1. 总论---学习方法论 6.1.1. 简--繁 的无限循环： 图 上 下， 是证明！！！！！！ 下到上的证明（只能证明，不能记忆）： 先从最基本的概念出发，从最简单的问题出发，通过逻辑推理一步一步推演出整个系统 上到下的归纳，归一： 细节虽繁 -> 大道至简，我们就要去帮助大家再把刚才所讲的所有知识梳理一下，整理归纳一下，重新回到大道至简的状态 站在任意的一个点上，一定要做两件事情： 向上：更具象： 5w2h 向下：更抽象：通用迁移、万能 一切思想的，都有物理性！ 一切物理的，都有思想性！ 6.1.2. 功能 结构的 无限循环 TODO: 图 功能 结构 ， 功能与结构之间是支撑关系，也是证明关系 -功能是根本（是标题、是思考关注的点、“为什么”的原因、是目的、是目标.................） 功能是上面 “简--繁 ” 的 “简” -------------归一 （所以，功能是简单的，其实现的结构是复杂的） 例子：IDE 代码跳转，有时候就找不到 所以，要分析跳转结构。总结跳转有哪些结构？查找有哪些结构？ https://www.campzhe.com/archives/1372 6.1.3. 闭眼 闭眼！！！！！！！！！ 1、沟通神识的方法 例子：看别人软件架构图 ，一定不是你 神识中的图（因为方向、重点都不一样）。别人的图 一定都是垃圾，因为一定会与神识中的图 冲突，造成紊乱。 而 神识中的图，才是你的唯一 方法：闭上眼睛，构建自己的图 -化简的最终目的，就是一，一就是神识 所见都是垃圾，尤其是别人的 2、闭眼：才能看得更清楚、屏蔽细节。 -从物理层、更本质的证明（理解） 6.1.4. 追求一 极度化简 极度忽略细节 极度追求本质（物理层面） 所见都是垃圾，唯有神识是一 6.2. 结构之 知识框架 看视频，是搭建知识框架的非常好方式： 1、有个模糊的概念就行，后面自己填充 2、自己看书/看博客，不适合用于搭建框架 ------------> 因为静态的东西，不会告诉你重点是啥？没有重点，你会累死，而且容易遗忘 3、自己看代码总结，比2还要傻 6.3. 学习动力与阻力 好奇心是根本动力 ----> 多问。培养好奇心 做学问：好奇心重要，品味也很重要 动力的好坏： 美感 > 好奇心 > 兴奋点 > 竞争、攀比 激发了我探索这个世界的兴趣 ---> 来理解大自然的工作机理 激发了我探索系统的兴趣 ---> 来理解系统的工作机理 ------> 为机理而活 我对科学有兴趣只是因为我想了解这个世界， 我发现越多， 探索世界这件事情就越美妙 我迷恋于 应用的级别，为啥呢？我觉得会使用某一项技术后，会方便很多 ----> 便利很多，超越很多人 --------> 我关注的点（兴奋的点）的层级， 决定我的层次 --------> 如何改变兴奋点呢？ 兴奋点： 在主要任务、主要分支做出主要贡献 不急、不重要、不是必须+费时间，就靠后 6.4. 动力： 成瘾-----奖励机制 见上： 学习知识 如何成瘾？ 6.5. 阻力：缓解痛苦 难题、知识过于复杂、游戏闯不过去、环境搭建总是失败、苦思冥想 ，都是佛家 求不得的痛苦 ------> 这些必然会产生痛苦，可是我们又没办法规避，必须做出来。 那么，如何缓解这种痛苦呢？方法： 1、想办法，降低问题的难度 --- > 做一个低难度的、阶段性问题，适应了再逐渐升高难度： -比如：学习安卓的显示系统，自己看代码难度为90，看技术文章为60，挺别人讲视频20 ​ 正确做法： 先看视频------> 视频了解后，看技术文章加深------> 最后跟着代码走一遍 2、梳头 3、对于非常困难的，需要常年累月的问题，可以做一些，不通的话，先休息几天，再尝试 比如之前搭建Docker搭建代理环境，我前前后后，弄了一年多，终于弄好。还有linux可视化界面 4、多看看大家的视频，尤其张益唐的淡泊 6.6. 学习之无招胜有招 真正意义上的复杂系统，必须来自于简单的规则，以及在时间这个变量的参与下，衍生出的无穷可能性。 ---------> 风清扬给令狐冲 风清扬对令狐冲的武功教诲和岳不群对令狐冲的武功教诲是截然不同的，风清扬对令狐冲人生的教诲更为精妙，更合令狐冲的脾气。这一回的传剑是实实在在，风清扬的一剑中竟有三百六十种变化，这种武功是不是真是至高无上的呢？但风清扬传剑术与令狐冲，虽说是剑术却有另一种高人境界，放飞自我，做学问方法。“剑术之道，讲究如行云流水，任意所至”，学问之道，生活之理，其实亦是如此 无招胜有招，说的并不是没有任何招式，白纸一张。而是： 1、掌握最核心的精髓（极度简化，近似无招） 2、基于精髓，任意演变 （行云流水，任意所至），从而可以忽略演变，无需记忆： -通过链接一切，做到极致化简。例子：三百六十种变化，风清扬知道如何由 三百六十种变化 链接到 一剑 ，所以在风的眼里，只有一剑，忘却了三百六十种变化 无招胜有招，说的就是极致化简（超级减法） 具体如何化简，见《化简-----> 检验是否学会的标准（也是学习的方法）： 见下 当你觉得一个东西复杂的时候，一定是 1、你理解没深刻 2、你看问题的角度有问题 复杂的东西，其内核一定是简单的、明了的 复杂的东西，不仅内核简单明了，本身也一定是简单、明了的（这世上不可能存在复杂的东西） 人是不可能，理解与记忆复杂的东西。 真传一句话。 这也是 检验自己是否 真得的标准。 柯浩然-------------------一法通，万法通 6.7. 无招胜有招之目的论 目的论就会让我们忘记，不需要记忆 有了目的，就不会无聊。听课也会有主动性，看书看代码也是 关于目标： 不应该是1个小时内，进度多少 -----------> 而是，一个小时内，获得多少智慧？见过路途中多少风景？ 6.8. 无招胜有招之链接实操 6.8.1. 理想的学习知识路径： 1、左图：我们不可能认识一棵树: 一棵树有太多的细节（叶子），仅仅外表都让我们眩晕（还有叶子光合、树枝养分吸收等等）：比如 安卓的操作系统，各种操作、各种功能 2、中图：将 一棵树 的主干、主要枝丫、果实 提取出来，忽略细节 （抓住主干的能力）：比如 : 安卓系统，显示与触摸就是两个大的主干 3、右图：对主干、主要枝丫 留一两个关键点（极度化简的能力：不得不的点、唯一决定的点）。比如：安卓系统的显示的根本是surface上的数据 4、基于右图链接： 树根------树节点1----树节点2----果实 一定要形成关键节点的强链接 5、如何认识系统？基于最简的关键节点 （右图），反推 左图 ： 如果不基于右图，我们永远无法理解左图，反而越理解越糊涂！ 6、一定牢牢地把握树根，把整个世界链进去！ ----------------> 知识的应用便是从 树根 链到 节点1，节点1链到节点2，最后链到果实的 过程 常见的一些例子： 写文章也应该如此--------文章目录就是 关键节点----key 看文章也是如此--------只需要看目录结构就行 规定：看文章时，必须旁边有目录章节，随时看所处的位置： 定位bug，也应该如此---------看关键status 我们记不住这个世界，只能记住这个世界的所有key，链接所有key 打开最外层的.md, 则可以链接其他所有的.md文件： 6.8.2. 从记忆中搜索的路径： (字典 《----------------------------------------------------------------------------树 《----------------------------------------------------------------------------以锚点为基) -要求： 锚点必须熟练记忆 树的路径尽量熟悉 字典无需记忆，只需要知道怎么查： 锚点 ---> 树 ---> 字典 由此推导出一个行文要求： 0层架构必须熟悉、1层尽量熟悉、3层是字典了，必须删除（知道如何查） TODO： 写文章存在的一个问题，如何让1、2、3层的论述 完美隔离（但又能联系的很好），因为2中有3，会让视觉与记忆陷入混乱 写任何文章，记忆，理解 -----> 最关键的是关键词（锚点） 例子： 人为什么喜欢给别人贴标签呢？ 比如： 老板认为这个员工是个懒惰的员工 ------------> 标签： 懒惰 那个员工是个很有创新性的员工 ------------> 标签： 创新性 ---------> 结论：因为人的认知、记忆、推理的模式就是： 从锚点出发，向前链接........... ​ “标签”就是人认知的锚点 ----------> 推论： 学习方法： （1）疯狂给自己的知识贴\"标签锚\" + 链接 比如： cpp性能高 、java跨平台性好、c 硬件性语言 比如flut ： UI框架 + 渲染引擎 ​ （2）“标签锚” 是极大化简工具。少量标签精确记忆，其他依附记忆 6.9. 如何化简？ 原则：【1】 核心尽量是绝对的锚、【2】 逻辑链彻底的短、【3】 逻辑链要强固 关键在于【2】，因为人不可能记忆长的东西 应用一：代码的化简 比如： 起点----目标反推法 见 TODO: 延拓应用领域 ​ 写文章 ​ 思考代码 6.10. 学习之底层逻辑 6.11. 学习之 以问题、面试问题驱动 目的论 6.12. 学习知识之各个维度------拆解|切割 学生时期课堂里，老师讲课的方式是从下往上，一步一步搭建完整个楼（知识）给你看 --------------> 社会上的海量知识，差异： 1、海量知识，难以一步一步； ------------> 对应方法：拆解、看大的纵向 2、由于知识是已经完成的事物。自己去看，必然是 从上往下；我们很难理解（甚至看不到）从下往上（房子最开始有没有搭地基、房子内部结构是怎么设计的） -------------> 如何更好地逆向？如何从上到下的角度更好地理解？ ​ 对应方法：目的论（基于目的，一步步论述 每一个“下”的合理性） 目的----出发点 寻找问题------回答问题 （这其实也是目的论） 字面上--------结构上----------本质上 纵向（大的）-------横向 如何深刻？ ：上面的技巧，无论如何，没法做到深刻。。。。。要深刻，必须有深刻的问题嘛？ 6.13. 学习效果拆解 &checkList 参考： https://www.zhihu.com/question/324702775/answer/1007956506?utm_campaign=shareopn&utm_medium=social&utm_oi=903075405244817408&utm_psn=1586476031338307584&utm_source=wechat_session 学习效果=有效学习时间*学习状态*学习方法 -------> 逐渐从这三方面拆解 手机远离5m以上 方法： A4纸检查法 6.14. 学习材料 有言者： 老师（学校老师、年长者、培训视频） 书本（技术博客、互联网） 无言者： 学习一切差异化的思想 ： （1）别人与你不一样的地方 （2）识别好的 ----> (3)拿过来学习 -----> （4）拓展应用 比如：aosp编译前，source envoromrnt.sh ------> 就是一个很好的思想（把root下所有环境都初始化好，比如make 在任意目录下执行都一样！） TODO:应用 6.15. 如何超快速学习新事物？ 1、吸收先进的理念（想法、技术） -----> 结构上的吸收 2、嫁接到已有，删减 -----> 结构上的删减 7. checklist 7.1. 思想模型 证明！！！！！！！！！ 闭眼！！！！！！！！！ 分析之5W2H 分析之 物质、能量、信息 根因，一定要找到物理级别的!!!!! 避免模糊！ 解耦思想： （调试linux，把安卓干掉！！！！机器卡，把CPU占比高的干掉！！！依赖，干掉） ​ 两个纠缠，干掉一个。。。。精髓在哪？神在哪儿？ 学习大智之人！！！向伟大看齐！！！ 避免负面情绪！！！！ -追求利，而不是追求真（真意味着现实、意味着悲观！！！！意味着喋喋不休） -------> 学习李嘉诚！！ 一切思想的，都有物理性！ 一切物理的，都有思想性！ 《思想模型》 在各种领域里用上述思想工具： 生活、工作、知识点............ 行为主线： 计算机、理财、数学 我这一生，被心态毁了 向后看，蔑视过去的创伤 向前看：TODO 法则： 1、 六根是驱动、大脑是cpu、灵魂是....... 2、符合专注模型（不相容）： 如果 专注于 自己的六根，那么大脑和灵魂都会被压制 --------> 比如，享受美食时，大脑没有了，灵魂也没了 如果专注于大脑...............................................................---------> 比如，钻研于困难问题，茶不思（六根） 如果关闭六根、关闭大脑 -----------> 便开悟状态 3、所以，如何戒除色欲(大脑) ? 专注于物质（比如暴走、比如美食） 或者 进入 开悟状态 对立与统一，checklist： 经常变换角度、先切开再切换： 抽象与具象（金字塔模型） 理论与实践（学习与工作） 模型与应用 长期目标与短期目标 恩与威 学与思：学而不思则罔，思而不学则殆 终日而思，不如须臾之所学也 7.2. 精力模型 ​ 《精力模型 .eddx》 8. 道，天道 道是最大的结构，是一切规则的合集，是自然和社会规律 得道得一切 美好的东西，本身就值钱 ----------> 所以要记录 # 精力管理 最优： > 投资：金钱的最优 > > 注意力的最优 > > 精力的最优 **管理精力，而不是管理时间！！！！！！！！！！！！！！！！** 不悲不喜，永恒大喜悦；隔离你的感受 职业生涯，往往精力确定最后跑的多远 意志力是最不可靠的、最不可持续的东西 从底层思想上看，精力管理的精髓在于 抓大放小： 把精力放在大上 ![img](ReadingAndThinking.assets/v2-70b709119ceed6d5c3b598991517a11f_720w.webp) ## 降低消耗 ### 他耗： 他人即地狱 具体技巧：对于level比较低、能力弱的人，不要争辩 -----> 只能徒消耗自己 ### 内耗 具体技巧： 管我屁事 ### 抓大放小 比如： clion过一段时间，激活码就失效，还得再去找------> 淘宝上6个月激活码才4块。十年也才80 ​ -------> 从经济上，完全是小，不值得投入精力去找免费的 再比如： docker的各种问题，因为docker可以通过jar，每次commit ------> 可以复用，一次解决，终生解决 ​ ------> 可复用的东西，是值得投入精力的 大与小的checkList： | | 大 | 小 | | ---- | :--: | :--: | | | | | | | | | | | | | ## 睡眠 关于睡眠： 裸睡，低温 随时带着腿黑 十一点必须关灯关手机 十二点睡 准点睡，最重要的是准点起，7点半 白天多晒太阳，抑制褪黑素。回家就关灯，留小灯。 休息不一定要睡觉，而在于放空大脑 下午以及晚上，一定不要喝茶、奶茶、咖啡 如果晚上实在睡不着，就起来吃饱-----> 吃饱的情况下，容易睡着 放松大脑的利器： > 1、看视频 > > 2、看已经非常熟悉的视频（不新鲜的） 激活大脑的： > 1、听小说 脑力劳动者有几大问题： > 1、**身体没有充分的疲劳**导致睡眠往往更差,要么睡不着,要么睡着以后半睡半醒。 --------> 要有足够的身体疲劳 > > 2、大量使用**脑力**后,一样会产生**严重的饥饿感**,吃下很多食物和糖分,但是又无法消耗。这就导 致了。脑力劳动者在不配合体力劳动或者严格的自我节制的情况下,会得不到良好的休息, 身体状 态很容易肥胖化和营养过剩。 -------> 如何减少饥饿感？ > > 3、脑力劳动的疲惫感非常之不明显,一般人疲惫的节奏,和身体天然形成的节奏差别巨大,很难保 持在24小时左右这个周期里, 这就导致了很多人会间歇性的熬夜或者失眠。 > > 4、脑力的消耗会导致人的自控力下降,在需要关灯睡眠的时候,却克制不住自己玩手机,由于光线 的刺激,越来越兴奋。 -------> 自控力下降 > > 5、大脑的疲劳会让人非常不愿意运动,同时自控力下降会使人无法主动运动,缺乏运动。加重失眠 和热量过剩。 这样,就会形成恶性循环,脑力耗尽不能做体力活动。缺乏体力活动,导致难以入睡。睡眠不足, 导致脑力下降。螺旋下滑,而这个循环是非常容易进入,且难以打破的,需要很大的毅力打破 他,但是一两次的放纵或者紧急任务就会把人重新拉入这个循环。 **解决方法：** 1、尽可能早起,早上醒来马上起床,不要赖床,快速的进入到明亮的环境中去。如果工作生活允 许,可以保持一到两周的强制早起 (6-7点之间)来恢复节律; 2、早上起来进食大量的蛋白质来减少全天的饥饿感。避免因为蛋白质缺乏,而无法自控进食大量 零食导致的营养缺乏型热量过剩所带来的肥胖和精力上限降低的问题; 3、保持饮食的时间,摸索自己的承受度, 把晚饭放在一个睡前不太撑也不太饿的时间点进行; 4、尽可能多**晒太阳或者在明亮的光线下(室外)活动一两个小时**; 5、摸索自己的睡眠节奏,在睡前的一个合适的时间运动半小时左右。运动后会有一个兴奋期反而睡 不着,但是每个人的兴奋期不一样,所以要自己摸索自己的周期; 6、尽可能安抚自己的情绪,说服自己不为生活中的小事烦心,避免情绪的干扰,消耗仅有的自控力 Q,打乱正常的节奏。 ### checkList ## 内与外 的关系 干活，应该是事件驱动--------> 因为内心是极度不稳定的东西 事情驱动，太痛苦 内心驱动，会很容易放纵。内心的不稳定造成的（对于天才，反而是） 内心的纠结，会导致一个人唯唯诺诺 -------> 内心的外化 是导致人被看不起的**根本原因** 所以，将外的纠结、物质的贫困 与 心里的平静、富足 分隔开。。。。比如： 佩雷尔曼家徒四壁，内心却异常富足，给人的感觉也是 ## 极简主义 与 扣 我们的终极目标：**内心世界的极简** -----------> 衍生的表象： 1、对物质的极简。虽然都是物质简单，与扣是完全两种相反的东西： 极简主义：由内向外，内心追求极简，导致外物极简 -----------> 保护了内心与精力 扣： 由外而内，外物的纠结，导致内心的紊乱 -----------> 内耗严重 ## 到底要不要 一个光鲜的外壳？ 外壳： > 一个邋遢的外表，让人第一印象很差、让人看不起。。。。。。。 > > 一个好的车谈生意能让老板看得起 > > 吹自己的经验、能力，吹高有利于获取更多的资源 同时，如果你对上面的东西，很反感。。。。。那么外势必引起内心的紊乱、内耗 差的外壳 > 你在公司经常说你是土木毕业的，这样就会让同事觉得你不专业 满心欢喜 -----------> 如何智慧地解决这一问题呢？ ## 关于心态、心境--------动力问题 进一寸有一寸的欢喜 希望成为查理芒格这种有智慧的人 -----> 如何倒推？ 方法： > 1、每次低沉的时候，看一看张益唐的采访视频 > > ## 得到课程 https://www.youtube.com/watch?v=Dot4oW61Q0w&list=PLF9eBHC33xs9jlPDEvj81v5BM3RgSw_Uu&index=2&pp=iAQB # 时间管理 这时间最贵的就是时间 --------> 每天问一下自己，今天的收获是啥？值得嘛？ ## checkList 1. 戒除手机：尽量用电脑。 2. 电脑工作背景音乐：~~让人停止思考的钢琴音乐。https://www.youtube.com/watch?v=PtqevDJz7W8~~ # 善护念 1、尽可能不与别人争辩：不与傻瓜论短长 2、不要让其他人对向你的脑子里灌输 垃圾： 不看抖音、小红书等 3、觉察： > 生活中看到的大部分都是垃圾 > > 生活中听到的绝大部分都是垃圾 判断是否值得看、值得听、值得想的唯一标准：是否是智慧、技巧 9. 觉察系统 TODO：如何建立？ 10. 阅读 10.1. 为什么要读书？读完书就忘 读完书就应该忘 读书的目的在于： 1、得其神（书中的思想、人格、模型、方法论），忘其形（事情、时间、地点、人物） ------------> 反馈：用 书中模型，应用于生活 2、截取书中的树结构中重要的点 -----> 链接到你的树结构中。同时要做好化简。用结构链接一切你要的知识点 ​ 注意：如果保持 原书的结构，永远都不是你的 例子： -----------> 链接到你的结构中: (1) 学习的方法树中 或（2） checklist中 10.2. 书单 柳冠中推荐的书籍： 伟大的探索者 ----> 人生的信仰问题 一般系统论：脱离知识结构的元素，是毫无意义的 关于人为事物的科学 自然资本论 10.3. 如何训练思维的深度？ ------> 5why法（向前追因） 和 5so法（向后追果） https://www.zhihu.com/question/19553569/answer/208715100?utm_source=wechat_session&utm_medium=social&utm_oi=903075405244817408&utm_content=group1_Answer&utm_campaign=shareopn 思维的深度，可以说就是逻辑链条的长度。 5why法，简单来说就是连续追问为什么，寻找问题的根因。 一个合理的层次是：追问到问题变得没有意义为止。 为什么东边的墙上有很多鸟粪？ 调查发现，原来是因为墙上有很多蜘蛛，而这些鸟以蜘蛛为食，所以经常在墙附近活动。 为什么墙上有很多蜘蛛？ 因为墙上有很多小虫子，而蜘蛛以这些小虫子为食。 为什么墙上有很多小虫子？ 因为东面墙上有几扇窗子，半晚时候博物馆里的光会从这里透出去，而这些趋光性很强的虫子就被光吸引过来了。 所以，正确的解决问题方法应该是，在窗户那里安装遮光性很强的厚窗帘，这样就能彻底解决问题了。 5 so法 比如金融投资。比如几年前国家发布多个政策，多个场合明确表示要进行产业转型。 So？ 新能源汽车是产业转型的重要方向之一。 So？ 新能源汽车将会迎来很高的产量爆发（新能源汽车股票值得投资）。 So？ 锂电池作为新能源汽车核心部件，其需求量会暴增（锂电池股票值得投资） So？ 锂矿作为锂电池原料，起需求量会暴增（锂矿股票值得投资） 10.4. 思考快与慢： 10.5. 穷查理宝典 10.6. 如何成为技术领域的高手？ 1、学会拆解 2、对拆解后的专项做强加联系！ 10.7. 大家&大书 目的：研究大家的思想。哪怕吃透一个，也足以让你拉开同龄人一个身位。 求真书院的院训是“寻天人乐处，拓万古心胸” 君子生非异也，善假于物也 -----> 劝学 ------> 根本, 洞察力 https://blog.sciencenet.cn/blog-3377-1269721.html 杨振宁和爱因斯坦不断提到的宗教体验是什么? 10.8. 不要骗自己-------费曼方法 “最小作用量”这个话题巴德只与费曼讨论过一次，却深深地印在了费曼的脑海中。[2]费曼说：“他只是解说，他并没有证明任何东西。没有任何复杂的事情，他只是说明有这样一个原理存在。我随即为之倾倒，能以这样不寻常的方式来表达一个法则，简直是个不可思议的奇迹。” 1、衡量自己有没有理解知识的标准：（绝大多数时候，我们会被自己所骗，以为自己理解） 技巧： What I cannot create, I do not understand (只要是)我不能创造的, 我就(还)没有理解。-------> 即：检验自己有没有理解的方法：从0开始，把它创造出来。绝好的方法 2、Know how to solve every problem that has been solved （需要知道“每一个”已被解决问题的解决方法） 10.9. 费曼学习法更一般的理论 参考：https://www.campzhe.com/archives/1280 ----> 好文 布卢姆分类法把学习分为6个层次： 记忆（Remember） 理解（Understand） 应用（Apply） 分析（Analyze） 评价（Evaluate） 创造（Create） 注意：创造，不是一下子创造所有细节 而是：先创造出骨架，再在骨架上填充上血和肉 ------------> 所以，创造 和 化简 似乎说的是一件事情 检验是否学会的标准（也是学习的方法）： 如果你没有极度化简，你就没有真正掌握 如果你没有创造出来，你就没有真正掌握 10.10. 教育 https://www.campzhe.com/archives/1428 你们的孩子，并不是你们的孩子 10.11. 性 萨古鲁：https://kknews.cc/news/5jxyxrk.html ​ https://www.bilibili.com/read/cv4760798 11. 管理 管理也是技术， 11.1. 管理他人 管理； 1、管理的表格 2、进度表格：（1）进度有时间 （2）进度有计划、有责任人、有 smart原则 3、每天过进展，每天注上时间，保留历史记录 捅人： 高风险、请审视 针对进度表里的责任人，找到具体的责任人，再具体对进展 提问题： 1、serdes是最复杂的接口—————-----> 所以，提问，关注了这一点 2、必须提问，以怀疑的眼光进行对抗。。。。对抗才能有好的效果。。。不要一团和气 11.2. 自我管理 11.2.1. 每周checklist 跑步 ------> 为了头脑清晰，为了大脑快乐 冥想 思考 阅读 时刻保持好心情，是一切做事的前提 看孩子视频 想象是你的亲人 金刚经 跨过门，十个俯卧撑 乐观 乐趣 ------> 为了大脑快乐 对一切新事物感兴趣（新事物必然战胜旧事物） 永远永远要有热情，不要做一个老人 记忆，与理解，图像+链接： 1、不要浮于文字----看到文字，闭上眼，想象图像 2、建立好 文字----图像的链接： 比如 迪米特法则，从文字很难知道是什么，但： 迪米特吃汉堡包 每天给自己洗脑： 我一定会成为顶尖的人才。一定会在技术上到达顶尖专家的水平。一定会成为管理水平高超之人 我厌恶性、食物、抖音这些低级欲望 我爱道，以及道后面的道。。。模型，模型 我珍惜一切时间 大我：我要推动整个行业的发展，我要成为时代的弄潮儿 我已经30岁了，没有多少时日了，我这辈子一定要为自己的人生做一件大事。 我要把生命献给我的事业。 你若真的喜欢编程，是拦不住的 11.2.2. 时间管理 马斯克： 不按照 时间线 去 列计划 ------> 会造成一件事情，完成不了，其他事情都完成不了 而是给每个任务安排 时间限 ，即：每一件事情最小的时间 ----> Deadline是第一生產力 12. 文章&演讲 list 12.1. 丘成桐 http://wen.org.cn/modules/article/view.article.php/3956 丘成桐：数学与生活 虽然我得到政府奖学金的资助，我在闲暇时还须靠辅导学童挣钱。生活虽然很艰难，但我却学会如何去应付这些困境，并从中取乐。 困难的环境可以令人变得更加成熟。但是反过来说，长久的为生计奔波，对学者的成功却可能是有害的。毕竟，学者需要在一个稳定的环境下成长和发展，才能完成有深度的成果。我观察到历史上的伟大数学家之中，顶多百分之五的人在其整个职业生涯中都身处穷困。在历史上，我们看到一个社会，一个国家，在百战之余，都需要休养生息，才能成长。 12.2. 陆奇 《新范式 新时代 新机会-----> ---------- 陆奇 https://www.youtube.com/watch?v=-LECKZqygzk ppt： https://drive.google.com/file/d/1GVwHZAgUYMkjJ-kEGRAc1P_GPGbTAQ2j/view 本质是讲任何复杂体系，包括一个人、一家公司、一个社会，甚至数字化本身的数字化体系，都是复杂体系。“三位一体”包括： “信息”系统（subsystem of information），从环境当中获得信息； “模型”系统（subsystem of model），对信息做一种表达，进行推理和规划； “行动”系统（subsystem of action），我们最终和环境做交互，达到人类想达到的目的。 -----------------> 用三位一体来分析任何一个复杂系统 人是模型的组合，人有三种模型： 认知模型，我们能看、能听、能思考、能规划； 任务模型，我们能爬楼梯、搬椅子剥鸡蛋； 领域模型，我们有些人是医生，有些人是律师，有些人是码农。 拐点：模型的成本从边际走向固定 12.3. 普通聊天如何缓解尴尬？ ------------话题来源： 13. 关于辩论 13.1. 辩论的前提 大多时候，我们为了驳倒对方，为了驳倒而驳倒 辩论的结果没有带来任何的利益与价值 14. 翟东升2021年预测 1、中美关系局部回暖，但科技封锁会继续----> 中国 2、中欧双边协定会有反复 3、中国在解决卡脖子技术方法：基础软件、工业软件、芯片、光刻机有好消息传来！！！！ 4、新冠疫苗成本竞争 5、人民币对美元将会继续保持一定的强势。 graph TD A(工业用地效率)-->B1(土地利用强度) A-->B2(土地经济效益) B1-->C1(容积率) B1-->C2(建筑系数) B1-->C3(亩均固定资本投入) B2-->D1(亩均工业产值) B2-->D2(亩均税收) graph LR KaTex--> A(标记 Accents) A-->撇,估计,均值,向量等写于符号上下的标记 KaTex--> 分隔符_Delimiters 分隔符_Delimiters-->小中大括号,竖杠,绝对值等分隔符的反斜杠写法 KaTex--> 公式组_Enviroments 公式组_Enviroments-->B(.....) KaTex-->C(...) 15. 随时记录美好 -美好的东西，本身就值钱 1、比如联播：本质：联系 多屏幕联动 能拉起别人 -----------> 本质：联动，帮别人-------交互方式 扩展： 多屏输入法 2、美好： 本质：联系 perfetto 把图形trace 和 log结合到一起了，结合点时间 3、对于割裂的东西 尝试去联系；对于 联系的东西 尝试去 割裂：--------> 思想 ----------> 例子： 多屏开机动画联动 4、荣耀任意门： --------> 背后思想：（1）、减少路径（复制、下载的） （2）、打破App之间的壁垒 技术：先识别内容，猜测可能使用APP，不同APP 疑问：需要应用侧去适配嘛？ 5、 跟踪眼球 --------> 发微信，自动打开微信 6、全局收藏（三指） -----> 收藏网页/摘录视频至笔记 7、信任环-----------多设备协同 日程： 收集各个APP里面，关于时间日程方面的信息 语音创建日程----自然 搜图： 用AI大模型来搜索，包括视频 记录美好： 第一点苹果键盘同一个按键两个符号下拉是一个点击，是另一个号 基本思想是复用思想，复用位置，根据其他来区别—— ——目的：节省屏幕空间 同样的设计有：button的长按与短按、图片的长按与 长按 + 移动 第2点：秒控键盘的手势是放在触摸键盘上—— ——目的：删除鼠标 第3点 ： 右上角的控制中心是一个统一的入口(仅限于几个App 第4点： Siri也是一个入口，但Siri本身有两种进入方式，一种是语音第二种是连续三次案件( 不需要语音对话 快捷键组合： 锁屏: cmd + L --------------------> 与苹果输入法的（button： touch + 下拉） 一样 快速匹配、模糊匹配： Tab按鍵、Ctrl + R （查找）、鼠标 -----> TODO: 提炼本质 15.1. 专利查询网站 https://patents.google.com/?q=(高斯模糊)&oq=高斯模糊 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"book2.html":{"url":"book2.html","title":"Book 2","keywords":"","body":"book2: Introduction · Kent的博客 (kenttj.github.io) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CheckList.html":{"url":"CheckList.html","title":"Check List","keywords":"","body":"1. Daily checkList1. Daily checkList 牵引 ------追求 冥想--15min 身体： 十个俯卧撑 十一点闹钟，关灯光 一直努力在弄环境，追求最好的工具。----> 反而把“主”弄丢了，技术本身 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}